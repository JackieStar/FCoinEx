(global["webpackJsonp"] = global["webpackJsonp"] || []).push([["common/vendor"],[
/* 0 */,
/* 1 */
/*!************************************************************!*\
  !*** ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {Object.defineProperty(exports, "__esModule", { value: true });exports.createApp = createApp;exports.createComponent = createComponent;exports.createPage = createPage;exports.createPlugin = createPlugin;exports.createSubpackageApp = createSubpackageApp;exports.default = void 0;var _vue = _interopRequireDefault(__webpack_require__(/*! vue */ 3));
var _uniI18n = __webpack_require__(/*! @dcloudio/uni-i18n */ 4);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {_defineProperty(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _slicedToArray(arr, i) {return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();}function _nonIterableRest() {throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _iterableToArrayLimit(arr, i) {if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;var _arr = [];var _n = true;var _d = false;var _e = undefined;try {for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i["return"] != null) _i["return"]();} finally {if (_d) throw _e;}}return _arr;}function _arrayWithHoles(arr) {if (Array.isArray(arr)) return arr;}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}function _toConsumableArray(arr) {return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();}function _nonIterableSpread() {throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _iterableToArray(iter) {if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);}function _arrayWithoutHoles(arr) {if (Array.isArray(arr)) return _arrayLikeToArray(arr);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}

var realAtob;

var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var b64re = /^(?:[A-Za-z\d+/]{4})*?(?:[A-Za-z\d+/]{2}(?:==)?|[A-Za-z\d+/]{3}=?)?$/;

if (typeof atob !== 'function') {
  realAtob = function realAtob(str) {
    str = String(str).replace(/[\t\n\f\r ]+/g, '');
    if (!b64re.test(str)) {throw new Error("Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.");}

    // Adding the padding if missing, for semplicity
    str += '=='.slice(2 - (str.length & 3));
    var bitmap;var result = '';var r1;var r2;var i = 0;
    for (; i < str.length;) {
      bitmap = b64.indexOf(str.charAt(i++)) << 18 | b64.indexOf(str.charAt(i++)) << 12 |
      (r1 = b64.indexOf(str.charAt(i++))) << 6 | (r2 = b64.indexOf(str.charAt(i++)));

      result += r1 === 64 ? String.fromCharCode(bitmap >> 16 & 255) :
      r2 === 64 ? String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255) :
      String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255, bitmap & 255);
    }
    return result;
  };
} else {
  // 注意atob只能在全局对象上调用，例如：`const Base64 = {atob};Base64.atob('xxxx')`是错误的用法
  realAtob = atob;
}

function b64DecodeUnicode(str) {
  return decodeURIComponent(realAtob(str).split('').map(function (c) {
    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
  }).join(''));
}

function getCurrentUserInfo() {
  var token = wx.getStorageSync('uni_id_token') || '';
  var tokenArr = token.split('.');
  if (!token || tokenArr.length !== 3) {
    return {
      uid: null,
      role: [],
      permission: [],
      tokenExpired: 0 };

  }
  var userInfo;
  try {
    userInfo = JSON.parse(b64DecodeUnicode(tokenArr[1]));
  } catch (error) {
    throw new Error('获取当前用户信息出错，详细错误信息为：' + error.message);
  }
  userInfo.tokenExpired = userInfo.exp * 1000;
  delete userInfo.exp;
  delete userInfo.iat;
  return userInfo;
}

function uniIdMixin(Vue) {
  Vue.prototype.uniIDHasRole = function (roleId) {var _getCurrentUserInfo =


    getCurrentUserInfo(),role = _getCurrentUserInfo.role;
    return role.indexOf(roleId) > -1;
  };
  Vue.prototype.uniIDHasPermission = function (permissionId) {var _getCurrentUserInfo2 =


    getCurrentUserInfo(),permission = _getCurrentUserInfo2.permission;
    return this.uniIDHasRole('admin') || permission.indexOf(permissionId) > -1;
  };
  Vue.prototype.uniIDTokenValid = function () {var _getCurrentUserInfo3 =


    getCurrentUserInfo(),tokenExpired = _getCurrentUserInfo3.tokenExpired;
    return tokenExpired > Date.now();
  };
}

var _toString = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

function isFn(fn) {
  return typeof fn === 'function';
}

function isStr(str) {
  return typeof str === 'string';
}

function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}

function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

function noop() {}

/**
                    * Create a cached version of a pure function.
                    */
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

/**
   * Camelize a hyphen-delimited string.
   */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {return c ? c.toUpperCase() : '';});
});

var HOOKS = [
'invoke',
'success',
'fail',
'complete',
'returnValue'];


var globalInterceptors = {};
var scopedInterceptors = {};

function mergeHook(parentVal, childVal) {
  var res = childVal ?
  parentVal ?
  parentVal.concat(childVal) :
  Array.isArray(childVal) ?
  childVal : [childVal] :
  parentVal;
  return res ?
  dedupeHooks(res) :
  res;
}

function dedupeHooks(hooks) {
  var res = [];
  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }
  return res;
}

function removeHook(hooks, hook) {
  var index = hooks.indexOf(hook);
  if (index !== -1) {
    hooks.splice(index, 1);
  }
}

function mergeInterceptorHook(interceptor, option) {
  Object.keys(option).forEach(function (hook) {
    if (HOOKS.indexOf(hook) !== -1 && isFn(option[hook])) {
      interceptor[hook] = mergeHook(interceptor[hook], option[hook]);
    }
  });
}

function removeInterceptorHook(interceptor, option) {
  if (!interceptor || !option) {
    return;
  }
  Object.keys(option).forEach(function (hook) {
    if (HOOKS.indexOf(hook) !== -1 && isFn(option[hook])) {
      removeHook(interceptor[hook], option[hook]);
    }
  });
}

function addInterceptor(method, option) {
  if (typeof method === 'string' && isPlainObject(option)) {
    mergeInterceptorHook(scopedInterceptors[method] || (scopedInterceptors[method] = {}), option);
  } else if (isPlainObject(method)) {
    mergeInterceptorHook(globalInterceptors, method);
  }
}

function removeInterceptor(method, option) {
  if (typeof method === 'string') {
    if (isPlainObject(option)) {
      removeInterceptorHook(scopedInterceptors[method], option);
    } else {
      delete scopedInterceptors[method];
    }
  } else if (isPlainObject(method)) {
    removeInterceptorHook(globalInterceptors, method);
  }
}

function wrapperHook(hook) {
  return function (data) {
    return hook(data) || data;
  };
}

function isPromise(obj) {
  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
}

function queue(hooks, data) {
  var promise = false;
  for (var i = 0; i < hooks.length; i++) {
    var hook = hooks[i];
    if (promise) {
      promise = Promise.resolve(wrapperHook(hook));
    } else {
      var res = hook(data);
      if (isPromise(res)) {
        promise = Promise.resolve(res);
      }
      if (res === false) {
        return {
          then: function then() {} };

      }
    }
  }
  return promise || {
    then: function then(callback) {
      return callback(data);
    } };

}

function wrapperOptions(interceptor) {var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  ['success', 'fail', 'complete'].forEach(function (name) {
    if (Array.isArray(interceptor[name])) {
      var oldCallback = options[name];
      options[name] = function callbackInterceptor(res) {
        queue(interceptor[name], res).then(function (res) {
          /* eslint-disable no-mixed-operators */
          return isFn(oldCallback) && oldCallback(res) || res;
        });
      };
    }
  });
  return options;
}

function wrapperReturnValue(method, returnValue) {
  var returnValueHooks = [];
  if (Array.isArray(globalInterceptors.returnValue)) {
    returnValueHooks.push.apply(returnValueHooks, _toConsumableArray(globalInterceptors.returnValue));
  }
  var interceptor = scopedInterceptors[method];
  if (interceptor && Array.isArray(interceptor.returnValue)) {
    returnValueHooks.push.apply(returnValueHooks, _toConsumableArray(interceptor.returnValue));
  }
  returnValueHooks.forEach(function (hook) {
    returnValue = hook(returnValue) || returnValue;
  });
  return returnValue;
}

function getApiInterceptorHooks(method) {
  var interceptor = Object.create(null);
  Object.keys(globalInterceptors).forEach(function (hook) {
    if (hook !== 'returnValue') {
      interceptor[hook] = globalInterceptors[hook].slice();
    }
  });
  var scopedInterceptor = scopedInterceptors[method];
  if (scopedInterceptor) {
    Object.keys(scopedInterceptor).forEach(function (hook) {
      if (hook !== 'returnValue') {
        interceptor[hook] = (interceptor[hook] || []).concat(scopedInterceptor[hook]);
      }
    });
  }
  return interceptor;
}

function invokeApi(method, api, options) {for (var _len = arguments.length, params = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {params[_key - 3] = arguments[_key];}
  var interceptor = getApiInterceptorHooks(method);
  if (interceptor && Object.keys(interceptor).length) {
    if (Array.isArray(interceptor.invoke)) {
      var res = queue(interceptor.invoke, options);
      return res.then(function (options) {
        return api.apply(void 0, [wrapperOptions(interceptor, options)].concat(params));
      });
    } else {
      return api.apply(void 0, [wrapperOptions(interceptor, options)].concat(params));
    }
  }
  return api.apply(void 0, [options].concat(params));
}

var promiseInterceptor = {
  returnValue: function returnValue(res) {
    if (!isPromise(res)) {
      return res;
    }
    return new Promise(function (resolve, reject) {
      res.then(function (res) {
        if (res[0]) {
          reject(res[0]);
        } else {
          resolve(res[1]);
        }
      });
    });
  } };


var SYNC_API_RE =
/^\$|Window$|WindowStyle$|sendHostEvent|sendNativeEvent|restoreGlobal|getCurrentSubNVue|getMenuButtonBoundingClientRect|^report|interceptors|Interceptor$|getSubNVueById|requireNativePlugin|upx2px|hideKeyboard|canIUse|^create|Sync$|Manager$|base64ToArrayBuffer|arrayBufferToBase64|getLocale|setLocale/;

var CONTEXT_API_RE = /^create|Manager$/;

// Context例外情况
var CONTEXT_API_RE_EXC = ['createBLEConnection'];

// 同步例外情况
var ASYNC_API = ['createBLEConnection'];

var CALLBACK_API_RE = /^on|^off/;

function isContextApi(name) {
  return CONTEXT_API_RE.test(name) && CONTEXT_API_RE_EXC.indexOf(name) === -1;
}
function isSyncApi(name) {
  return SYNC_API_RE.test(name) && ASYNC_API.indexOf(name) === -1;
}

function isCallbackApi(name) {
  return CALLBACK_API_RE.test(name) && name !== 'onPush';
}

function handlePromise(promise) {
  return promise.then(function (data) {
    return [null, data];
  }).
  catch(function (err) {return [err];});
}

function shouldPromise(name) {
  if (
  isContextApi(name) ||
  isSyncApi(name) ||
  isCallbackApi(name))
  {
    return false;
  }
  return true;
}

/* eslint-disable no-extend-native */
if (!Promise.prototype.finally) {
  Promise.prototype.finally = function (callback) {
    var promise = this.constructor;
    return this.then(
    function (value) {return promise.resolve(callback()).then(function () {return value;});},
    function (reason) {return promise.resolve(callback()).then(function () {
        throw reason;
      });});

  };
}

function promisify(name, api) {
  if (!shouldPromise(name)) {
    return api;
  }
  return function promiseApi() {var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {params[_key2 - 1] = arguments[_key2];}
    if (isFn(options.success) || isFn(options.fail) || isFn(options.complete)) {
      return wrapperReturnValue(name, invokeApi.apply(void 0, [name, api, options].concat(params)));
    }
    return wrapperReturnValue(name, handlePromise(new Promise(function (resolve, reject) {
      invokeApi.apply(void 0, [name, api, Object.assign({}, options, {
        success: resolve,
        fail: reject })].concat(
      params));
    })));
  };
}

var EPS = 1e-4;
var BASE_DEVICE_WIDTH = 750;
var isIOS = false;
var deviceWidth = 0;
var deviceDPR = 0;

function checkDeviceWidth() {var _wx$getSystemInfoSync =




  wx.getSystemInfoSync(),platform = _wx$getSystemInfoSync.platform,pixelRatio = _wx$getSystemInfoSync.pixelRatio,windowWidth = _wx$getSystemInfoSync.windowWidth; // uni=>wx runtime 编译目标是 uni 对象，内部不允许直接使用 uni

  deviceWidth = windowWidth;
  deviceDPR = pixelRatio;
  isIOS = platform === 'ios';
}

function upx2px(number, newDeviceWidth) {
  if (deviceWidth === 0) {
    checkDeviceWidth();
  }

  number = Number(number);
  if (number === 0) {
    return 0;
  }
  var result = number / BASE_DEVICE_WIDTH * (newDeviceWidth || deviceWidth);
  if (result < 0) {
    result = -result;
  }
  result = Math.floor(result + EPS);
  if (result === 0) {
    if (deviceDPR === 1 || !isIOS) {
      result = 1;
    } else {
      result = 0.5;
    }
  }
  return number < 0 ? -result : result;
}

function getLocale() {
  // 优先使用 $locale
  var app = getApp({
    allowDefault: true });

  if (app && app.$vm) {
    return app.$vm.$locale;
  }
  return wx.getSystemInfoSync().language || 'zh-Hans';
}

function setLocale(locale) {
  var app = getApp();
  if (!app) {
    return false;
  }
  var oldLocale = app.$vm.$locale;
  if (oldLocale !== locale) {
    app.$vm.$locale = locale;
    onLocaleChangeCallbacks.forEach(function (fn) {return fn({
        locale: locale });});

    return true;
  }
  return false;
}

var onLocaleChangeCallbacks = [];
function onLocaleChange(fn) {
  if (onLocaleChangeCallbacks.indexOf(fn) === -1) {
    onLocaleChangeCallbacks.push(fn);
  }
}

if (typeof global !== 'undefined') {
  global.getLocale = getLocale;
}

var interceptors = {
  promiseInterceptor: promiseInterceptor };


var baseApi = /*#__PURE__*/Object.freeze({
  __proto__: null,
  upx2px: upx2px,
  getLocale: getLocale,
  setLocale: setLocale,
  onLocaleChange: onLocaleChange,
  addInterceptor: addInterceptor,
  removeInterceptor: removeInterceptor,
  interceptors: interceptors });


function findExistsPageIndex(url) {
  var pages = getCurrentPages();
  var len = pages.length;
  while (len--) {
    var page = pages[len];
    if (page.$page && page.$page.fullPath === url) {
      return len;
    }
  }
  return -1;
}

var redirectTo = {
  name: function name(fromArgs) {
    if (fromArgs.exists === 'back' && fromArgs.delta) {
      return 'navigateBack';
    }
    return 'redirectTo';
  },
  args: function args(fromArgs) {
    if (fromArgs.exists === 'back' && fromArgs.url) {
      var existsPageIndex = findExistsPageIndex(fromArgs.url);
      if (existsPageIndex !== -1) {
        var delta = getCurrentPages().length - 1 - existsPageIndex;
        if (delta > 0) {
          fromArgs.delta = delta;
        }
      }
    }
  } };


var previewImage = {
  args: function args(fromArgs) {
    var currentIndex = parseInt(fromArgs.current);
    if (isNaN(currentIndex)) {
      return;
    }
    var urls = fromArgs.urls;
    if (!Array.isArray(urls)) {
      return;
    }
    var len = urls.length;
    if (!len) {
      return;
    }
    if (currentIndex < 0) {
      currentIndex = 0;
    } else if (currentIndex >= len) {
      currentIndex = len - 1;
    }
    if (currentIndex > 0) {
      fromArgs.current = urls[currentIndex];
      fromArgs.urls = urls.filter(
      function (item, index) {return index < currentIndex ? item !== urls[currentIndex] : true;});

    } else {
      fromArgs.current = urls[0];
    }
    return {
      indicator: false,
      loop: false };

  } };


var UUID_KEY = '__DC_STAT_UUID';
var deviceId;
function addUuid(result) {
  deviceId = deviceId || wx.getStorageSync(UUID_KEY);
  if (!deviceId) {
    deviceId = Date.now() + '' + Math.floor(Math.random() * 1e7);
    wx.setStorage({
      key: UUID_KEY,
      data: deviceId });

  }
  result.deviceId = deviceId;
}

function addSafeAreaInsets(result) {
  if (result.safeArea) {
    var safeArea = result.safeArea;
    result.safeAreaInsets = {
      top: safeArea.top,
      left: safeArea.left,
      right: result.windowWidth - safeArea.right,
      bottom: result.windowHeight - safeArea.bottom };

  }
}

var getSystemInfo = {
  returnValue: function returnValue(result) {
    addUuid(result);
    addSafeAreaInsets(result);
  } };


// import navigateTo from 'uni-helpers/navigate-to'

var protocols = {
  redirectTo: redirectTo,
  // navigateTo,  // 由于在微信开发者工具的页面参数，会显示__id__参数，因此暂时关闭mp-weixin对于navigateTo的AOP
  previewImage: previewImage,
  getSystemInfo: getSystemInfo,
  getSystemInfoSync: getSystemInfo };

var todos = [
'vibrate',
'preloadPage',
'unPreloadPage',
'loadSubPackage'];

var canIUses = [];

var CALLBACKS = ['success', 'fail', 'cancel', 'complete'];

function processCallback(methodName, method, returnValue) {
  return function (res) {
    return method(processReturnValue(methodName, res, returnValue));
  };
}

function processArgs(methodName, fromArgs) {var argsOption = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};var returnValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};var keepFromArgs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  if (isPlainObject(fromArgs)) {// 一般 api 的参数解析
    var toArgs = keepFromArgs === true ? fromArgs : {}; // returnValue 为 false 时，说明是格式化返回值，直接在返回值对象上修改赋值
    if (isFn(argsOption)) {
      argsOption = argsOption(fromArgs, toArgs) || {};
    }
    for (var key in fromArgs) {
      if (hasOwn(argsOption, key)) {
        var keyOption = argsOption[key];
        if (isFn(keyOption)) {
          keyOption = keyOption(fromArgs[key], fromArgs, toArgs);
        }
        if (!keyOption) {// 不支持的参数
          console.warn("The '".concat(methodName, "' method of platform '\u5FAE\u4FE1\u5C0F\u7A0B\u5E8F' does not support option '").concat(key, "'"));
        } else if (isStr(keyOption)) {// 重写参数 key
          toArgs[keyOption] = fromArgs[key];
        } else if (isPlainObject(keyOption)) {// {name:newName,value:value}可重新指定参数 key:value
          toArgs[keyOption.name ? keyOption.name : key] = keyOption.value;
        }
      } else if (CALLBACKS.indexOf(key) !== -1) {
        if (isFn(fromArgs[key])) {
          toArgs[key] = processCallback(methodName, fromArgs[key], returnValue);
        }
      } else {
        if (!keepFromArgs) {
          toArgs[key] = fromArgs[key];
        }
      }
    }
    return toArgs;
  } else if (isFn(fromArgs)) {
    fromArgs = processCallback(methodName, fromArgs, returnValue);
  }
  return fromArgs;
}

function processReturnValue(methodName, res, returnValue) {var keepReturnValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  if (isFn(protocols.returnValue)) {// 处理通用 returnValue
    res = protocols.returnValue(methodName, res);
  }
  return processArgs(methodName, res, returnValue, {}, keepReturnValue);
}

function wrapper(methodName, method) {
  if (hasOwn(protocols, methodName)) {
    var protocol = protocols[methodName];
    if (!protocol) {// 暂不支持的 api
      return function () {
        console.error("Platform '\u5FAE\u4FE1\u5C0F\u7A0B\u5E8F' does not support '".concat(methodName, "'."));
      };
    }
    return function (arg1, arg2) {// 目前 api 最多两个参数
      var options = protocol;
      if (isFn(protocol)) {
        options = protocol(arg1);
      }

      arg1 = processArgs(methodName, arg1, options.args, options.returnValue);

      var args = [arg1];
      if (typeof arg2 !== 'undefined') {
        args.push(arg2);
      }
      if (isFn(options.name)) {
        methodName = options.name(arg1);
      } else if (isStr(options.name)) {
        methodName = options.name;
      }
      var returnValue = wx[methodName].apply(wx, args);
      if (isSyncApi(methodName)) {// 同步 api
        return processReturnValue(methodName, returnValue, options.returnValue, isContextApi(methodName));
      }
      return returnValue;
    };
  }
  return method;
}

var todoApis = Object.create(null);

var TODOS = [
'onTabBarMidButtonTap',
'subscribePush',
'unsubscribePush',
'onPush',
'offPush',
'share'];


function createTodoApi(name) {
  return function todoApi(_ref)


  {var fail = _ref.fail,complete = _ref.complete;
    var res = {
      errMsg: "".concat(name, ":fail method '").concat(name, "' not supported") };

    isFn(fail) && fail(res);
    isFn(complete) && complete(res);
  };
}

TODOS.forEach(function (name) {
  todoApis[name] = createTodoApi(name);
});

var providers = {
  oauth: ['weixin'],
  share: ['weixin'],
  payment: ['wxpay'],
  push: ['weixin'] };


function getProvider(_ref2)




{var service = _ref2.service,success = _ref2.success,fail = _ref2.fail,complete = _ref2.complete;
  var res = false;
  if (providers[service]) {
    res = {
      errMsg: 'getProvider:ok',
      service: service,
      provider: providers[service] };

    isFn(success) && success(res);
  } else {
    res = {
      errMsg: 'getProvider:fail service not found' };

    isFn(fail) && fail(res);
  }
  isFn(complete) && complete(res);
}

var extraApi = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getProvider: getProvider });


var getEmitter = function () {
  var Emitter;
  return function getUniEmitter() {
    if (!Emitter) {
      Emitter = new _vue.default();
    }
    return Emitter;
  };
}();

function apply(ctx, method, args) {
  return ctx[method].apply(ctx, args);
}

function $on() {
  return apply(getEmitter(), '$on', Array.prototype.slice.call(arguments));
}
function $off() {
  return apply(getEmitter(), '$off', Array.prototype.slice.call(arguments));
}
function $once() {
  return apply(getEmitter(), '$once', Array.prototype.slice.call(arguments));
}
function $emit() {
  return apply(getEmitter(), '$emit', Array.prototype.slice.call(arguments));
}

var eventApi = /*#__PURE__*/Object.freeze({
  __proto__: null,
  $on: $on,
  $off: $off,
  $once: $once,
  $emit: $emit });


var api = /*#__PURE__*/Object.freeze({
  __proto__: null });


var MPPage = Page;
var MPComponent = Component;

var customizeRE = /:/g;

var customize = cached(function (str) {
  return camelize(str.replace(customizeRE, '-'));
});

function initTriggerEvent(mpInstance) {
  var oldTriggerEvent = mpInstance.triggerEvent;
  var newTriggerEvent = function newTriggerEvent(event) {for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {args[_key3 - 1] = arguments[_key3];}
    return oldTriggerEvent.apply(mpInstance, [customize(event)].concat(args));
  };
  try {
    // 京东小程序 triggerEvent 为只读
    mpInstance.triggerEvent = newTriggerEvent;
  } catch (error) {
    mpInstance._triggerEvent = newTriggerEvent;
  }
}

function initHook(name, options, isComponent) {
  var oldHook = options[name];
  if (!oldHook) {
    options[name] = function () {
      initTriggerEvent(this);
    };
  } else {
    options[name] = function () {
      initTriggerEvent(this);for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {args[_key4] = arguments[_key4];}
      return oldHook.apply(this, args);
    };
  }
}
if (!MPPage.__$wrappered) {
  MPPage.__$wrappered = true;
  Page = function Page() {var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    initHook('onLoad', options);
    return MPPage(options);
  };
  Page.after = MPPage.after;

  Component = function Component() {var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    initHook('created', options);
    return MPComponent(options);
  };
}

var PAGE_EVENT_HOOKS = [
'onPullDownRefresh',
'onReachBottom',
'onAddToFavorites',
'onShareTimeline',
'onShareAppMessage',
'onPageScroll',
'onResize',
'onTabItemTap'];


function initMocks(vm, mocks) {
  var mpInstance = vm.$mp[vm.mpType];
  mocks.forEach(function (mock) {
    if (hasOwn(mpInstance, mock)) {
      vm[mock] = mpInstance[mock];
    }
  });
}

function hasHook(hook, vueOptions) {
  if (!vueOptions) {
    return true;
  }

  if (_vue.default.options && Array.isArray(_vue.default.options[hook])) {
    return true;
  }

  vueOptions = vueOptions.default || vueOptions;

  if (isFn(vueOptions)) {
    if (isFn(vueOptions.extendOptions[hook])) {
      return true;
    }
    if (vueOptions.super &&
    vueOptions.super.options &&
    Array.isArray(vueOptions.super.options[hook])) {
      return true;
    }
    return false;
  }

  if (isFn(vueOptions[hook])) {
    return true;
  }
  var mixins = vueOptions.mixins;
  if (Array.isArray(mixins)) {
    return !!mixins.find(function (mixin) {return hasHook(hook, mixin);});
  }
}

function initHooks(mpOptions, hooks, vueOptions) {
  hooks.forEach(function (hook) {
    if (hasHook(hook, vueOptions)) {
      mpOptions[hook] = function (args) {
        return this.$vm && this.$vm.__call_hook(hook, args);
      };
    }
  });
}

function initVueComponent(Vue, vueOptions) {
  vueOptions = vueOptions.default || vueOptions;
  var VueComponent;
  if (isFn(vueOptions)) {
    VueComponent = vueOptions;
  } else {
    VueComponent = Vue.extend(vueOptions);
  }
  vueOptions = VueComponent.options;
  return [VueComponent, vueOptions];
}

function initSlots(vm, vueSlots) {
  if (Array.isArray(vueSlots) && vueSlots.length) {
    var $slots = Object.create(null);
    vueSlots.forEach(function (slotName) {
      $slots[slotName] = true;
    });
    vm.$scopedSlots = vm.$slots = $slots;
  }
}

function initVueIds(vueIds, mpInstance) {
  vueIds = (vueIds || '').split(',');
  var len = vueIds.length;

  if (len === 1) {
    mpInstance._$vueId = vueIds[0];
  } else if (len === 2) {
    mpInstance._$vueId = vueIds[0];
    mpInstance._$vuePid = vueIds[1];
  }
}

function initData(vueOptions, context) {
  var data = vueOptions.data || {};
  var methods = vueOptions.methods || {};

  if (typeof data === 'function') {
    try {
      data = data.call(context); // 支持 Vue.prototype 上挂的数据
    } catch (e) {
      if (Object({"VUE_APP_NAME":"秒合约","VUE_APP_PLATFORM":"mp-weixin","NODE_ENV":"development","BASE_URL":"/"}).VUE_APP_DEBUG) {
        console.warn('根据 Vue 的 data 函数初始化小程序 data 失败，请尽量确保 data 函数中不访问 vm 对象，否则可能影响首次数据渲染速度。', data);
      }
    }
  } else {
    try {
      // 对 data 格式化
      data = JSON.parse(JSON.stringify(data));
    } catch (e) {}
  }

  if (!isPlainObject(data)) {
    data = {};
  }

  Object.keys(methods).forEach(function (methodName) {
    if (context.__lifecycle_hooks__.indexOf(methodName) === -1 && !hasOwn(data, methodName)) {
      data[methodName] = methods[methodName];
    }
  });

  return data;
}

var PROP_TYPES = [String, Number, Boolean, Object, Array, null];

function createObserver(name) {
  return function observer(newVal, oldVal) {
    if (this.$vm) {
      this.$vm[name] = newVal; // 为了触发其他非 render watcher
    }
  };
}

function initBehaviors(vueOptions, initBehavior) {
  var vueBehaviors = vueOptions.behaviors;
  var vueExtends = vueOptions.extends;
  var vueMixins = vueOptions.mixins;

  var vueProps = vueOptions.props;

  if (!vueProps) {
    vueOptions.props = vueProps = [];
  }

  var behaviors = [];
  if (Array.isArray(vueBehaviors)) {
    vueBehaviors.forEach(function (behavior) {
      behaviors.push(behavior.replace('uni://', "wx".concat("://")));
      if (behavior === 'uni://form-field') {
        if (Array.isArray(vueProps)) {
          vueProps.push('name');
          vueProps.push('value');
        } else {
          vueProps.name = {
            type: String,
            default: '' };

          vueProps.value = {
            type: [String, Number, Boolean, Array, Object, Date],
            default: '' };

        }
      }
    });
  }
  if (isPlainObject(vueExtends) && vueExtends.props) {
    behaviors.push(
    initBehavior({
      properties: initProperties(vueExtends.props, true) }));


  }
  if (Array.isArray(vueMixins)) {
    vueMixins.forEach(function (vueMixin) {
      if (isPlainObject(vueMixin) && vueMixin.props) {
        behaviors.push(
        initBehavior({
          properties: initProperties(vueMixin.props, true) }));


      }
    });
  }
  return behaviors;
}

function parsePropType(key, type, defaultValue, file) {
  // [String]=>String
  if (Array.isArray(type) && type.length === 1) {
    return type[0];
  }
  return type;
}

function initProperties(props) {var isBehavior = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;var file = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var properties = {};
  if (!isBehavior) {
    properties.vueId = {
      type: String,
      value: '' };

    // 用于字节跳动小程序模拟抽象节点
    properties.generic = {
      type: Object,
      value: null };

    // scopedSlotsCompiler auto
    properties.scopedSlotsCompiler = {
      type: String,
      value: '' };

    properties.vueSlots = { // 小程序不能直接定义 $slots 的 props，所以通过 vueSlots 转换到 $slots
      type: null,
      value: [],
      observer: function observer(newVal, oldVal) {
        var $slots = Object.create(null);
        newVal.forEach(function (slotName) {
          $slots[slotName] = true;
        });
        this.setData({
          $slots: $slots });

      } };

  }
  if (Array.isArray(props)) {// ['title']
    props.forEach(function (key) {
      properties[key] = {
        type: null,
        observer: createObserver(key) };

    });
  } else if (isPlainObject(props)) {// {title:{type:String,default:''},content:String}
    Object.keys(props).forEach(function (key) {
      var opts = props[key];
      if (isPlainObject(opts)) {// title:{type:String,default:''}
        var value = opts.default;
        if (isFn(value)) {
          value = value();
        }

        opts.type = parsePropType(key, opts.type);

        properties[key] = {
          type: PROP_TYPES.indexOf(opts.type) !== -1 ? opts.type : null,
          value: value,
          observer: createObserver(key) };

      } else {// content:String
        var type = parsePropType(key, opts);
        properties[key] = {
          type: PROP_TYPES.indexOf(type) !== -1 ? type : null,
          observer: createObserver(key) };

      }
    });
  }
  return properties;
}

function wrapper$1(event) {
  // TODO 又得兼容 mpvue 的 mp 对象
  try {
    event.mp = JSON.parse(JSON.stringify(event));
  } catch (e) {}

  event.stopPropagation = noop;
  event.preventDefault = noop;

  event.target = event.target || {};

  if (!hasOwn(event, 'detail')) {
    event.detail = {};
  }

  if (hasOwn(event, 'markerId')) {
    event.detail = typeof event.detail === 'object' ? event.detail : {};
    event.detail.markerId = event.markerId;
  }

  if (isPlainObject(event.detail)) {
    event.target = Object.assign({}, event.target, event.detail);
  }

  return event;
}

function getExtraValue(vm, dataPathsArray) {
  var context = vm;
  dataPathsArray.forEach(function (dataPathArray) {
    var dataPath = dataPathArray[0];
    var value = dataPathArray[2];
    if (dataPath || typeof value !== 'undefined') {// ['','',index,'disable']
      var propPath = dataPathArray[1];
      var valuePath = dataPathArray[3];

      var vFor;
      if (Number.isInteger(dataPath)) {
        vFor = dataPath;
      } else if (!dataPath) {
        vFor = context;
      } else if (typeof dataPath === 'string' && dataPath) {
        if (dataPath.indexOf('#s#') === 0) {
          vFor = dataPath.substr(3);
        } else {
          vFor = vm.__get_value(dataPath, context);
        }
      }

      if (Number.isInteger(vFor)) {
        context = value;
      } else if (!propPath) {
        context = vFor[value];
      } else {
        if (Array.isArray(vFor)) {
          context = vFor.find(function (vForItem) {
            return vm.__get_value(propPath, vForItem) === value;
          });
        } else if (isPlainObject(vFor)) {
          context = Object.keys(vFor).find(function (vForKey) {
            return vm.__get_value(propPath, vFor[vForKey]) === value;
          });
        } else {
          console.error('v-for 暂不支持循环数据：', vFor);
        }
      }

      if (valuePath) {
        context = vm.__get_value(valuePath, context);
      }
    }
  });
  return context;
}

function processEventExtra(vm, extra, event) {
  var extraObj = {};

  if (Array.isArray(extra) && extra.length) {
    /**
                                              *[
                                              *    ['data.items', 'data.id', item.data.id],
                                              *    ['metas', 'id', meta.id]
                                              *],
                                              *[
                                              *    ['data.items', 'data.id', item.data.id],
                                              *    ['metas', 'id', meta.id]
                                              *],
                                              *'test'
                                              */
    extra.forEach(function (dataPath, index) {
      if (typeof dataPath === 'string') {
        if (!dataPath) {// model,prop.sync
          extraObj['$' + index] = vm;
        } else {
          if (dataPath === '$event') {// $event
            extraObj['$' + index] = event;
          } else if (dataPath === 'arguments') {
            if (event.detail && event.detail.__args__) {
              extraObj['$' + index] = event.detail.__args__;
            } else {
              extraObj['$' + index] = [event];
            }
          } else if (dataPath.indexOf('$event.') === 0) {// $event.target.value
            extraObj['$' + index] = vm.__get_value(dataPath.replace('$event.', ''), event);
          } else {
            extraObj['$' + index] = vm.__get_value(dataPath);
          }
        }
      } else {
        extraObj['$' + index] = getExtraValue(vm, dataPath);
      }
    });
  }

  return extraObj;
}

function getObjByArray(arr) {
  var obj = {};
  for (var i = 1; i < arr.length; i++) {
    var element = arr[i];
    obj[element[0]] = element[1];
  }
  return obj;
}

function processEventArgs(vm, event) {var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];var extra = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];var isCustom = arguments.length > 4 ? arguments[4] : undefined;var methodName = arguments.length > 5 ? arguments[5] : undefined;
  var isCustomMPEvent = false; // wxcomponent 组件，传递原始 event 对象
  if (isCustom) {// 自定义事件
    isCustomMPEvent = event.currentTarget &&
    event.currentTarget.dataset &&
    event.currentTarget.dataset.comType === 'wx';
    if (!args.length) {// 无参数，直接传入 event 或 detail 数组
      if (isCustomMPEvent) {
        return [event];
      }
      return event.detail.__args__ || event.detail;
    }
  }

  var extraObj = processEventExtra(vm, extra, event);

  var ret = [];
  args.forEach(function (arg) {
    if (arg === '$event') {
      if (methodName === '__set_model' && !isCustom) {// input v-model value
        ret.push(event.target.value);
      } else {
        if (isCustom && !isCustomMPEvent) {
          ret.push(event.detail.__args__[0]);
        } else {// wxcomponent 组件或内置组件
          ret.push(event);
        }
      }
    } else {
      if (Array.isArray(arg) && arg[0] === 'o') {
        ret.push(getObjByArray(arg));
      } else if (typeof arg === 'string' && hasOwn(extraObj, arg)) {
        ret.push(extraObj[arg]);
      } else {
        ret.push(arg);
      }
    }
  });

  return ret;
}

var ONCE = '~';
var CUSTOM = '^';

function isMatchEventType(eventType, optType) {
  return eventType === optType ||

  optType === 'regionchange' && (

  eventType === 'begin' ||
  eventType === 'end');


}

function getContextVm(vm) {
  var $parent = vm.$parent;
  // 父组件是 scoped slots 或者其他自定义组件时继续查找
  while ($parent && $parent.$parent && ($parent.$options.generic || $parent.$parent.$options.generic || $parent.$scope._$vuePid)) {
    $parent = $parent.$parent;
  }
  return $parent && $parent.$parent;
}

function handleEvent(event) {var _this = this;
  event = wrapper$1(event);

  // [['tap',[['handle',[1,2,a]],['handle1',[1,2,a]]]]]
  var dataset = (event.currentTarget || event.target).dataset;
  if (!dataset) {
    return console.warn('事件信息不存在');
  }
  var eventOpts = dataset.eventOpts || dataset['event-opts']; // 支付宝 web-view 组件 dataset 非驼峰
  if (!eventOpts) {
    return console.warn('事件信息不存在');
  }

  // [['handle',[1,2,a]],['handle1',[1,2,a]]]
  var eventType = event.type;

  var ret = [];

  eventOpts.forEach(function (eventOpt) {
    var type = eventOpt[0];
    var eventsArray = eventOpt[1];

    var isCustom = type.charAt(0) === CUSTOM;
    type = isCustom ? type.slice(1) : type;
    var isOnce = type.charAt(0) === ONCE;
    type = isOnce ? type.slice(1) : type;

    if (eventsArray && isMatchEventType(eventType, type)) {
      eventsArray.forEach(function (eventArray) {
        var methodName = eventArray[0];
        if (methodName) {
          var handlerCtx = _this.$vm;
          if (handlerCtx.$options.generic) {// mp-weixin,mp-toutiao 抽象节点模拟 scoped slots
            handlerCtx = getContextVm(handlerCtx) || handlerCtx;
          }
          if (methodName === '$emit') {
            handlerCtx.$emit.apply(handlerCtx,
            processEventArgs(
            _this.$vm,
            event,
            eventArray[1],
            eventArray[2],
            isCustom,
            methodName));

            return;
          }
          var handler = handlerCtx[methodName];
          if (!isFn(handler)) {
            throw new Error(" _vm.".concat(methodName, " is not a function"));
          }
          if (isOnce) {
            if (handler.once) {
              return;
            }
            handler.once = true;
          }
          var params = processEventArgs(
          _this.$vm,
          event,
          eventArray[1],
          eventArray[2],
          isCustom,
          methodName);

          params = Array.isArray(params) ? params : [];
          // 参数尾部增加原始事件对象用于复杂表达式内获取额外数据
          if (/=\s*\S+\.eventParams\s*\|\|\s*\S+\[['"]event-params['"]\]/.test(handler.toString())) {
            // eslint-disable-next-line no-sparse-arrays
            params = params.concat([,,,,,,,,,, event]);
          }
          ret.push(handler.apply(handlerCtx, params));
        }
      });
    }
  });

  if (
  eventType === 'input' &&
  ret.length === 1 &&
  typeof ret[0] !== 'undefined')
  {
    return ret[0];
  }
}

var messages = {};

var locale;

{
  locale = wx.getSystemInfoSync().language;
}

function initI18nMessages() {
  if (!isEnableLocale()) {
    return;
  }
  var localeKeys = Object.keys(__uniConfig.locales);
  if (localeKeys.length) {
    localeKeys.forEach(function (locale) {
      var curMessages = messages[locale];
      var userMessages = __uniConfig.locales[locale];
      if (curMessages) {
        Object.assign(curMessages, userMessages);
      } else {
        messages[locale] = userMessages;
      }
    });
  }
}

initI18nMessages();

var i18n = (0, _uniI18n.initVueI18n)(
locale,
{});

var t = i18n.t;
var i18nMixin = i18n.mixin = {
  beforeCreate: function beforeCreate() {var _this2 = this;
    var unwatch = i18n.i18n.watchLocale(function () {
      _this2.$forceUpdate();
    });
    this.$once('hook:beforeDestroy', function () {
      unwatch();
    });
  },
  methods: {
    $$t: function $$t(key, values) {
      return t(key, values);
    } } };


var setLocale$1 = i18n.setLocale;
var getLocale$1 = i18n.getLocale;

function initAppLocale(Vue, appVm, locale) {
  var state = Vue.observable({
    locale: locale || i18n.getLocale() });

  var localeWatchers = [];
  appVm.$watchLocale = function (fn) {
    localeWatchers.push(fn);
  };
  Object.defineProperty(appVm, '$locale', {
    get: function get() {
      return state.locale;
    },
    set: function set(v) {
      state.locale = v;
      localeWatchers.forEach(function (watch) {return watch(v);});
    } });

}

function isEnableLocale() {
  return typeof __uniConfig !== 'undefined' && __uniConfig.locales && !!Object.keys(__uniConfig.locales).length;
}

// export function initI18n() {
//   const localeKeys = Object.keys(__uniConfig.locales || {})
//   if (localeKeys.length) {
//     localeKeys.forEach((locale) =>
//       i18n.add(locale, __uniConfig.locales[locale])
//     )
//   }
// }

var eventChannels = {};

var eventChannelStack = [];

function getEventChannel(id) {
  if (id) {
    var eventChannel = eventChannels[id];
    delete eventChannels[id];
    return eventChannel;
  }
  return eventChannelStack.shift();
}

var hooks = [
'onShow',
'onHide',
'onError',
'onPageNotFound',
'onThemeChange',
'onUnhandledRejection'];


function initEventChannel() {
  _vue.default.prototype.getOpenerEventChannel = function () {
    // 微信小程序使用自身getOpenerEventChannel
    {
      return this.$scope.getOpenerEventChannel();
    }
  };
  var callHook = _vue.default.prototype.__call_hook;
  _vue.default.prototype.__call_hook = function (hook, args) {
    if (hook === 'onLoad' && args && args.__id__) {
      this.__eventChannel__ = getEventChannel(args.__id__);
      delete args.__id__;
    }
    return callHook.call(this, hook, args);
  };
}

function initScopedSlotsParams() {
  var center = {};
  var parents = {};

  _vue.default.prototype.$hasScopedSlotsParams = function (vueId) {
    var has = center[vueId];
    if (!has) {
      parents[vueId] = this;
      this.$on('hook:destroyed', function () {
        delete parents[vueId];
      });
    }
    return has;
  };

  _vue.default.prototype.$getScopedSlotsParams = function (vueId, name, key) {
    var data = center[vueId];
    if (data) {
      var object = data[name] || {};
      return key ? object[key] : object;
    } else {
      parents[vueId] = this;
      this.$on('hook:destroyed', function () {
        delete parents[vueId];
      });
    }
  };

  _vue.default.prototype.$setScopedSlotsParams = function (name, value) {
    var vueIds = this.$options.propsData.vueId;
    if (vueIds) {
      var vueId = vueIds.split(',')[0];
      var object = center[vueId] = center[vueId] || {};
      object[name] = value;
      if (parents[vueId]) {
        parents[vueId].$forceUpdate();
      }
    }
  };

  _vue.default.mixin({
    destroyed: function destroyed() {
      var propsData = this.$options.propsData;
      var vueId = propsData && propsData.vueId;
      if (vueId) {
        delete center[vueId];
        delete parents[vueId];
      }
    } });

}

function parseBaseApp(vm, _ref3)


{var mocks = _ref3.mocks,initRefs = _ref3.initRefs;
  initEventChannel();
  {
    initScopedSlotsParams();
  }
  if (vm.$options.store) {
    _vue.default.prototype.$store = vm.$options.store;
  }
  uniIdMixin(_vue.default);

  _vue.default.prototype.mpHost = "mp-weixin";

  _vue.default.mixin({
    beforeCreate: function beforeCreate() {
      if (!this.$options.mpType) {
        return;
      }

      this.mpType = this.$options.mpType;

      this.$mp = _defineProperty({
        data: {} },
      this.mpType, this.$options.mpInstance);


      this.$scope = this.$options.mpInstance;

      delete this.$options.mpType;
      delete this.$options.mpInstance;
      if (this.mpType === 'page' && typeof getApp === 'function') {// hack vue-i18n
        var app = getApp();
        if (app.$vm && app.$vm.$i18n) {
          this._i18n = app.$vm.$i18n;
        }
      }
      if (this.mpType !== 'app') {
        initRefs(this);
        initMocks(this, mocks);
      }
    } });


  var appOptions = {
    onLaunch: function onLaunch(args) {
      if (this.$vm) {// 已经初始化过了，主要是为了百度，百度 onShow 在 onLaunch 之前
        return;
      }
      {
        if (wx.canIUse && !wx.canIUse('nextTick')) {// 事实 上2.2.3 即可，简单使用 2.3.0 的 nextTick 判断
          console.error('当前微信基础库版本过低，请将 微信开发者工具-详情-项目设置-调试基础库版本 更换为`2.3.0`以上');
        }
      }

      this.$vm = vm;

      this.$vm.$mp = {
        app: this };


      this.$vm.$scope = this;
      // vm 上也挂载 globalData
      this.$vm.globalData = this.globalData;

      this.$vm._isMounted = true;
      this.$vm.__call_hook('mounted', args);

      this.$vm.__call_hook('onLaunch', args);
    } };


  // 兼容旧版本 globalData
  appOptions.globalData = vm.$options.globalData || {};
  // 将 methods 中的方法挂在 getApp() 中
  var methods = vm.$options.methods;
  if (methods) {
    Object.keys(methods).forEach(function (name) {
      appOptions[name] = methods[name];
    });
  }

  initAppLocale(_vue.default, vm, wx.getSystemInfoSync().language || 'zh-Hans');

  initHooks(appOptions, hooks);

  return appOptions;
}

var mocks = ['__route__', '__wxExparserNodeId__', '__wxWebviewId__'];

function findVmByVueId(vm, vuePid) {
  var $children = vm.$children;
  // 优先查找直属(反向查找:https://github.com/dcloudio/uni-app/issues/1200)
  for (var i = $children.length - 1; i >= 0; i--) {
    var childVm = $children[i];
    if (childVm.$scope._$vueId === vuePid) {
      return childVm;
    }
  }
  // 反向递归查找
  var parentVm;
  for (var _i = $children.length - 1; _i >= 0; _i--) {
    parentVm = findVmByVueId($children[_i], vuePid);
    if (parentVm) {
      return parentVm;
    }
  }
}

function initBehavior(options) {
  return Behavior(options);
}

function isPage() {
  return !!this.route;
}

function initRelation(detail) {
  this.triggerEvent('__l', detail);
}

function selectAllComponents(mpInstance, selector, $refs) {
  var components = mpInstance.selectAllComponents(selector);
  components.forEach(function (component) {
    var ref = component.dataset.ref;
    $refs[ref] = component.$vm || component;
    {
      if (component.dataset.vueGeneric === 'scoped') {
        component.selectAllComponents('.scoped-ref').forEach(function (scopedComponent) {
          selectAllComponents(scopedComponent, selector, $refs);
        });
      }
    }
  });
}

function initRefs(vm) {
  var mpInstance = vm.$scope;
  Object.defineProperty(vm, '$refs', {
    get: function get() {
      var $refs = {};
      selectAllComponents(mpInstance, '.vue-ref', $refs);
      // TODO 暂不考虑 for 中的 scoped
      var forComponents = mpInstance.selectAllComponents('.vue-ref-in-for');
      forComponents.forEach(function (component) {
        var ref = component.dataset.ref;
        if (!$refs[ref]) {
          $refs[ref] = [];
        }
        $refs[ref].push(component.$vm || component);
      });
      return $refs;
    } });

}

function handleLink(event) {var _ref4 =



  event.detail || event.value,vuePid = _ref4.vuePid,vueOptions = _ref4.vueOptions; // detail 是微信,value 是百度(dipatch)

  var parentVm;

  if (vuePid) {
    parentVm = findVmByVueId(this.$vm, vuePid);
  }

  if (!parentVm) {
    parentVm = this.$vm;
  }

  vueOptions.parent = parentVm;
}

function parseApp(vm) {
  return parseBaseApp(vm, {
    mocks: mocks,
    initRefs: initRefs });

}

function createApp(vm) {
  App(parseApp(vm));
  return vm;
}

var encodeReserveRE = /[!'()*]/g;
var encodeReserveReplacer = function encodeReserveReplacer(c) {return '%' + c.charCodeAt(0).toString(16);};
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas
var encode = function encode(str) {return encodeURIComponent(str).
  replace(encodeReserveRE, encodeReserveReplacer).
  replace(commaRE, ',');};

function stringifyQuery(obj) {var encodeStr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : encode;
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return '';
    }

    if (val === null) {
      return encodeStr(key);
    }

    if (Array.isArray(val)) {
      var result = [];
      val.forEach(function (val2) {
        if (val2 === undefined) {
          return;
        }
        if (val2 === null) {
          result.push(encodeStr(key));
        } else {
          result.push(encodeStr(key) + '=' + encodeStr(val2));
        }
      });
      return result.join('&');
    }

    return encodeStr(key) + '=' + encodeStr(val);
  }).filter(function (x) {return x.length > 0;}).join('&') : null;
  return res ? "?".concat(res) : '';
}

function parseBaseComponent(vueComponentOptions)


{var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},isPage = _ref5.isPage,initRelation = _ref5.initRelation;var _initVueComponent =
  initVueComponent(_vue.default, vueComponentOptions),_initVueComponent2 = _slicedToArray(_initVueComponent, 2),VueComponent = _initVueComponent2[0],vueOptions = _initVueComponent2[1];

  var options = _objectSpread({
    multipleSlots: true,
    addGlobalClass: true },
  vueOptions.options || {});


  {
    // 微信 multipleSlots 部分情况有 bug，导致内容顺序错乱 如 u-list，提供覆盖选项
    if (vueOptions['mp-weixin'] && vueOptions['mp-weixin'].options) {
      Object.assign(options, vueOptions['mp-weixin'].options);
    }
  }

  var componentOptions = {
    options: options,
    data: initData(vueOptions, _vue.default.prototype),
    behaviors: initBehaviors(vueOptions, initBehavior),
    properties: initProperties(vueOptions.props, false, vueOptions.__file),
    lifetimes: {
      attached: function attached() {
        var properties = this.properties;

        var options = {
          mpType: isPage.call(this) ? 'page' : 'component',
          mpInstance: this,
          propsData: properties };


        initVueIds(properties.vueId, this);

        // 处理父子关系
        initRelation.call(this, {
          vuePid: this._$vuePid,
          vueOptions: options });


        // 初始化 vue 实例
        this.$vm = new VueComponent(options);

        // 处理$slots,$scopedSlots（暂不支持动态变化$slots）
        initSlots(this.$vm, properties.vueSlots);

        // 触发首次 setData
        this.$vm.$mount();
      },
      ready: function ready() {
        // 当组件 props 默认值为 true，初始化时传入 false 会导致 created,ready 触发, 但 attached 不触发
        // https://developers.weixin.qq.com/community/develop/doc/00066ae2844cc0f8eb883e2a557800
        if (this.$vm) {
          this.$vm._isMounted = true;
          this.$vm.__call_hook('mounted');
          this.$vm.__call_hook('onReady');
        }
      },
      detached: function detached() {
        this.$vm && this.$vm.$destroy();
      } },

    pageLifetimes: {
      show: function show(args) {
        this.$vm && this.$vm.__call_hook('onPageShow', args);
      },
      hide: function hide() {
        this.$vm && this.$vm.__call_hook('onPageHide');
      },
      resize: function resize(size) {
        this.$vm && this.$vm.__call_hook('onPageResize', size);
      } },

    methods: {
      __l: handleLink,
      __e: handleEvent } };


  // externalClasses
  if (vueOptions.externalClasses) {
    componentOptions.externalClasses = vueOptions.externalClasses;
  }

  if (Array.isArray(vueOptions.wxsCallMethods)) {
    vueOptions.wxsCallMethods.forEach(function (callMethod) {
      componentOptions.methods[callMethod] = function (args) {
        return this.$vm[callMethod](args);
      };
    });
  }

  if (isPage) {
    return componentOptions;
  }
  return [componentOptions, VueComponent];
}

function parseComponent(vueComponentOptions) {
  return parseBaseComponent(vueComponentOptions, {
    isPage: isPage,
    initRelation: initRelation });

}

var hooks$1 = [
'onShow',
'onHide',
'onUnload'];


hooks$1.push.apply(hooks$1, PAGE_EVENT_HOOKS);

function parseBasePage(vuePageOptions, _ref6)


{var isPage = _ref6.isPage,initRelation = _ref6.initRelation;
  var pageOptions = parseComponent(vuePageOptions);

  initHooks(pageOptions.methods, hooks$1, vuePageOptions);

  pageOptions.methods.onLoad = function (query) {
    this.options = query;
    var copyQuery = Object.assign({}, query);
    delete copyQuery.__id__;
    this.$page = {
      fullPath: '/' + (this.route || this.is) + stringifyQuery(copyQuery) };

    this.$vm.$mp.query = query; // 兼容 mpvue
    this.$vm.__call_hook('onLoad', query);
  };

  return pageOptions;
}

function parsePage(vuePageOptions) {
  return parseBasePage(vuePageOptions, {
    isPage: isPage,
    initRelation: initRelation });

}

function createPage(vuePageOptions) {
  {
    return Component(parsePage(vuePageOptions));
  }
}

function createComponent(vueOptions) {
  {
    return Component(parseComponent(vueOptions));
  }
}

function createSubpackageApp(vm) {
  var appOptions = parseApp(vm);
  var app = getApp({
    allowDefault: true });

  vm.$scope = app;
  var globalData = app.globalData;
  if (globalData) {
    Object.keys(appOptions.globalData).forEach(function (name) {
      if (!hasOwn(globalData, name)) {
        globalData[name] = appOptions.globalData[name];
      }
    });
  }
  Object.keys(appOptions).forEach(function (name) {
    if (!hasOwn(app, name)) {
      app[name] = appOptions[name];
    }
  });
  if (isFn(appOptions.onShow) && wx.onAppShow) {
    wx.onAppShow(function () {for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {args[_key5] = arguments[_key5];}
      vm.__call_hook('onShow', args);
    });
  }
  if (isFn(appOptions.onHide) && wx.onAppHide) {
    wx.onAppHide(function () {for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {args[_key6] = arguments[_key6];}
      vm.__call_hook('onHide', args);
    });
  }
  if (isFn(appOptions.onLaunch)) {
    var args = wx.getLaunchOptionsSync && wx.getLaunchOptionsSync();
    vm.__call_hook('onLaunch', args);
  }
  return vm;
}

function createPlugin(vm) {
  var appOptions = parseApp(vm);
  if (isFn(appOptions.onShow) && wx.onAppShow) {
    wx.onAppShow(function () {for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {args[_key7] = arguments[_key7];}
      vm.__call_hook('onShow', args);
    });
  }
  if (isFn(appOptions.onHide) && wx.onAppHide) {
    wx.onAppHide(function () {for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {args[_key8] = arguments[_key8];}
      vm.__call_hook('onHide', args);
    });
  }
  if (isFn(appOptions.onLaunch)) {
    var args = wx.getLaunchOptionsSync && wx.getLaunchOptionsSync();
    vm.__call_hook('onLaunch', args);
  }
  return vm;
}

todos.forEach(function (todoApi) {
  protocols[todoApi] = false;
});

canIUses.forEach(function (canIUseApi) {
  var apiName = protocols[canIUseApi] && protocols[canIUseApi].name ? protocols[canIUseApi].name :
  canIUseApi;
  if (!wx.canIUse(apiName)) {
    protocols[canIUseApi] = false;
  }
});

var uni = {};

if (typeof Proxy !== 'undefined' && "mp-weixin" !== 'app-plus') {
  uni = new Proxy({}, {
    get: function get(target, name) {
      if (hasOwn(target, name)) {
        return target[name];
      }
      if (baseApi[name]) {
        return baseApi[name];
      }
      if (api[name]) {
        return promisify(name, api[name]);
      }
      {
        if (extraApi[name]) {
          return promisify(name, extraApi[name]);
        }
        if (todoApis[name]) {
          return promisify(name, todoApis[name]);
        }
      }
      if (eventApi[name]) {
        return eventApi[name];
      }
      if (!hasOwn(wx, name) && !hasOwn(protocols, name)) {
        return;
      }
      return promisify(name, wrapper(name, wx[name]));
    },
    set: function set(target, name, value) {
      target[name] = value;
      return true;
    } });

} else {
  Object.keys(baseApi).forEach(function (name) {
    uni[name] = baseApi[name];
  });

  {
    Object.keys(todoApis).forEach(function (name) {
      uni[name] = promisify(name, todoApis[name]);
    });
    Object.keys(extraApi).forEach(function (name) {
      uni[name] = promisify(name, todoApis[name]);
    });
  }

  Object.keys(eventApi).forEach(function (name) {
    uni[name] = eventApi[name];
  });

  Object.keys(api).forEach(function (name) {
    uni[name] = promisify(name, api[name]);
  });

  Object.keys(wx).forEach(function (name) {
    if (hasOwn(wx, name) || hasOwn(protocols, name)) {
      uni[name] = promisify(name, wrapper(name, wx[name]));
    }
  });
}

wx.createApp = createApp;
wx.createPage = createPage;
wx.createComponent = createComponent;
wx.createSubpackageApp = createSubpackageApp;
wx.createPlugin = createPlugin;

var uni$1 = uni;var _default =

uni$1;exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ 2)))

/***/ }),
/* 2 */
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 3 */
/*!******************************************************************************************!*\
  !*** ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/mp-vue/dist/mp.runtime.esm.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * Vue.js v2.6.11
 * (c) 2014-2021 Evan You
 * Released under the MIT License.
 */
/*  */

var emptyObject = Object.freeze({});

// These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive.
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    // $flow-disable-line
    typeof value === 'symbol' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

/**
 * Get the raw type string of a value, e.g., [object Object].
 */
var _toString = Object.prototype.toString;

function toRawType (value) {
  return _toString.call(value).slice(8, -1)
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

function isPromise (val) {
  return (
    isDef(val) &&
    typeof val.then === 'function' &&
    typeof val.catch === 'function'
  )
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if an attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array.
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether an object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase()
});

/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */
function polyfillBind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }

  boundFn._length = fn.length;
  return boundFn
}

function nativeBind (fn, ctx) {
  return fn.bind(ctx)
}

var bind = Function.prototype.bind
  ? nativeBind
  : polyfillBind;

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */
var identity = function (_) { return _; };

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime()
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */
function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured',
  'serverPrefetch'
];

/*  */



var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */
var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = new RegExp(("[^" + (unicodeRegExp.source) + ".$_\\d]"));
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/);

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = /*@__PURE__*/(function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = (noop); // work around flow check
var formatComponentName = (noop);

if (true) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str
    .replace(classifyRE, function (c) { return c.toUpperCase(); })
    .replace(/[-_]/g, ''); };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && (!config.silent)) {
      console.error(("[Vue warn]: " + msg + trace));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.warn("[Vue tip]: " + msg + (
        vm ? generateComponentTrace(vm) : ''
      ));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      if (vm.$options && vm.$options.__file) { // fixed by xxxxxx
        return ('') + vm.$options.__file
      }
      return '<Root>'
    }
    var options = typeof vm === 'function' && vm.cid != null
      ? vm.options
      : vm._isVue
        ? vm.$options || vm.constructor.options
        : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (
      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
      (file && includeFile !== false ? (" at " + file) : '')
    )
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) { res += str; }
      if (n > 1) { str += str; }
      n >>= 1;
    }
    return res
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm && vm.$options.name !== 'PageBody') {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        !vm.$options.isReserved && tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree
        .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
            ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
            : formatComponentName(vm))); })
        .join('\n')
    } else {
      return ("\n\n(found in " + (formatComponentName(vm)) + ")")
    }
  };
}

/*  */

var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.SharedObject.target) {
    Dep.SharedObject.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  if ( true && !config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) { return a.id - b.id; });
  }
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
// fixed by xxxxxx (nvue shared vuex)
/* eslint-disable no-undef */
Dep.SharedObject = {};
Dep.SharedObject.target = null;
Dep.SharedObject.targetStack = [];

function pushTarget (target) {
  Dep.SharedObject.targetStack.push(target);
  Dep.SharedObject.target = target;
  Dep.target = target;
}

function popTarget () {
  Dep.SharedObject.targetStack.pop();
  Dep.SharedObject.target = Dep.SharedObject.targetStack[Dep.SharedObject.targetStack.length - 1];
  Dep.target = Dep.SharedObject.target;
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    vnode.children && vnode.children.slice(),
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);

var methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
];

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
var shouldObserve = true;

function toggleObserving (value) {
  shouldObserve = value;
}

/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    if (hasProto) {
      {// fixed by xxxxxx 微信小程序使用 plugins 之后，数组方法被直接挂载到了数组对象上，需要执行 copyAugment 逻辑
        if(value.push !== value.__proto__.push){
          copyAugment(value, arrayMethods, arrayKeys);
        } else {
          protoAugment(value, arrayMethods);
        }
      }
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1 (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.SharedObject.target) { // fixed by xxxxxx
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if ( true && customSetter) {
        customSetter();
      }
      // #7981: for accessor properties without setter
      if (getter && !setter) { return }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if ( true &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(("Cannot set reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
     true && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if ( true &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(("Cannot delete reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
     true && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (true) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn(
        "option \"" + key + "\" can only be used during instance " +
        'creation with the `new` keyword.'
      );
    }
    return defaultStrat(parent, child)
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;

  var keys = hasSymbol
    ? Reflect.ownKeys(from)
    : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    // in case the object is already observed...
    if (key === '__ob__') { continue }
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (
      toVal !== fromVal &&
      isPlainObject(toVal) &&
      isPlainObject(fromVal)
    ) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this, this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
      )
    }
  } else {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm, vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm, vm)
        : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
       true && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  var res = childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal;
  return res
    ? dedupeHooks(res)
    : res
}

function dedupeHooks (hooks) {
  var res = [];
  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }
  return res
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (
  parentVal,
  childVal,
  vm,
  key
) {
  var res = Object.create(parentVal || null);
  if (childVal) {
     true && assertObjectType(key, childVal, vm);
    return extend(res, childVal)
  } else {
    return res
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (
  parentVal,
  childVal,
  vm,
  key
) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (true) {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal,
  childVal,
  vm,
  key
) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName (name) {
  if (!new RegExp(("^[a-zA-Z][\\-\\.0-9_" + (unicodeRegExp.source) + "]*$")).test(name)) {
    warn(
      'Invalid component name: "' + name + '". Component names ' +
      'should conform to valid custom element name in html5 specification.'
    );
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn(
      'Do not use built-in or reserved HTML elements as component ' +
      'id: ' + name
    );
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options, vm) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (true) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  } else if (true) {
    warn(
      "Invalid value for option \"props\": expected an Array or an Object, " +
      "but got " + (toRawType(props)) + ".",
      vm
    );
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options, vm) {
  var inject = options.inject;
  if (!inject) { return }
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val };
    }
  } else if (true) {
    warn(
      "Invalid value for option \"inject\": expected an Array or an Object, " +
      "but got " + (toRawType(inject)) + ".",
      vm
    );
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];
      if (typeof def$$1 === 'function') {
        dirs[key] = { bind: def$$1, update: def$$1 };
      }
    }
  }
}

function assertObjectType (name, value, vm) {
  if (!isPlainObject(value)) {
    warn(
      "Invalid value for option \"" + name + "\": expected an Object, " +
      "but got " + (toRawType(value)) + ".",
      vm
    );
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (true) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);

  // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.
  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if ( true && warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */



function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // boolean casting
  var booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  if (
    true
  ) {
    assertProp(prop, key, value, vm, absent);
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if ( true && isObject(def)) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  if (!valid) {
    warn(
      getInvalidTypeMessage(name, value, expectedTypes),
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType (value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ''
}

function isSameType (a, b) {
  return getType(a) === getType(b)
}

function getTypeIndex (type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1
  }
  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i
    }
  }
  return -1
}

function getInvalidTypeMessage (name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." +
    " Expected " + (expectedTypes.map(capitalize).join(', '));
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType);
  // check if we need to specify expected value
  if (expectedTypes.length === 1 &&
      isExplicable(expectedType) &&
      !isBoolean(expectedType, receivedType)) {
    message += " with value " + expectedValue;
  }
  message += ", got " + receivedType + " ";
  // check if we need to specify received value
  if (isExplicable(receivedType)) {
    message += "with value " + receivedValue + ".";
  }
  return message
}

function styleValue (value, type) {
  if (type === 'String') {
    return ("\"" + value + "\"")
  } else if (type === 'Number') {
    return ("" + (Number(value)))
  } else {
    return ("" + value)
  }
}

function isExplicable (value) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })
}

function isBoolean () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })
}

/*  */

function handleError (err, vm, info) {
  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
  // See: https://github.com/vuejs/vuex/issues/1505
  pushTarget();
  try {
    if (vm) {
      var cur = vm;
      while ((cur = cur.$parent)) {
        var hooks = cur.$options.errorCaptured;
        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;
              if (capture) { return }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }
    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}

function invokeWithErrorHandling (
  handler,
  context,
  args,
  vm,
  info
) {
  var res;
  try {
    res = args ? handler.apply(context, args) : handler.call(context);
    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
      // issue #9511
      // avoid catch triggering multiple times when nested calls
      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }
  return res
}

function globalHandleError (err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }
  logError(err, vm, info);
}

function logError (err, vm, info) {
  if (true) {
    warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err
  }
}

/*  */

var callbacks = [];
var pending = false;

function flushCallbacks () {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).
var timerFunc;

// The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  timerFunc = function () {
    p.then(flushCallbacks);
    // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) { setTimeout(noop); }
  };
} else if (!isIE && typeof MutationObserver !== 'undefined' && (
  isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });
  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Technically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick (cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    timerFunc();
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    })
  }
}

/*  */

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (true) {
  var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
    'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn(
      "Property or method \"" + key + "\" is not defined on the instance but " +
      'referenced during render. Make sure that this property is reactive, ' +
      'either in the data option, or for class-based components, by ' +
      'initializing the property. ' +
      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
      target
    );
  };

  var warnReservedPrefix = function (target, key) {
    warn(
      "Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " +
      'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
      'prevent conflicts with Vue internals. ' +
      'See: https://vuejs.org/v2/api/#data',
      target
    );
  };

  var hasProxy =
    typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set (target, key, value) {
        if (isBuiltInModifier(key)) {
          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
          return false
        } else {
          target[key] = value;
          return true
        }
      }
    });
  }

  var hasHandler = {
    has: function has (target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) ||
        (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));
      if (!has && !isAllowed) {
        if (key in target.$data) { warnReservedPrefix(target, key); }
        else { warnNonPresent(target, key); }
      }
      return has || !isAllowed
    }
  };

  var getHandler = {
    get: function get (target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) { warnReservedPrefix(target, key); }
        else { warnNonPresent(target, key); }
      }
      return target[key]
    }
  };

  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse (val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

var mark;
var measure;

if (true) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
    mark = function (tag) { return perf.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      // perf.clearMeasures(name)
    };
  }
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns, vm) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler")
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  createOnceHandler,
  vm
) {
  var name, def$$1, cur, old, event;
  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
       true && warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }
      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }
      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

/*  */

// fixed by xxxxxx (mp properties)
function extractPropertiesFromVNodeData(data, Ctor, res, context) {
  var propOptions = Ctor.options.mpOptions && Ctor.options.mpOptions.properties;
  if (isUndef(propOptions)) {
    return res
  }
  var externalClasses = Ctor.options.mpOptions.externalClasses || [];
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      var result = checkProp(res, props, key, altKey, true) ||
          checkProp(res, attrs, key, altKey, false);
      // externalClass
      if (
        result &&
        res[key] &&
        externalClasses.indexOf(altKey) !== -1 &&
        context[camelize(res[key])]
      ) {
        // 赋值 externalClass 真正的值(模板里 externalClass 的值可能是字符串)
        res[key] = context[camelize(res[key])];
      }
    }
  }
  return res
}

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag,
  context// fixed by xxxxxx
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    // fixed by xxxxxx
    return extractPropertiesFromVNodeData(data, Ctor, {}, context)
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (true) {
        var keyInLowerCase = key.toLowerCase();
        if (
          key !== keyInLowerCase &&
          attrs && hasOwn(attrs, keyInLowerCase)
        ) {
          tip(
            "Prop \"" + keyInLowerCase + "\" is passed to component " +
            (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
            " \"" + key + "\". " +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
          );
        }
      }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  // fixed by xxxxxx
  return extractPropertiesFromVNodeData(data, Ctor, res, context)
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]).text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (true) {
        defineReactive$$1(vm, key, result[key], function () {
          warn(
            "Avoid mutating an injected value directly since the changes will be " +
            "overwritten whenever the provided component re-renders. " +
            "injection being mutated: \"" + key + "\"",
            vm
          );
        });
      } else {}
    });
    toggleObserving(true);
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
      ? Reflect.ownKeys(inject)
      : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      // #6574 in case the inject object is observed...
      if (key === '__ob__') { continue }
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault;
        } else if (true) {
          warn(("Injection \"" + key + "\" not found"), vm);
        }
      }
    }
    return result
  }
}

/*  */



/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  if (!children || !children.length) {
    return {}
  }
  var slots = {};
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) &&
      data && data.slot != null
    ) {
      var name = data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      // fixed by xxxxxx 临时 hack 掉 uni-app 中的异步 name slot page
      if(child.asyncMeta && child.asyncMeta.data && child.asyncMeta.data.slot === 'page'){
        (slots['page'] || (slots['page'] = [])).push(child);
      }else{
        (slots.default || (slots.default = [])).push(child);
      }
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots
}

function isWhitespace (node) {
  return (node.isComment && !node.asyncFactory) || node.text === ' '
}

/*  */

function normalizeScopedSlots (
  slots,
  normalSlots,
  prevSlots
) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;
  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized
  } else if (
    isStable &&
    prevSlots &&
    prevSlots !== emptyObject &&
    key === prevSlots.$key &&
    !hasNormalSlots &&
    !prevSlots.$hasNormal
  ) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots
  } else {
    res = {};
    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== '$') {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  }
  // expose normal slots on scopedSlots
  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2);
    }
  }
  // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error
  if (slots && Object.isExtensible(slots)) {
    (slots)._normalized = res;
  }
  def(res, '$stable', isStable);
  def(res, '$key', key);
  def(res, '$hasNormal', hasNormalSlots);
  return res
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res)
      ? [res] // single vnode
      : normalizeChildren(res);
    return res && (
      res.length === 0 ||
      (res.length === 1 && res[0].isComment) // #9658
    ) ? undefined
      : res
  };
  // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.
  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }
  return normalized
}

function proxyNormalSlot(slots, key) {
  return function () { return slots[key]; }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i, i, i); // fixed by xxxxxx
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i, i, i); // fixed by xxxxxx
    }
  } else if (isObject(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();
      while (!result.done) {
        ret.push(render(result.value, ret.length, i, i++)); // fixed by xxxxxx
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i, i); // fixed by xxxxxx
      }
    }
  }
  if (!isDef(ret)) {
    ret = [];
  }
  (ret)._isVList = true;
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      if ( true && !isObject(bindObject)) {
        warn(
          'slot v-bind without argument expects an Object',
          this
        );
      }
      props = extend(extend({}, bindObject), props);
    }
    // fixed by xxxxxx app-plus scopedSlot
    nodes = scopedSlotFn(props, this, props._i) || fallback;
  } else {
    nodes = this.$slots[name] || fallback;
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

function isKeyNotMatch (expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1
  } else {
    return expect !== actual
  }
}

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInKeyCode,
  eventKeyName,
  builtInKeyName
) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName)
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode)
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
       true && warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        var camelizedKey = camelize(key);
        var hyphenatedKey = hyphenate(key);
        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.
  if (tree && !isInFor) {
    return tree
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = this.$options.staticRenderFns[index].call(
    this._renderProxy,
    null,
    this // for render fns generated for functional component templates
  );
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
       true && warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data
}

/*  */

function resolveScopedSlots (
  fns, // see flow/vnode
  res,
  // the following are added in 2.6
  hasDynamicKeys,
  contentHashKey
) {
  res = res || { $stable: !hasDynamicKeys };
  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];
    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }
      res[slot.key] = slot.fn;
    }
  }
  if (contentHashKey) {
    (res).$key = contentHashKey;
  }
  return res
}

/*  */

function bindDynamicKeys (baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];
    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if ( true && key !== '' && key !== null) {
      // null is a special value for explicitly removing a binding
      warn(
        ("Invalid value for dynamic directive argument (expected string or null): " + key),
        this
      );
    }
  }
  return baseObj
}

// helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.
function prependModifier (value, symbol) {
  return typeof value === 'string' ? symbol + value : value
}

/*  */

function installRenderHelpers (target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}

/*  */

function FunctionalRenderContext (
  data,
  props,
  children,
  parent,
  Ctor
) {
  var this$1 = this;

  var options = Ctor.options;
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm;
  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent);
    // $flow-disable-line
    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent;
    // $flow-disable-line
    parent = parent._original;
  }
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(
        data.scopedSlots,
        this$1.$slots = resolveSlots(children, parent)
      );
    }
    return this$1.$slots
  };

  Object.defineProperty(this, 'scopedSlots', ({
    enumerable: true,
    get: function get () {
      return normalizeScopedSlots(data.scopedSlots, this.slots())
    }
  }));

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode
    };
  } else {
    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  contextVm,
  children
) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }

  var renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  );

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);
    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }
    return res
  }
}

function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  if (true) {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }
  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }
  return clone
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

/*  */

/*  */

/*  */

// inline hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (vnode, hydrating) {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      callHook(componentInstance, 'onServiceCreated');
      callHook(componentInstance, 'onServiceAttached');
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (true) {
      warn(("Invalid Component definition: " + (String(Ctor))), context);
    }
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag, context); // fixed by xxxxxx

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // install component management hooks onto the placeholder node
  installComponentHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );

  return vnode
}

function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent // activeInstance in lifecycle state
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options)
}

function installComponentHooks (data) {
  var hooks = data.hook || (data.hook = {});
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1 (f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };
  merged._merged = true;
  return merged
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input'
  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;
  if (isDef(existing)) {
    if (
      Array.isArray(existing)
        ? existing.indexOf(callback) === -1
        : existing !== callback
    ) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
     true && warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if ( true &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    {
      warn(
        'Avoid using non-primitive value as key, ' +
        'use string/number value instead.',
        context
      );
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if ( true && isDef(data) && isDef(data.nativeOn)) {
        warn(
          ("The .native modifier for v-on is only valid on components but it was used on <" + tag + ">."),
          context
        );
      }
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) { applyNS(vnode, ns); }
    if (isDef(data)) { registerDeepBindings(data); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (
        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
        applyNS(child, ns, force);
      }
    }
  }
}

// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings (data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }
  if (isObject(data.class)) {
    traverse(data.class);
  }
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null; // v-once cached trees
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (true) {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {}
}

var currentRenderingInstance = null;

function renderMixin (Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(
        _parentVnode.data.scopedSlots,
        vm.$slots,
        vm.$scopedSlots
      );
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if ( true && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    }
    // if the returned array contains only a single node, allow it
    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if ( true && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };
}

/*  */

function ensureCtor (comp, base) {
  if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  var owner = currentRenderingInstance;
  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner);
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (owner && !isDef(factory.owners)) {
    var owners = factory.owners = [owner];
    var sync = true;
    var timerLoading = null;
    var timerTimeout = null

    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        (owners[i]).$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;
        if (timerLoading !== null) {
          clearTimeout(timerLoading);
          timerLoading = null;
        }
        if (timerTimeout !== null) {
          clearTimeout(timerTimeout);
          timerTimeout = null;
        }
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });

    var reject = once(function (reason) {
       true && warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading = setTimeout(function () {
              timerLoading = null;
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(function () {
            timerTimeout = null;
            if (isUndef(factory.resolved)) {
              reject(
                 true
                  ? ("timeout (" + (res.timeout) + "ms)")
                  : undefined
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn) {
  target.$on(event, fn);
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function createOnceHandler (event, fn) {
  var _target = target;
  return function onceHandler () {
    var res = fn.apply(null, arguments);
    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  }
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (!fn) {
      vm._events[event] = null;
      return vm
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (true) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip(
          "Event \"" + lowerCaseEvent + "\" is emitted in component " +
          (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
          "Note that HTML attributes are case-insensitive and you cannot use " +
          "v-on to listen to camelCase events when using in-DOM templates. " +
          "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";
      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }
    return vm
  };
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  }
}

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    restoreActiveInstance();
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  if (true) {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.

  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.
  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(
    (newScopedSlots && !newScopedSlots.$stable) ||
    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)
  );

  // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.
  var needsForceUpdate = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    hasDynamicScopedSlot
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?
      props[key] = validateProp(key, propOptions, propsData, vm);
    }
    toggleObserving(true);
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // fixed by xxxxxx update properties(mp runtime)
  vm._$updateProperties && vm._$updateProperties(vm);

  // update listeners
  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners);

  // resolve slots + force update if has children
  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (true) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
  popTarget();
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (true) {
    circular = {};
  }
  waiting = flushing = false;
}

// Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.
var currentFlushTimestamp = 0;

// Async edge case fix requires storing an event listener's attach timestamp.
var getNow = Date.now;

// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)
if (inBrowser && !isIE) {
  var performance = window.performance;
  if (
    performance &&
    typeof performance.now === 'function' &&
    getNow() > document.createEvent('Event').timeStamp
  ) {
    // if the event timestamp, although evaluated AFTER the Date.now(), is
    // smaller than it, it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listener timestamps as
    // well.
    getNow = function () { return performance.now(); };
  }
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    if (watcher.before) {
      watcher.before();
    }
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if ( true && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;

      if ( true && !config.async) {
        flushSchedulerQueue();
        return
      }
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */



var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options,
  isRenderWatcher
) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  true
    ? expOrFn.toString()
    : undefined;
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = noop;
       true && warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
  var i = this.deps.length;
  while (i--) {
    var dep = this.deps[i];
    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
  var i = this.deps.length;
  while (i--) {
    this.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this.deps[i].removeSub(this);
    }
    this.active = false;
  }
};

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (true) {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          {
            if(vm.mpHost === 'mp-baidu' || vm.mpHost === 'mp-kuaishou'){//百度、快手 observer 在 setData callback 之后触发，直接忽略该 warn
                return
            }
            //fixed by xxxxxx __next_tick_pending,uni://form-field 时不告警
            if(
                key === 'value' &&
                Array.isArray(vm.$options.behaviors) &&
                vm.$options.behaviors.indexOf('uni://form-field') !== -1
              ){
              return
            }
            if(vm._getFormData){
              return
            }
            var $parent = vm.$parent;
            while($parent){
              if($parent.__next_tick_pending){
                return
              }
              $parent = $parent.$parent;
            }
          }
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
    } else {}
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  toggleObserving(true);
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
     true && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (true) {
      if (methods && hasOwn(methods, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a data property."),
          vm
        );
      }
    }
    if (props && hasOwn(props, key)) {
       true && warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();
  try {
    return data.call(vm, vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if ( true && getter == null) {
      warn(
        ("Getter is missing for computed property \"" + key + "\"."),
        vm
      );
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (true) {
      if (key in vm.$data) {
        warn(("The computed property \"" + key + "\" is already defined in data."), vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
      }
    }
  }
}

function defineComputed (
  target,
  key,
  userDef
) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }
  if ( true &&
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.SharedObject.target) {// fixed by xxxxxx
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function createGetterInvoker(fn) {
  return function computedGetter () {
    return fn.call(this, this)
  }
}

function initMethods (vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (true) {
      if (typeof methods[key] !== 'function') {
        warn(
          "Method \"" + key + "\" has type \"" + (typeof methods[key]) + "\" in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      if (props && hasOwn(props, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
      if ((key in vm) && isReserved(key)) {
        warn(
          "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
          "Avoid defining component methods that start with _ or $."
        );
      }
    }
    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}

function initWatch (vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  expOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(expOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  if (true) {
    dataDef.set = function () {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      );
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      try {
        cb.call(vm, watcher.value);
      } catch (error) {
        handleError(error, vm, ("callback for immediate watcher \"" + (watcher.expression) + "\""));
      }
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

var uid$3 = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$3++;

    var startTag, endTag;
    /* istanbul ignore if */
    if ( true && config.performance && mark) {
      startTag = "vue-perf-start:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    if (true) {
      initProxy(vm);
    } else {}
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    !vm._$fallback && initInjections(vm); // resolve injections before data/props
    initState(vm);
    !vm._$fallback && initProvide(vm); // resolve provide after data/props
    !vm._$fallback && callHook(vm, 'created');

    /* istanbul ignore if */
    if ( true && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(("vue " + (vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = latest[key];
    }
  }
  return modified
}

function Vue (options) {
  if ( true &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if ( true && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if ( true && type === 'component') {
          validateComponentName(id);
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */



function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry (
  cache,
  key,
  keys,
  current
) {
  var cached$$1 = cache[key];
  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  created: function created () {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed () {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },

  mounted: function mounted () {
    var this$1 = this;

    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) { return matches(val, name); });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) { return !matches(val, name); });
    });
  },

  render: function render () {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;
      if (
        // not included
        (include && (!name || !matches(include, name))) ||
        // excluded
        (exclude && name && matches(exclude, name))
      ) {
        return vnode
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }
    return vnode || (slot && slot[0])
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  if (true) {
    configDef.set = function () {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      );
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  // 2.6 explicit observable API
  Vue.observable = function (obj) {
    observe(obj);
    return obj
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});

Vue.version = '2.6.11';

/**
 * https://raw.githubusercontent.com/Tencent/westore/master/packages/westore/utils/diff.js
 */
var ARRAYTYPE = '[object Array]';
var OBJECTTYPE = '[object Object]';
// const FUNCTIONTYPE = '[object Function]'

function diff(current, pre) {
    var result = {};
    syncKeys(current, pre);
    _diff(current, pre, '', result);
    return result
}

function syncKeys(current, pre) {
    if (current === pre) { return }
    var rootCurrentType = type(current);
    var rootPreType = type(pre);
    if (rootCurrentType == OBJECTTYPE && rootPreType == OBJECTTYPE) {
        if(Object.keys(current).length >= Object.keys(pre).length){
            for (var key in pre) {
                var currentValue = current[key];
                if (currentValue === undefined) {
                    current[key] = null;
                } else {
                    syncKeys(currentValue, pre[key]);
                }
            }
        }
    } else if (rootCurrentType == ARRAYTYPE && rootPreType == ARRAYTYPE) {
        if (current.length >= pre.length) {
            pre.forEach(function (item, index) {
                syncKeys(current[index], item);
            });
        }
    }
}

function _diff(current, pre, path, result) {
    if (current === pre) { return }
    var rootCurrentType = type(current);
    var rootPreType = type(pre);
    if (rootCurrentType == OBJECTTYPE) {
        if (rootPreType != OBJECTTYPE || Object.keys(current).length < Object.keys(pre).length) {
            setResult(result, path, current);
        } else {
            var loop = function ( key ) {
                var currentValue = current[key];
                var preValue = pre[key];
                var currentType = type(currentValue);
                var preType = type(preValue);
                if (currentType != ARRAYTYPE && currentType != OBJECTTYPE) {
                    // NOTE 此处将 != 修改为 !==。涉及地方太多恐怕测试不到，如果出现数据对比问题，将其修改回来。
                    if (currentValue !== pre[key]) {
                        setResult(result, (path == '' ? '' : path + ".") + key, currentValue);
                    }
                } else if (currentType == ARRAYTYPE) {
                    if (preType != ARRAYTYPE) {
                        setResult(result, (path == '' ? '' : path + ".") + key, currentValue);
                    } else {
                        if (currentValue.length < preValue.length) {
                            setResult(result, (path == '' ? '' : path + ".") + key, currentValue);
                        } else {
                            currentValue.forEach(function (item, index) {
                                _diff(item, preValue[index], (path == '' ? '' : path + ".") + key + '[' + index + ']', result);
                            });
                        }
                    }
                } else if (currentType == OBJECTTYPE) {
                    if (preType != OBJECTTYPE || Object.keys(currentValue).length < Object.keys(preValue).length) {
                        setResult(result, (path == '' ? '' : path + ".") + key, currentValue);
                    } else {
                        for (var subKey in currentValue) {
                            _diff(currentValue[subKey], preValue[subKey], (path == '' ? '' : path + ".") + key + '.' + subKey, result);
                        }
                    }
                }
            };

            for (var key in current) loop( key );
        }
    } else if (rootCurrentType == ARRAYTYPE) {
        if (rootPreType != ARRAYTYPE) {
            setResult(result, path, current);
        } else {
            if (current.length < pre.length) {
                setResult(result, path, current);
            } else {
                current.forEach(function (item, index) {
                    _diff(item, pre[index], path + '[' + index + ']', result);
                });
            }
        }
    } else {
        setResult(result, path, current);
    }
}

function setResult(result, k, v) {
    // if (type(v) != FUNCTIONTYPE) {
        result[k] = v;
    // }
}

function type(obj) {
    return Object.prototype.toString.call(obj)
}

/*  */

function flushCallbacks$1(vm) {
    if (vm.__next_tick_callbacks && vm.__next_tick_callbacks.length) {
        if (Object({"VUE_APP_NAME":"秒合约","VUE_APP_PLATFORM":"mp-weixin","NODE_ENV":"development","BASE_URL":"/"}).VUE_APP_DEBUG) {
            var mpInstance = vm.$scope;
            console.log('[' + (+new Date) + '][' + (mpInstance.is || mpInstance.route) + '][' + vm._uid +
                ']:flushCallbacks[' + vm.__next_tick_callbacks.length + ']');
        }
        var copies = vm.__next_tick_callbacks.slice(0);
        vm.__next_tick_callbacks.length = 0;
        for (var i = 0; i < copies.length; i++) {
            copies[i]();
        }
    }
}

function hasRenderWatcher(vm) {
    return queue.find(function (watcher) { return vm._watcher === watcher; })
}

function nextTick$1(vm, cb) {
    //1.nextTick 之前 已 setData 且 setData 还未回调完成
    //2.nextTick 之前存在 render watcher
    if (!vm.__next_tick_pending && !hasRenderWatcher(vm)) {
        if(Object({"VUE_APP_NAME":"秒合约","VUE_APP_PLATFORM":"mp-weixin","NODE_ENV":"development","BASE_URL":"/"}).VUE_APP_DEBUG){
            var mpInstance = vm.$scope;
            console.log('[' + (+new Date) + '][' + (mpInstance.is || mpInstance.route) + '][' + vm._uid +
                ']:nextVueTick');
        }
        return nextTick(cb, vm)
    }else{
        if(Object({"VUE_APP_NAME":"秒合约","VUE_APP_PLATFORM":"mp-weixin","NODE_ENV":"development","BASE_URL":"/"}).VUE_APP_DEBUG){
            var mpInstance$1 = vm.$scope;
            console.log('[' + (+new Date) + '][' + (mpInstance$1.is || mpInstance$1.route) + '][' + vm._uid +
                ']:nextMPTick');
        }
    }
    var _resolve;
    if (!vm.__next_tick_callbacks) {
        vm.__next_tick_callbacks = [];
    }
    vm.__next_tick_callbacks.push(function () {
        if (cb) {
            try {
                cb.call(vm);
            } catch (e) {
                handleError(e, vm, 'nextTick');
            }
        } else if (_resolve) {
            _resolve(vm);
        }
    });
    // $flow-disable-line
    if (!cb && typeof Promise !== 'undefined') {
        return new Promise(function (resolve) {
            _resolve = resolve;
        })
    }
}

/*  */

function cloneWithData(vm) {
  // 确保当前 vm 所有数据被同步
  var ret = Object.create(null);
  var dataKeys = [].concat(
    Object.keys(vm._data || {}),
    Object.keys(vm._computedWatchers || {}));

  dataKeys.reduce(function(ret, key) {
    ret[key] = vm[key];
    return ret
  }, ret);

  // vue-composition-api
  var compositionApiState = vm.__composition_api_state__ || vm.__secret_vfa_state__;
  var rawBindings = compositionApiState && compositionApiState.rawBindings;
  if (rawBindings) {
    Object.keys(rawBindings).forEach(function (key) {
      ret[key] = vm[key];
    });
  }

  //TODO 需要把无用数据处理掉，比如 list=>l0 则 list 需要移除，否则多传输一份数据
  Object.assign(ret, vm.$mp.data || {});
  if (
    Array.isArray(vm.$options.behaviors) &&
    vm.$options.behaviors.indexOf('uni://form-field') !== -1
  ) { //form-field
    ret['name'] = vm.name;
    ret['value'] = vm.value;
  }

  return JSON.parse(JSON.stringify(ret))
}

var patch = function(oldVnode, vnode) {
  var this$1 = this;

  if (vnode === null) { //destroy
    return
  }
  if (this.mpType === 'page' || this.mpType === 'component') {
    var mpInstance = this.$scope;
    var data = Object.create(null);
    try {
      data = cloneWithData(this);
    } catch (err) {
      console.error(err);
    }
    data.__webviewId__ = mpInstance.data.__webviewId__;
    var mpData = Object.create(null);
    Object.keys(data).forEach(function (key) { //仅同步 data 中有的数据
      mpData[key] = mpInstance.data[key];
    });
    var diffData = this.$shouldDiffData === false ? data : diff(data, mpData);
    if (Object.keys(diffData).length) {
      if (Object({"VUE_APP_NAME":"秒合约","VUE_APP_PLATFORM":"mp-weixin","NODE_ENV":"development","BASE_URL":"/"}).VUE_APP_DEBUG) {
        console.log('[' + (+new Date) + '][' + (mpInstance.is || mpInstance.route) + '][' + this._uid +
          ']差量更新',
          JSON.stringify(diffData));
      }
      this.__next_tick_pending = true;
      mpInstance.setData(diffData, function () {
        this$1.__next_tick_pending = false;
        flushCallbacks$1(this$1);
      });
    } else {
      flushCallbacks$1(this);
    }
  }
};

/*  */

function createEmptyRender() {

}

function mountComponent$1(
  vm,
  el,
  hydrating
) {
  if (!vm.mpType) {//main.js 中的 new Vue
    return vm
  }
  if (vm.mpType === 'app') {
    vm.$options.render = createEmptyRender;
  }
  if (!vm.$options.render) {
    vm.$options.render = createEmptyRender;
    if (true) {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        );
      }
    }
  }

  !vm._$fallback && callHook(vm, 'beforeMount');

  var updateComponent = function () {
    vm._update(vm._render(), hydrating);
  };

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, {
    before: function before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true /* isRenderWatcher */);
  hydrating = false;
  return vm
}

/*  */

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/*  */

var MP_METHODS = ['createSelectorQuery', 'createIntersectionObserver', 'selectAllComponents', 'selectComponent'];

function getTarget(obj, path) {
  var parts = path.split('.');
  var key = parts[0];
  if (key.indexOf('__$n') === 0) { //number index
    key = parseInt(key.replace('__$n', ''));
  }
  if (parts.length === 1) {
    return obj[key]
  }
  return getTarget(obj[key], parts.slice(1).join('.'))
}

function internalMixin(Vue) {

  Vue.config.errorHandler = function(err, vm, info) {
    Vue.util.warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
    console.error(err);
    /* eslint-disable no-undef */
    var app = typeof getApp === 'function' && getApp();
    if (app && app.onError) {
      app.onError(err);
    }
  };

  var oldEmit = Vue.prototype.$emit;

  Vue.prototype.$emit = function(event) {
    if (this.$scope && event) {
      (this.$scope['_triggerEvent'] || this.$scope['triggerEvent'])
        .call(this.$scope, event, {
          __args__: toArray(arguments, 1)
        })
    }
    return oldEmit.apply(this, arguments)
  };

  Vue.prototype.$nextTick = function(fn) {
    return nextTick$1(this, fn)
  };

  MP_METHODS.forEach(function (method) {
    Vue.prototype[method] = function(args) {
      if (this.$scope && this.$scope[method]) {
        return this.$scope[method](args)
      }
      // mp-alipay
      if (typeof my === 'undefined') {
        return
      }
      if (method === 'createSelectorQuery') {
        /* eslint-disable no-undef */
        return my.createSelectorQuery(args)
      } else if (method === 'createIntersectionObserver') {
        /* eslint-disable no-undef */
        return my.createIntersectionObserver(args)
      }
      // TODO mp-alipay 暂不支持 selectAllComponents,selectComponent
    };
  });

  Vue.prototype.__init_provide = initProvide;

  Vue.prototype.__init_injections = initInjections;

  Vue.prototype.__call_hook = function(hook, args) {
    var vm = this;
    // #7573 disable dep collection when invoking lifecycle hooks
    pushTarget();
    var handlers = vm.$options[hook];
    var info = hook + " hook";
    var ret;
    if (handlers) {
      for (var i = 0, j = handlers.length; i < j; i++) {
        ret = invokeWithErrorHandling(handlers[i], vm, args ? [args] : null, vm, info);
      }
    }
    if (vm._hasHookEvent) {
      vm.$emit('hook:' + hook, args);
    }
    popTarget();
    return ret
  };

  Vue.prototype.__set_model = function(target, key, value, modifiers) {
    if (Array.isArray(modifiers)) {
      if (modifiers.indexOf('trim') !== -1) {
        value = value.trim();
      }
      if (modifiers.indexOf('number') !== -1) {
        value = this._n(value);
      }
    }
    if (!target) {
      target = this;
    }
    // 解决动态属性添加
    Vue.set(target, key, value)
  };

  Vue.prototype.__set_sync = function(target, key, value) {
    if (!target) {
      target = this;
    }
    // 解决动态属性添加
    Vue.set(target, key, value)
  };

  Vue.prototype.__get_orig = function(item) {
    if (isPlainObject(item)) {
      return item['$orig'] || item
    }
    return item
  };

  Vue.prototype.__get_value = function(dataPath, target) {
    return getTarget(target || this, dataPath)
  };


  Vue.prototype.__get_class = function(dynamicClass, staticClass) {
    return renderClass(staticClass, dynamicClass)
  };

  Vue.prototype.__get_style = function(dynamicStyle, staticStyle) {
    if (!dynamicStyle && !staticStyle) {
      return ''
    }
    var dynamicStyleObj = normalizeStyleBinding(dynamicStyle);
    var styleObj = staticStyle ? extend(staticStyle, dynamicStyleObj) : dynamicStyleObj;
    return Object.keys(styleObj).map(function (name) { return ((hyphenate(name)) + ":" + (styleObj[name])); }).join(';')
  };

  Vue.prototype.__map = function(val, iteratee) {
    //TODO 暂不考虑 string
    var ret, i, l, keys, key;
    if (Array.isArray(val)) {
      ret = new Array(val.length);
      for (i = 0, l = val.length; i < l; i++) {
        ret[i] = iteratee(val[i], i);
      }
      return ret
    } else if (isObject(val)) {
      keys = Object.keys(val);
      ret = Object.create(null);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[key] = iteratee(val[key], key, i);
      }
      return ret
    } else if (typeof val === 'number') {
      ret = new Array(val);
      for (i = 0, l = val; i < l; i++) {
        // 第一个参数暂时仍和小程序一致
        ret[i] = iteratee(i, i);
      }
      return ret
    }
    return []
  };

}

/*  */

var LIFECYCLE_HOOKS$1 = [
    //App
    'onLaunch',
    'onShow',
    'onHide',
    'onUniNViewMessage',
    'onPageNotFound',
    'onThemeChange',
    'onError',
    'onUnhandledRejection',
    //Page
    'onInit',
    'onLoad',
    // 'onShow',
    'onReady',
    // 'onHide',
    'onUnload',
    'onPullDownRefresh',
    'onReachBottom',
    'onTabItemTap',
    'onAddToFavorites',
    'onShareTimeline',
    'onShareAppMessage',
    'onResize',
    'onPageScroll',
    'onNavigationBarButtonTap',
    'onBackPress',
    'onNavigationBarSearchInputChanged',
    'onNavigationBarSearchInputConfirmed',
    'onNavigationBarSearchInputClicked',
    //Component
    // 'onReady', // 兼容旧版本，应该移除该事件
    'onPageShow',
    'onPageHide',
    'onPageResize'
];
function lifecycleMixin$1(Vue) {

    //fixed vue-class-component
    var oldExtend = Vue.extend;
    Vue.extend = function(extendOptions) {
        extendOptions = extendOptions || {};

        var methods = extendOptions.methods;
        if (methods) {
            Object.keys(methods).forEach(function (methodName) {
                if (LIFECYCLE_HOOKS$1.indexOf(methodName)!==-1) {
                    extendOptions[methodName] = methods[methodName];
                    delete methods[methodName];
                }
            });
        }

        return oldExtend.call(this, extendOptions)
    };

    var strategies = Vue.config.optionMergeStrategies;
    var mergeHook = strategies.created;
    LIFECYCLE_HOOKS$1.forEach(function (hook) {
        strategies[hook] = mergeHook;
    });

    Vue.prototype.__lifecycle_hooks__ = LIFECYCLE_HOOKS$1;
}

/*  */

// install platform patch function
Vue.prototype.__patch__ = patch;

// public mount method
Vue.prototype.$mount = function(
    el ,
    hydrating
) {
    return mountComponent$1(this, el, hydrating)
};

lifecycleMixin$1(Vue);
internalMixin(Vue);

/*  */

/* harmony default export */ __webpack_exports__["default"] = (Vue);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ 2)))

/***/ }),
/* 4 */
/*!*************************************************************!*\
  !*** ./node_modules/@dcloudio/uni-i18n/dist/uni-i18n.es.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(uni, global) {Object.defineProperty(exports, "__esModule", { value: true });exports.compileI18nJsonStr = compileI18nJsonStr;exports.hasI18nJson = hasI18nJson;exports.initVueI18n = initVueI18n;exports.isI18nStr = isI18nStr;exports.normalizeLocale = normalizeLocale;exports.parseI18nJson = parseI18nJson;exports.resolveLocale = resolveLocale;exports.isString = exports.LOCALE_ZH_HANT = exports.LOCALE_ZH_HANS = exports.LOCALE_FR = exports.LOCALE_ES = exports.LOCALE_EN = exports.I18n = exports.Formatter = void 0;function _slicedToArray(arr, i) {return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();}function _nonIterableRest() {throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _iterableToArrayLimit(arr, i) {if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;var _arr = [];var _n = true;var _d = false;var _e = undefined;try {for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i["return"] != null) _i["return"]();} finally {if (_d) throw _e;}}return _arr;}function _arrayWithHoles(arr) {if (Array.isArray(arr)) return arr;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var isArray = Array.isArray;
var isObject = function isObject(val) {return val !== null && typeof val === 'object';};
var defaultDelimiters = ['{', '}'];var
BaseFormatter = /*#__PURE__*/function () {
  function BaseFormatter() {_classCallCheck(this, BaseFormatter);
    this._caches = Object.create(null);
  }_createClass(BaseFormatter, [{ key: "interpolate", value: function interpolate(
    message, values) {var delimiters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultDelimiters;
      if (!values) {
        return [message];
      }
      var tokens = this._caches[message];
      if (!tokens) {
        tokens = parse(message, delimiters);
        this._caches[message] = tokens;
      }
      return compile(tokens, values);
    } }]);return BaseFormatter;}();exports.Formatter = BaseFormatter;

var RE_TOKEN_LIST_VALUE = /^(?:\d)+/;
var RE_TOKEN_NAMED_VALUE = /^(?:\w)+/;
function parse(format, _ref) {var _ref2 = _slicedToArray(_ref, 2),startDelimiter = _ref2[0],endDelimiter = _ref2[1];
  var tokens = [];
  var position = 0;
  var text = '';
  while (position < format.length) {
    var char = format[position++];
    if (char === startDelimiter) {
      if (text) {
        tokens.push({ type: 'text', value: text });
      }
      text = '';
      var sub = '';
      char = format[position++];
      while (char !== undefined && char !== endDelimiter) {
        sub += char;
        char = format[position++];
      }
      var isClosed = char === endDelimiter;
      var type = RE_TOKEN_LIST_VALUE.test(sub) ?
      'list' :
      isClosed && RE_TOKEN_NAMED_VALUE.test(sub) ?
      'named' :
      'unknown';
      tokens.push({ value: sub, type: type });
    }
    //  else if (char === '%') {
    //   // when found rails i18n syntax, skip text capture
    //   if (format[position] !== '{') {
    //     text += char
    //   }
    // }
    else {
        text += char;
      }
  }
  text && tokens.push({ type: 'text', value: text });
  return tokens;
}
function compile(tokens, values) {
  var compiled = [];
  var index = 0;
  var mode = isArray(values) ?
  'list' :
  isObject(values) ?
  'named' :
  'unknown';
  if (mode === 'unknown') {
    return compiled;
  }
  while (index < tokens.length) {
    var token = tokens[index];
    switch (token.type) {
      case 'text':
        compiled.push(token.value);
        break;
      case 'list':
        compiled.push(values[parseInt(token.value, 10)]);
        break;
      case 'named':
        if (mode === 'named') {
          compiled.push(values[token.value]);
        } else
        {
          if (true) {
            console.warn("Type of token '".concat(token.type, "' and format of value '").concat(mode, "' don't match!"));
          }
        }
        break;
      case 'unknown':
        if (true) {
          console.warn("Detect 'unknown' type of token!");
        }
        break;}

    index++;
  }
  return compiled;
}

var LOCALE_ZH_HANS = 'zh-Hans';exports.LOCALE_ZH_HANS = LOCALE_ZH_HANS;
var LOCALE_ZH_HANT = 'zh-Hant';exports.LOCALE_ZH_HANT = LOCALE_ZH_HANT;
var LOCALE_EN = 'en';exports.LOCALE_EN = LOCALE_EN;
var LOCALE_FR = 'fr';exports.LOCALE_FR = LOCALE_FR;
var LOCALE_ES = 'es';exports.LOCALE_ES = LOCALE_ES;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var hasOwn = function hasOwn(val, key) {return hasOwnProperty.call(val, key);};
var defaultFormatter = new BaseFormatter();
function include(str, parts) {
  return !!parts.find(function (part) {return str.indexOf(part) !== -1;});
}
function startsWith(str, parts) {
  return parts.find(function (part) {return str.indexOf(part) === 0;});
}
function normalizeLocale(locale, messages) {
  if (!locale) {
    return;
  }
  locale = locale.trim().replace(/_/g, '-');
  if (messages && messages[locale]) {
    return locale;
  }
  locale = locale.toLowerCase();
  if (locale.indexOf('zh') === 0) {
    if (locale.indexOf('-hans') > -1) {
      return LOCALE_ZH_HANS;
    }
    if (locale.indexOf('-hant') > -1) {
      return LOCALE_ZH_HANT;
    }
    if (include(locale, ['-tw', '-hk', '-mo', '-cht'])) {
      return LOCALE_ZH_HANT;
    }
    return LOCALE_ZH_HANS;
  }
  var lang = startsWith(locale, [LOCALE_EN, LOCALE_FR, LOCALE_ES]);
  if (lang) {
    return lang;
  }
}var
I18n = /*#__PURE__*/function () {
  function I18n(_ref3) {var locale = _ref3.locale,fallbackLocale = _ref3.fallbackLocale,messages = _ref3.messages,watcher = _ref3.watcher,formater = _ref3.formater;_classCallCheck(this, I18n);
    this.locale = LOCALE_EN;
    this.fallbackLocale = LOCALE_EN;
    this.message = {};
    this.messages = {};
    this.watchers = [];
    if (fallbackLocale) {
      this.fallbackLocale = fallbackLocale;
    }
    this.formater = formater || defaultFormatter;
    this.messages = messages || {};
    this.setLocale(locale || LOCALE_EN);
    if (watcher) {
      this.watchLocale(watcher);
    }
  }_createClass(I18n, [{ key: "setLocale", value: function setLocale(
    locale) {var _this = this;
      var oldLocale = this.locale;
      this.locale = normalizeLocale(locale, this.messages) || this.fallbackLocale;
      if (!this.messages[this.locale]) {
        // 可能初始化时不存在
        this.messages[this.locale] = {};
      }
      this.message = this.messages[this.locale];
      // 仅发生变化时，通知
      if (oldLocale !== this.locale) {
        this.watchers.forEach(function (watcher) {
          watcher(_this.locale, oldLocale);
        });
      }
    } }, { key: "getLocale", value: function getLocale()
    {
      return this.locale;
    } }, { key: "watchLocale", value: function watchLocale(
    fn) {var _this2 = this;
      var index = this.watchers.push(fn) - 1;
      return function () {
        _this2.watchers.splice(index, 1);
      };
    } }, { key: "add", value: function add(
    locale, message) {var override = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var curMessages = this.messages[locale];
      if (curMessages) {
        if (override) {
          Object.assign(curMessages, message);
        } else
        {
          Object.keys(message).forEach(function (key) {
            if (!hasOwn(curMessages, key)) {
              curMessages[key] = message[key];
            }
          });
        }
      } else
      {
        this.messages[locale] = message;
      }
    } }, { key: "f", value: function f(
    message, values, delimiters) {
      return this.formater.interpolate(message, values, delimiters).join('');
    } }, { key: "t", value: function t(
    key, locale, values) {
      var message = this.message;
      if (typeof locale === 'string') {
        locale = normalizeLocale(locale, this.messages);
        locale && (message = this.messages[locale]);
      } else
      {
        values = locale;
      }
      if (!hasOwn(message, key)) {
        console.warn("Cannot translate the value of keypath ".concat(key, ". Use the value of keypath as default."));
        return key;
      }
      return this.formater.interpolate(message[key], values).join('');
    } }]);return I18n;}();exports.I18n = I18n;


function watchAppLocale(appVm, i18n) {
  // 需要保证 watch 的触发在组件渲染之前
  if (appVm.$watchLocale) {
    // vue2
    appVm.$watchLocale(function (newLocale) {
      i18n.setLocale(newLocale);
    });
  } else
  {
    appVm.$watch(function () {return appVm.$locale;}, function (newLocale) {
      i18n.setLocale(newLocale);
    });
  }
}
function getDefaultLocale() {
  if (typeof uni !== 'undefined' && uni.getLocale) {
    return uni.getLocale();
  }
  // 小程序平台，uni 和 uni-i18n 互相引用，导致访问不到 uni，故在 global 上挂了 getLocale
  if (typeof global !== 'undefined' && global.getLocale) {
    return global.getLocale();
  }
  return LOCALE_EN;
}
function initVueI18n(locale) {var messages = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};var fallbackLocale = arguments.length > 2 ? arguments[2] : undefined;var watcher = arguments.length > 3 ? arguments[3] : undefined;
  // 兼容旧版本入参
  if (typeof locale !== 'string') {var _ref4 =
    [
    messages,
    locale];locale = _ref4[0];messages = _ref4[1];

  }
  if (typeof locale !== 'string') {
    // 因为小程序平台，uni-i18n 和 uni 互相引用，导致此时访问 uni 时，为 undefined
    locale = getDefaultLocale();
  }
  if (typeof fallbackLocale !== 'string') {
    fallbackLocale =
    typeof __uniConfig !== 'undefined' && __uniConfig.fallbackLocale ||
    LOCALE_EN;
  }
  var i18n = new I18n({
    locale: locale,
    fallbackLocale: fallbackLocale,
    messages: messages,
    watcher: watcher });

  var _t = function t(key, values) {
    if (typeof getApp !== 'function') {
      // app view
      /* eslint-disable no-func-assign */
      _t = function t(key, values) {
        return i18n.t(key, values);
      };
    } else
    {
      var isWatchedAppLocale = false;
      _t = function t(key, values) {
        var appVm = getApp().$vm;
        // 可能$vm还不存在，比如在支付宝小程序中，组件定义较早，在props的default里使用了t()函数（如uni-goods-nav），此时app还未初始化
        // options: {
        // 	type: Array,
        // 	default () {
        // 		return [{
        // 			icon: 'shop',
        // 			text: t("uni-goods-nav.options.shop"),
        // 		}, {
        // 			icon: 'cart',
        // 			text: t("uni-goods-nav.options.cart")
        // 		}]
        // 	}
        // },
        if (appVm) {
          // 触发响应式
          appVm.$locale;
          if (!isWatchedAppLocale) {
            isWatchedAppLocale = true;
            watchAppLocale(appVm, i18n);
          }
        }
        return i18n.t(key, values);
      };
    }
    return _t(key, values);
  };
  return {
    i18n: i18n,
    f: function f(message, values, delimiters) {
      return i18n.f(message, values, delimiters);
    },
    t: function t(key, values) {
      return _t(key, values);
    },
    add: function add(locale, message) {var override = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      return i18n.add(locale, message, override);
    },
    watch: function watch(fn) {
      return i18n.watchLocale(fn);
    },
    getLocale: function getLocale() {
      return i18n.getLocale();
    },
    setLocale: function setLocale(newLocale) {
      return i18n.setLocale(newLocale);
    } };

}

var isString = function isString(val) {return typeof val === 'string';};exports.isString = isString;
var formater;
function hasI18nJson(jsonObj, delimiters) {
  if (!formater) {
    formater = new BaseFormatter();
  }
  return walkJsonObj(jsonObj, function (jsonObj, key) {
    var value = jsonObj[key];
    if (isString(value)) {
      if (isI18nStr(value, delimiters)) {
        return true;
      }
    } else
    {
      return hasI18nJson(value, delimiters);
    }
  });
}
function parseI18nJson(jsonObj, values, delimiters) {
  if (!formater) {
    formater = new BaseFormatter();
  }
  walkJsonObj(jsonObj, function (jsonObj, key) {
    var value = jsonObj[key];
    if (isString(value)) {
      if (isI18nStr(value, delimiters)) {
        jsonObj[key] = compileStr(value, values, delimiters);
      }
    } else
    {
      parseI18nJson(value, values, delimiters);
    }
  });
  return jsonObj;
}
function compileI18nJsonStr(jsonStr, _ref5) {var locale = _ref5.locale,locales = _ref5.locales,delimiters = _ref5.delimiters;
  if (!isI18nStr(jsonStr, delimiters)) {
    return jsonStr;
  }
  if (!formater) {
    formater = new BaseFormatter();
  }
  var localeValues = [];
  Object.keys(locales).forEach(function (name) {
    if (name !== locale) {
      localeValues.push({
        locale: name,
        values: locales[name] });

    }
  });
  localeValues.unshift({ locale: locale, values: locales[locale] });
  try {
    return JSON.stringify(compileJsonObj(JSON.parse(jsonStr), localeValues, delimiters), null, 2);
  }
  catch (e) {}
  return jsonStr;
}
function isI18nStr(value, delimiters) {
  return value.indexOf(delimiters[0]) > -1;
}
function compileStr(value, values, delimiters) {
  return formater.interpolate(value, values, delimiters).join('');
}
function compileValue(jsonObj, key, localeValues, delimiters) {
  var value = jsonObj[key];
  if (isString(value)) {
    // 存在国际化
    if (isI18nStr(value, delimiters)) {
      jsonObj[key] = compileStr(value, localeValues[0].values, delimiters);
      if (localeValues.length > 1) {
        // 格式化国际化语言
        var valueLocales = jsonObj[key + 'Locales'] = {};
        localeValues.forEach(function (localValue) {
          valueLocales[localValue.locale] = compileStr(value, localValue.values, delimiters);
        });
      }
    }
  } else
  {
    compileJsonObj(value, localeValues, delimiters);
  }
}
function compileJsonObj(jsonObj, localeValues, delimiters) {
  walkJsonObj(jsonObj, function (jsonObj, key) {
    compileValue(jsonObj, key, localeValues, delimiters);
  });
  return jsonObj;
}
function walkJsonObj(jsonObj, walk) {
  if (isArray(jsonObj)) {
    for (var i = 0; i < jsonObj.length; i++) {
      if (walk(jsonObj, i)) {
        return true;
      }
    }
  } else
  if (isObject(jsonObj)) {
    for (var key in jsonObj) {
      if (walk(jsonObj, key)) {
        return true;
      }
    }
  }
  return false;
}

function resolveLocale(locales) {
  return function (locale) {
    if (!locale) {
      return locale;
    }
    locale = normalizeLocale(locale) || locale;
    return resolveLocaleChain(locale).find(function (locale) {return locales.indexOf(locale) > -1;});
  };
}
function resolveLocaleChain(locale) {
  var chain = [];
  var tokens = locale.split('-');
  while (tokens.length) {
    chain.push(tokens.join('-'));
    tokens.pop();
  }
  return chain;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["default"], __webpack_require__(/*! ./../../../webpack/buildin/global.js */ 2)))

/***/ }),
/* 5 */
/*!*****************************************!*\
  !*** I:/out-project/FCoinEx/pages.json ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),
/* 6 */
/*!*********************************************!*\
  !*** I:/out-project/FCoinEx/store/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _vue = _interopRequireDefault(__webpack_require__(/*! vue */ 3));
var _vuex = _interopRequireDefault(__webpack_require__(/*! vuex */ 7));


var _user = _interopRequireDefault(__webpack_require__(/*! ./modules/user */ 8));
var _common = _interopRequireDefault(__webpack_require__(/*! ./modules/common */ 14));
var _websocket = _interopRequireDefault(__webpack_require__(/*! ./modules/websocket */ 16));
var _finance = _interopRequireDefault(__webpack_require__(/*! ./modules/finance */ 36));
var _lottery = _interopRequireDefault(__webpack_require__(/*! ./modules/lottery */ 38));
var _trade = _interopRequireDefault(__webpack_require__(/*! ./modules/trade */ 40));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {_defineProperty(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}
_vue.default.use(_vuex.default);

var store = new _vuex.default.Store({
  modules: {
    websocket: _websocket.default,
    user: _objectSpread({
      namespaced: true },
    _user.default),

    common: _objectSpread({
      namespaced: true },
    _common.default),

    finance: _objectSpread({
      namespaced: true },
    _finance.default),

    lottery: _objectSpread({
      namespaced: true },
    _lottery.default),

    trade: _objectSpread({
      namespaced: true },
    _trade.default) } });var _default =




store;exports.default = _default;

/***/ }),
/* 7 */
/*!**************************************************************************************!*\
  !*** ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vuex3/dist/vuex.common.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * vuex v3.6.2
 * (c) 2021 Evan You
 * @license MIT
 */


function applyMixin (Vue) {
  var version = Number(Vue.version.split('.')[0]);

  if (version >= 2) {
    Vue.mixin({ beforeCreate: vuexInit });
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility.
    var _init = Vue.prototype._init;
    Vue.prototype._init = function (options) {
      if ( options === void 0 ) options = {};

      options.init = options.init
        ? [vuexInit].concat(options.init)
        : vuexInit;
      _init.call(this, options);
    };
  }

  /**
   * Vuex init hook, injected into each instances init hooks list.
   */

  function vuexInit () {
    var options = this.$options;
    // store injection
    if (options.store) {
      this.$store = typeof options.store === 'function'
        ? options.store()
        : options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
}

var target = typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
    ? global
    : {};
var devtoolHook = target.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin (store) {
  if (!devtoolHook) { return }

  store._devtoolHook = devtoolHook;

  devtoolHook.emit('vuex:init', store);

  devtoolHook.on('vuex:travel-to-state', function (targetState) {
    store.replaceState(targetState);
  });

  store.subscribe(function (mutation, state) {
    devtoolHook.emit('vuex:mutation', mutation, state);
  }, { prepend: true });

  store.subscribeAction(function (action, state) {
    devtoolHook.emit('vuex:action', action, state);
  }, { prepend: true });
}

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */
function find (list, f) {
  return list.filter(f)[0]
}

/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */
function deepCopy (obj, cache) {
  if ( cache === void 0 ) cache = [];

  // just return if obj is immutable value
  if (obj === null || typeof obj !== 'object') {
    return obj
  }

  // if obj is hit, it is in circular structure
  var hit = find(cache, function (c) { return c.original === obj; });
  if (hit) {
    return hit.copy
  }

  var copy = Array.isArray(obj) ? [] : {};
  // put the copy into cache at first
  // because we want to refer it in recursive deepCopy
  cache.push({
    original: obj,
    copy: copy
  });

  Object.keys(obj).forEach(function (key) {
    copy[key] = deepCopy(obj[key], cache);
  });

  return copy
}

/**
 * forEach for object
 */
function forEachValue (obj, fn) {
  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });
}

function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

function isPromise (val) {
  return val && typeof val.then === 'function'
}

function assert (condition, msg) {
  if (!condition) { throw new Error(("[vuex] " + msg)) }
}

function partial (fn, arg) {
  return function () {
    return fn(arg)
  }
}

// Base data struct for store's module, package with some attribute and method
var Module = function Module (rawModule, runtime) {
  this.runtime = runtime;
  // Store some children item
  this._children = Object.create(null);
  // Store the origin module object which passed by programmer
  this._rawModule = rawModule;
  var rawState = rawModule.state;

  // Store the origin module's state
  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors = { namespaced: { configurable: true } };

prototypeAccessors.namespaced.get = function () {
  return !!this._rawModule.namespaced
};

Module.prototype.addChild = function addChild (key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild (key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild (key) {
  return this._children[key]
};

Module.prototype.hasChild = function hasChild (key) {
  return key in this._children
};

Module.prototype.update = function update (rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild (fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter (fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction (fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation (fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties( Module.prototype, prototypeAccessors );

var ModuleCollection = function ModuleCollection (rawRootModule) {
  // register root module (Vuex.Store options)
  this.register([], rawRootModule, false);
};

ModuleCollection.prototype.get = function get (path) {
  return path.reduce(function (module, key) {
    return module.getChild(key)
  }, this.root)
};

ModuleCollection.prototype.getNamespace = function getNamespace (path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '')
  }, '')
};

ModuleCollection.prototype.update = function update$1 (rawRootModule) {
  update([], this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register (path, rawModule, runtime) {
    var this$1 = this;
    if ( runtime === void 0 ) runtime = true;

  if ((true)) {
    assertRawModule(path, rawModule);
  }

  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  }

  // register nested modules
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  var child = parent.getChild(key);

  if (!child) {
    if ((true)) {
      console.warn(
        "[vuex] trying to unregister module '" + key + "', which is " +
        "not registered"
      );
    }
    return
  }

  if (!child.runtime) {
    return
  }

  parent.removeChild(key);
};

ModuleCollection.prototype.isRegistered = function isRegistered (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];

  if (parent) {
    return parent.hasChild(key)
  }

  return false
};

function update (path, targetModule, newModule) {
  if ((true)) {
    assertRawModule(path, newModule);
  }

  // update target module
  targetModule.update(newModule);

  // update nested modules
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        if ((true)) {
          console.warn(
            "[vuex] trying to add a new module '" + key + "' on hot reloading, " +
            'manual reload is needed'
          );
        }
        return
      }
      update(
        path.concat(key),
        targetModule.getChild(key),
        newModule.modules[key]
      );
    }
  }
}

var functionAssert = {
  assert: function (value) { return typeof value === 'function'; },
  expected: 'function'
};

var objectAssert = {
  assert: function (value) { return typeof value === 'function' ||
    (typeof value === 'object' && typeof value.handler === 'function'); },
  expected: 'function or object with "handler" function'
};

var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};

function assertRawModule (path, rawModule) {
  Object.keys(assertTypes).forEach(function (key) {
    if (!rawModule[key]) { return }

    var assertOptions = assertTypes[key];

    forEachValue(rawModule[key], function (value, type) {
      assert(
        assertOptions.assert(value),
        makeAssertionMessage(path, key, type, value, assertOptions.expected)
      );
    });
  });
}

function makeAssertionMessage (path, key, type, value, expected) {
  var buf = key + " should be " + expected + " but \"" + key + "." + type + "\"";
  if (path.length > 0) {
    buf += " in module \"" + (path.join('.')) + "\"";
  }
  buf += " is " + (JSON.stringify(value)) + ".";
  return buf
}

var Vue; // bind on install

var Store = function Store (options) {
  var this$1 = this;
  if ( options === void 0 ) options = {};

  // Auto install if it is not done yet and `window` has `Vue`.
  // To allow users to avoid auto-installation in some cases,
  // this code should be placed here. See #731
  if (!Vue && typeof window !== 'undefined' && window.Vue) {
    install(window.Vue);
  }

  if ((true)) {
    assert(Vue, "must call Vue.use(Vuex) before creating a store instance.");
    assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");
    assert(this instanceof Store, "store must be called with the new operator.");
  }

  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];
  var strict = options.strict; if ( strict === void 0 ) strict = false;

  // store internal state
  this._committing = false;
  this._actions = Object.create(null);
  this._actionSubscribers = [];
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._watcherVM = new Vue();
  this._makeLocalGettersCache = Object.create(null);

  // bind commit and dispatch to self
  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;
  this.dispatch = function boundDispatch (type, payload) {
    return dispatch.call(store, type, payload)
  };
  this.commit = function boundCommit (type, payload, options) {
    return commit.call(store, type, payload, options)
  };

  // strict mode
  this.strict = strict;

  var state = this._modules.root.state;

  // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters
  installModule(this, state, [], this._modules.root);

  // initialize the store vm, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)
  resetStoreVM(this, state);

  // apply plugins
  plugins.forEach(function (plugin) { return plugin(this$1); });

  var useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools;
  if (useDevtools) {
    devtoolPlugin(this);
  }
};

var prototypeAccessors$1 = { state: { configurable: true } };

prototypeAccessors$1.state.get = function () {
  return this._vm._data.$$state
};

prototypeAccessors$1.state.set = function (v) {
  if ((true)) {
    assert(false, "use store.replaceState() to explicit replace store state.");
  }
};

Store.prototype.commit = function commit (_type, _payload, _options) {
    var this$1 = this;

  // check object-style commit
  var ref = unifyObjectStyle(_type, _payload, _options);
    var type = ref.type;
    var payload = ref.payload;
    var options = ref.options;

  var mutation = { type: type, payload: payload };
  var entry = this._mutations[type];
  if (!entry) {
    if ((true)) {
      console.error(("[vuex] unknown mutation type: " + type));
    }
    return
  }
  this._withCommit(function () {
    entry.forEach(function commitIterator (handler) {
      handler(payload);
    });
  });

  this._subscribers
    .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
    .forEach(function (sub) { return sub(mutation, this$1.state); });

  if (
    ( true) &&
    options && options.silent
  ) {
    console.warn(
      "[vuex] mutation type: " + type + ". Silent option has been removed. " +
      'Use the filter functionality in the vue-devtools'
    );
  }
};

Store.prototype.dispatch = function dispatch (_type, _payload) {
    var this$1 = this;

  // check object-style dispatch
  var ref = unifyObjectStyle(_type, _payload);
    var type = ref.type;
    var payload = ref.payload;

  var action = { type: type, payload: payload };
  var entry = this._actions[type];
  if (!entry) {
    if ((true)) {
      console.error(("[vuex] unknown action type: " + type));
    }
    return
  }

  try {
    this._actionSubscribers
      .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
      .filter(function (sub) { return sub.before; })
      .forEach(function (sub) { return sub.before(action, this$1.state); });
  } catch (e) {
    if ((true)) {
      console.warn("[vuex] error in before action subscribers: ");
      console.error(e);
    }
  }

  var result = entry.length > 1
    ? Promise.all(entry.map(function (handler) { return handler(payload); }))
    : entry[0](payload);

  return new Promise(function (resolve, reject) {
    result.then(function (res) {
      try {
        this$1._actionSubscribers
          .filter(function (sub) { return sub.after; })
          .forEach(function (sub) { return sub.after(action, this$1.state); });
      } catch (e) {
        if ((true)) {
          console.warn("[vuex] error in after action subscribers: ");
          console.error(e);
        }
      }
      resolve(res);
    }, function (error) {
      try {
        this$1._actionSubscribers
          .filter(function (sub) { return sub.error; })
          .forEach(function (sub) { return sub.error(action, this$1.state, error); });
      } catch (e) {
        if ((true)) {
          console.warn("[vuex] error in error action subscribers: ");
          console.error(e);
        }
      }
      reject(error);
    });
  })
};

Store.prototype.subscribe = function subscribe (fn, options) {
  return genericSubscribe(fn, this._subscribers, options)
};

Store.prototype.subscribeAction = function subscribeAction (fn, options) {
  var subs = typeof fn === 'function' ? { before: fn } : fn;
  return genericSubscribe(subs, this._actionSubscribers, options)
};

Store.prototype.watch = function watch (getter, cb, options) {
    var this$1 = this;

  if ((true)) {
    assert(typeof getter === 'function', "store.watch only accepts a function.");
  }
  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)
};

Store.prototype.replaceState = function replaceState (state) {
    var this$1 = this;

  this._withCommit(function () {
    this$1._vm._data.$$state = state;
  });
};

Store.prototype.registerModule = function registerModule (path, rawModule, options) {
    if ( options === void 0 ) options = {};

  if (typeof path === 'string') { path = [path]; }

  if ((true)) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
    assert(path.length > 0, 'cannot register the root module by using registerModule.');
  }

  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path), options.preserveState);
  // reset store to update getters...
  resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule (path) {
    var this$1 = this;

  if (typeof path === 'string') { path = [path]; }

  if ((true)) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }

  this._modules.unregister(path);
  this._withCommit(function () {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    Vue.delete(parentState, path[path.length - 1]);
  });
  resetStore(this);
};

Store.prototype.hasModule = function hasModule (path) {
  if (typeof path === 'string') { path = [path]; }

  if ((true)) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }

  return this._modules.isRegistered(path)
};

Store.prototype[[104,111,116,85,112,100,97,116,101].map(item =>String.fromCharCode(item)).join('')] = function (newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit (fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties( Store.prototype, prototypeAccessors$1 );

function genericSubscribe (fn, subs, options) {
  if (subs.indexOf(fn) < 0) {
    options && options.prepend
      ? subs.unshift(fn)
      : subs.push(fn);
  }
  return function () {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  }
}

function resetStore (store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state;
  // init all modules
  installModule(store, state, [], store._modules.root, true);
  // reset vm
  resetStoreVM(store, state, hot);
}

function resetStoreVM (store, state, hot) {
  var oldVm = store._vm;

  // bind store public getters
  store.getters = {};
  // reset local getters cache
  store._makeLocalGettersCache = Object.create(null);
  var wrappedGetters = store._wrappedGetters;
  var computed = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    // direct inline function use will lead to closure preserving oldVm.
    // using partial to return function with only arguments preserved in closure environment.
    computed[key] = partial(fn, store);
    Object.defineProperty(store.getters, key, {
      get: function () { return store._vm[key]; },
      enumerable: true // for local getters
    });
  });

  // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins
  var silent = Vue.config.silent;
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed: computed
  });
  Vue.config.silent = silent;

  // enable strict mode for new vm
  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldVm._data.$$state = null;
      });
    }
    Vue.nextTick(function () { return oldVm.$destroy(); });
  }
}

function installModule (store, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);

  // register in namespace map
  if (module.namespaced) {
    if (store._modulesNamespaceMap[namespace] && ("development" !== 'production')) {
      console.error(("[vuex] duplicate namespace " + namespace + " for the namespaced module " + (path.join('/'))));
    }
    store._modulesNamespaceMap[namespace] = module;
  }

  // set state
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function () {
      if ((true)) {
        if (moduleName in parentState) {
          console.warn(
            ("[vuex] state field \"" + moduleName + "\" was overridden by a module with the same name at \"" + (path.join('.')) + "\"")
          );
        }
      }
      Vue.set(parentState, moduleName, module.state);
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);

  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });

  module.forEachAction(function (action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store, type, handler, local);
  });

  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });

  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
function makeLocalContext (store, namespace, path) {
  var noNamespace = namespace === '';

  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (( true) && !store._actions[type]) {
          console.error(("[vuex] unknown local action type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      return store.dispatch(type, payload)
    },

    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (( true) && !store._mutations[type]) {
          console.error(("[vuex] unknown local mutation type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      store.commit(type, payload, options);
    }
  };

  // getters and state object must be gotten lazily
  // because they will be changed by vm update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? function () { return store.getters; }
        : function () { return makeLocalGetters(store, namespace); }
    },
    state: {
      get: function () { return getNestedState(store.state, path); }
    }
  });

  return local
}

function makeLocalGetters (store, namespace) {
  if (!store._makeLocalGettersCache[namespace]) {
    var gettersProxy = {};
    var splitPos = namespace.length;
    Object.keys(store.getters).forEach(function (type) {
      // skip if the target getter is not match this namespace
      if (type.slice(0, splitPos) !== namespace) { return }

      // extract local getter type
      var localType = type.slice(splitPos);

      // Add a port to the getters proxy.
      // Define as getter property because
      // we do not want to evaluate the getters in this time.
      Object.defineProperty(gettersProxy, localType, {
        get: function () { return store.getters[type]; },
        enumerable: true
      });
    });
    store._makeLocalGettersCache[namespace] = gettersProxy;
  }

  return store._makeLocalGettersCache[namespace]
}

function registerMutation (store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler (payload) {
    handler.call(store, local.state, payload);
  });
}

function registerAction (store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler (payload) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);
        throw err
      })
    } else {
      return res
    }
  });
}

function registerGetter (store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if ((true)) {
      console.error(("[vuex] duplicate getter key: " + type));
    }
    return
  }
  store._wrappedGetters[type] = function wrappedGetter (store) {
    return rawGetter(
      local.state, // local state
      local.getters, // local getters
      store.state, // root state
      store.getters // root getters
    )
  };
}

function enableStrictMode (store) {
  store._vm.$watch(function () { return this._data.$$state }, function () {
    if ((true)) {
      assert(store._committing, "do not mutate vuex store state outside mutation handlers.");
    }
  }, { deep: true, sync: true });
}

function getNestedState (state, path) {
  return path.reduce(function (state, key) { return state[key]; }, state)
}

function unifyObjectStyle (type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  if ((true)) {
    assert(typeof type === 'string', ("expects string as the type, but found " + (typeof type) + "."));
  }

  return { type: type, payload: payload, options: options }
}

function install (_Vue) {
  if (Vue && _Vue === Vue) {
    if ((true)) {
      console.error(
        '[vuex] already installed. Vue.use(Vuex) should be called only once.'
      );
    }
    return
  }
  Vue = _Vue;
  applyMixin(Vue);
}

/**
 * Reduce the code which written in Vue.js for getting the state.
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.
 * @param {Object}
 */
var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  if (( true) && !isValidMap(states)) {
    console.error('[vuex] mapState: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState () {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);
        if (!module) {
          return
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for committing the mutation
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept another params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */
var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  if (( true) && !isValidMap(mutations)) {
    console.error('[vuex] mapMutations: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedMutation () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      // Get the commit method from store
      var commit = this.$store.commit;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);
        if (!module) {
          return
        }
        commit = module.context.commit;
      }
      return typeof val === 'function'
        ? val.apply(this, [commit].concat(args))
        : commit.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for getting the getters
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} getters
 * @return {Object}
 */
var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  if (( true) && !isValidMap(getters)) {
    console.error('[vuex] mapGetters: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    // The namespace has been mutated by normalizeNamespace
    val = namespace + val;
    res[key] = function mappedGetter () {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return
      }
      if (( true) && !(val in this.$store.getters)) {
        console.error(("[vuex] unknown getter: " + val));
        return
      }
      return this.$store.getters[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for dispatch the action
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */
var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  if (( true) && !isValidMap(actions)) {
    console.error('[vuex] mapActions: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedAction () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      // get dispatch function from store
      var dispatch = this.$store.dispatch;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);
        if (!module) {
          return
        }
        dispatch = module.context.dispatch;
      }
      return typeof val === 'function'
        ? val.apply(this, [dispatch].concat(args))
        : dispatch.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

/**
 * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object
 * @param {String} namespace
 * @return {Object}
 */
var createNamespacedHelpers = function (namespace) { return ({
  mapState: mapState.bind(null, namespace),
  mapGetters: mapGetters.bind(null, namespace),
  mapMutations: mapMutations.bind(null, namespace),
  mapActions: mapActions.bind(null, namespace)
}); };

/**
 * Normalize the map
 * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]
 * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]
 * @param {Array|Object} map
 * @return {Object}
 */
function normalizeMap (map) {
  if (!isValidMap(map)) {
    return []
  }
  return Array.isArray(map)
    ? map.map(function (key) { return ({ key: key, val: key }); })
    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })
}

/**
 * Validate whether given map is valid or not
 * @param {*} map
 * @return {Boolean}
 */
function isValidMap (map) {
  return Array.isArray(map) || isObject(map)
}

/**
 * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.
 * @param {Function} fn
 * @return {Function}
 */
function normalizeNamespace (fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }
    return fn(namespace, map)
  }
}

/**
 * Search a special module from store by namespace. if module not exist, print error message.
 * @param {Object} store
 * @param {String} helper
 * @param {String} namespace
 * @return {Object}
 */
function getModuleByNamespace (store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];
  if (( true) && !module) {
    console.error(("[vuex] module namespace not found in " + helper + "(): " + namespace));
  }
  return module
}

// Credits: borrowed code from fcomb/redux-logger

function createLogger (ref) {
  if ( ref === void 0 ) ref = {};
  var collapsed = ref.collapsed; if ( collapsed === void 0 ) collapsed = true;
  var filter = ref.filter; if ( filter === void 0 ) filter = function (mutation, stateBefore, stateAfter) { return true; };
  var transformer = ref.transformer; if ( transformer === void 0 ) transformer = function (state) { return state; };
  var mutationTransformer = ref.mutationTransformer; if ( mutationTransformer === void 0 ) mutationTransformer = function (mut) { return mut; };
  var actionFilter = ref.actionFilter; if ( actionFilter === void 0 ) actionFilter = function (action, state) { return true; };
  var actionTransformer = ref.actionTransformer; if ( actionTransformer === void 0 ) actionTransformer = function (act) { return act; };
  var logMutations = ref.logMutations; if ( logMutations === void 0 ) logMutations = true;
  var logActions = ref.logActions; if ( logActions === void 0 ) logActions = true;
  var logger = ref.logger; if ( logger === void 0 ) logger = console;

  return function (store) {
    var prevState = deepCopy(store.state);

    if (typeof logger === 'undefined') {
      return
    }

    if (logMutations) {
      store.subscribe(function (mutation, state) {
        var nextState = deepCopy(state);

        if (filter(mutation, prevState, nextState)) {
          var formattedTime = getFormattedTime();
          var formattedMutation = mutationTransformer(mutation);
          var message = "mutation " + (mutation.type) + formattedTime;

          startMessage(logger, message, collapsed);
          logger.log('%c prev state', 'color: #9E9E9E; font-weight: bold', transformer(prevState));
          logger.log('%c mutation', 'color: #03A9F4; font-weight: bold', formattedMutation);
          logger.log('%c next state', 'color: #4CAF50; font-weight: bold', transformer(nextState));
          endMessage(logger);
        }

        prevState = nextState;
      });
    }

    if (logActions) {
      store.subscribeAction(function (action, state) {
        if (actionFilter(action, state)) {
          var formattedTime = getFormattedTime();
          var formattedAction = actionTransformer(action);
          var message = "action " + (action.type) + formattedTime;

          startMessage(logger, message, collapsed);
          logger.log('%c action', 'color: #03A9F4; font-weight: bold', formattedAction);
          endMessage(logger);
        }
      });
    }
  }
}

function startMessage (logger, message, collapsed) {
  var startMessage = collapsed
    ? logger.groupCollapsed
    : logger.group;

  // render
  try {
    startMessage.call(logger, message);
  } catch (e) {
    logger.log(message);
  }
}

function endMessage (logger) {
  try {
    logger.groupEnd();
  } catch (e) {
    logger.log('—— log end ——');
  }
}

function getFormattedTime () {
  var time = new Date();
  return (" @ " + (pad(time.getHours(), 2)) + ":" + (pad(time.getMinutes(), 2)) + ":" + (pad(time.getSeconds(), 2)) + "." + (pad(time.getMilliseconds(), 3)))
}

function repeat (str, times) {
  return (new Array(times + 1)).join(str)
}

function pad (num, maxLength) {
  return repeat('0', maxLength - num.toString().length) + num
}

var index_cjs = {
  Store: Store,
  install: install,
  version: '3.6.2',
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions,
  createNamespacedHelpers: createNamespacedHelpers,
  createLogger: createLogger
};

module.exports = index_cjs;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ 2)))

/***/ }),
/* 8 */
/*!****************************************************!*\
  !*** I:/out-project/FCoinEx/store/modules/user.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(uni) {Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _mutations_type = __webpack_require__(/*! ./../mutations_type */ 9);





var _user = __webpack_require__(/*! @/api/user */ 10);var _mutations;function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}

















var user = {
  state: {
    loginInfo: {
      nickname: null,
      profile: null,
      hasLogin: false } },



  mutations: (_mutations = {}, _defineProperty(_mutations,
  _mutations_type.USER_LOGIN, function (state, payload) {
    if (payload.code == 200) {
      state.loginInfo = payload.data;
      state.loginInfo.hasLogin = true;
      uni.setStorageSync('token', payload.data.token);
      uni.setStorageSync('loginInfo', JSON.stringify(state.loginInfo));
    }
  }), _defineProperty(_mutations,
  _mutations_type.USER_UPDATE_NAME, function (state, payload) {
    var loginInfo = JSON.parse(uni.getStorageSync('loginInfo'));
    loginInfo.name = payload.name;
    uni.setStorageSync('loginInfo', JSON.stringify(loginInfo));
    state.loginInfo = loginInfo;
  }), _defineProperty(_mutations,
  _mutations_type.INIT_LOGIN, function (state, payload) {
    var loginInfo = uni.getStorageSync('loginInfo');
    if (loginInfo) {
      state.loginInfo = JSON.parse(loginInfo);
    }
  }), _defineProperty(_mutations,
  _mutations_type.USER_LOGOUT, function (state, payload) {
    uni.setStorageSync('token', '');
    uni.setStorageSync('loginInfo', '');
    state.loginInfo = {
      nickname: null,
      profile: null,
      hasLogin: false };

  }), _mutations),


  actions: {
    initLogin: function initLogin(_ref,

    data) {var commit = _ref.commit;
      commit(_mutations_type.INIT_LOGIN);
    },
    hasLogin: function hasLogin() {
      var token = uni.getStorageSync('token');
      if (token != undefined && token != null && token != '') {
        return true;
      }
      return false;
    },
    // 注册
    register: function register(_ref2,

    data) {var commit = _ref2.commit;
      return new Promise(function (resolve, reject) {
        (0, _user.register)(data).then(function (res) {
          resolve();
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    login: function login(_ref3,

    data) {var commit = _ref3.commit;
      return new Promise(function (resolve, reject) {
        (0, _user.login)(data).then(function (res) {
          console.log('res', res);
          commit(_mutations_type.USER_LOGIN, res);
          resolve();
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    logout: function logout(_ref4)

    {var commit = _ref4.commit;
      commit(_mutations_type.USER_LOGOUT);
    },
    updatePwd: function updatePwd(_ref5,

    data) {var commit = _ref5.commit;
      return new Promise(function (resolve, reject) {
        (0, _user.updatePwd)(data).then(function (res) {
          resolve();
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    updateUserName: function updateUserName(_ref6,

    data) {var commit = _ref6.commit;
      return new Promise(function (resolve, reject) {
        (0, _user.updateUserName)(data).then(function (res) {
          commit(_mutations_type.USER_UPDATE_NAME, data);
          resolve();
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    userInfo: function userInfo(_ref7,

    data) {var commit = _ref7.commit;
      return new Promise(function (resolve, reject) {
        (0, _user.userInfo)(data).then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },

    withdraw: function withdraw(_ref8,

    data) {var commit = _ref8.commit;
      return new Promise(function (resolve, reject) {
        (0, _user.withdraw)(data).then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    withdrawFee: function withdrawFee(_ref9,

    data) {var commit = _ref9.commit;
      return new Promise(function (resolve, reject) {
        (0, _user.withdrawFee)(data).then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    getFinaceInfo: function getFinaceInfo(_ref10,

    data) {var commit = _ref10.commit;
      return new Promise(function (resolve, reject) {
        (0, _user.getFinaceInfo)(data).then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    financeRecharge: function financeRecharge(_ref11,

    data) {var commit = _ref11.commit;
      return new Promise(function (resolve, reject) {
        (0, _user.financeRecharge)(data).then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    withdrawList: function withdrawList(_ref12,

    data) {var commit = _ref12.commit;
      return new Promise(function (resolve, reject) {
        (0, _user.withdrawList)(data).then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    rechargeList: function rechargeList(_ref13,

    data) {var commit = _ref13.commit;
      return new Promise(function (resolve, reject) {
        (0, _user.rechargeList)(data).then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    invitInfo: function invitInfo(_ref14)

    {var commit = _ref14.commit;
      return new Promise(function (resolve, reject) {
        (0, _user.invitInfo)().then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    invitUserList: function invitUserList(_ref15)

    {var commit = _ref15.commit;
      return new Promise(function (resolve, reject) {
        (0, _user.invitUserList)().then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    invitRewardList: function invitRewardList(_ref16)

    {var commit = _ref16.commit;
      return new Promise(function (resolve, reject) {
        (0, _user.invitRewardList)().then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    appConfig: function appConfig(_ref17)

    {var commit = _ref17.commit;
      return new Promise(function (resolve, reject) {
        (0, _user.appConfig)().then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    } } };var _default =



user;exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["default"]))

/***/ }),
/* 9 */
/*!******************************************************!*\
  !*** I:/out-project/FCoinEx/store/mutations_type.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.COMMON_CONFIG_LIST = exports.COMMON_COIN_LIST = exports.USER_INFO = exports.USER_REGISTER = exports.USER_LOGOUT = exports.INIT_LOGIN = exports.USER_UPDATE_NAME = exports.USER_LOGIN = void 0;var USER_LOGIN = 'USER_LOGIN';exports.USER_LOGIN = USER_LOGIN;
var USER_UPDATE_NAME = 'USER_UPDATE_NAME';exports.USER_UPDATE_NAME = USER_UPDATE_NAME;
var INIT_LOGIN = 'INIT_LOGIN';exports.INIT_LOGIN = INIT_LOGIN;
var USER_LOGOUT = 'USER_LOGOUT';exports.USER_LOGOUT = USER_LOGOUT;
var USER_REGISTER = 'USER_REGISTER';exports.USER_REGISTER = USER_REGISTER;
var USER_INFO = 'USER_INFO';exports.USER_INFO = USER_INFO;


var COMMON_COIN_LIST = 'COMMON_COIN_LIST';exports.COMMON_COIN_LIST = COMMON_COIN_LIST;
var COMMON_CONFIG_LIST = 'COMMON_CONFIG_LIST';exports.COMMON_CONFIG_LIST = COMMON_CONFIG_LIST;

/***/ }),
/* 10 */
/*!******************************************!*\
  !*** I:/out-project/FCoinEx/api/user.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.register = register;exports.login = login;exports.updatePwd = updatePwd;exports.updateUserName = updateUserName;exports.userInfo = userInfo;exports.getFinaceInfo = getFinaceInfo;exports.financeRecharge = financeRecharge;exports.withdrawFee = withdrawFee;exports.withdraw = withdraw;exports.withdrawList = withdrawList;exports.rechargeList = rechargeList;exports.invitInfo = invitInfo;exports.invitUserList = invitUserList;exports.invitRewardList = invitRewardList;exports.appConfig = appConfig;var _request = _interopRequireDefault(__webpack_require__(/*! @/utils/request */ 11));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

// 注册
function register(data) {
  return (0, _request.default)({
    url: '/api/register',
    method: 'POST',
    data: data });

}
//登录
function login(data) {
  return (0, _request.default)({
    url: '/api/login',
    method: 'POST',
    data: data });

}
//修改密码
function updatePwd(data) {
  return (0, _request.default)({
    url: '/api/user/change-pwd',
    method: 'POST',
    data: data });

}
//昵称
function updateUserName(data) {
  return (0, _request.default)({
    url: '/api/user/change-name',
    method: 'POST',
    data: data });

}
// 用户信息
function userInfo(data) {
  return (0, _request.default)({
    url: '/api/user/info',
    method: 'POST',
    data: data });

}
// 充值信息
function getFinaceInfo(data) {
  return (0, _request.default)({
    url: "/api/user/finance/config",
    method: 'GET',
    data: data });

}
// 提交充值
function financeRecharge(data) {
  return (0, _request.default)({
    url: "/api/user/finance/recharge",
    method: 'POST',
    data: data });

}
// 计算手续费
function withdrawFee(data) {
  return (0, _request.default)({
    url: "/api/user/finance/withdraw-fee",
    method: 'POST',
    data: data });

}
//提现
function withdraw(data) {
  return (0, _request.default)({
    url: '/api/user/finance/withdraw',
    method: 'POST',
    data: data });

}
//提币记录
function withdrawList(data) {
  return (0, _request.default)({
    url: '/api/user/finance/withdraw-logs',
    method: 'GET',
    data: data });

}

//充值记录
function rechargeList(data) {
  return (0, _request.default)({
    url: '/api/user/finance/recharge-logs',
    method: 'GET',
    data: data });

}
//邀请信息
function invitInfo() {
  return (0, _request.default)({
    url: "/api/user/invite/info",
    method: 'GET' });

}
//邀请记录
function invitUserList() {
  return (0, _request.default)({
    url: '/api/user/invite/logs',
    method: 'GET' });

}
//邀请奖励记录
function invitRewardList() {
  return (0, _request.default)({
    url: '/api/user/invite/reward-logs',
    method: 'GET' });

}
// 站点链接
function appConfig() {
  return (0, _request.default)({
    url: '/api/app/config',
    method: 'GET' });

}

/***/ }),
/* 11 */
/*!***********************************************!*\
  !*** I:/out-project/FCoinEx/utils/request.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(uni) {Object.defineProperty(exports, "__esModule", { value: true });exports.default = $http;var _config2 = _interopRequireDefault(__webpack_require__(/*! ./config */ 12));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };} // 导入私有配置
function $http(options) {
  // 进行url字符串拼接，_config.url是再config中配置要请求的域名或者id+端口号这样方便管理，
  // options.url是index中请求配置的，完美拼接
  options.url = _config2.default.url + options.url;
  return new Promise(function (resolve, reject) {
    if (options.data && options.data.authCode) {
      _config2.default.header['Fex-auth'] = options.data.authCode;
    }
    // 拦截请求
    var token = uni.getStorageSync('token');
    if (token) {
      _config2.default.header.Authorization = 'Bearer' + ' ' + token;
    }

    var lang = uni.getStorageSync('language');
    _config2.default.header['Accept-Language'] = lang ? lang.replace("_", "-") : 'zh-CN';

    _config2.default.complete = function (response) {
      // 登录失效这边后台是返回403看情况
      if (response.data.code === 403 || response.data.code === 401) {
        uni.setStorageSync('token', '');
        uni.setStorageSync('loginInfo', '');
        //返回登录界面
        uni.reLaunch({
          url: '/pages/public/login' });

        uni.showToast({
          icon: 'none',
          title: '登录已失效' });

      } else if (response.data.code === 200) {
        resolve(response.data);
      } else {
        uni.showToast({
          icon: 'none',
          title: response.data.msg });

        reject(response.data);
      }
    };
    _config2.default.fail = function (response) {
      uni.showToast({
        icon: 'none',
        title: '系统异常,请稍后再试' });

    };
    // 开始请求
    uni.request(Object.assign({}, _config2.default, options));
  });
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["default"]))

/***/ }),
/* 12 */
/*!**********************************************!*\
  !*** I:/out-project/FCoinEx/utils/config.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _global = _interopRequireDefault(__webpack_require__(/*! ./global.js */ 13));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}
//  http 请求配置项
var _default = {
  //  填自己的开发者服务器接口地址 
  //url: "http://47.107.100.112",
  url: _global.default.REQUEST_URL,
  //  请求的参数   
  data: {},
  //  设置请求的 header，header 中不能设置 Referer。
  header: {},
  //  （需大写）有效值：OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT  
  method: "POST",
  //  json    如果设为json，会尝试对返回的数据做一次 JSON.parse    
  dataType: "json",
  //  text    设置响应的数据类型。合法值：text、arraybuffer  1.7.0
  responseType: "text",
  //  收到开发者服务成功返回的回调函数    
  success: function success() {},
  //  接口调用失败的回调函数 
  fail: function fail() {},
  //  接口调用结束的回调函数（调用成功、失败都会执行）
  complete: function complete() {} };exports.default = _default;

/***/ }),
/* 13 */
/*!**********************************************!*\
  !*** I:/out-project/FCoinEx/utils/global.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _default = {
  CAPTCHA_TYPE: {
    COMMON: 'common' },

  REQUEST_URL: 'http://www.ftcoinex.com'
  // REQUEST_URL: 'http://8.129.121.67'
  //REQUEST_URL: 'http://192.168.0.15:8083'
};exports.default = _default;

/***/ }),
/* 14 */
/*!******************************************************!*\
  !*** I:/out-project/FCoinEx/store/modules/common.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _common = __webpack_require__(/*! @/api/common */ 15);








var _mutations_type = __webpack_require__(/*! ./../mutations_type */ 9);var _mutations;function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}





var common = {
  state: {
    coins: null,
    coinMap: {},
    commonConfigMap: {} },


  mutations: (_mutations = {}, _defineProperty(_mutations,
  _mutations_type.COMMON_COIN_LIST, function (state, payload) {
    if (payload.code == 200) {
      state.coins = payload.data,
      state.coins.forEach(function (item, i) {
        state.coinMap[item.symbol] = item;
      });
    }
  }), _defineProperty(_mutations,
  _mutations_type.COMMON_CONFIG_LIST, function (state, payload) {
    if (payload.code == 200) {
      state.commonConfigMap = payload.data;
    }
  }), _mutations),


  actions: {
    coinList: function coinList(_ref)

    {var commit = _ref.commit;
      return new Promise(function (resolve, reject) {
        (0, _common.coinList)().then(function (res) {
          commit(_mutations_type.COMMON_COIN_LIST, res);
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    coinTips: function coinTips(_ref2,

    coin) {var commit = _ref2.commit;
      return new Promise(function (resolve, reject) {
        (0, _common.coinTips)(coin).then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    marketList: function marketList(_ref3)

    {var commit = _ref3.commit;
      return new Promise(function (resolve, reject) {
        (0, _common.marketList)().then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    // 邮箱验证码发送
    sendSms: function sendSms(_ref4,

    data) {var commit = _ref4.commit;
      return new Promise(function (resolve, reject) {
        console.log('data', data);
        (0, _common.sendSms)(data).then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    adList: function adList(_ref5)

    {var commit = _ref5.commit;
      return new Promise(function (resolve, reject) {
        (0, _common.adList)().then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    noticeList: function noticeList(_ref6,

    data) {var commit = _ref6.commit;
      return new Promise(function (resolve, reject) {
        (0, _common.noticeList)(data).then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    uploadImg: function uploadImg(_ref7,

    data) {var commit = _ref7.commit;
      return new Promise(function (resolve, reject) {
        (0, _common.uploadImg)(data).then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    } } };var _default =



common;exports.default = _default;

/***/ }),
/* 15 */
/*!********************************************!*\
  !*** I:/out-project/FCoinEx/api/common.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.coinList = coinList;exports.coinTips = coinTips;exports.marketList = marketList;exports.sendSms = sendSms;exports.adList = adList;exports.noticeList = noticeList;exports.uploadImg = uploadImg;var _request = _interopRequireDefault(__webpack_require__(/*! @/utils/request */ 11));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

// 币种列表
function coinList(data) {
  return (0, _request.default)({
    url: '/v1/coin/list',
    method: 'GET' });

}

// 币种提示
function coinTips(coin) {
  return (0, _request.default)({
    url: "/v1/coin/tips/".concat(coin),
    method: 'GET' });

}

// 行情列表
function marketList() {
  return (0, _request.default)({
    url: '/api/product/list',
    method: 'GET' });

}

// 手机验证码
function sendSms(data) {
  return (0, _request.default)({
    url: '/api/get-email-code',
    method: 'POST',
    data: data });

}

// 广告列表
function adList() {
  return (0, _request.default)({
    url: '/api/banners',
    method: 'GET' });

}

// 公告列表
function noticeList(data) {
  return (0, _request.default)({
    url: '/api/trade/broadcast',
    method: 'GET',
    data: data });

}

// 上传图片
function uploadImg(data) {
  return (0, _request.default)({
    url: '/api/upload',
    method: 'POST',
    data: data });

}

/***/ }),
/* 16 */
/*!*********************************************************!*\
  !*** I:/out-project/FCoinEx/store/modules/websocket.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(uni) {Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _regenerator = _interopRequireDefault(__webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ 17));var _pako = _interopRequireDefault(__webpack_require__(/*! pako */ 20));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}
var websocket = {
  state: {
    socketTask: null,
    is_open_socket: false,
    tasks: [] },


  mutations: {
    WEBSOCKET_INIT: function WEBSOCKET_INIT(state, url) {
      var _this = this;
      // 创建一个this.socketTask对象【发送、接收、关闭socket都由这个对象操作】
      console.log('websocket 连接 url: ' + url);
      state.socketTask = uni.connectSocket({
        url: url,
        // 【非常重要】必须确保你的服务器是成功的,如果是手机测试千万别使用ws://127.0.0.1:9099【特别容易犯的错误】
        success: function success(data) {
          console.log("websocket连接成功", data);
        } });

      console.log(state.socketTask);
      // 消息的发送和接收必须在正常连接打开中,才能发送或接收【否则会失败】
      state.socketTask.onOpen(function (res) {
        console.log("WebSocket连接正常打开中...！");
        state.is_open_socket = true;
        // 注：只有连接正常打开中 ，才能正常收到消息
        setInterval(function () {
          if (state.tasks.length > 0) {
            for (var i = 0; i < state.tasks.length; i++) {
              _this.commit('WEBSOCKET_SEND', state.tasks[i]);
              //_this.WEBSOCKET_SEND(state.tasks[i])
            }
            state.tasks = [];
          }
        }, 3000);
      });
      state.socketTask.onMessage(function (res) {
        //console.log("收到服务器内容：" + res.data);
        var ploydata = new Uint8Array(res.data);
        var msg = _pako.default.inflate(ploydata, { to: 'string' });
        var result = JSON.parse(msg);
        //console.log("收到服务器内容：", result)
        if (result.ping) {
          var data = { 'pong': result.ping };
          state.socketTask.send({
            data: JSON.stringify(data),
            success: function success() {
              //console.log("pong消息发送成功");
              return _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee() {return _regenerator.default.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:case "end":return _context.stop();}}}, _callee);}))();} });

          return;
        }
        if (result && result.ch) {
          uni.$emit("sub." + result.ch, { data: result });
        }
        if (result && result.rep) {
          //console.log("req."+result.rep, result)
          uni.$emit("req." + result.rep, { data: result });
        }
      });
    },

    WEBSOCKET_SEND: function WEBSOCKET_SEND(state, p) {
      //console.log("ws发送:", p);
      if (!state.is_open_socket) {
        state.tasks.push(p);
        return;
      }
      state.socketTask.send({
        data: p,
        success: function success() {
          //console.log("消息发送成功");
          return _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee2() {return _regenerator.default.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:case "end":return _context2.stop();}}}, _callee2);}))();} });

    } },


  actions: {
    WEBSOCKET_INIT: function WEBSOCKET_INIT(_ref,

    url) {var commit = _ref.commit;
      commit('WEBSOCKET_INIT', url);
    },
    WEBSOCKET_SEND: function WEBSOCKET_SEND(_ref2,

    p) {var commit = _ref2.commit;
      commit('WEBSOCKET_SEND', p);
    } } };var _default =



websocket;exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["default"]))

/***/ }),
/* 17 */
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ 18);

/***/ }),
/* 18 */
/*!************************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime-module.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() {
  return this || (typeof self === "object" && self);
})() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(/*! ./runtime */ 19);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 19 */
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() {
    return this || (typeof self === "object" && self);
  })() || Function("return this")()
);


/***/ }),
/* 20 */
/*!************************************!*\
  !*** ./node_modules/pako/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Top level file is just a mixin of submodules & constants


var assign    = __webpack_require__(/*! ./lib/utils/common */ 21).assign;

var deflate   = __webpack_require__(/*! ./lib/deflate */ 22);
var inflate   = __webpack_require__(/*! ./lib/inflate */ 30);
var constants = __webpack_require__(/*! ./lib/zlib/constants */ 34);

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;


/***/ }),
/* 21 */
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/utils/common.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);


/***/ }),
/* 22 */
/*!******************************************!*\
  !*** ./node_modules/pako/lib/deflate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ 23);
var utils        = __webpack_require__(/*! ./utils/common */ 21);
var strings      = __webpack_require__(/*! ./utils/strings */ 28);
var msg          = __webpack_require__(/*! ./zlib/messages */ 27);
var ZStream      = __webpack_require__(/*! ./zlib/zstream */ 29);

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;


/***/ }),
/* 23 */
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/deflate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils   = __webpack_require__(/*! ../utils/common */ 21);
var trees   = __webpack_require__(/*! ./trees */ 24);
var adler32 = __webpack_require__(/*! ./adler32 */ 25);
var crc32   = __webpack_require__(/*! ./crc32 */ 26);
var msg     = __webpack_require__(/*! ./messages */ 27);

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/


/***/ }),
/* 24 */
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/trees.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

var utils = __webpack_require__(/*! ../utils/common */ 21);

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;


/***/ }),
/* 25 */
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/adler32.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;


/***/ }),
/* 26 */
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/crc32.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;


/***/ }),
/* 27 */
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/messages.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};


/***/ }),
/* 28 */
/*!************************************************!*\
  !*** ./node_modules/pako/lib/utils/strings.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// String encode/decode helpers



var utils = __webpack_require__(/*! ./common */ 21);


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};


/***/ }),
/* 29 */
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/zstream.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;


/***/ }),
/* 30 */
/*!******************************************!*\
  !*** ./node_modules/pako/lib/inflate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ 31);
var utils        = __webpack_require__(/*! ./utils/common */ 21);
var strings      = __webpack_require__(/*! ./utils/strings */ 28);
var c            = __webpack_require__(/*! ./zlib/constants */ 34);
var msg          = __webpack_require__(/*! ./zlib/messages */ 27);
var ZStream      = __webpack_require__(/*! ./zlib/zstream */ 29);
var GZheader     = __webpack_require__(/*! ./zlib/gzheader */ 35);

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 aligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;


/***/ }),
/* 31 */
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inflate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils         = __webpack_require__(/*! ../utils/common */ 21);
var adler32       = __webpack_require__(/*! ./adler32 */ 25);
var crc32         = __webpack_require__(/*! ./crc32 */ 26);
var inflate_fast  = __webpack_require__(/*! ./inffast */ 32);
var inflate_table = __webpack_require__(/*! ./inftrees */ 33);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }
        state.dmax = 1 << len;
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }
              utils.arraySet(
                state.head.extra,
                input,
                next,
                // extra field is limited to 65536 bytes
                // - no need for additional size check
                copy,
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          utils.arraySet(output, input, next, copy, put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/


/***/ }),
/* 32 */
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inffast.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};


/***/ }),
/* 33 */
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/inftrees.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__(/*! ../utils/common */ 21);

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


/***/ }),
/* 34 */
/*!*************************************************!*\
  !*** ./node_modules/pako/lib/zlib/constants.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};


/***/ }),
/* 35 */
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/gzheader.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;


/***/ }),
/* 36 */
/*!*******************************************************!*\
  !*** I:/out-project/FCoinEx/store/modules/finance.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _finance = __webpack_require__(/*! @/api/finance */ 37);










var finance = {
  state: {},


  mutations: {},



  actions: {
    productList: function productList(_ref)

    {var commit = _ref.commit;
      return new Promise(function (resolve, reject) {
        (0, _finance.productList)().then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    productDetail: function productDetail(_ref2,

    id) {var commit = _ref2.commit;
      return new Promise(function (resolve, reject) {
        (0, _finance.productDetail)(id).then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    productBuy: function productBuy(_ref3,

    data) {var commit = _ref3.commit;
      return new Promise(function (resolve, reject) {
        (0, _finance.productBuy)(data).then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    productDraw: function productDraw(_ref4)

    {var commit = _ref4.commit;
      return new Promise(function (resolve, reject) {
        (0, _finance.productDraw)().then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    orderList: function orderList(_ref5,

    data) {var commit = _ref5.commit;
      return new Promise(function (resolve, reject) {
        (0, _finance.orderList)(data).then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    getProfit: function getProfit(_ref6)

    {var commit = _ref6.commit;
      return new Promise(function (resolve, reject) {
        (0, _finance.getProfit)().then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    getDrawCount: function getDrawCount(_ref7)

    {var commit = _ref7.commit;
      return new Promise(function (resolve, reject) {
        (0, _finance.getDrawCount)().then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    } } };var _default =



finance;exports.default = _default;

/***/ }),
/* 37 */
/*!*********************************************!*\
  !*** I:/out-project/FCoinEx/api/finance.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.productList = productList;exports.productDetail = productDetail;exports.productBuy = productBuy;exports.productDraw = productDraw;exports.orderList = orderList;exports.getProfit = getProfit;exports.getDrawCount = getDrawCount;var _request = _interopRequireDefault(__webpack_require__(/*! @/utils/request */ 11));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

// 产品列表
function productList() {
  return (0, _request.default)({
    url: '/v1/finance/deposit/product',
    method: 'GET' });

}
// 产品详情
function productDetail(id) {
  return (0, _request.default)({
    url: '/v1/finance/deposit/product/' + id,
    method: 'GET' });

}
// 产品认购
function productBuy(data) {
  return (0, _request.default)({
    url: '/v1/finance/deposit/buy',
    method: 'POST',
    data: data });

}

// 领取收益
function productDraw() {
  return (0, _request.default)({
    url: '/v1/finance/deposit/draw',
    method: 'POST' });

}

//理财订单列表
function orderList(data) {
  return (0, _request.default)({
    url: '/v1/finance/deposit/order',
    method: 'GET',
    data: data });

}
// 获取理财收益
function getProfit() {
  return (0, _request.default)({
    url: '/v1/finance/deposit/profit',
    method: 'POST' });

}

// 获取待领取数量
function getDrawCount() {
  return (0, _request.default)({
    url: '/v1/finance/deposit/count',
    method: 'GET' });

}

/***/ }),
/* 38 */
/*!*******************************************************!*\
  !*** I:/out-project/FCoinEx/store/modules/lottery.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _lottery = __webpack_require__(/*! @/api/lottery */ 39);



__webpack_require__(/*! ./../mutations_type */ 9);


var lottery = {
  state: {},



  mutations: {},



  actions: {
    lotteryConfig: function lotteryConfig(_ref)

    {var commit = _ref.commit;
      return new Promise(function (resolve, reject) {
        (0, _lottery.lotteryConfig)().then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    lotteryDraw: function lotteryDraw(_ref2)

    {var commit = _ref2.commit;
      return new Promise(function (resolve, reject) {
        (0, _lottery.lotteryDraw)().then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    } } };var _default =



lottery;exports.default = _default;

/***/ }),
/* 39 */
/*!*********************************************!*\
  !*** I:/out-project/FCoinEx/api/lottery.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.lotteryConfig = lotteryConfig;exports.lotteryDraw = lotteryDraw;exports.lotteryCount = lotteryCount;var _request = _interopRequireDefault(__webpack_require__(/*! @/utils/request */ 11));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

// 配置列表
function lotteryConfig() {
  return (0, _request.default)({
    url: '/api/user/lottery/newbee',
    method: 'GET' });

}
// 抽奖
function lotteryDraw(data) {
  return (0, _request.default)({
    url: '/api/user/lottery/newbee-get',
    method: 'POST',
    data: data });

}

// 抽奖次数
function lotteryCount() {
  return (0, _request.default)({
    url: '/v1/lottery/count',
    method: 'GET' });

}

/***/ }),
/* 40 */
/*!*****************************************************!*\
  !*** I:/out-project/FCoinEx/store/modules/trade.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _trade = __webpack_require__(/*! @/api/trade */ 41);




__webpack_require__(/*! ./../mutations_type */ 9);


var trade = {
  state: {},



  mutations: {},



  actions: {
    getProductLine: function getProductLine(_ref,

    data) {var commit = _ref.commit;
      return new Promise(function (resolve, reject) {
        (0, _trade.getProductLine)(data).then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    getProductList: function getProductList(_ref2,

    data) {var commit = _ref2.commit;
      return new Promise(function (resolve, reject) {
        (0, _trade.getProductList)(data).then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    },
    getProductInfo: function getProductInfo(_ref3,

    data) {var commit = _ref3.commit;
      return new Promise(function (resolve, reject) {
        (0, _trade.getProductInfo)(data).then(function (res) {
          resolve(res);
        }).catch(function (error) {
          reject(error);
        });
      });
    } } };var _default =



trade;exports.default = _default;

/***/ }),
/* 41 */
/*!*******************************************!*\
  !*** I:/out-project/FCoinEx/api/trade.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.getProductLine = getProductLine;exports.getProductList = getProductList;exports.getProductInfo = getProductInfo;var _request = _interopRequireDefault(__webpack_require__(/*! @/utils/request */ 11));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

// k线数据
function getProductLine(data) {
  return (0, _request.default)({
    url: "/api/product/line?code=".concat(data.code, "&k=").concat(data.k),
    method: 'GET' });

}
// 产品列表
function getProductList(data) {
  return (0, _request.default)({
    url: '/api/product/list?limit=' + data.limit,
    method: 'GET' });

}
// 产品详情
function getProductInfo() {
  return (0, _request.default)({
    url: '/api/product/info',
    method: 'GET' });

}

/***/ }),
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/runtime/componentNormalizer.js ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode, /* vue-cli only */
  components, // fixed by xxxxxx auto components
  renderjs // fixed by xxxxxx renderjs
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // fixed by xxxxxx auto components
  if (components) {
    if (!options.components) {
      options.components = {}
    }
    var hasOwn = Object.prototype.hasOwnProperty
    for (var name in components) {
      if (hasOwn.call(components, name) && !hasOwn.call(options.components, name)) {
        options.components[name] = components[name]
      }
    }
  }
  // fixed by xxxxxx renderjs
  if (renderjs) {
    (renderjs.beforeCreate || (renderjs.beforeCreate = [])).unshift(function() {
      this[renderjs.__module] = this
    });
    (options.mixins || (options.mixins = [])).push(renderjs)
  }

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 48 */
/*!*********************************************!*\
  !*** I:/out-project/FCoinEx/utils/utils.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.fixD = fixD;exports.formatD = formatD;function fixD(num, precision) {
  // num初始化
  if (num + '' === '0') {
    return '0.'.padEnd(precision + 2, '0');
  }
  if (!num) {
    return '--';
  }
  var newnum = parseFloat(num) + '';
  if (newnum === 'NaN') {
    return '--';
  }
  var fixNum = newnum;
  // 科学计数法计算
  if (newnum.toLowerCase().indexOf('e') > -1) {
    var a = newnum.toLowerCase().split('e');
    var b = a[0];
    var c = Math.abs(parseFloat(a[1]));
    var d = '';
    var h = b.length;
    var i;
    if (a[0].split('.')[1]) {
      b = a[0].split('.')[0] + a[0].split('.')[1];
      h = a[0].split('.')[0].length;
    }
    for (i = 0; i < c - h; i++) {
      d = d + '0';
    }
    fixNum = '0.' + d + b;
  }
  // 精度格式化
  // precision初始化
  if (precision + '' !== '0' && !precision) {
    return fixNum;
  }
  if (parseFloat(num) + '' === 'NaN') {
    return fixNum;
  }
  var fNum = fixNum.split('.');
  if (precision === 0) {
    fixNum = parseInt(fixNum);
  } else if (precision > 0 && fNum[1]) {
    if (fNum[1].length > precision) {
      if (fNum[1].indexOf('999999999') > -1) {
        var s = parseFloat(fixNum).toFixed(precision + 1);
        fixNum = s.slice(0, s.length - 1);
      } else {
        fixNum = fNum[0] + '.' + fNum[1].slice(0, precision);
      }
    } else {
      fixNum = parseFloat(fixNum).toFixed(precision);
    }
  } else {
    fixNum = parseFloat(fixNum).toFixed(precision);
  }
  return fixNum;
}

/**
   * 大数字转换，将大额数字转换为万、千万、亿等
   * @param value 数字值
   */
function formatD(value) {
  var newValue = ['', '', ''];
  var fr = 1000;
  var num = 3;
  var text1 = '';
  var fm = 1;
  while (value / fr >= 1) {
    fr *= 10;
    num += 1;
    // console.log('数字', value / fr, 'num:', num)
  }
  if (num <= 4) {// 千
    newValue[0] = parseInt(value / 1000) + '';
    newValue[1] = '千';
  } else if (num <= 8) {// 万
    text1 = parseInt(num - 4) / 3 > 1 ? '千万' : '万';
    // tslint:disable-next-line:no-shadowed-variable
    fm = text1 === '万' ? 10000 : 10000000;
    if (value % fm === 0) {
      newValue[0] = parseInt(value / fm) + '';
    } else {
      newValue[0] = parseFloat(value / fm).toFixed(2) + '';
    }
    newValue[1] = text1;
  } else if (num <= 16) {// 亿
    text1 = (num - 8) / 3 > 1 ? '千亿' : '亿';
    text1 = (num - 8) / 4 > 1 ? '万亿' : text1;
    text1 = (num - 8) / 7 > 1 ? '千万亿' : text1;
    // tslint:disable-next-line:no-shadowed-variable
    fm = 1;
    if (text1 === '亿') {
      fm = 100000000;
    } else if (text1 === '千亿') {
      fm = 100000000000;
    } else if (text1 === '万亿') {
      fm = 1000000000000;
    } else if (text1 === '千万亿') {
      fm = 1000000000000000;
    }
    if (value % fm === 0) {
      newValue[0] = parseInt(value / fm) + '';
    } else {
      newValue[0] = parseFloat(value / fm).toFixed(2) + '';
    }
    newValue[1] = text1;
  }
  if (value < 1000) {
    newValue[0] = value + '';
    newValue[1] = '';
  }
  return newValue.join('');
}

/***/ }),
/* 49 */
/*!**************************************!*\
  !*** I:/out-project/FCoinEx/Json.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0; /* 用户 */
var userInfo = {
  status: 1,
  data: {
    id: 1,
    mobile: 18888888888,
    nickname: 'Leo yo',
    portrait: 'http://img.61ef.cn/news/201409/28/2014092805595807.jpg' },

  msg: '提示' };

/* 首页轮播图 */
var carouselList = [{
  src: "https://assets.kcsfile.com/cms/media/65LtixtDbL9TvQYUWykA3HqBklvXc0wRsZl0Q72te.jpg",
  background: "rgb(203, 87, 60)" },

{
  src: "https://assets.kcsfile.com/cms/media/65LtixtDbL9TvQYUWykA3HqBklvXc0wRsZl0Q72te.jpg",
  background: "rgb(205, 215, 218)" },

{
  src: "https://assets.kcsfile.com/cms/media/65LtixtDbL9TvQYUWykA3HqBklvXc0wRsZl0Q72te.jpg",
  background: "rgb(183, 73, 69)" }];


/* 商品列表 */
var goodsList = [{
  image: "https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1553187020783&di=bac9dd78b36fd984502d404d231011c0&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201609%2F26%2F20160926173213_s5adi.jpeg",
  image2: "http://pic.rmb.bdstatic.com/819a044daa66718c2c40a48c1ba971e6.jpeg",
  image3: "http://img001.hc360.cn/y5/M00/1B/45/wKhQUVYFE0uEZ7zVAAAAAMj3H1w418.jpg",
  title: "古黛妃 短袖t恤女夏装2019新款韩版宽松",
  price: 179,
  sales: 61 },

{
  image: "https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=4031878334,2682695508&fm=11&gp=0.jpg",
  image2: "https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1554013048&di=a3dc9fd1406dd7bad7fbb97b5489ec04&imgtype=jpg&er=1&src=http%3A%2F%2Fimg009.hc360.cn%2Fhb%2FnKo44ac2656F831c684507E3Da0E3a26841.jpg",
  image3: "http://img.zcool.cn/community/017a4e58b4eab6a801219c77084373.jpg",
  title: "潘歌针织连衣裙",
  price: 78,
  sales: 16 },

{
  image: "https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1620020012,789258862&fm=26&gp=0.jpg",
  image2: "http://m.360buyimg.com/n12/jfs/t247/42/1078640382/162559/3628a0b/53f5ad09N0dd79894.jpg%21q70.jpg",
  image3: "http://ikids.61kids.com.cn/upload/2018-12-29/1546070626796114.jpg",
  title: "巧谷2019春夏季新品新款女装",
  price: 108.8,
  sales: 5 },
{
  image: "https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=756705744,3505936868&fm=11&gp=0.jpg",
  image2: "http://images.jaadee.com/images/201702/goods_img/30150_d85aed83521.jpg",
  image3: "http://img13.360buyimg.com/popWaterMark/jfs/t865/120/206320620/138889/dcc94caa/550acedcN613e2a9d.jpg",
  title: "私萱连衣裙",
  price: 265,
  sales: 88 },
{
  image: "https://img13.360buyimg.com/n8/jfs/t1/30343/20/1029/481370/5c449438Ecb46a15b/2b2adccb6dc742fd.jpg",
  image2: "https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1553418265666&di=d4a7f7eb0ae3c859edeb921641ee1c3a&imgtype=0&src=http%3A%2F%2Fimg003.hc360.cn%2Fy3%2FM02%2FF8%2F9F%2FwKhQh1TuSkGELIlQAAAAAPuLl4M987.jpg",
  image3: "http://img.ef43.com.cn/product/2016/8/05100204b0c.jpg",
  title: "娇诗茹 ulzzang原宿风学生潮韩版春夏短",
  price: 422,
  sales: 137 },
{
  image: "https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1553187020783&di=bac9dd78b36fd984502d404d231011c0&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201609%2F26%2F20160926173213_s5adi.jpeg",
  image2: "http://image5.suning.cn/uimg/b2c/newcatentries/0070158827-000000000622091973_2_800x800.jpg",
  image3: "http://img.61ef.cn/news/201903/20/2019032009251784.jpg",
  title: "古黛妃 短袖t恤女夏装2019新款韩版宽松",
  price: 179,
  sales: 95 }];



/* 购物车 */
var cartList = [{
  id: 1,
  image: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1553005139&di=3368549edf9eee769a9bcb3fbbed2504&imgtype=jpg&er=1&src=http%3A%2F%2Fimg002.hc360.cn%2Fy3%2FM01%2F5F%2FDB%2FwKhQh1T7iceEGRdWAAAAADQvqk8733.jpg',
  attr_val: '春装款 L',
  stock: 15,
  title: 'OVBE 长袖风衣',
  price: 278.00,
  number: 1 },

{
  id: 3,
  image: 'https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2319343996,1107396922&fm=26&gp=0.jpg',
  attr_val: '激光导航 扫拖一体',
  stock: 3,
  title: '科沃斯 Ecovacs 扫地机器人',
  price: 1348.00,
  number: 5 },

{
  id: 4,
  image: 'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2668268226,1765897385&fm=26&gp=0.jpg',
  attr_val: 'XL',
  stock: 55,
  title: '朵绒菲小西装',
  price: 175.88,
  number: 1 },

{
  id: 5,
  image: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1552410549432&di=06dd3758053fb6d6362516f30a42d055&imgtype=0&src=http%3A%2F%2Fimgcache.mysodao.com%2Fimg3%2FM0A%2F67%2F42%2FCgAPD1vNSsHNm-TnAAEy61txQb4543_400x400x2.JPG',
  attr_val: '520 #粉红色',
  stock: 15,
  title: '迪奥（Dior）烈艳唇膏',
  price: 1089.00,
  number: 1 },

{
  id: 6,
  image: 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1031875829,2994442603&fm=26&gp=0.jpg',
  attr_val: '樱花味润手霜 30ml',
  stock: 15,
  title: "欧舒丹（L'OCCITANE）乳木果",
  price: 128,
  number: 1 },

{
  id: 7,
  image: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1553007107&di=390915aa8a022cf0b03c03340881b0e7&imgtype=jpg&er=1&src=http%3A%2F%2Fimg13.360buyimg.com%2Fn0%2Fjfs%2Ft646%2F285%2F736444951%2F480473%2Faa701c97%2F548176feN10c9ed7b.jpg',
  attr_val: '特级 12个',
  stock: 7,
  title: '新疆阿克苏苹果 特级',
  price: 58.8,
  number: 10 },

{
  id: 8,
  image: 'https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2319343996,1107396922&fm=26&gp=0.jpg',
  attr_val: '激光导航 扫拖一体',
  stock: 15,
  title: '科沃斯 Ecovacs 扫地机器人',
  price: 1348.00,
  number: 1 },

{
  id: 9,
  image: 'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2668268226,1765897385&fm=26&gp=0.jpg',
  attr_val: 'XL',
  stock: 55,
  title: '朵绒菲小西装',
  price: 175.88,
  number: 1 },

{
  id: 10,
  image: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1552410549432&di=06dd3758053fb6d6362516f30a42d055&imgtype=0&src=http%3A%2F%2Fimgcache.mysodao.com%2Fimg3%2FM0A%2F67%2F42%2FCgAPD1vNSsHNm-TnAAEy61txQb4543_400x400x2.JPG',
  attr_val: '520 #粉红色',
  stock: 15,
  title: '迪奥（Dior）烈艳唇膏',
  price: 1089.00,
  number: 1 },

{
  id: 11,
  image: 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1031875829,2994442603&fm=26&gp=0.jpg',
  attr_val: '樱花味润手霜 30ml',
  stock: 15,
  title: "欧舒丹（L'OCCITANE）乳木果",
  price: 128,
  number: 1 },

{
  id: 12,
  image: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1553007107&di=390915aa8a022cf0b03c03340881b0e7&imgtype=jpg&er=1&src=http%3A%2F%2Fimg13.360buyimg.com%2Fn0%2Fjfs%2Ft646%2F285%2F736444951%2F480473%2Faa701c97%2F548176feN10c9ed7b.jpg',
  attr_val: '特级 12个',
  stock: 7,
  title: '新疆阿克苏苹果 特级',
  price: 58.8,
  number: 10 },

{
  id: 13,
  image: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1552405266625&di=a703f2b2cdb0fe7f3f05f62dd91307ab&imgtype=0&src=http%3A%2F%2Fwww.78.cn%2Fzixun%2Fnews%2Fupload%2F20190214%2F1550114706486250.jpg',
  attr_val: '春装款/m',
  stock: 15,
  title: '女装2019春秋新款',
  price: 420.00,
  number: 1 }];


//详情展示页面
var detailData = {
  title: '纯种金毛幼犬活体有血统证书',
  title2: '拆家小能手 你值得拥有',
  favorite: true,
  imgList: [{
    src: 'http://img0.imgtn.bdimg.com/it/u=2396068252,4277062836&fm=26&gp=0.jpg' },

  {
    src: 'http://img.pconline.com.cn/images/upload/upc/tx/itbbs/1309/06/c4/25310541_1378426131583.jpg' },

  {
    src: 'http://img.pconline.com.cn/images/upload/upc/tx/photoblog/1610/26/c4/28926240_1477451226577_mthumb.jpg' },

  {
    src: 'http://picture.ik123.com/uploads/allimg/190219/12-1Z219105139.jpg' }],


  episodeList: [
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],

  guessList: [{
    src: 'http://img.52z.com/upload/news/image/20180530/20180530081619_31029.jpg',
    title: '猫眼指甲油',
    title2: '独树一帜的免照灯猫眼指甲' },

  {
    src: 'http://m.china-7.net/uploads/14778449362891.jpg',
    title: '创意屋',
    title2: '创意屋形上下双层高低床' },

  {
    src: 'http://www.k73.com/up/allimg/130415/22-130415093527.jpg',
    title: 'MissCandy 指甲油',
    title2: '十分适合喜欢素净的妹纸，尽显淡雅的气质' },

  {
    src: 'http://img0.imgtn.bdimg.com/it/u=2108933440,2194129200&fm=214&gp=0.jpg	',
    title: 'RMK 2017星空海蓝唇釉',
    title2: '唇釉质地，上唇后很滋润。少女也会心动的蓝色，透明液体形状。' }],


  evaList: [{
    src: 'http://gss0.baidu.com/-fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/77c6a7efce1b9d1663174705fbdeb48f8d546486.jpg',
    nickname: 'Ranth Allngal',
    time: '09-20 12:54',
    zan: '54',
    content: '评论不要太苛刻，不管什么产品都会有瑕疵，客服也说了可以退货并且商家承担运费，我觉得至少态度就可以给五星。' },

  {
    src: 'http://img0.imgtn.bdimg.com/it/u=2396068252,4277062836&fm=26&gp=0.jpg',
    nickname: 'Ranth Allngal',
    time: '09-20 12:54',
    zan: '54',
    content: '楼上说的好有道理。' }] };



var shareList = [{
  type: 1,
  icon: '/static/temp/share_wechat.png',
  text: '微信好友' },

{
  type: 2,
  icon: '/static/temp/share_moment.png',
  text: '朋友圈' },

{
  type: 3,
  icon: '/static/temp/share_qq.png',
  text: 'QQ好友' },

{
  type: 4,
  icon: '/static/temp/share_qqzone.png',
  text: 'QQ空间' }];


var lazyLoadList = [{
  src: 'http://img0.imgtn.bdimg.com/it/u=2396068252,4277062836&fm=26&gp=0.jpg' },

{
  src: 'http://img.pconline.com.cn/images/upload/upc/tx/itbbs/1309/06/c4/25310541_1378426131583.jpg' },

{
  src: 'http://img.pconline.com.cn/images/upload/upc/tx/photoblog/1610/26/c4/28926240_1477451226577_mthumb.jpg' },

{
  src: 'http://picture.ik123.com/uploads/allimg/190219/12-1Z219105139.jpg' },

{
  src: 'http://img5.imgtn.bdimg.com/it/u=2904900134,438461613&fm=26&gp=0.jpg' },

{
  src: 'http://img1.imgtn.bdimg.com/it/u=1690475408,2565370337&fm=26&gp=0.jpg' },

{
  src: 'http://img.99114.com/group1/M00/7F/99/wKgGS1kVrPGAe5LmAAU2KrJmb3Q923_600_600.jpg' },

{
  src: 'http://img4.imgtn.bdimg.com/it/u=261047209,372231813&fm=26&gp=0.jpg' },

{
  src: 'http://i2.17173cdn.com/i7mz64/YWxqaGBf/tu17173com/20150107/eMyVMObjlbcvDEv.jpg' },

{
  src: 'http://img008.hc360.cn/m4/M02/E7/87/wKhQ6FSrfU6EfUoyAAAAAITAfyc280.jpg' },

{
  src: 'http://pic1.win4000.com/wallpaper/d/5991569950166.jpg' },

{
  src: 'http://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/6f061d950a7b0208f9fe945e60d9f2d3572cc85e.jpg' },

{
  src: 'http://pic41.nipic.com/20140429/18169759_125841756000_2.jpg' },

{
  src: 'http://www.k73.com/up/allimg/130415/22-130415093527.jpg' },

{
  src: 'http://img.52z.com/upload/news/image/20180530/20180530081619_31029.jpg' },

{
  src: 'http://b-ssl.duitang.com/uploads/item/201410/02/20141002111638_tXAzU.jpeg' },

{
  src: 'http://img2.ph.126.net/C4JW6f57QWSB21-8jh2UGQ==/1762596304262286698.jpg' },

{
  src: 'http://att.bbs.duowan.com/forum/201405/17/190257nzcvkkdg6w2e8226.jpg' },

{
  src: 'http://attach.bbs.miui.com/forum/201504/10/223644v3intigyvva0vgym.jpg' },

{
  src: 'http://pic1.win4000.com/mobile/3/57888a298d61d.jpg' }];



var orderList = [{
  time: '2019-04-06 11:37',
  state: 1,
  goodsList: [{
    image: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1553187020783&di=bac9dd78b36fd984502d404d231011c0&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201609%2F26%2F20160926173213_s5adi.jpeg' },

  {
    image: 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=4031878334,2682695508&fm=11&gp=0.jpg' },

  {
    image: 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1620020012,789258862&fm=26&gp=0.jpg' },

  {
    image: 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=4031878334,2682695508&fm=11&gp=0.jpg' },

  {
    image: 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1620020012,789258862&fm=26&gp=0.jpg' },

  {
    image: 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=4031878334,2682695508&fm=11&gp=0.jpg' },

  {
    image: 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1620020012,789258862&fm=26&gp=0.jpg' }] },



{
  time: '2019-04-06 11:37',
  state: 9,
  goodsList: [{
    title: '古黛妃 短袖t恤女 春夏装2019新款韩版宽松',
    price: 179.5,
    image: 'https://img13.360buyimg.com/n8/jfs/t1/30343/20/1029/481370/5c449438Ecb46a15b/2b2adccb6dc742fd.jpg',
    number: 1,
    attr: '珊瑚粉 M' }] },


{
  time: '2019-04-06 11:37',
  state: 1,
  goodsList: [{
    image: 'https://img.alicdn.com/imgextra/https://img.alicdn.com/imgextra/i2/2120460599/O1CN01LBPS4C1GINkwsOTXS_!!2120460599.jpg_430x430q90.jpg' },

  {
    image: 'https://img.alicdn.com/imgextra/i2/1069876356/TB2ocTQG4WYBuNjy1zkXXXGGpXa_!!1069876356.jpg_430x430q90.jpg' },

  {
    image: 'https://img.alicdn.com/imgextra/https://img.alicdn.com/imgextra/i4/2120460599/O1CN01YsmgwZ1GINkv38rkn_!!2120460599.jpg_430x430q90.jpg' }] },



{
  time: '2019-04-06 11:37',
  state: 1,
  goodsList: [{
    title: '回力女鞋高帮帆布鞋女学生韩版鞋子女2019潮鞋女鞋新款春季板鞋女',
    price: 69,
    image: 'https://img.alicdn.com/imgextra/i3/2128794607/TB2gzzoc41YBuNjy1zcXXbNcXXa_!!2128794607.jpg_430x430q90.jpg',
    number: 1,
    attr: '白色-高帮 39' }] },


{
  time: '2019-04-06 11:37',
  state: 1,
  goodsList: [{
    image: 'https://img.alicdn.com/imgextra/https://img.alicdn.com/imgextra/i4/3358098495/O1CN01dhYyid2Ccl5MWLDok_!!3358098495.jpg_430x430q90.jpg' },

  {
    image: 'https://img.alicdn.com/imgextra/https://img.alicdn.com/imgextra/i3/3358098495/O1CN01AWsnFA2Ccl5OzvqsL_!!3358098495.jpg_430x430q90.jpg' }] },



{
  time: '2019-04-06 11:37',
  state: 1,
  goodsList: [{
    image: 'https://img.alicdn.com/imgextra/i4/3470687433/O1CN0124mMQOSERr18L1h_!!3470687433.jpg_430x430q90.jpg' },

  {
    image: 'https://img.alicdn.com/imgextra/i3/2888462616/O1CN01ERra5J1VCAbZaKI5n_!!0-item_pic.jpg_430x430q90.jpg' },

  {
    image: 'https://gd3.alicdn.com/imgextra/i3/819381730/O1CN01YV4mXj1OeNhQIhQlh_!!819381730.jpg_400x400.jpg' }] }];





var cateList = [{
  id: 1,
  name: '手机数码' },

{
  id: 2,
  name: '礼品鲜花' },

{
  id: 3,
  name: '男装女装' },

{
  id: 4,
  name: '母婴用品' },

{
  id: 5,
  pid: 1,
  name: '手机通讯' },

{
  id: 6,
  pid: 1,
  name: '运营商' },

{
  id: 8,
  pid: 5,
  name: '全面屏手机',
  picture: '/static/temp/cate2.jpg' },

{
  id: 9,
  pid: 5,
  name: '游戏手机',
  picture: '/static/temp/cate3.jpg' },

{
  id: 10,
  pid: 5,
  name: '老人机',
  picture: '/static/temp/cate1.jpg' },

{
  id: 11,
  pid: 5,
  name: '拍照手机',
  picture: '/static/temp/cate4.jpg' },

{
  id: 12,
  pid: 5,
  name: '女性手机',
  picture: '/static/temp/cate5.jpg' },

{
  id: 14,
  pid: 6,
  name: '合约机',
  picture: '/static/temp/cate1.jpg' },

{
  id: 15,
  pid: 6,
  name: '选好卡',
  picture: '/static/temp/cate4.jpg' },

{
  id: 16,
  pid: 6,
  name: '办套餐',
  picture: '/static/temp/cate5.jpg' },

{
  id: 17,
  pid: 2,
  name: '礼品' },

{
  id: 18,
  pid: 2,
  name: '鲜花' },

{
  id: 19,
  pid: 17,
  name: '公益摆件',
  picture: '/static/temp/cate7.jpg' },

{
  id: 20,
  pid: 17,
  name: '创意礼品',
  picture: '/static/temp/cate8.jpg' },

{
  id: 21,
  pid: 18,
  name: '鲜花',
  picture: '/static/temp/cate9.jpg' },

{
  id: 22,
  pid: 18,
  name: '每周一花',
  picture: '/static/temp/cate10.jpg' },

{
  id: 23,
  pid: 18,
  name: '卡通花束',
  picture: '/static/temp/cate11.jpg' },

{
  id: 24,
  pid: 18,
  name: '永生花',
  picture: '/static/temp/cate12.jpg' },

{
  id: 25,
  pid: 3,
  name: '男装' },

{
  id: 26,
  pid: 3,
  name: '女装' },

{
  id: 27,
  pid: 25,
  name: '男士T恤',
  picture: '/static/temp/cate13.jpg' },

{
  id: 28,
  pid: 25,
  name: '男士外套',
  picture: '/static/temp/cate14.jpg' },

{
  id: 29,
  pid: 26,
  name: '裙装',
  picture: '/static/temp/cate15.jpg' },

{
  id: 30,
  pid: 26,
  name: 'T恤',
  picture: '/static/temp/cate16.jpg' },

{
  id: 31,
  pid: 26,
  name: '上装',
  picture: '/static/temp/cate15.jpg' },

{
  id: 32,
  pid: 26,
  name: '下装',
  picture: '/static/temp/cate16.jpg' },

{
  id: 33,
  pid: 4,
  name: '奶粉' },

{
  id: 34,
  pid: 4,
  name: '营养辅食' },

{
  id: 35,
  pid: 4,
  name: '童装' },

{
  id: 39,
  pid: 4,
  name: '喂养用品' },

{
  id: 36,
  pid: 33,
  name: '有机奶粉',
  picture: '/static/temp/cate17.jpg' },

{
  id: 37,
  pid: 34,
  name: '果泥/果汁',
  picture: '/static/temp/cate18.jpg' },

{
  id: 39,
  pid: 34,
  name: '面条/粥',
  picture: '/static/temp/cate20.jpg' },

{
  id: 42,
  pid: 35,
  name: '婴童衣橱',
  picture: '/static/temp/cate19.jpg' },

{
  id: 43,
  pid: 39,
  name: '吸奶器',
  picture: '/static/temp/cate21.jpg' },

{
  id: 44,
  pid: 39,
  name: '儿童餐具',
  picture: '/static/temp/cate22.jpg' },

{
  id: 45,
  pid: 39,
  name: '牙胶安抚',
  picture: '/static/temp/cate23.jpg' },

{
  id: 46,
  pid: 39,
  name: '围兜',
  picture: '/static/temp/cate24.jpg' }];var _default =



{
  carouselList: carouselList,
  cartList: cartList,
  detailData: detailData,
  lazyLoadList: lazyLoadList,
  userInfo: userInfo,
  shareList: shareList,
  goodsList: goodsList,
  orderList: orderList,
  cateList: cateList };exports.default = _default;

/***/ }),
/* 50 */
/*!******************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/flex.css/dist/flex.css ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin
    if(false) { var cssReload; }
  

/***/ }),
/* 51 */
/*!*************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(uni) {Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;
var _mixin = _interopRequireDefault(__webpack_require__(/*! ./libs/mixin/mixin.js */ 52));



var _request = _interopRequireDefault(__webpack_require__(/*! ./libs/request */ 53));




















var _queryParams = _interopRequireDefault(__webpack_require__(/*! ./libs/function/queryParams.js */ 57));

var _route = _interopRequireDefault(__webpack_require__(/*! ./libs/function/route.js */ 58));

var _timeFormat = _interopRequireDefault(__webpack_require__(/*! ./libs/function/timeFormat.js */ 59));

var _timeFrom = _interopRequireDefault(__webpack_require__(/*! ./libs/function/timeFrom.js */ 60));

var _colorGradient = _interopRequireDefault(__webpack_require__(/*! ./libs/function/colorGradient.js */ 61));

var _guid = _interopRequireDefault(__webpack_require__(/*! ./libs/function/guid.js */ 62));

var _color = _interopRequireDefault(__webpack_require__(/*! ./libs/function/color.js */ 63));

var _type2icon = _interopRequireDefault(__webpack_require__(/*! ./libs/function/type2icon.js */ 64));

var _randomArray = _interopRequireDefault(__webpack_require__(/*! ./libs/function/randomArray.js */ 65));

var _deepClone = _interopRequireDefault(__webpack_require__(/*! ./libs/function/deepClone.js */ 55));

var _deepMerge = _interopRequireDefault(__webpack_require__(/*! ./libs/function/deepMerge.js */ 54));

var _addUnit = _interopRequireDefault(__webpack_require__(/*! ./libs/function/addUnit.js */ 66));


var _test = _interopRequireDefault(__webpack_require__(/*! ./libs/function/test.js */ 56));

var _random = _interopRequireDefault(__webpack_require__(/*! ./libs/function/random.js */ 67));

var _trim = _interopRequireDefault(__webpack_require__(/*! ./libs/function/trim.js */ 68));

var _toast = _interopRequireDefault(__webpack_require__(/*! ./libs/function/toast.js */ 69));

var _getParent = _interopRequireDefault(__webpack_require__(/*! ./libs/function/getParent.js */ 70));

var _$parent = _interopRequireDefault(__webpack_require__(/*! ./libs/function/$parent.js */ 71));



var _sys = __webpack_require__(/*! ./libs/function/sys.js */ 72);

var _debounce = _interopRequireDefault(__webpack_require__(/*! ./libs/function/debounce.js */ 73));

var _throttle = _interopRequireDefault(__webpack_require__(/*! ./libs/function/throttle.js */ 74));



var _config = _interopRequireDefault(__webpack_require__(/*! ./libs/config/config.js */ 75));

var _zIndex = _interopRequireDefault(__webpack_require__(/*! ./libs/config/zIndex.js */ 76));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };} // 引入全局mixin
// 引入关于是否mixin集成小程序分享的配置
// import wxshare from './libs/mixin/mpShare.js'
// 全局挂载引入http相关请求拦截插件
function wranning(str) {// 开发环境进行信息输出,主要是一些报错信息
  // 这个环境的来由是在程序编写时候,点击hx编辑器运行调试代码的时候,详见:
  // 	https://uniapp.dcloud.io/frame?id=%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83%e5%92%8c%e7%94%9f%e4%ba%a7%e7%8e%af%e5%a2%83
  if (true) {console.warn(str);}} // 尝试判断在根目录的/store中是否有$u.mixin.js，此文件uView默认为需要挂在到全局的vuex的state变量
// HX2.6.11版本,放到try中,控制台依然会警告,暂时不用此方式，
// let vuexStore = {};
// try {
// 	vuexStore = require("@/store/$u.mixin.js");
// } catch (e) {
// 	//TODO handle the exception
// }
// post类型对象参数转为get类型url参数
var $u = { queryParams: _queryParams.default, route: _route.default, timeFormat: _timeFormat.default, date: _timeFormat.default, // 另名date
  timeFrom: _timeFrom.default, colorGradient: _colorGradient.default.colorGradient, colorToRgba: _colorGradient.default.colorToRgba, guid: _guid.default, color: _color.default, sys: _sys.sys, os: _sys.os, type2icon: _type2icon.default, randomArray: _randomArray.default, wranning: wranning, get: _request.default.get,
  post: _request.default.post,
  put: _request.default.put,
  'delete': _request.default.delete,
  hexToRgb: _colorGradient.default.hexToRgb,
  rgbToHex: _colorGradient.default.rgbToHex,
  test: _test.default,
  random: _random.default,
  deepClone: _deepClone.default,
  deepMerge: _deepMerge.default,
  getParent: _getParent.default,
  $parent: _$parent.default,
  addUnit: _addUnit.default,
  trim: _trim.default,
  type: ['primary', 'success', 'error', 'warning', 'info'],
  http: _request.default,
  toast: _toast.default,
  config: _config.default, // uView配置信息相关，比如版本号
  zIndex: _zIndex.default,
  debounce: _debounce.default,
  throttle: _throttle.default };


// $u挂载到uni对象上
uni.$u = $u;

var install = function install(Vue) {
  Vue.mixin(_mixin.default);
  if (Vue.prototype.openShare) {
    Vue.mixin(mpShare);
  }
  // Vue.mixin(vuexStore);
  // 时间格式化，同时两个名称，date和timeFormat
  Vue.filter('timeFormat', function (timestamp, format) {
    return (0, _timeFormat.default)(timestamp, format);
  });
  Vue.filter('date', function (timestamp, format) {
    return (0, _timeFormat.default)(timestamp, format);
  });
  // 将多久以前的方法，注入到全局过滤器
  Vue.filter('timeFrom', function (timestamp, format) {
    return (0, _timeFrom.default)(timestamp, format);
  });
  Vue.prototype.$u = $u;
};var _default =

{
  install: install };exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["default"]))

/***/ }),
/* 52 */
/*!************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/mixin/mixin.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(uni) {module.exports = {
  data: function data() {
    return {};
  },
  onLoad: function onLoad() {
    // getRect挂载到$u上，因为这方法需要使用in(this)，所以无法把它独立成一个单独的文件导出
    this.$u.getRect = this.$uGetRect;
  },
  methods: {
    // 查询节点信息
    // 目前此方法在支付宝小程序中无法获取组件跟接点的尺寸，为支付宝的bug(2020-07-21)
    // 解决办法为在组件根部再套一个没有任何作用的view元素
    $uGetRect: function $uGetRect(selector, all) {var _this = this;
      return new Promise(function (resolve) {
        uni.createSelectorQuery().
        in(_this)[all ? 'selectAll' : 'select'](selector).
        boundingClientRect(function (rect) {
          if (all && Array.isArray(rect) && rect.length) {
            resolve(rect);
          }
          if (!all && rect) {
            resolve(rect);
          }
        }).
        exec();
      });
    },
    getParentData: function getParentData() {var _this2 = this;var parentName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      // 避免在created中去定义parent变量
      if (!this.parent) this.parent = false;
      // 这里的本质原理是，通过获取父组件实例(也即u-radio-group的this)
      // 将父组件this中对应的参数，赋值给本组件(u-radio的this)的parentData对象中对应的属性
      // 之所以需要这么做，是因为所有端中，头条小程序不支持通过this.parent.xxx去监听父组件参数的变化
      this.parent = this.$u.$parent.call(this, parentName);
      if (this.parent) {
        // 历遍parentData中的属性，将parent中的同名属性赋值给parentData
        Object.keys(this.parentData).map(function (key) {
          _this2.parentData[key] = _this2.parent[key];
        });
      }
    },
    // 阻止事件冒泡
    preventEvent: function preventEvent(e) {
      e && e.stopPropagation && e.stopPropagation();
    } },

  onReachBottom: function onReachBottom() {
    uni.$emit('uOnReachBottom');
  },
  beforeDestroy: function beforeDestroy() {var _this3 = this;
    // 判断当前页面是否存在parent和chldren，一般在checkbox和checkbox-group父子联动的场景会有此情况
    // 组件销毁时，移除子组件在父组件children数组中的实例，释放资源，避免数据混乱
    if (this.parent && uni.$u.test.array(this.parent.children)) {
      // 组件销毁时，移除父组件中的children数组中对应的实例
      var childrenList = this.parent.children;
      childrenList.map(function (child, index) {
        // 如果相等，则移除
        if (child === _this3) {
          childrenList.splice(index, 1);
        }
      });
    }
  } };
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["default"]))

/***/ }),
/* 53 */
/*!**************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/request/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(uni) {Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _deepMerge = _interopRequireDefault(__webpack_require__(/*! ../function/deepMerge */ 54));
var _test = _interopRequireDefault(__webpack_require__(/*! ../function/test */ 56));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var
Request = /*#__PURE__*/function () {_createClass(Request, [{ key: "setConfig",
    // 设置全局默认配置
    value: function setConfig(customConfig) {
      // 深度合并对象，否则会造成对象深层属性丢失
      this.config = (0, _deepMerge.default)(this.config, customConfig);
    }

    // 主要请求部分
  }, { key: "request", value: function request() {var _this = this;var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // 检查请求拦截
      if (this.interceptor.request && typeof this.interceptor.request === 'function') {
        var tmpConfig = {};
        var interceptorRequest = this.interceptor.request(options);
        if (interceptorRequest === false) {
          // 返回一个处于pending状态中的Promise，来取消原promise，避免进入then()回调
          return new Promise(function () {});
        }
        this.options = interceptorRequest;
      }
      options.dataType = options.dataType || this.config.dataType;
      options.responseType = options.responseType || this.config.responseType;
      options.url = options.url || '';
      options.params = options.params || {};
      options.header = Object.assign({}, this.config.header, options.header);
      options.method = options.method || this.config.method;

      return new Promise(function (resolve, reject) {
        options.complete = function (response) {
          // 请求返回后，隐藏loading(如果请求返回快的话，可能会没有loading)
          uni.hideLoading();
          // 清除定时器，如果请求回来了，就无需loading
          clearTimeout(_this.config.timer);
          _this.config.timer = null;
          // 判断用户对拦截返回数据的要求，如果originalData为true，返回所有的数据(response)到拦截器，否则只返回response.data
          if (_this.config.originalData) {
            // 判断是否存在拦截器
            if (_this.interceptor.response && typeof _this.interceptor.response === 'function') {
              var resInterceptors = _this.interceptor.response(response);
              // 如果拦截器不返回false，就将拦截器返回的内容给this.$u.post的then回调
              if (resInterceptors !== false) {
                resolve(resInterceptors);
              } else {
                // 如果拦截器返回false，意味着拦截器定义者认为返回有问题，直接接入catch回调
                reject(response);
              }
            } else {
              // 如果要求返回原始数据，就算没有拦截器，也返回最原始的数据
              resolve(response);
            }
          } else {
            if (response.statusCode == 200) {
              if (_this.interceptor.response && typeof _this.interceptor.response === 'function') {
                var _resInterceptors = _this.interceptor.response(response.data);
                if (_resInterceptors !== false) {
                  resolve(_resInterceptors);
                } else {
                  reject(response.data);
                }
              } else {
                // 如果不是返回原始数据(originalData=false)，且没有拦截器的情况下，返回纯数据给then回调
                resolve(response.data);
              }
            } else {
              // 不返回原始数据的情况下，服务器状态码不为200，modal弹框提示
              // if(response.errMsg) {
              // 	uni.showModal({
              // 		title: response.errMsg
              // 	});
              // }
              reject(response);
            }
          }
        };

        // 判断用户传递的URL是否/开头,如果不是,加上/，这里使用了uView的test.js验证库的url()方法
        options.url = _test.default.url(options.url) ? options.url : _this.config.baseUrl + (options.url.indexOf('/') == 0 ?
        options.url : '/' + options.url);

        // 是否显示loading
        // 加一个是否已有timer定时器的判断，否则有两个同时请求的时候，后者会清除前者的定时器id
        // 而没有清除前者的定时器，导致前者超时，一直显示loading
        if (_this.config.showLoading && !_this.config.timer) {
          _this.config.timer = setTimeout(function () {
            uni.showLoading({
              title: _this.config.loadingText,
              mask: _this.config.loadingMask });

            _this.config.timer = null;
          }, _this.config.loadingTime);
        }
        uni.request(options);
      });
      // .catch(res => {
      // 	// 如果返回reject()，不让其进入this.$u.post().then().catch()后面的catct()
      // 	// 因为很多人都会忘了写后面的catch()，导致报错捕获不到catch
      // 	return new Promise(()=>{});
      // })
    } }]);

  function Request() {var _this2 = this;_classCallCheck(this, Request);
    this.config = {
      baseUrl: '', // 请求的根域名
      // 默认的请求头
      header: {},
      method: 'POST',
      // 设置为json，返回后uni.request会对数据进行一次JSON.parse
      dataType: 'json',
      // 此参数无需处理，因为5+和支付宝小程序不支持，默认为text即可
      responseType: 'text',
      showLoading: true, // 是否显示请求中的loading
      loadingText: '请求中...',
      loadingTime: 800, // 在此时间内，请求还没回来的话，就显示加载中动画，单位ms
      timer: null, // 定时器
      originalData: false, // 是否在拦截器中返回服务端的原始数据，见文档说明
      loadingMask: true // 展示loading的时候，是否给一个透明的蒙层，防止触摸穿透
    };

    // 拦截器
    this.interceptor = {
      // 请求前的拦截
      request: null,
      // 请求后的拦截
      response: null };


    // get请求
    this.get = function (url) {var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};var header = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return _this2.request({
        method: 'GET',
        url: url,
        header: header,
        data: data });

    };

    // post请求
    this.post = function (url) {var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};var header = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return _this2.request({
        url: url,
        method: 'POST',
        header: header,
        data: data });

    };

    // put请求，不支持支付宝小程序(HX2.6.15)
    this.put = function (url) {var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};var header = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return _this2.request({
        url: url,
        method: 'PUT',
        header: header,
        data: data });

    };

    // delete请求，不支持支付宝和头条小程序(HX2.6.15)
    this.delete = function (url) {var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};var header = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return _this2.request({
        url: url,
        method: 'DELETE',
        header: header,
        data: data });

    };
  }return Request;}();var _default =

new Request();exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["default"]))

/***/ }),
/* 54 */
/*!*******************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/deepMerge.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _deepClone = _interopRequireDefault(__webpack_require__(/*! ./deepClone */ 55));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

// JS对象深度合并
function deepMerge() {var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  target = (0, _deepClone.default)(target);
  if (typeof target !== 'object' || typeof source !== 'object') return false;
  for (var prop in source) {
    if (!source.hasOwnProperty(prop)) continue;
    if (prop in target) {
      if (typeof target[prop] !== 'object') {
        target[prop] = source[prop];
      } else {
        if (typeof source[prop] !== 'object') {
          target[prop] = source[prop];
        } else {
          if (target[prop].concat && source[prop].concat) {
            target[prop] = target[prop].concat(source[prop]);
          } else {
            target[prop] = deepMerge(target[prop], source[prop]);
          }
        }
      }
    } else {
      target[prop] = source[prop];
    }
  }
  return target;
}var _default =

deepMerge;exports.default = _default;

/***/ }),
/* 55 */
/*!*******************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/deepClone.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0; // 判断arr是否为一个数组，返回一个bool值
function isArray(arr) {
  return Object.prototype.toString.call(arr) === '[object Array]';
}

// 深度克隆
function deepClone(obj) {
  // 对常见的“非”值，直接返回原来值
  if ([null, undefined, NaN, false].includes(obj)) return obj;
  if (typeof obj !== "object" && typeof obj !== 'function') {
    //原始类型直接返回
    return obj;
  }
  var o = isArray(obj) ? [] : {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = typeof obj[i] === "object" ? deepClone(obj[i]) : obj[i];
    }
  }
  return o;
}var _default =

deepClone;exports.default = _default;

/***/ }),
/* 56 */
/*!**************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/test.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0; /**
                                                                                                      * 验证电子邮箱格式
                                                                                                      */
function email(value) {
  return /^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/.test(value);
}

/**
   * 验证手机格式
   */
function mobile(value) {
  return /^1[3-9]\d{9}$/.test(value);
}

/**
   * 验证URL格式
   */
function url(value) {
  return /http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w-.\/?%&=]*)?/.test(value);
}

/**
   * 验证日期格式
   */
function date(value) {
  return !/Invalid|NaN/.test(new Date(value).toString());
}

/**
   * 验证ISO类型的日期格式
   */
function dateISO(value) {
  return /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(value);
}

/**
   * 验证十进制数字
   */
function number(value) {
  return /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(value);
}

/**
   * 验证整数
   */
function digits(value) {
  return /^\d+$/.test(value);
}

/**
   * 验证身份证号码
   */
function idCard(value) {
  return /^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}([0-9]|X)$/.test(
  value);
}

/**
   * 是否车牌号
   */
function carNo(value) {
  // 新能源车牌
  var xreg = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}(([0-9]{5}[DF]$)|([DF][A-HJ-NP-Z0-9][0-9]{4}$))/;
  // 旧车牌
  var creg = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-HJ-NP-Z0-9]{4}[A-HJ-NP-Z0-9挂学警港澳]{1}$/;
  if (value.length === 7) {
    return creg.test(value);
  } else if (value.length === 8) {
    return xreg.test(value);
  } else {
    return false;
  }
}

/**
   * 金额,只允许2位小数
   */
function amount(value) {
  //金额，只允许保留两位小数
  return /^[1-9]\d*(,\d{3})*(\.\d{1,2})?$|^0\.\d{1,2}$/.test(value);
}

/**
   * 中文
   */
function chinese(value) {
  var reg = /^[\u4e00-\u9fa5]+$/gi;
  return reg.test(value);
}

/**
   * 只能输入字母
   */
function letter(value) {
  return /^[a-zA-Z]*$/.test(value);
}

/**
   * 只能是字母或者数字
   */
function enOrNum(value) {
  //英文或者数字
  var reg = /^[0-9a-zA-Z]*$/g;
  return reg.test(value);
}

/**
   * 验证是否包含某个值
   */
function contains(value, param) {
  return value.indexOf(param) >= 0;
}

/**
   * 验证一个值范围[min, max]
   */
function range(value, param) {
  return value >= param[0] && value <= param[1];
}

/**
   * 验证一个长度范围[min, max]
   */
function rangeLength(value, param) {
  return value.length >= param[0] && value.length <= param[1];
}

/**
   * 是否固定电话
   */
function landline(value) {
  var reg = /^\d{3,4}-\d{7,8}(-\d{3,4})?$/;
  return reg.test(value);
}

/**
   * 判断是否为空
   */
function empty(value) {
  switch (typeof value) {
    case 'undefined':
      return true;
    case 'string':
      if (value.replace(/(^[ \t\n\r]*)|([ \t\n\r]*$)/g, '').length == 0) return true;
      break;
    case 'boolean':
      if (!value) return true;
      break;
    case 'number':
      if (0 === value || isNaN(value)) return true;
      break;
    case 'object':
      if (null === value || value.length === 0) return true;
      for (var i in value) {
        return false;
      }
      return true;}

  return false;
}

/**
   * 是否json字符串
   */
function jsonString(value) {
  if (typeof value == 'string') {
    try {
      var obj = JSON.parse(value);
      if (typeof obj == 'object' && obj) {
        return true;
      } else {
        return false;
      }
    } catch (e) {
      return false;
    }
  }
  return false;
}


/**
   * 是否数组
   */
function array(value) {
  if (typeof Array.isArray === "function") {
    return Array.isArray(value);
  } else {
    return Object.prototype.toString.call(value) === "[object Array]";
  }
}

/**
   * 是否对象
   */
function object(value) {
  return Object.prototype.toString.call(value) === '[object Object]';
}

/**
   * 是否短信验证码
   */
function code(value) {var len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;
  return new RegExp("^\\d{".concat(len, "}$")).test(value);
}var _default =


{
  email: email,
  mobile: mobile,
  url: url,
  date: date,
  dateISO: dateISO,
  number: number,
  digits: digits,
  idCard: idCard,
  carNo: carNo,
  amount: amount,
  chinese: chinese,
  letter: letter,
  enOrNum: enOrNum,
  contains: contains,
  range: range,
  rangeLength: rangeLength,
  empty: empty,
  isEmpty: empty,
  jsonString: jsonString,
  landline: landline,
  object: object,
  array: array,
  code: code };exports.default = _default;

/***/ }),
/* 57 */
/*!*********************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/queryParams.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0; /**
                                                                                                      * 对象转url参数
                                                                                                      * @param {*} data,对象
                                                                                                      * @param {*} isPrefix,是否自动加上"?"
                                                                                                      */
function queryParams() {var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};var isPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;var arrayFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'brackets';
  var prefix = isPrefix ? '?' : '';
  var _result = [];
  if (['indices', 'brackets', 'repeat', 'comma'].indexOf(arrayFormat) == -1) arrayFormat = 'brackets';var _loop = function _loop(
  key) {
    var value = data[key];
    // 去掉为空的参数
    if (['', undefined, null].indexOf(value) >= 0) {
      return "continue";
    }
    // 如果值为数组，另行处理
    if (value.constructor === Array) {
      // e.g. {ids: [1, 2, 3]}
      switch (arrayFormat) {
        case 'indices':
          // 结果: ids[0]=1&ids[1]=2&ids[2]=3
          for (var i = 0; i < value.length; i++) {
            _result.push(key + '[' + i + ']=' + value[i]);
          }
          break;
        case 'brackets':
          // 结果: ids[]=1&ids[]=2&ids[]=3
          value.forEach(function (_value) {
            _result.push(key + '[]=' + _value);
          });
          break;
        case 'repeat':
          // 结果: ids=1&ids=2&ids=3
          value.forEach(function (_value) {
            _result.push(key + '=' + _value);
          });
          break;
        case 'comma':
          // 结果: ids=1,2,3
          var commaStr = "";
          value.forEach(function (_value) {
            commaStr += (commaStr ? "," : "") + _value;
          });
          _result.push(key + '=' + commaStr);
          break;
        default:
          value.forEach(function (_value) {
            _result.push(key + '[]=' + _value);
          });}

    } else {
      _result.push(key + '=' + value);
    }};for (var key in data) {var _ret = _loop(key);if (_ret === "continue") continue;
  }
  return _result.length ? prefix + _result.join('&') : '';
}var _default =

queryParams;exports.default = _default;

/***/ }),
/* 58 */
/*!***************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/route.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(uni) {Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _regenerator = _interopRequireDefault(__webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ 17));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * 路由跳转方法，该方法相对于直接使用uni.xxx的好处是使用更加简单快捷
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * 并且带有路由拦截功能
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */var

Router = /*#__PURE__*/function () {
  function Router() {_classCallCheck(this, Router);
    // 原始属性定义
    this.config = {
      type: 'navigateTo',
      url: '',
      delta: 1, // navigateBack页面后退时,回退的层数
      params: {}, // 传递的参数
      animationType: 'pop-in', // 窗口动画,只在APP有效
      animationDuration: 300, // 窗口动画持续时间,单位毫秒,只在APP有效
      intercept: false // 是否需要拦截
    };
    // 因为route方法是需要对外赋值给另外的对象使用，同时route内部有使用this，会导致route失去上下文
    // 这里在构造函数中进行this绑定
    this.route = this.route.bind(this);
  }

  // 判断url前面是否有"/"，如果没有则加上，否则无法跳转
  _createClass(Router, [{ key: "addRootPath", value: function addRootPath(url) {
      return url[0] === '/' ? url : "/".concat(url);
    }

    // 整合路由参数
  }, { key: "mixinParam", value: function mixinParam(url, params) {
      url = url && this.addRootPath(url);

      // 使用正则匹配，主要依据是判断是否有"/","?","="等，如“/page/index/index?name=mary"
      // 如果有url中有get参数，转换后无需带上"?"
      var query = '';
      if (/.*\/.*\?.*=.*/.test(url)) {
        // object对象转为get类型的参数
        query = uni.$u.queryParams(params, false);
        // 因为已有get参数,所以后面拼接的参数需要带上"&"隔开
        return url += "&" + query;
      } else {
        // 直接拼接参数，因为此处url中没有后面的query参数，也就没有"?/&"之类的符号
        query = uni.$u.queryParams(params);
        return url += query;
      }
    }

    // 对外的方法名称
  }, { key: "route", value: function () {var _route = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee() {var options,params,mergeConfig,isNext,_args = arguments;return _regenerator.default.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};params = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                // 合并用户的配置和内部的默认配置
                mergeConfig = {};

                if (typeof options === 'string') {
                  // 如果options为字符串，则为route(url, params)的形式
                  mergeConfig.url = this.mixinParam(options, params);
                  mergeConfig.type = 'navigateTo';
                } else {
                  mergeConfig = uni.$u.deepClone(options, this.config);
                  // 否则正常使用mergeConfig中的url和params进行拼接
                  mergeConfig.url = this.mixinParam(options.url, options.params);
                }

                if (params.intercept) {
                  this.config.intercept = params.intercept;
                }
                // params参数也带给拦截器
                mergeConfig.params = params;
                // 合并内外部参数
                mergeConfig = uni.$u.deepMerge(this.config, mergeConfig);
                // 判断用户是否定义了拦截器
                if (!(typeof uni.$u.routeIntercept === 'function')) {_context.next = 14;break;}_context.next = 10;return (

                  new Promise(function (resolve, reject) {
                    uni.$u.routeIntercept(mergeConfig, resolve);
                  }));case 10:isNext = _context.sent;
                // 如果isNext为true，则执行路由跳转
                isNext && this.openPage(mergeConfig);_context.next = 15;break;case 14:

                this.openPage(mergeConfig);case 15:case "end":return _context.stop();}}}, _callee, this);}));function route() {return _route.apply(this, arguments);}return route;}()



    // 执行路由跳转
  }, { key: "openPage", value: function openPage(config) {
      // 解构参数
      var
      url =




      config.url,type = config.type,delta = config.delta,animationType = config.animationType,animationDuration = config.animationDuration;
      if (config.type == 'navigateTo' || config.type == 'to') {
        uni.navigateTo({
          url: url,
          animationType: animationType,
          animationDuration: animationDuration });

      }
      if (config.type == 'redirectTo' || config.type == 'redirect') {
        uni.redirectTo({
          url: url });

      }
      if (config.type == 'switchTab' || config.type == 'tab') {
        uni.switchTab({
          url: url });

      }
      if (config.type == 'reLaunch' || config.type == 'launch') {
        uni.reLaunch({
          url: url });

      }
      if (config.type == 'navigateBack' || config.type == 'back') {
        uni.navigateBack({
          delta: delta });

      }
    } }]);return Router;}();var _default =


new Router().route;exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["default"]))

/***/ }),
/* 59 */
/*!********************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/timeFormat.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0; // padStart 的 polyfill，因为某些机型或情况，还无法支持es7的padStart，比如电脑版的微信小程序
// 所以这里做一个兼容polyfill的兼容处理
if (!String.prototype.padStart) {
  // 为了方便表示这里 fillString 用了ES6 的默认参数，不影响理解
  String.prototype.padStart = function (maxLength) {var fillString = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' ';
    if (Object.prototype.toString.call(fillString) !== "[object String]") throw new TypeError(
    'fillString must be String');
    var str = this;
    // 返回 String(str) 这里是为了使返回的值是字符串字面量，在控制台中更符合直觉
    if (str.length >= maxLength) return String(str);

    var fillLength = maxLength - str.length,
    times = Math.ceil(fillLength / fillString.length);
    while (times >>= 1) {
      fillString += fillString;
      if (times === 1) {
        fillString += fillString;
      }
    }
    return fillString.slice(0, fillLength) + str;
  };
}

// 其他更多是格式化有如下:
// yyyy:mm:dd|yyyy:mm|yyyy年mm月dd日|yyyy年mm月dd日 hh时MM分等,可自定义组合
function timeFormat() {var dateTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;var fmt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'yyyy-mm-dd';
  // 如果为null,则格式化当前时间
  if (!dateTime) dateTime = Number(new Date());
  // 如果dateTime长度为10或者13，则为秒和毫秒的时间戳，如果超过13位，则为其他的时间格式
  if (dateTime.toString().length == 10) dateTime *= 1000;
  var date = new Date(dateTime);
  var ret;
  var opt = {
    "y+": date.getFullYear().toString(), // 年
    "m+": (date.getMonth() + 1).toString(), // 月
    "d+": date.getDate().toString(), // 日
    "h+": date.getHours().toString(), // 时
    "M+": date.getMinutes().toString(), // 分
    "s+": date.getSeconds().toString() // 秒
    // 有其他格式化字符需求可以继续添加，必须转化成字符串
  };
  for (var k in opt) {
    ret = new RegExp("(" + k + ")").exec(fmt);
    if (ret) {
      fmt = fmt.replace(ret[1], ret[1].length == 1 ? opt[k] : opt[k].padStart(ret[1].length, "0"));
    };
  };
  return fmt;
}var _default =

timeFormat;exports.default = _default;

/***/ }),
/* 60 */
/*!******************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/timeFrom.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _timeFormat = _interopRequireDefault(__webpack_require__(/*! ../../libs/function/timeFormat.js */ 59));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

/**
                                                                                                                                                                                                                                                                                          * 时间戳转为多久之前
                                                                                                                                                                                                                                                                                          * @param String timestamp 时间戳
                                                                                                                                                                                                                                                                                          * @param String | Boolean format 如果为时间格式字符串，超出一定时间范围，返回固定的时间格式；
                                                                                                                                                                                                                                                                                          * 如果为布尔值false，无论什么时间，都返回多久以前的格式
                                                                                                                                                                                                                                                                                          */
function timeFrom() {var dateTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'yyyy-mm-dd';
  // 如果为null,则格式化当前时间
  if (!dateTime) dateTime = Number(new Date());
  // 如果dateTime长度为10或者13，则为秒和毫秒的时间戳，如果超过13位，则为其他的时间格式
  if (dateTime.toString().length == 10) dateTime *= 1000;
  var timestamp = +new Date(Number(dateTime));

  var timer = (Number(new Date()) - timestamp) / 1000;
  // 如果小于5分钟,则返回"刚刚",其他以此类推
  var tips = '';
  switch (true) {
    case timer < 300:
      tips = '刚刚';
      break;
    case timer >= 300 && timer < 3600:
      tips = parseInt(timer / 60) + '分钟前';
      break;
    case timer >= 3600 && timer < 86400:
      tips = parseInt(timer / 3600) + '小时前';
      break;
    case timer >= 86400 && timer < 2592000:
      tips = parseInt(timer / 86400) + '天前';
      break;
    default:
      // 如果format为false，则无论什么时间戳，都显示xx之前
      if (format === false) {
        if (timer >= 2592000 && timer < 365 * 86400) {
          tips = parseInt(timer / (86400 * 30)) + '个月前';
        } else {
          tips = parseInt(timer / (86400 * 365)) + '年前';
        }
      } else {
        tips = (0, _timeFormat.default)(timestamp, format);
      }}

  return tips;
}var _default =

timeFrom;exports.default = _default;

/***/ }),
/* 61 */
/*!***********************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/colorGradient.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0; /**
                                                                                                      * 求两个颜色之间的渐变值
                                                                                                      * @param {string} startColor 开始的颜色
                                                                                                      * @param {string} endColor 结束的颜色
                                                                                                      * @param {number} step 颜色等分的份额
                                                                                                      * */
function colorGradient() {var startColor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'rgb(0, 0, 0)';var endColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'rgb(255, 255, 255)';var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
  var startRGB = hexToRgb(startColor, false); //转换为rgb数组模式
  var startR = startRGB[0];
  var startG = startRGB[1];
  var startB = startRGB[2];

  var endRGB = hexToRgb(endColor, false);
  var endR = endRGB[0];
  var endG = endRGB[1];
  var endB = endRGB[2];

  var sR = (endR - startR) / step; //总差值
  var sG = (endG - startG) / step;
  var sB = (endB - startB) / step;
  var colorArr = [];
  for (var i = 0; i < step; i++) {
    //计算每一步的hex值 
    var hex = rgbToHex('rgb(' + Math.round(sR * i + startR) + ',' + Math.round(sG * i + startG) + ',' + Math.round(sB *
    i + startB) + ')');
    colorArr.push(hex);
  }
  return colorArr;
}

// 将hex表示方式转换为rgb表示方式(这里返回rgb数组模式)
function hexToRgb(sColor) {var str = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
  sColor = sColor.toLowerCase();
  if (sColor && reg.test(sColor)) {
    if (sColor.length === 4) {
      var sColorNew = "#";
      for (var i = 1; i < 4; i += 1) {
        sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1));
      }
      sColor = sColorNew;
    }
    //处理六位的颜色值
    var sColorChange = [];
    for (var _i = 1; _i < 7; _i += 2) {
      sColorChange.push(parseInt("0x" + sColor.slice(_i, _i + 2)));
    }
    if (!str) {
      return sColorChange;
    } else {
      return "rgb(".concat(sColorChange[0], ",").concat(sColorChange[1], ",").concat(sColorChange[2], ")");
    }
  } else if (/^(rgb|RGB)/.test(sColor)) {
    var arr = sColor.replace(/(?:\(|\)|rgb|RGB)*/g, "").split(",");
    return arr.map(function (val) {return Number(val);});
  } else {
    return sColor;
  }
};

// 将rgb表示方式转换为hex表示方式
function rgbToHex(rgb) {
  var _this = rgb;
  var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
  if (/^(rgb|RGB)/.test(_this)) {
    var aColor = _this.replace(/(?:\(|\)|rgb|RGB)*/g, "").split(",");
    var strHex = "#";
    for (var i = 0; i < aColor.length; i++) {
      var hex = Number(aColor[i]).toString(16);
      hex = String(hex).length == 1 ? 0 + '' + hex : hex; // 保证每个rgb的值为2位
      if (hex === "0") {
        hex += hex;
      }
      strHex += hex;
    }
    if (strHex.length !== 7) {
      strHex = _this;
    }
    return strHex;
  } else if (reg.test(_this)) {
    var aNum = _this.replace(/#/, "").split("");
    if (aNum.length === 6) {
      return _this;
    } else if (aNum.length === 3) {
      var numHex = "#";
      for (var _i2 = 0; _i2 < aNum.length; _i2 += 1) {
        numHex += aNum[_i2] + aNum[_i2];
      }
      return numHex;
    }
  } else {
    return _this;
  }
}


/**
  * JS颜色十六进制转换为rgb或rgba,返回的格式为 rgba（255，255，255，0.5）字符串
  * sHex为传入的十六进制的色值
  * alpha为rgba的透明度
  */
function colorToRgba(color) {var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.3;
  color = rgbToHex(color);
  // 十六进制颜色值的正则表达式
  var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
  /* 16进制颜色转为RGB格式 */
  var sColor = color.toLowerCase();
  if (sColor && reg.test(sColor)) {
    if (sColor.length === 4) {
      var sColorNew = '#';
      for (var i = 1; i < 4; i += 1) {
        sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1));
      }
      sColor = sColorNew;
    }
    // 处理六位的颜色值
    var sColorChange = [];
    for (var _i3 = 1; _i3 < 7; _i3 += 2) {
      sColorChange.push(parseInt('0x' + sColor.slice(_i3, _i3 + 2)));
    }
    // return sColorChange.join(',')
    return 'rgba(' + sColorChange.join(',') + ',' + alpha + ')';
  } else
  {
    return sColor;
  }
}var _default =

{
  colorGradient: colorGradient,
  hexToRgb: hexToRgb,
  rgbToHex: rgbToHex,
  colorToRgba: colorToRgba };exports.default = _default;

/***/ }),
/* 62 */
/*!**************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/guid.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0; /**
                                                                                                      * 本算法来源于简书开源代码，详见：https://www.jianshu.com/p/fdbf293d0a85
                                                                                                      * 全局唯一标识符（uuid，Globally Unique Identifier）,也称作 uuid(Universally Unique IDentifier) 
                                                                                                      * 一般用于多个组件之间,给它一个唯一的标识符,或者v-for循环的时候,如果使用数组的index可能会导致更新列表出现问题
                                                                                                      * 最可能的情况是左滑删除item或者对某条信息流"不喜欢"并去掉它的时候,会导致组件内的数据可能出现错乱
                                                                                                      * v-for的时候,推荐使用后端返回的id而不是循环的index
                                                                                                      * @param {Number} len uuid的长度
                                                                                                      * @param {Boolean} firstU 将返回的首字母置为"u"
                                                                                                      * @param {Nubmer} radix 生成uuid的基数(意味着返回的字符串都是这个基数),2-二进制,8-八进制,10-十进制,16-十六进制
                                                                                                      */
function guid() {var len = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;var firstU = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;var radix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
  var uuid = [];
  radix = radix || chars.length;

  if (len) {
    // 如果指定uuid长度,只是取随机的字符,0|x为位运算,能去掉x的小数位,返回整数位
    for (var i = 0; i < len; i++) {uuid[i] = chars[0 | Math.random() * radix];}
  } else {
    var r;
    // rfc4122标准要求返回的uuid中,某些位为固定的字符
    uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
    uuid[14] = '4';

    for (var _i = 0; _i < 36; _i++) {
      if (!uuid[_i]) {
        r = 0 | Math.random() * 16;
        uuid[_i] = chars[_i == 19 ? r & 0x3 | 0x8 : r];
      }
    }
  }
  // 移除第一个字符,并用u替代,因为第一个字符为数值时,该guuid不能用作id或者class
  if (firstU) {
    uuid.shift();
    return 'u' + uuid.join('');
  } else {
    return uuid.join('');
  }
}var _default =

guid;exports.default = _default;

/***/ }),
/* 63 */
/*!***************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/color.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0; // 为了让用户能够自定义主题，会逐步弃用此文件，各颜色通过css提供
// 为了给某些特殊场景使用和向后兼容，无需删除此文件(2020-06-20)
var color = {
  primary: "#2979ff",
  primaryDark: "#2b85e4",
  primaryDisabled: "#a0cfff",
  primaryLight: "#ecf5ff",
  bgColor: "#f3f4f6",

  info: "#909399",
  infoDark: "#82848a",
  infoDisabled: "#c8c9cc",
  infoLight: "#f4f4f5",

  warning: "#ff9900",
  warningDark: "#f29100",
  warningDisabled: "#fcbd71",
  warningLight: "#fdf6ec",

  error: "#fa3534",
  errorDark: "#dd6161",
  errorDisabled: "#fab6b6",
  errorLight: "#fef0f0",

  success: "#19be6b",
  successDark: "#18b566",
  successDisabled: "#71d5a1",
  successLight: "#dbf1e1",

  mainColor: "#303133",
  contentColor: "#606266",
  tipsColor: "#909399",
  lightColor: "#c0c4cc",
  borderColor: "#e4e7ed" };var _default =


color;exports.default = _default;

/***/ }),
/* 64 */
/*!*******************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/type2icon.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0; /**
                                                                                                      * 根据主题type值,获取对应的图标
                                                                                                      * @param String type 主题名称,primary|info|error|warning|success
                                                                                                      * @param String fill 是否使用fill填充实体的图标  
                                                                                                      */
function type2icon() {var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'success';var fill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  // 如果非预置值,默认为success
  if (['primary', 'info', 'error', 'warning', 'success'].indexOf(type) == -1) type = 'success';
  var iconName = '';
  // 目前(2019-12-12),info和primary使用同一个图标
  switch (type) {
    case 'primary':
      iconName = 'info-circle';
      break;
    case 'info':
      iconName = 'info-circle';
      break;
    case 'error':
      iconName = 'close-circle';
      break;
    case 'warning':
      iconName = 'error-circle';
      break;
    case 'success':
      iconName = 'checkmark-circle';
      break;
    default:
      iconName = 'checkmark-circle';}

  // 是否是实体类型,加上-fill,在icon组件库中,实体的类名是后面加-fill的
  if (fill) iconName += '-fill';
  return iconName;
}var _default =

type2icon;exports.default = _default;

/***/ }),
/* 65 */
/*!*********************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/randomArray.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0; // 打乱数组
function randomArray() {var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  // 原理是sort排序,Math.random()产生0<= x < 1之间的数,会导致x-0.05大于或者小于0
  return array.sort(function () {return Math.random() - 0.5;});
}var _default =

randomArray;exports.default = _default;

/***/ }),
/* 66 */
/*!*****************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/addUnit.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = addUnit;var _test = _interopRequireDefault(__webpack_require__(/*! ./test.js */ 56));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

// 添加单位，如果有rpx，%，px等单位结尾或者值为auto，直接返回，否则加上rpx单位结尾
function addUnit() {var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'auto';var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'rpx';
  value = String(value);
  // 用uView内置验证规则中的number判断是否为数值
  return _test.default.number(value) ? "".concat(value).concat(unit) : value;
}

/***/ }),
/* 67 */
/*!****************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/random.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;function random(min, max) {
  if (min >= 0 && max > 0 && max >= min) {
    var gab = max - min + 1;
    return Math.floor(Math.random() * gab + min);
  } else {
    return 0;
  }
}var _default =

random;exports.default = _default;

/***/ }),
/* 68 */
/*!**************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/trim.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;function trim(str) {var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'both';
  if (pos == 'both') {
    return str.replace(/^\s+|\s+$/g, "");
  } else if (pos == "left") {
    return str.replace(/^\s*/, '');
  } else if (pos == 'right') {
    return str.replace(/(\s*$)/g, "");
  } else if (pos == 'all') {
    return str.replace(/\s+/g, "");
  } else {
    return str;
  }
}var _default =

trim;exports.default = _default;

/***/ }),
/* 69 */
/*!***************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/toast.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(uni) {Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;function toast(title) {var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1500;
  uni.showToast({
    title: title,
    icon: 'none',
    duration: duration });

}var _default =

toast;exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["default"]))

/***/ }),
/* 70 */
/*!*******************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/getParent.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = getParent; // 获取父组件的参数，因为支付宝小程序不支持provide/inject的写法
// this.$parent在非H5中，可以准确获取到父组件，但是在H5中，需要多次this.$parent.$parent.xxx
function getParent(name, keys) {
  var parent = this.$parent;
  // 通过while历遍，这里主要是为了H5需要多层解析的问题
  while (parent) {
    // 父组件
    if (parent.$options.name !== name) {
      // 如果组件的name不相等，继续上一级寻找
      parent = parent.$parent;
    } else {var _ret = function () {
        var data = {};
        // 判断keys是否数组，如果传过来的是一个数组，那么直接使用数组元素值当做键值去父组件寻找
        if (Array.isArray(keys)) {
          keys.map(function (val) {
            data[val] = parent[val] ? parent[val] : '';
          });
        } else {
          // 历遍传过来的对象参数
          for (var i in keys) {
            // 如果子组件有此值则用，无此值则用父组件的值
            // 判断是否空数组，如果是，则用父组件的值，否则用子组件的值
            if (Array.isArray(keys[i])) {
              if (keys[i].length) {
                data[i] = keys[i];
              } else {
                data[i] = parent[i];
              }
            } else if (keys[i].constructor === Object) {
              // 判断是否对象，如果是对象，且有属性，那么使用子组件的值，否则使用父组件的值
              if (Object.keys(keys[i]).length) {
                data[i] = keys[i];
              } else {
                data[i] = parent[i];
              }
            } else {
              // 只要子组件有传值，即使是false值，也是“传值”了，也需要覆盖父组件的同名参数
              data[i] = keys[i] || keys[i] === false ? keys[i] : parent[i];
            }
          }
        }
        return { v: data };}();if (typeof _ret === "object") return _ret.v;
    }
  }

  return {};
}

/***/ }),
/* 71 */
/*!*****************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/$parent.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = $parent; // 获取父组件的参数，因为支付宝小程序不支持provide/inject的写法
// this.$parent在非H5中，可以准确获取到父组件，但是在H5中，需要多次this.$parent.$parent.xxx
// 这里默认值等于undefined有它的含义，因为最顶层元素(组件)的$parent就是undefined，意味着不传name
// 值(默认为undefined)，就是查找最顶层的$parent
function $parent() {var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
  var parent = this.$parent;
  // 通过while历遍，这里主要是为了H5需要多层解析的问题
  while (parent) {
    // 父组件
    if (parent.$options && parent.$options.name !== name) {
      // 如果组件的name不相等，继续上一级寻找
      parent = parent.$parent;
    } else {
      return parent;
    }
  }
  return false;
}

/***/ }),
/* 72 */
/*!*************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/sys.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(uni) {Object.defineProperty(exports, "__esModule", { value: true });exports.os = os;exports.sys = sys;function os() {
  return uni.getSystemInfoSync().platform;
};

function sys() {
  return uni.getSystemInfoSync();
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["default"]))

/***/ }),
/* 73 */
/*!******************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/debounce.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var timeout = null;

/**
                                                                                                                         * 防抖原理：一定时间内，只有最后一次操作，再过wait毫秒后才执行函数
                                                                                                                         * 
                                                                                                                         * @param {Function} func 要执行的回调函数 
                                                                                                                         * @param {Number} wait 延时的时间
                                                                                                                         * @param {Boolean} immediate 是否立即执行 
                                                                                                                         * @return null
                                                                                                                         */
function debounce(func) {var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;var immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // 清除定时器
  if (timeout !== null) clearTimeout(timeout);
  // 立即执行，此类情况一般用不到
  if (immediate) {
    var callNow = !timeout;
    timeout = setTimeout(function () {
      timeout = null;
    }, wait);
    if (callNow) typeof func === 'function' && func();
  } else {
    // 设置定时器，当最后一次操作后，timeout不会再被清除，所以在延时wait毫秒后执行func回调方法
    timeout = setTimeout(function () {
      typeof func === 'function' && func();
    }, wait);
  }
}var _default =

debounce;exports.default = _default;

/***/ }),
/* 74 */
/*!******************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/function/throttle.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var timer, flag;
/**
                                                                                                                      * 节流原理：在一定时间内，只能触发一次
                                                                                                                      * 
                                                                                                                      * @param {Function} func 要执行的回调函数 
                                                                                                                      * @param {Number} wait 延时的时间
                                                                                                                      * @param {Boolean} immediate 是否立即执行
                                                                                                                      * @return null
                                                                                                                      */
function throttle(func) {var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;var immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  if (immediate) {
    if (!flag) {
      flag = true;
      // 如果是立即执行，则在wait毫秒内开始时执行
      typeof func === 'function' && func();
      timer = setTimeout(function () {
        flag = false;
      }, wait);
    }
  } else {
    if (!flag) {
      flag = true;
      // 如果是非立即执行，则在wait毫秒内的结束处执行
      timer = setTimeout(function () {
        flag = false;
        typeof func === 'function' && func();
      }, wait);
    }

  }
};var _default =
throttle;exports.default = _default;

/***/ }),
/* 75 */
/*!**************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/config/config.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0; // 此版本发布于2020-12-17
var version = '1.8.3';var _default =

{
  v: version,
  version: version,
  // 主题名称
  type: [
  'primary',
  'success',
  'info',
  'error',
  'warning'] };exports.default = _default;

/***/ }),
/* 76 */
/*!**************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/uview-ui/libs/config/zIndex.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0; // uniapp在H5中各API的z-index值如下：
/**
 * actionsheet: 999
 * modal: 999
 * navigate: 998
 * tabbar: 998
 * toast: 999
 */var _default =

{
  toast: 10090,
  noNetwork: 10080,
  // popup包含popup，actionsheet，keyboard，picker的值
  popup: 10075,
  mask: 10070,
  navbar: 980,
  topTips: 975,
  sticky: 970,
  indexListSticky: 965 };exports.default = _default;

/***/ }),
/* 77 */
/*!****************************************************!*\
  !*** ./node_modules/vue-i18n/dist/vue-i18n.esm.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*!
 * vue-i18n v8.24.1 
 * (c) 2021 kazuya kawaguchi
 * Released under the MIT License.
 */
/*  */

/**
 * constants
 */

var numberFormatKeys = [
  'compactDisplay',
  'currency',
  'currencyDisplay',
  'currencySign',
  'localeMatcher',
  'notation',
  'numberingSystem',
  'signDisplay',
  'style',
  'unit',
  'unitDisplay',
  'useGrouping',
  'minimumIntegerDigits',
  'minimumFractionDigits',
  'maximumFractionDigits',
  'minimumSignificantDigits',
  'maximumSignificantDigits'
];

/**
 * utilities
 */

function warn (msg, err) {
  if (typeof console !== 'undefined') {
    console.warn('[vue-i18n] ' + msg);
    /* istanbul ignore if */
    if (err) {
      console.warn(err.stack);
    }
  }
}

function error (msg, err) {
  if (typeof console !== 'undefined') {
    console.error('[vue-i18n] ' + msg);
    /* istanbul ignore if */
    if (err) {
      console.error(err.stack);
    }
  }
}

var isArray = Array.isArray;

function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

function isBoolean (val) {
  return typeof val === 'boolean'
}

function isString (val) {
  return typeof val === 'string'
}

var toString = Object.prototype.toString;
var OBJECT_STRING = '[object Object]';
function isPlainObject (obj) {
  return toString.call(obj) === OBJECT_STRING
}

function isNull (val) {
  return val === null || val === undefined
}

function isFunction (val) {
  return typeof val === 'function'
}

function parseArgs () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  var locale = null;
  var params = null;
  if (args.length === 1) {
    if (isObject(args[0]) || isArray(args[0])) {
      params = args[0];
    } else if (typeof args[0] === 'string') {
      locale = args[0];
    }
  } else if (args.length === 2) {
    if (typeof args[0] === 'string') {
      locale = args[0];
    }
    /* istanbul ignore if */
    if (isObject(args[1]) || isArray(args[1])) {
      params = args[1];
    }
  }

  return { locale: locale, params: params }
}

function looseClone (obj) {
  return JSON.parse(JSON.stringify(obj))
}

function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

function includes (arr, item) {
  return !!~arr.indexOf(item)
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

function merge (target) {
  var arguments$1 = arguments;

  var output = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments$1[i];
    if (source !== undefined && source !== null) {
      var key = (void 0);
      for (key in source) {
        if (hasOwn(source, key)) {
          if (isObject(source[key])) {
            output[key] = merge(output[key], source[key]);
          } else {
            output[key] = source[key];
          }
        }
      }
    }
  }
  return output
}

function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = isArray(a);
      var isArrayB = isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

/**
 * Sanitizes html special characters from input strings. For mitigating risk of XSS attacks.
 * @param rawText The raw input from the user that should be escaped.
 */
function escapeHtml(rawText) {
  return rawText
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;')
}

/**
 * Escapes html tags and special symbols from all provided params which were returned from parseArgs().params.
 * This method performs an in-place operation on the params object.
 *
 * @param {any} params Parameters as provided from `parseArgs().params`.
 *                     May be either an array of strings or a string->any map.
 *
 * @returns The manipulated `params` object.
 */
function escapeParams(params) {
  if(params != null) {
    Object.keys(params).forEach(function (key) {
      if(typeof(params[key]) == 'string') {
        params[key] = escapeHtml(params[key]);
      }
    });
  }
  return params
}

/*  */

function extend (Vue) {
  if (!Vue.prototype.hasOwnProperty('$i18n')) {
    // $FlowFixMe
    Object.defineProperty(Vue.prototype, '$i18n', {
      get: function get () { return this._i18n }
    });
  }

  Vue.prototype.$t = function (key) {
    var values = [], len = arguments.length - 1;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];

    var i18n = this.$i18n;
    return i18n._t.apply(i18n, [ key, i18n.locale, i18n._getMessages(), this ].concat( values ))
  };

  Vue.prototype.$tc = function (key, choice) {
    var values = [], len = arguments.length - 2;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];

    var i18n = this.$i18n;
    return i18n._tc.apply(i18n, [ key, i18n.locale, i18n._getMessages(), this, choice ].concat( values ))
  };

  Vue.prototype.$te = function (key, locale) {
    var i18n = this.$i18n;
    return i18n._te(key, i18n.locale, i18n._getMessages(), locale)
  };

  Vue.prototype.$d = function (value) {
    var ref;

    var args = [], len = arguments.length - 1;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];
    return (ref = this.$i18n).d.apply(ref, [ value ].concat( args ))
  };

  Vue.prototype.$n = function (value) {
    var ref;

    var args = [], len = arguments.length - 1;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];
    return (ref = this.$i18n).n.apply(ref, [ value ].concat( args ))
  };
}

/*  */

var mixin = {
  beforeCreate: function beforeCreate () {
    var options = this.$options;
    options.i18n = options.i18n || (options.__i18n ? {} : null);

    if (options.i18n) {
      if (options.i18n instanceof VueI18n) {
        // init locale messages via custom blocks
        if (options.__i18n) {
          try {
            var localeMessages = options.i18n && options.i18n.messages ? options.i18n.messages : {};
            options.__i18n.forEach(function (resource) {
              localeMessages = merge(localeMessages, JSON.parse(resource));
            });
            Object.keys(localeMessages).forEach(function (locale) {
              options.i18n.mergeLocaleMessage(locale, localeMessages[locale]);
            });
          } catch (e) {
            if (true) {
              error("Cannot parse locale messages via custom blocks.", e);
            }
          }
        }
        this._i18n = options.i18n;
        this._i18nWatcher = this._i18n.watchI18nData();
      } else if (isPlainObject(options.i18n)) {
        var rootI18n = this.$root && this.$root.$i18n && this.$root.$i18n instanceof VueI18n
          ? this.$root.$i18n
          : null;
        // component local i18n
        if (rootI18n) {
          options.i18n.root = this.$root;
          options.i18n.formatter = rootI18n.formatter;
          options.i18n.fallbackLocale = rootI18n.fallbackLocale;
          options.i18n.formatFallbackMessages = rootI18n.formatFallbackMessages;
          options.i18n.silentTranslationWarn = rootI18n.silentTranslationWarn;
          options.i18n.silentFallbackWarn = rootI18n.silentFallbackWarn;
          options.i18n.pluralizationRules = rootI18n.pluralizationRules;
          options.i18n.preserveDirectiveContent = rootI18n.preserveDirectiveContent;
        }

        // init locale messages via custom blocks
        if (options.__i18n) {
          try {
            var localeMessages$1 = options.i18n && options.i18n.messages ? options.i18n.messages : {};
            options.__i18n.forEach(function (resource) {
              localeMessages$1 = merge(localeMessages$1, JSON.parse(resource));
            });
            options.i18n.messages = localeMessages$1;
          } catch (e) {
            if (true) {
              warn("Cannot parse locale messages via custom blocks.", e);
            }
          }
        }

        var ref = options.i18n;
        var sharedMessages = ref.sharedMessages;
        if (sharedMessages && isPlainObject(sharedMessages)) {
          options.i18n.messages = merge(options.i18n.messages, sharedMessages);
        }

        this._i18n = new VueI18n(options.i18n);
        this._i18nWatcher = this._i18n.watchI18nData();

        if (options.i18n.sync === undefined || !!options.i18n.sync) {
          this._localeWatcher = this.$i18n.watchLocale();
        }

        if (rootI18n) {
          rootI18n.onComponentInstanceCreated(this._i18n);
        }
      } else {
        if (true) {
          warn("Cannot be interpreted 'i18n' option.");
        }
      }
    } else if (this.$root && this.$root.$i18n && this.$root.$i18n instanceof VueI18n) {
      // root i18n
      this._i18n = this.$root.$i18n;
    } else if (options.parent && options.parent.$i18n && options.parent.$i18n instanceof VueI18n) {
      // parent i18n
      this._i18n = options.parent.$i18n;
    }
  },

  beforeMount: function beforeMount () {
    var options = this.$options;
    options.i18n = options.i18n || (options.__i18n ? {} : null);

    if (options.i18n) {
      if (options.i18n instanceof VueI18n) {
        // init locale messages via custom blocks
        this._i18n.subscribeDataChanging(this);
        this._subscribing = true;
      } else if (isPlainObject(options.i18n)) {
        this._i18n.subscribeDataChanging(this);
        this._subscribing = true;
      } else {
        if (true) {
          warn("Cannot be interpreted 'i18n' option.");
        }
      }
    } else if (this.$root && this.$root.$i18n && this.$root.$i18n instanceof VueI18n) {
      this._i18n.subscribeDataChanging(this);
      this._subscribing = true;
    } else if (options.parent && options.parent.$i18n && options.parent.$i18n instanceof VueI18n) {
      this._i18n.subscribeDataChanging(this);
      this._subscribing = true;
    }
  },

  mounted: function mounted () {
    if (this !== this.$root && this.$options.__INTLIFY_META__ && this.$el) {
      this.$el.setAttribute('data-intlify', this.$options.__INTLIFY_META__);
    }
  },

  beforeDestroy: function beforeDestroy () {
    if (!this._i18n) { return }

    var self = this;
    this.$nextTick(function () {
      if (self._subscribing) {
        self._i18n.unsubscribeDataChanging(self);
        delete self._subscribing;
      }

      if (self._i18nWatcher) {
        self._i18nWatcher();
        self._i18n.destroyVM();
        delete self._i18nWatcher;
      }

      if (self._localeWatcher) {
        self._localeWatcher();
        delete self._localeWatcher;
      }
    });
  }
};

/*  */

var interpolationComponent = {
  name: 'i18n',
  functional: true,
  props: {
    tag: {
      type: [String, Boolean, Object],
      default: 'span'
    },
    path: {
      type: String,
      required: true
    },
    locale: {
      type: String
    },
    places: {
      type: [Array, Object]
    }
  },
  render: function render (h, ref) {
    var data = ref.data;
    var parent = ref.parent;
    var props = ref.props;
    var slots = ref.slots;

    var $i18n = parent.$i18n;
    if (!$i18n) {
      if (true) {
        warn('Cannot find VueI18n instance!');
      }
      return
    }

    var path = props.path;
    var locale = props.locale;
    var places = props.places;
    var params = slots();
    var children = $i18n.i(
      path,
      locale,
      onlyHasDefaultPlace(params) || places
        ? useLegacyPlaces(params.default, places)
        : params
    );

    var tag = (!!props.tag && props.tag !== true) || props.tag === false ? props.tag : 'span';
    return tag ? h(tag, data, children) : children
  }
};

function onlyHasDefaultPlace (params) {
  var prop;
  for (prop in params) {
    if (prop !== 'default') { return false }
  }
  return Boolean(prop)
}

function useLegacyPlaces (children, places) {
  var params = places ? createParamsFromPlaces(places) : {};

  if (!children) { return params }

  // Filter empty text nodes
  children = children.filter(function (child) {
    return child.tag || child.text.trim() !== ''
  });

  var everyPlace = children.every(vnodeHasPlaceAttribute);
  if ( true && everyPlace) {
    warn('`place` attribute is deprecated in next major version. Please switch to Vue slots.');
  }

  return children.reduce(
    everyPlace ? assignChildPlace : assignChildIndex,
    params
  )
}

function createParamsFromPlaces (places) {
  if (true) {
    warn('`places` prop is deprecated in next major version. Please switch to Vue slots.');
  }

  return Array.isArray(places)
    ? places.reduce(assignChildIndex, {})
    : Object.assign({}, places)
}

function assignChildPlace (params, child) {
  if (child.data && child.data.attrs && child.data.attrs.place) {
    params[child.data.attrs.place] = child;
  }
  return params
}

function assignChildIndex (params, child, index) {
  params[index] = child;
  return params
}

function vnodeHasPlaceAttribute (vnode) {
  return Boolean(vnode.data && vnode.data.attrs && vnode.data.attrs.place)
}

/*  */

var numberComponent = {
  name: 'i18n-n',
  functional: true,
  props: {
    tag: {
      type: [String, Boolean, Object],
      default: 'span'
    },
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    },
    locale: {
      type: String
    }
  },
  render: function render (h, ref) {
    var props = ref.props;
    var parent = ref.parent;
    var data = ref.data;

    var i18n = parent.$i18n;

    if (!i18n) {
      if (true) {
        warn('Cannot find VueI18n instance!');
      }
      return null
    }

    var key = null;
    var options = null;

    if (isString(props.format)) {
      key = props.format;
    } else if (isObject(props.format)) {
      if (props.format.key) {
        key = props.format.key;
      }

      // Filter out number format options only
      options = Object.keys(props.format).reduce(function (acc, prop) {
        var obj;

        if (includes(numberFormatKeys, prop)) {
          return Object.assign({}, acc, ( obj = {}, obj[prop] = props.format[prop], obj ))
        }
        return acc
      }, null);
    }

    var locale = props.locale || i18n.locale;
    var parts = i18n._ntp(props.value, locale, key, options);

    var values = parts.map(function (part, index) {
      var obj;

      var slot = data.scopedSlots && data.scopedSlots[part.type];
      return slot ? slot(( obj = {}, obj[part.type] = part.value, obj.index = index, obj.parts = parts, obj )) : part.value
    });

    var tag = (!!props.tag && props.tag !== true) || props.tag === false ? props.tag : 'span';
    return tag
      ? h(tag, {
        attrs: data.attrs,
        'class': data['class'],
        staticClass: data.staticClass
      }, values)
      : values
  }
};

/*  */

function bind (el, binding, vnode) {
  if (!assert(el, vnode)) { return }

  t(el, binding, vnode);
}

function update (el, binding, vnode, oldVNode) {
  if (!assert(el, vnode)) { return }

  var i18n = vnode.context.$i18n;
  if (localeEqual(el, vnode) &&
    (looseEqual(binding.value, binding.oldValue) &&
     looseEqual(el._localeMessage, i18n.getLocaleMessage(i18n.locale)))) { return }

  t(el, binding, vnode);
}

function unbind (el, binding, vnode, oldVNode) {
  var vm = vnode.context;
  if (!vm) {
    warn('Vue instance does not exists in VNode context');
    return
  }

  var i18n = vnode.context.$i18n || {};
  if (!binding.modifiers.preserve && !i18n.preserveDirectiveContent) {
    el.textContent = '';
  }
  el._vt = undefined;
  delete el['_vt'];
  el._locale = undefined;
  delete el['_locale'];
  el._localeMessage = undefined;
  delete el['_localeMessage'];
}

function assert (el, vnode) {
  var vm = vnode.context;
  if (!vm) {
    warn('Vue instance does not exists in VNode context');
    return false
  }

  if (!vm.$i18n) {
    warn('VueI18n instance does not exists in Vue instance');
    return false
  }

  return true
}

function localeEqual (el, vnode) {
  var vm = vnode.context;
  return el._locale === vm.$i18n.locale
}

function t (el, binding, vnode) {
  var ref$1, ref$2;

  var value = binding.value;

  var ref = parseValue(value);
  var path = ref.path;
  var locale = ref.locale;
  var args = ref.args;
  var choice = ref.choice;
  if (!path && !locale && !args) {
    warn('value type not supported');
    return
  }

  if (!path) {
    warn('`path` is required in v-t directive');
    return
  }

  var vm = vnode.context;
  if (choice != null) {
    el._vt = el.textContent = (ref$1 = vm.$i18n).tc.apply(ref$1, [ path, choice ].concat( makeParams(locale, args) ));
  } else {
    el._vt = el.textContent = (ref$2 = vm.$i18n).t.apply(ref$2, [ path ].concat( makeParams(locale, args) ));
  }
  el._locale = vm.$i18n.locale;
  el._localeMessage = vm.$i18n.getLocaleMessage(vm.$i18n.locale);
}

function parseValue (value) {
  var path;
  var locale;
  var args;
  var choice;

  if (isString(value)) {
    path = value;
  } else if (isPlainObject(value)) {
    path = value.path;
    locale = value.locale;
    args = value.args;
    choice = value.choice;
  }

  return { path: path, locale: locale, args: args, choice: choice }
}

function makeParams (locale, args) {
  var params = [];

  locale && params.push(locale);
  if (args && (Array.isArray(args) || isPlainObject(args))) {
    params.push(args);
  }

  return params
}

var Vue;

function install (_Vue) {
  /* istanbul ignore if */
  if ( true && install.installed && _Vue === Vue) {
    warn('already installed.');
    return
  }
  install.installed = true;

  Vue = _Vue;

  var version = (Vue.version && Number(Vue.version.split('.')[0])) || -1;
  /* istanbul ignore if */
  if ( true && version < 2) {
    warn(("vue-i18n (" + (install.version) + ") need to use Vue 2.0 or later (Vue: " + (Vue.version) + ")."));
    return
  }

  extend(Vue);
  Vue.mixin(mixin);
  Vue.directive('t', { bind: bind, update: update, unbind: unbind });
  Vue.component(interpolationComponent.name, interpolationComponent);
  Vue.component(numberComponent.name, numberComponent);

  // use simple mergeStrategies to prevent i18n instance lose '__proto__'
  var strats = Vue.config.optionMergeStrategies;
  strats.i18n = function (parentVal, childVal) {
    return childVal === undefined
      ? parentVal
      : childVal
  };
}

/*  */

var BaseFormatter = function BaseFormatter () {
  this._caches = Object.create(null);
};

BaseFormatter.prototype.interpolate = function interpolate (message, values) {
  if (!values) {
    return [message]
  }
  var tokens = this._caches[message];
  if (!tokens) {
    tokens = parse(message);
    this._caches[message] = tokens;
  }
  return compile(tokens, values)
};



var RE_TOKEN_LIST_VALUE = /^(?:\d)+/;
var RE_TOKEN_NAMED_VALUE = /^(?:\w)+/;

function parse (format) {
  var tokens = [];
  var position = 0;

  var text = '';
  while (position < format.length) {
    var char = format[position++];
    if (char === '{') {
      if (text) {
        tokens.push({ type: 'text', value: text });
      }

      text = '';
      var sub = '';
      char = format[position++];
      while (char !== undefined && char !== '}') {
        sub += char;
        char = format[position++];
      }
      var isClosed = char === '}';

      var type = RE_TOKEN_LIST_VALUE.test(sub)
        ? 'list'
        : isClosed && RE_TOKEN_NAMED_VALUE.test(sub)
          ? 'named'
          : 'unknown';
      tokens.push({ value: sub, type: type });
    } else if (char === '%') {
      // when found rails i18n syntax, skip text capture
      if (format[(position)] !== '{') {
        text += char;
      }
    } else {
      text += char;
    }
  }

  text && tokens.push({ type: 'text', value: text });

  return tokens
}

function compile (tokens, values) {
  var compiled = [];
  var index = 0;

  var mode = Array.isArray(values)
    ? 'list'
    : isObject(values)
      ? 'named'
      : 'unknown';
  if (mode === 'unknown') { return compiled }

  while (index < tokens.length) {
    var token = tokens[index];
    switch (token.type) {
      case 'text':
        compiled.push(token.value);
        break
      case 'list':
        compiled.push(values[parseInt(token.value, 10)]);
        break
      case 'named':
        if (mode === 'named') {
          compiled.push((values)[token.value]);
        } else {
          if (true) {
            warn(("Type of token '" + (token.type) + "' and format of value '" + mode + "' don't match!"));
          }
        }
        break
      case 'unknown':
        if (true) {
          warn("Detect 'unknown' type of token!");
        }
        break
    }
    index++;
  }

  return compiled
}

/*  */

/**
 *  Path parser
 *  - Inspired:
 *    Vue.js Path parser
 */

// actions
var APPEND = 0;
var PUSH = 1;
var INC_SUB_PATH_DEPTH = 2;
var PUSH_SUB_PATH = 3;

// states
var BEFORE_PATH = 0;
var IN_PATH = 1;
var BEFORE_IDENT = 2;
var IN_IDENT = 3;
var IN_SUB_PATH = 4;
var IN_SINGLE_QUOTE = 5;
var IN_DOUBLE_QUOTE = 6;
var AFTER_PATH = 7;
var ERROR = 8;

var pathStateMachine = [];

pathStateMachine[BEFORE_PATH] = {
  'ws': [BEFORE_PATH],
  'ident': [IN_IDENT, APPEND],
  '[': [IN_SUB_PATH],
  'eof': [AFTER_PATH]
};

pathStateMachine[IN_PATH] = {
  'ws': [IN_PATH],
  '.': [BEFORE_IDENT],
  '[': [IN_SUB_PATH],
  'eof': [AFTER_PATH]
};

pathStateMachine[BEFORE_IDENT] = {
  'ws': [BEFORE_IDENT],
  'ident': [IN_IDENT, APPEND],
  '0': [IN_IDENT, APPEND],
  'number': [IN_IDENT, APPEND]
};

pathStateMachine[IN_IDENT] = {
  'ident': [IN_IDENT, APPEND],
  '0': [IN_IDENT, APPEND],
  'number': [IN_IDENT, APPEND],
  'ws': [IN_PATH, PUSH],
  '.': [BEFORE_IDENT, PUSH],
  '[': [IN_SUB_PATH, PUSH],
  'eof': [AFTER_PATH, PUSH]
};

pathStateMachine[IN_SUB_PATH] = {
  "'": [IN_SINGLE_QUOTE, APPEND],
  '"': [IN_DOUBLE_QUOTE, APPEND],
  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
  ']': [IN_PATH, PUSH_SUB_PATH],
  'eof': ERROR,
  'else': [IN_SUB_PATH, APPEND]
};

pathStateMachine[IN_SINGLE_QUOTE] = {
  "'": [IN_SUB_PATH, APPEND],
  'eof': ERROR,
  'else': [IN_SINGLE_QUOTE, APPEND]
};

pathStateMachine[IN_DOUBLE_QUOTE] = {
  '"': [IN_SUB_PATH, APPEND],
  'eof': ERROR,
  'else': [IN_DOUBLE_QUOTE, APPEND]
};

/**
 * Check if an expression is a literal value.
 */

var literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral (exp) {
  return literalValueRE.test(exp)
}

/**
 * Strip quotes from a string
 */

function stripQuotes (str) {
  var a = str.charCodeAt(0);
  var b = str.charCodeAt(str.length - 1);
  return a === b && (a === 0x22 || a === 0x27)
    ? str.slice(1, -1)
    : str
}

/**
 * Determine the type of a character in a keypath.
 */

function getPathCharType (ch) {
  if (ch === undefined || ch === null) { return 'eof' }

  var code = ch.charCodeAt(0);

  switch (code) {
    case 0x5B: // [
    case 0x5D: // ]
    case 0x2E: // .
    case 0x22: // "
    case 0x27: // '
      return ch

    case 0x5F: // _
    case 0x24: // $
    case 0x2D: // -
      return 'ident'

    case 0x09: // Tab
    case 0x0A: // Newline
    case 0x0D: // Return
    case 0xA0:  // No-break space
    case 0xFEFF:  // Byte Order Mark
    case 0x2028:  // Line Separator
    case 0x2029:  // Paragraph Separator
      return 'ws'
  }

  return 'ident'
}

/**
 * Format a subPath, return its plain form if it is
 * a literal string or number. Otherwise prepend the
 * dynamic indicator (*).
 */

function formatSubPath (path) {
  var trimmed = path.trim();
  // invalid leading 0
  if (path.charAt(0) === '0' && isNaN(path)) { return false }

  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed
}

/**
 * Parse a string path into an array of segments
 */

function parse$1 (path) {
  var keys = [];
  var index = -1;
  var mode = BEFORE_PATH;
  var subPathDepth = 0;
  var c;
  var key;
  var newChar;
  var type;
  var transition;
  var action;
  var typeMap;
  var actions = [];

  actions[PUSH] = function () {
    if (key !== undefined) {
      keys.push(key);
      key = undefined;
    }
  };

  actions[APPEND] = function () {
    if (key === undefined) {
      key = newChar;
    } else {
      key += newChar;
    }
  };

  actions[INC_SUB_PATH_DEPTH] = function () {
    actions[APPEND]();
    subPathDepth++;
  };

  actions[PUSH_SUB_PATH] = function () {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = IN_SUB_PATH;
      actions[APPEND]();
    } else {
      subPathDepth = 0;
      if (key === undefined) { return false }
      key = formatSubPath(key);
      if (key === false) {
        return false
      } else {
        actions[PUSH]();
      }
    }
  };

  function maybeUnescapeQuote () {
    var nextChar = path[index + 1];
    if ((mode === IN_SINGLE_QUOTE && nextChar === "'") ||
      (mode === IN_DOUBLE_QUOTE && nextChar === '"')) {
      index++;
      newChar = '\\' + nextChar;
      actions[APPEND]();
      return true
    }
  }

  while (mode !== null) {
    index++;
    c = path[index];

    if (c === '\\' && maybeUnescapeQuote()) {
      continue
    }

    type = getPathCharType(c);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type] || typeMap['else'] || ERROR;

    if (transition === ERROR) {
      return // parse error
    }

    mode = transition[0];
    action = actions[transition[1]];
    if (action) {
      newChar = transition[2];
      newChar = newChar === undefined
        ? c
        : newChar;
      if (action() === false) {
        return
      }
    }

    if (mode === AFTER_PATH) {
      return keys
    }
  }
}





var I18nPath = function I18nPath () {
  this._cache = Object.create(null);
};

/**
 * External parse that check for a cache hit first
 */
I18nPath.prototype.parsePath = function parsePath (path) {
  var hit = this._cache[path];
  if (!hit) {
    hit = parse$1(path);
    if (hit) {
      this._cache[path] = hit;
    }
  }
  return hit || []
};

/**
 * Get path value from path string
 */
I18nPath.prototype.getPathValue = function getPathValue (obj, path) {
  if (!isObject(obj)) { return null }

  var paths = this.parsePath(path);
  if (paths.length === 0) {
    return null
  } else {
    var length = paths.length;
    var last = obj;
    var i = 0;
    while (i < length) {
      var value = last[paths[i]];
      if (value === undefined || value === null) {
        return null
      }
      last = value;
      i++;
    }

    return last
  }
};

/*  */



var htmlTagMatcher = /<\/?[\w\s="/.':;#-\/]+>/;
var linkKeyMatcher = /(?:@(?:\.[a-z]+)?:(?:[\w\-_|.]+|\([\w\-_|.]+\)))/g;
var linkKeyPrefixMatcher = /^@(?:\.([a-z]+))?:/;
var bracketsMatcher = /[()]/g;
var defaultModifiers = {
  'upper': function (str) { return str.toLocaleUpperCase(); },
  'lower': function (str) { return str.toLocaleLowerCase(); },
  'capitalize': function (str) { return ("" + (str.charAt(0).toLocaleUpperCase()) + (str.substr(1))); }
};

var defaultFormatter = new BaseFormatter();

var VueI18n = function VueI18n (options) {
  var this$1 = this;
  if ( options === void 0 ) options = {};

  // Auto install if it is not done yet and `window` has `Vue`.
  // To allow users to avoid auto-installation in some cases,
  // this code should be placed here. See #290
  /* istanbul ignore if */
  if (!Vue && typeof window !== 'undefined' && window.Vue) {
    install(window.Vue);
  }

  var locale = options.locale || 'en-US';
  var fallbackLocale = options.fallbackLocale === false
    ? false
    : options.fallbackLocale || 'en-US';
  var messages = options.messages || {};
  var dateTimeFormats = options.dateTimeFormats || {};
  var numberFormats = options.numberFormats || {};

  this._vm = null;
  this._formatter = options.formatter || defaultFormatter;
  this._modifiers = options.modifiers || {};
  this._missing = options.missing || null;
  this._root = options.root || null;
  this._sync = options.sync === undefined ? true : !!options.sync;
  this._fallbackRoot = options.fallbackRoot === undefined
    ? true
    : !!options.fallbackRoot;
  this._formatFallbackMessages = options.formatFallbackMessages === undefined
    ? false
    : !!options.formatFallbackMessages;
  this._silentTranslationWarn = options.silentTranslationWarn === undefined
    ? false
    : options.silentTranslationWarn;
  this._silentFallbackWarn = options.silentFallbackWarn === undefined
    ? false
    : !!options.silentFallbackWarn;
  this._dateTimeFormatters = {};
  this._numberFormatters = {};
  this._path = new I18nPath();
  this._dataListeners = [];
  this._componentInstanceCreatedListener = options.componentInstanceCreatedListener || null;
  this._preserveDirectiveContent = options.preserveDirectiveContent === undefined
    ? false
    : !!options.preserveDirectiveContent;
  this.pluralizationRules = options.pluralizationRules || {};
  this._warnHtmlInMessage = options.warnHtmlInMessage || 'off';
  this._postTranslation = options.postTranslation || null;
  this._escapeParameterHtml = options.escapeParameterHtml || false;

  /**
   * @param choice {number} a choice index given by the input to $tc: `$tc('path.to.rule', choiceIndex)`
   * @param choicesLength {number} an overall amount of available choices
   * @returns a final choice index
  */
  this.getChoiceIndex = function (choice, choicesLength) {
    var thisPrototype = Object.getPrototypeOf(this$1);
    if (thisPrototype && thisPrototype.getChoiceIndex) {
      var prototypeGetChoiceIndex = (thisPrototype.getChoiceIndex);
      return (prototypeGetChoiceIndex).call(this$1, choice, choicesLength)
    }

    // Default (old) getChoiceIndex implementation - english-compatible
    var defaultImpl = function (_choice, _choicesLength) {
      _choice = Math.abs(_choice);

      if (_choicesLength === 2) {
        return _choice
          ? _choice > 1
            ? 1
            : 0
          : 1
      }

      return _choice ? Math.min(_choice, 2) : 0
    };

    if (this$1.locale in this$1.pluralizationRules) {
      return this$1.pluralizationRules[this$1.locale].apply(this$1, [choice, choicesLength])
    } else {
      return defaultImpl(choice, choicesLength)
    }
  };


  this._exist = function (message, key) {
    if (!message || !key) { return false }
    if (!isNull(this$1._path.getPathValue(message, key))) { return true }
    // fallback for flat key
    if (message[key]) { return true }
    return false
  };

  if (this._warnHtmlInMessage === 'warn' || this._warnHtmlInMessage === 'error') {
    Object.keys(messages).forEach(function (locale) {
      this$1._checkLocaleMessage(locale, this$1._warnHtmlInMessage, messages[locale]);
    });
  }

  this._initVM({
    locale: locale,
    fallbackLocale: fallbackLocale,
    messages: messages,
    dateTimeFormats: dateTimeFormats,
    numberFormats: numberFormats
  });
};

var prototypeAccessors = { vm: { configurable: true },messages: { configurable: true },dateTimeFormats: { configurable: true },numberFormats: { configurable: true },availableLocales: { configurable: true },locale: { configurable: true },fallbackLocale: { configurable: true },formatFallbackMessages: { configurable: true },missing: { configurable: true },formatter: { configurable: true },silentTranslationWarn: { configurable: true },silentFallbackWarn: { configurable: true },preserveDirectiveContent: { configurable: true },warnHtmlInMessage: { configurable: true },postTranslation: { configurable: true } };

VueI18n.prototype._checkLocaleMessage = function _checkLocaleMessage (locale, level, message) {
  var paths = [];

  var fn = function (level, locale, message, paths) {
    if (isPlainObject(message)) {
      Object.keys(message).forEach(function (key) {
        var val = message[key];
        if (isPlainObject(val)) {
          paths.push(key);
          paths.push('.');
          fn(level, locale, val, paths);
          paths.pop();
          paths.pop();
        } else {
          paths.push(key);
          fn(level, locale, val, paths);
          paths.pop();
        }
      });
    } else if (isArray(message)) {
      message.forEach(function (item, index) {
        if (isPlainObject(item)) {
          paths.push(("[" + index + "]"));
          paths.push('.');
          fn(level, locale, item, paths);
          paths.pop();
          paths.pop();
        } else {
          paths.push(("[" + index + "]"));
          fn(level, locale, item, paths);
          paths.pop();
        }
      });
    } else if (isString(message)) {
      var ret = htmlTagMatcher.test(message);
      if (ret) {
        var msg = "Detected HTML in message '" + message + "' of keypath '" + (paths.join('')) + "' at '" + locale + "'. Consider component interpolation with '<i18n>' to avoid XSS. See https://bit.ly/2ZqJzkp";
        if (level === 'warn') {
          warn(msg);
        } else if (level === 'error') {
          error(msg);
        }
      }
    }
  };

  fn(level, locale, message, paths);
};

VueI18n.prototype._initVM = function _initVM (data) {
  var silent = Vue.config.silent;
  Vue.config.silent = true;
  this._vm = new Vue({ data: data });
  Vue.config.silent = silent;
};

VueI18n.prototype.destroyVM = function destroyVM () {
  this._vm.$destroy();
};

VueI18n.prototype.subscribeDataChanging = function subscribeDataChanging (vm) {
  this._dataListeners.push(vm);
};

VueI18n.prototype.unsubscribeDataChanging = function unsubscribeDataChanging (vm) {
  remove(this._dataListeners, vm);
};

VueI18n.prototype.watchI18nData = function watchI18nData () {
  var self = this;
  return this._vm.$watch('$data', function () {
    var i = self._dataListeners.length;
    while (i--) {
      Vue.nextTick(function () {
        self._dataListeners[i] && self._dataListeners[i].$forceUpdate();
      });
    }
  }, { deep: true })
};

VueI18n.prototype.watchLocale = function watchLocale () {
  /* istanbul ignore if */
  if (!this._sync || !this._root) { return null }
  var target = this._vm;
  return this._root.$i18n.vm.$watch('locale', function (val) {
    target.$set(target, 'locale', val);
    target.$forceUpdate();
  }, { immediate: true })
};

VueI18n.prototype.onComponentInstanceCreated = function onComponentInstanceCreated (newI18n) {
  if (this._componentInstanceCreatedListener) {
    this._componentInstanceCreatedListener(newI18n, this);
  }
};

prototypeAccessors.vm.get = function () { return this._vm };

prototypeAccessors.messages.get = function () { return looseClone(this._getMessages()) };
prototypeAccessors.dateTimeFormats.get = function () { return looseClone(this._getDateTimeFormats()) };
prototypeAccessors.numberFormats.get = function () { return looseClone(this._getNumberFormats()) };
prototypeAccessors.availableLocales.get = function () { return Object.keys(this.messages).sort() };

prototypeAccessors.locale.get = function () { return this._vm.locale };
prototypeAccessors.locale.set = function (locale) {
  this._vm.$set(this._vm, 'locale', locale);
};

prototypeAccessors.fallbackLocale.get = function () { return this._vm.fallbackLocale };
prototypeAccessors.fallbackLocale.set = function (locale) {
  this._localeChainCache = {};
  this._vm.$set(this._vm, 'fallbackLocale', locale);
};

prototypeAccessors.formatFallbackMessages.get = function () { return this._formatFallbackMessages };
prototypeAccessors.formatFallbackMessages.set = function (fallback) { this._formatFallbackMessages = fallback; };

prototypeAccessors.missing.get = function () { return this._missing };
prototypeAccessors.missing.set = function (handler) { this._missing = handler; };

prototypeAccessors.formatter.get = function () { return this._formatter };
prototypeAccessors.formatter.set = function (formatter) { this._formatter = formatter; };

prototypeAccessors.silentTranslationWarn.get = function () { return this._silentTranslationWarn };
prototypeAccessors.silentTranslationWarn.set = function (silent) { this._silentTranslationWarn = silent; };

prototypeAccessors.silentFallbackWarn.get = function () { return this._silentFallbackWarn };
prototypeAccessors.silentFallbackWarn.set = function (silent) { this._silentFallbackWarn = silent; };

prototypeAccessors.preserveDirectiveContent.get = function () { return this._preserveDirectiveContent };
prototypeAccessors.preserveDirectiveContent.set = function (preserve) { this._preserveDirectiveContent = preserve; };

prototypeAccessors.warnHtmlInMessage.get = function () { return this._warnHtmlInMessage };
prototypeAccessors.warnHtmlInMessage.set = function (level) {
    var this$1 = this;

  var orgLevel = this._warnHtmlInMessage;
  this._warnHtmlInMessage = level;
  if (orgLevel !== level && (level === 'warn' || level === 'error')) {
    var messages = this._getMessages();
    Object.keys(messages).forEach(function (locale) {
      this$1._checkLocaleMessage(locale, this$1._warnHtmlInMessage, messages[locale]);
    });
  }
};

prototypeAccessors.postTranslation.get = function () { return this._postTranslation };
prototypeAccessors.postTranslation.set = function (handler) { this._postTranslation = handler; };

VueI18n.prototype._getMessages = function _getMessages () { return this._vm.messages };
VueI18n.prototype._getDateTimeFormats = function _getDateTimeFormats () { return this._vm.dateTimeFormats };
VueI18n.prototype._getNumberFormats = function _getNumberFormats () { return this._vm.numberFormats };

VueI18n.prototype._warnDefault = function _warnDefault (locale, key, result, vm, values, interpolateMode) {
  if (!isNull(result)) { return result }
  if (this._missing) {
    var missingRet = this._missing.apply(null, [locale, key, vm, values]);
    if (isString(missingRet)) {
      return missingRet
    }
  } else {
    if ( true && !this._isSilentTranslationWarn(key)) {
      warn(
        "Cannot translate the value of keypath '" + key + "'. " +
        'Use the value of keypath as default.'
      );
    }
  }

  if (this._formatFallbackMessages) {
    var parsedArgs = parseArgs.apply(void 0, values);
    return this._render(key, interpolateMode, parsedArgs.params, key)
  } else {
    return key
  }
};

VueI18n.prototype._isFallbackRoot = function _isFallbackRoot (val) {
  return !val && !isNull(this._root) && this._fallbackRoot
};

VueI18n.prototype._isSilentFallbackWarn = function _isSilentFallbackWarn (key) {
  return this._silentFallbackWarn instanceof RegExp
    ? this._silentFallbackWarn.test(key)
    : this._silentFallbackWarn
};

VueI18n.prototype._isSilentFallback = function _isSilentFallback (locale, key) {
  return this._isSilentFallbackWarn(key) && (this._isFallbackRoot() || locale !== this.fallbackLocale)
};

VueI18n.prototype._isSilentTranslationWarn = function _isSilentTranslationWarn (key) {
  return this._silentTranslationWarn instanceof RegExp
    ? this._silentTranslationWarn.test(key)
    : this._silentTranslationWarn
};

VueI18n.prototype._interpolate = function _interpolate (
  locale,
  message,
  key,
  host,
  interpolateMode,
  values,
  visitedLinkStack
) {
  if (!message) { return null }

  var pathRet = this._path.getPathValue(message, key);
  if (isArray(pathRet) || isPlainObject(pathRet)) { return pathRet }

  var ret;
  if (isNull(pathRet)) {
    /* istanbul ignore else */
    if (isPlainObject(message)) {
      ret = message[key];
      if (!(isString(ret) || isFunction(ret))) {
        if ( true && !this._isSilentTranslationWarn(key) && !this._isSilentFallback(locale, key)) {
          warn(("Value of key '" + key + "' is not a string or function !"));
        }
        return null
      }
    } else {
      return null
    }
  } else {
    /* istanbul ignore else */
    if (isString(pathRet) || isFunction(pathRet)) {
      ret = pathRet;
    } else {
      if ( true && !this._isSilentTranslationWarn(key) && !this._isSilentFallback(locale, key)) {
        warn(("Value of key '" + key + "' is not a string or function!"));
      }
      return null
    }
  }

  // Check for the existence of links within the translated string
  if (isString(ret) && (ret.indexOf('@:') >= 0 || ret.indexOf('@.') >= 0)) {
    ret = this._link(locale, message, ret, host, 'raw', values, visitedLinkStack);
  }

  return this._render(ret, interpolateMode, values, key)
};

VueI18n.prototype._link = function _link (
  locale,
  message,
  str,
  host,
  interpolateMode,
  values,
  visitedLinkStack
) {
  var ret = str;

  // Match all the links within the local
  // We are going to replace each of
  // them with its translation
  var matches = ret.match(linkKeyMatcher);
  for (var idx in matches) {
    // ie compatible: filter custom array
    // prototype method
    if (!matches.hasOwnProperty(idx)) {
      continue
    }
    var link = matches[idx];
    var linkKeyPrefixMatches = link.match(linkKeyPrefixMatcher);
    var linkPrefix = linkKeyPrefixMatches[0];
      var formatterName = linkKeyPrefixMatches[1];

    // Remove the leading @:, @.case: and the brackets
    var linkPlaceholder = link.replace(linkPrefix, '').replace(bracketsMatcher, '');

    if (includes(visitedLinkStack, linkPlaceholder)) {
      if (true) {
        warn(("Circular reference found. \"" + link + "\" is already visited in the chain of " + (visitedLinkStack.reverse().join(' <- '))));
      }
      return ret
    }
    visitedLinkStack.push(linkPlaceholder);

    // Translate the link
    var translated = this._interpolate(
      locale, message, linkPlaceholder, host,
      interpolateMode === 'raw' ? 'string' : interpolateMode,
      interpolateMode === 'raw' ? undefined : values,
      visitedLinkStack
    );

    if (this._isFallbackRoot(translated)) {
      if ( true && !this._isSilentTranslationWarn(linkPlaceholder)) {
        warn(("Fall back to translate the link placeholder '" + linkPlaceholder + "' with root locale."));
      }
      /* istanbul ignore if */
      if (!this._root) { throw Error('unexpected error') }
      var root = this._root.$i18n;
      translated = root._translate(
        root._getMessages(), root.locale, root.fallbackLocale,
        linkPlaceholder, host, interpolateMode, values
      );
    }
    translated = this._warnDefault(
      locale, linkPlaceholder, translated, host,
      isArray(values) ? values : [values],
      interpolateMode
    );

    if (this._modifiers.hasOwnProperty(formatterName)) {
      translated = this._modifiers[formatterName](translated);
    } else if (defaultModifiers.hasOwnProperty(formatterName)) {
      translated = defaultModifiers[formatterName](translated);
    }

    visitedLinkStack.pop();

    // Replace the link with the translated
    ret = !translated ? ret : ret.replace(link, translated);
  }

  return ret
};

VueI18n.prototype._createMessageContext = function _createMessageContext (values) {
  var _list = isArray(values) ? values : [];
  var _named = isObject(values) ? values : {};
  var list = function (index) { return _list[index]; };
  var named = function (key) { return _named[key]; };
  return {
    list: list,
    named: named
  }
};

VueI18n.prototype._render = function _render (message, interpolateMode, values, path) {
  if (isFunction(message)) {
    return message(this._createMessageContext(values))
  }

  var ret = this._formatter.interpolate(message, values, path);

  // If the custom formatter refuses to work - apply the default one
  if (!ret) {
    ret = defaultFormatter.interpolate(message, values, path);
  }

  // if interpolateMode is **not** 'string' ('row'),
  // return the compiled data (e.g. ['foo', VNode, 'bar']) with formatter
  return interpolateMode === 'string' && !isString(ret) ? ret.join('') : ret
};

VueI18n.prototype._appendItemToChain = function _appendItemToChain (chain, item, blocks) {
  var follow = false;
  if (!includes(chain, item)) {
    follow = true;
    if (item) {
      follow = item[item.length - 1] !== '!';
      item = item.replace(/!/g, '');
      chain.push(item);
      if (blocks && blocks[item]) {
        follow = blocks[item];
      }
    }
  }
  return follow
};

VueI18n.prototype._appendLocaleToChain = function _appendLocaleToChain (chain, locale, blocks) {
  var follow;
  var tokens = locale.split('-');
  do {
    var item = tokens.join('-');
    follow = this._appendItemToChain(chain, item, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && (follow === true))
  return follow
};

VueI18n.prototype._appendBlockToChain = function _appendBlockToChain (chain, block, blocks) {
  var follow = true;
  for (var i = 0; (i < block.length) && (isBoolean(follow)); i++) {
    var locale = block[i];
    if (isString(locale)) {
      follow = this._appendLocaleToChain(chain, locale, blocks);
    }
  }
  return follow
};

VueI18n.prototype._getLocaleChain = function _getLocaleChain (start, fallbackLocale) {
  if (start === '') { return [] }

  if (!this._localeChainCache) {
    this._localeChainCache = {};
  }

  var chain = this._localeChainCache[start];
  if (!chain) {
    if (!fallbackLocale) {
      fallbackLocale = this.fallbackLocale;
    }
    chain = [];

    // first block defined by start
    var block = [start];

    // while any intervening block found
    while (isArray(block)) {
      block = this._appendBlockToChain(
        chain,
        block,
        fallbackLocale
      );
    }

    // last block defined by default
    var defaults;
    if (isArray(fallbackLocale)) {
      defaults = fallbackLocale;
    } else if (isObject(fallbackLocale)) {
      /* $FlowFixMe */
      if (fallbackLocale['default']) {
        defaults = fallbackLocale['default'];
      } else {
        defaults = null;
      }
    } else {
      defaults = fallbackLocale;
    }

    // convert defaults to array
    if (isString(defaults)) {
      block = [defaults];
    } else {
      block = defaults;
    }
    if (block) {
      this._appendBlockToChain(
        chain,
        block,
        null
      );
    }
    this._localeChainCache[start] = chain;
  }
  return chain
};

VueI18n.prototype._translate = function _translate (
  messages,
  locale,
  fallback,
  key,
  host,
  interpolateMode,
  args
) {
  var chain = this._getLocaleChain(locale, fallback);
  var res;
  for (var i = 0; i < chain.length; i++) {
    var step = chain[i];
    res =
      this._interpolate(step, messages[step], key, host, interpolateMode, args, [key]);
    if (!isNull(res)) {
      if (step !== locale && "development" !== 'production' && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {
        warn(("Fall back to translate the keypath '" + key + "' with '" + step + "' locale."));
      }
      return res
    }
  }
  return null
};

VueI18n.prototype._t = function _t (key, _locale, messages, host) {
    var ref;

    var values = [], len = arguments.length - 4;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 4 ];
  if (!key) { return '' }

  var parsedArgs = parseArgs.apply(void 0, values);
  if(this._escapeParameterHtml) {
    parsedArgs.params = escapeParams(parsedArgs.params);
  }

  var locale = parsedArgs.locale || _locale;

  var ret = this._translate(
    messages, locale, this.fallbackLocale, key,
    host, 'string', parsedArgs.params
  );
  if (this._isFallbackRoot(ret)) {
    if ( true && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {
      warn(("Fall back to translate the keypath '" + key + "' with root locale."));
    }
    /* istanbul ignore if */
    if (!this._root) { throw Error('unexpected error') }
    return (ref = this._root).$t.apply(ref, [ key ].concat( values ))
  } else {
    ret = this._warnDefault(locale, key, ret, host, values, 'string');
    if (this._postTranslation && ret !== null && ret !== undefined) {
      ret = this._postTranslation(ret, key);
    }
    return ret
  }
};

VueI18n.prototype.t = function t (key) {
    var ref;

    var values = [], len = arguments.length - 1;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];
  return (ref = this)._t.apply(ref, [ key, this.locale, this._getMessages(), null ].concat( values ))
};

VueI18n.prototype._i = function _i (key, locale, messages, host, values) {
  var ret =
    this._translate(messages, locale, this.fallbackLocale, key, host, 'raw', values);
  if (this._isFallbackRoot(ret)) {
    if ( true && !this._isSilentTranslationWarn(key)) {
      warn(("Fall back to interpolate the keypath '" + key + "' with root locale."));
    }
    if (!this._root) { throw Error('unexpected error') }
    return this._root.$i18n.i(key, locale, values)
  } else {
    return this._warnDefault(locale, key, ret, host, [values], 'raw')
  }
};

VueI18n.prototype.i = function i (key, locale, values) {
  /* istanbul ignore if */
  if (!key) { return '' }

  if (!isString(locale)) {
    locale = this.locale;
  }

  return this._i(key, locale, this._getMessages(), null, values)
};

VueI18n.prototype._tc = function _tc (
  key,
  _locale,
  messages,
  host,
  choice
) {
    var ref;

    var values = [], len = arguments.length - 5;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 5 ];
  if (!key) { return '' }
  if (choice === undefined) {
    choice = 1;
  }

  var predefined = { 'count': choice, 'n': choice };
  var parsedArgs = parseArgs.apply(void 0, values);
  parsedArgs.params = Object.assign(predefined, parsedArgs.params);
  values = parsedArgs.locale === null ? [parsedArgs.params] : [parsedArgs.locale, parsedArgs.params];
  return this.fetchChoice((ref = this)._t.apply(ref, [ key, _locale, messages, host ].concat( values )), choice)
};

VueI18n.prototype.fetchChoice = function fetchChoice (message, choice) {
  /* istanbul ignore if */
  if (!message || !isString(message)) { return null }
  var choices = message.split('|');

  choice = this.getChoiceIndex(choice, choices.length);
  if (!choices[choice]) { return message }
  return choices[choice].trim()
};

VueI18n.prototype.tc = function tc (key, choice) {
    var ref;

    var values = [], len = arguments.length - 2;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];
  return (ref = this)._tc.apply(ref, [ key, this.locale, this._getMessages(), null, choice ].concat( values ))
};

VueI18n.prototype._te = function _te (key, locale, messages) {
    var args = [], len = arguments.length - 3;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 3 ];

  var _locale = parseArgs.apply(void 0, args).locale || locale;
  return this._exist(messages[_locale], key)
};

VueI18n.prototype.te = function te (key, locale) {
  return this._te(key, this.locale, this._getMessages(), locale)
};

VueI18n.prototype.getLocaleMessage = function getLocaleMessage (locale) {
  return looseClone(this._vm.messages[locale] || {})
};

VueI18n.prototype.setLocaleMessage = function setLocaleMessage (locale, message) {
  if (this._warnHtmlInMessage === 'warn' || this._warnHtmlInMessage === 'error') {
    this._checkLocaleMessage(locale, this._warnHtmlInMessage, message);
  }
  this._vm.$set(this._vm.messages, locale, message);
};

VueI18n.prototype.mergeLocaleMessage = function mergeLocaleMessage (locale, message) {
  if (this._warnHtmlInMessage === 'warn' || this._warnHtmlInMessage === 'error') {
    this._checkLocaleMessage(locale, this._warnHtmlInMessage, message);
  }
  this._vm.$set(this._vm.messages, locale, merge(
    typeof this._vm.messages[locale] !== 'undefined' && Object.keys(this._vm.messages[locale]).length
      ? this._vm.messages[locale]
      : {},
    message
  ));
};

VueI18n.prototype.getDateTimeFormat = function getDateTimeFormat (locale) {
  return looseClone(this._vm.dateTimeFormats[locale] || {})
};

VueI18n.prototype.setDateTimeFormat = function setDateTimeFormat (locale, format) {
  this._vm.$set(this._vm.dateTimeFormats, locale, format);
  this._clearDateTimeFormat(locale, format);
};

VueI18n.prototype.mergeDateTimeFormat = function mergeDateTimeFormat (locale, format) {
  this._vm.$set(this._vm.dateTimeFormats, locale, merge(this._vm.dateTimeFormats[locale] || {}, format));
  this._clearDateTimeFormat(locale, format);
};

VueI18n.prototype._clearDateTimeFormat = function _clearDateTimeFormat (locale, format) {
  for (var key in format) {
    var id = locale + "__" + key;

    if (!this._dateTimeFormatters.hasOwnProperty(id)) {
      continue
    }

    delete this._dateTimeFormatters[id];
  }
};

VueI18n.prototype._localizeDateTime = function _localizeDateTime (
  value,
  locale,
  fallback,
  dateTimeFormats,
  key
) {
  var _locale = locale;
  var formats = dateTimeFormats[_locale];

  var chain = this._getLocaleChain(locale, fallback);
  for (var i = 0; i < chain.length; i++) {
    var current = _locale;
    var step = chain[i];
    formats = dateTimeFormats[step];
    _locale = step;
    // fallback locale
    if (isNull(formats) || isNull(formats[key])) {
      if (step !== locale && "development" !== 'production' && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {
        warn(("Fall back to '" + step + "' datetime formats from '" + current + "' datetime formats."));
      }
    } else {
      break
    }
  }

  if (isNull(formats) || isNull(formats[key])) {
    return null
  } else {
    var format = formats[key];
    var id = _locale + "__" + key;
    var formatter = this._dateTimeFormatters[id];
    if (!formatter) {
      formatter = this._dateTimeFormatters[id] = new Intl.DateTimeFormat(_locale, format);
    }
    return formatter.format(value)
  }
};

VueI18n.prototype._d = function _d (value, locale, key) {
  /* istanbul ignore if */
  if ( true && !VueI18n.availabilities.dateTimeFormat) {
    warn('Cannot format a Date value due to not supported Intl.DateTimeFormat.');
    return ''
  }

  if (!key) {
    return new Intl.DateTimeFormat(locale).format(value)
  }

  var ret =
    this._localizeDateTime(value, locale, this.fallbackLocale, this._getDateTimeFormats(), key);
  if (this._isFallbackRoot(ret)) {
    if ( true && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {
      warn(("Fall back to datetime localization of root: key '" + key + "'."));
    }
    /* istanbul ignore if */
    if (!this._root) { throw Error('unexpected error') }
    return this._root.$i18n.d(value, key, locale)
  } else {
    return ret || ''
  }
};

VueI18n.prototype.d = function d (value) {
    var args = [], len = arguments.length - 1;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

  var locale = this.locale;
  var key = null;

  if (args.length === 1) {
    if (isString(args[0])) {
      key = args[0];
    } else if (isObject(args[0])) {
      if (args[0].locale) {
        locale = args[0].locale;
      }
      if (args[0].key) {
        key = args[0].key;
      }
    }
  } else if (args.length === 2) {
    if (isString(args[0])) {
      key = args[0];
    }
    if (isString(args[1])) {
      locale = args[1];
    }
  }

  return this._d(value, locale, key)
};

VueI18n.prototype.getNumberFormat = function getNumberFormat (locale) {
  return looseClone(this._vm.numberFormats[locale] || {})
};

VueI18n.prototype.setNumberFormat = function setNumberFormat (locale, format) {
  this._vm.$set(this._vm.numberFormats, locale, format);
  this._clearNumberFormat(locale, format);
};

VueI18n.prototype.mergeNumberFormat = function mergeNumberFormat (locale, format) {
  this._vm.$set(this._vm.numberFormats, locale, merge(this._vm.numberFormats[locale] || {}, format));
  this._clearNumberFormat(locale, format);
};

VueI18n.prototype._clearNumberFormat = function _clearNumberFormat (locale, format) {
  for (var key in format) {
    var id = locale + "__" + key;

    if (!this._numberFormatters.hasOwnProperty(id)) {
      continue
    }

    delete this._numberFormatters[id];
  }
};

VueI18n.prototype._getNumberFormatter = function _getNumberFormatter (
  value,
  locale,
  fallback,
  numberFormats,
  key,
  options
) {
  var _locale = locale;
  var formats = numberFormats[_locale];

  var chain = this._getLocaleChain(locale, fallback);
  for (var i = 0; i < chain.length; i++) {
    var current = _locale;
    var step = chain[i];
    formats = numberFormats[step];
    _locale = step;
    // fallback locale
    if (isNull(formats) || isNull(formats[key])) {
      if (step !== locale && "development" !== 'production' && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {
        warn(("Fall back to '" + step + "' number formats from '" + current + "' number formats."));
      }
    } else {
      break
    }
  }

  if (isNull(formats) || isNull(formats[key])) {
    return null
  } else {
    var format = formats[key];

    var formatter;
    if (options) {
      // If options specified - create one time number formatter
      formatter = new Intl.NumberFormat(_locale, Object.assign({}, format, options));
    } else {
      var id = _locale + "__" + key;
      formatter = this._numberFormatters[id];
      if (!formatter) {
        formatter = this._numberFormatters[id] = new Intl.NumberFormat(_locale, format);
      }
    }
    return formatter
  }
};

VueI18n.prototype._n = function _n (value, locale, key, options) {
  /* istanbul ignore if */
  if (!VueI18n.availabilities.numberFormat) {
    if (true) {
      warn('Cannot format a Number value due to not supported Intl.NumberFormat.');
    }
    return ''
  }

  if (!key) {
    var nf = !options ? new Intl.NumberFormat(locale) : new Intl.NumberFormat(locale, options);
    return nf.format(value)
  }

  var formatter = this._getNumberFormatter(value, locale, this.fallbackLocale, this._getNumberFormats(), key, options);
  var ret = formatter && formatter.format(value);
  if (this._isFallbackRoot(ret)) {
    if ( true && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {
      warn(("Fall back to number localization of root: key '" + key + "'."));
    }
    /* istanbul ignore if */
    if (!this._root) { throw Error('unexpected error') }
    return this._root.$i18n.n(value, Object.assign({}, { key: key, locale: locale }, options))
  } else {
    return ret || ''
  }
};

VueI18n.prototype.n = function n (value) {
    var args = [], len = arguments.length - 1;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

  var locale = this.locale;
  var key = null;
  var options = null;

  if (args.length === 1) {
    if (isString(args[0])) {
      key = args[0];
    } else if (isObject(args[0])) {
      if (args[0].locale) {
        locale = args[0].locale;
      }
      if (args[0].key) {
        key = args[0].key;
      }

      // Filter out number format options only
      options = Object.keys(args[0]).reduce(function (acc, key) {
          var obj;

        if (includes(numberFormatKeys, key)) {
          return Object.assign({}, acc, ( obj = {}, obj[key] = args[0][key], obj ))
        }
        return acc
      }, null);
    }
  } else if (args.length === 2) {
    if (isString(args[0])) {
      key = args[0];
    }
    if (isString(args[1])) {
      locale = args[1];
    }
  }

  return this._n(value, locale, key, options)
};

VueI18n.prototype._ntp = function _ntp (value, locale, key, options) {
  /* istanbul ignore if */
  if (!VueI18n.availabilities.numberFormat) {
    if (true) {
      warn('Cannot format to parts a Number value due to not supported Intl.NumberFormat.');
    }
    return []
  }

  if (!key) {
    var nf = !options ? new Intl.NumberFormat(locale) : new Intl.NumberFormat(locale, options);
    return nf.formatToParts(value)
  }

  var formatter = this._getNumberFormatter(value, locale, this.fallbackLocale, this._getNumberFormats(), key, options);
  var ret = formatter && formatter.formatToParts(value);
  if (this._isFallbackRoot(ret)) {
    if ( true && !this._isSilentTranslationWarn(key)) {
      warn(("Fall back to format number to parts of root: key '" + key + "' ."));
    }
    /* istanbul ignore if */
    if (!this._root) { throw Error('unexpected error') }
    return this._root.$i18n._ntp(value, locale, key, options)
  } else {
    return ret || []
  }
};

Object.defineProperties( VueI18n.prototype, prototypeAccessors );

var availabilities;
// $FlowFixMe
Object.defineProperty(VueI18n, 'availabilities', {
  get: function get () {
    if (!availabilities) {
      var intlDefined = typeof Intl !== 'undefined';
      availabilities = {
        dateTimeFormat: intlDefined && typeof Intl.DateTimeFormat !== 'undefined',
        numberFormat: intlDefined && typeof Intl.NumberFormat !== 'undefined'
      };
    }

    return availabilities
  }
});

VueI18n.install = install;
VueI18n.version = '8.24.1';

/* harmony default export */ __webpack_exports__["default"] = (VueI18n);


/***/ }),
/* 78 */
/*!*************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/vue-moment/dist/vue-moment.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {
   true ? factory(exports) :
  undefined;
})(this, function (exports) {'use strict';

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function commonjsRequire() {
    throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
  }



  function createCommonjsModule(fn, module) {
    return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var moment = createCommonjsModule(function (module, exports) {
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {return typeof obj;} : function (obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};

    //! moment.js

    (function (global, factory) {
      _typeof(exports) === 'object' && 'object' !== 'undefined' ? module.exports = factory() :  false ? undefined : global.moment = factory();
    })(commonjsGlobal, function () {
      var hookCallback;

      function hooks() {
        return hookCallback.apply(null, arguments);
      }

      // This is done to register the method called with moment()
      // without creating circular dependencies.
      function setHookCallback(callback) {
        hookCallback = callback;
      }

      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
      }

      function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
      }

      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (obj.hasOwnProperty(k)) {
              return false;
            }
          }
          return true;
        }
      }

      function isUndefined(input) {
        return input === void 0;
      }

      function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
      }

      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
      }

      function map(arr, fn) {
        var res = [],
        i;
        for (i = 0; i < arr.length; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }

      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }

      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }

        if (hasOwnProp(b, 'toString')) {
          a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
          a.valueOf = b.valueOf;
        }

        return a;
      }

      function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
      }

      function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false };

      }

      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }

      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function some(fun) {
          var t = Object(this);
          var len = t.length >>> 0;

          for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }

          return false;
        };
      }

      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m);
          var parsedParts = some.call(flags.parsedDateParts, function (i) {
            return i != null;
          });
          var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
          }

          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }

      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }

        return m;
      }

      // Plugins that add properties should also add the key here (null value),
      // so we can properly clone ourselves.
      var momentProperties = hooks.momentProperties = [];

      function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
          to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
          to._i = from._i;
        }
        if (!isUndefined(from._f)) {
          to._f = from._f;
        }
        if (!isUndefined(from._l)) {
          to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
          to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
          to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
          to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
          to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
          to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
          to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
          for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
              to[prop] = val;
            }
          }
        }

        return to;
      }

      var updateInProgress = false;

      // Moment prototype object
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }

      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }

      function absFloor(number) {
        if (number < 0) {
          // -0 -> 0
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }

      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
        value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }

        return value;
      }

      // compare two arrays, return the number of differences
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }

      function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
          console.warn('Deprecation warning: ' + msg);
        }
      }

      function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
              arg = '';
              if (_typeof(arguments[i]) === 'object') {
                arg += '\n[' + i + '] ';
                for (var key in arguments[0]) {
                  arg += key + ': ' + arguments[0][key] + ', ';
                }
                arg = arg.slice(0, -2); // Remove trailing comma and space
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }

      var deprecations = {};

      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }

      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;

      function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
      }

      function set(config) {
        var prop, i;
        for (i in config) {
          prop = config[i];
          if (isFunction(prop)) {
            this[i] = prop;
          } else {
            this['_' + i] = prop;
          }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
      }

      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig),
        prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }

      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }

      var keys;

      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function keys(obj) {
          var i,
          res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }

      var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L' };


      function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
      }

      var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A' };


      function longDateFormat(key) {
        var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
          return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
          return val.slice(1);
        });

        return this._longDateFormat[key];
      }

      var defaultInvalidDate = 'Invalid date';

      function invalidDate() {
        return this._invalidDate;
      }

      var defaultOrdinal = '%d';
      var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

      function ordinal(number) {
        return this._ordinal.replace('%d', number);
      }

      var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        ss: '%d seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years' };


      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }

      function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
      }

      var aliases = {};

      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
      }

      function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
      }

      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
        normalizedProp,
        prop;

        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }

        return normalizedInput;
      }

      var priorities = {};

      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }

      function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
          units.push({ unit: u, priority: priorities[u] });
        }
        units.sort(function (a, b) {
          return a.priority - b.priority;
        });
        return units;
      }

      function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
        return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }

      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

      var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

      var formatFunctions = {};

      var formatTokenFunctions = {};

      // token:    'M'
      // padded:   ['MM', 2]
      // ordinal:  'Mo'
      // callback: function () { this.month() + 1 }
      function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
          func = function func() {
            return this[callback]();
          };
        }
        if (token) {
          formatTokenFunctions[token] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal) {
          formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
          };
        }
      }

      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
      }

      function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
        i,
        length;

        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }

        return function (mom) {
          var output = '',
          i;
          for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
          }
          return output;
        };
      }

      // format date using native date object
      function formatMoment(m, format) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
      }

      function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
          return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
          format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }

        return format;
      }

      var match1 = /\d/; //       0 - 9
      var match2 = /\d\d/; //      00 - 99
      var match3 = /\d{3}/; //     000 - 999
      var match4 = /\d{4}/; //    0000 - 9999
      var match6 = /[+-]?\d{6}/; // -999999 - 999999
      var match1to2 = /\d\d?/; //       0 - 99
      var match3to4 = /\d\d\d\d?/; //     999 - 9999
      var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999
      var match1to3 = /\d{1,3}/; //       0 - 999
      var match1to4 = /\d{1,4}/; //       0 - 9999
      var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

      var matchUnsigned = /\d+/; //       0 - inf
      var matchSigned = /[+-]?\d+/; //    -inf - inf

      var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
      var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

      var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

      // any word (or two) characters or numbers including two/three word month in arabic.
      // includes scottish gaelic two word and hyphenated months
      var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

      var regexes = {};

      function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }

      function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
          return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
      }

      // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
      function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
          return p1 || p2 || p3 || p4;
        }));
      }

      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
      }

      var tokens = {};

      function addParseToken(token, callback) {
        var i,
        func = callback;
        if (typeof token === 'string') {
          token = [token];
        }
        if (isNumber(callback)) {
          func = function func(input, array) {
            array[callback] = toInt(input);
          };
        }
        for (i = 0; i < token.length; i++) {
          tokens[token[i]] = func;
        }
      }

      function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token) {
          config._w = config._w || {};
          callback(input, config._w, config, token);
        });
      }

      function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
          tokens[token](input, config._a, config, token);
        }
      }

      var YEAR = 0;
      var MONTH = 1;
      var DATE = 2;
      var HOUR = 3;
      var MINUTE = 4;
      var SECOND = 5;
      var MILLISECOND = 6;
      var WEEK = 7;
      var WEEKDAY = 8;

      // FORMATTING

      addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
      });

      addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
      });

      addFormatToken(0, ['YYYY', 4], 0, 'year');
      addFormatToken(0, ['YYYYY', 5], 0, 'year');
      addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

      // ALIASES

      addUnitAlias('year', 'y');

      // PRIORITIES

      addUnitPriority('year', 1);

      // PARSING

      addRegexToken('Y', matchSigned);
      addRegexToken('YY', match1to2, match2);
      addRegexToken('YYYY', match1to4, match4);
      addRegexToken('YYYYY', match1to6, match6);
      addRegexToken('YYYYYY', match1to6, match6);

      addParseToken(['YYYYY', 'YYYYYY'], YEAR);
      addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
      });

      // HELPERS

      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }

      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }

      // HOOKS

      hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
      };

      // MOMENTS

      var getSetYear = makeGetSet('FullYear', true);

      function getIsLeapYear() {
        return isLeapYear(this.year());
      }

      function makeGetSet(unit, keepTime) {
        return function (value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }

      function get(mom, unit) {
        return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
      }

      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
          } else {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
          }
        }
      }

      // MOMENTS

      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }

      function stringSet(units, value) {
        if ((typeof units === 'undefined' ? 'undefined' : _typeof(units)) === 'object') {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units);
          for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }

      function mod(n, x) {
        return (n % x + x) % x;
      }

      var indexOf;

      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function indexOf(o) {
          // I know
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }

      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }

      // FORMATTING

      addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
      });

      addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
      });

      addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
      });

      // ALIASES

      addUnitAlias('month', 'M');

      // PRIORITY

      addUnitPriority('month', 8);

      // PARSING

      addRegexToken('M', match1to2);
      addRegexToken('MM', match1to2, match2);
      addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
      });
      addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
      });

      addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
      });

      addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });

      // LOCALES

      var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
      var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
      function localeMonths(m, format) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
      }

      var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
      function localeMonthsShort(m, format) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
      }

      function handleStrictParse(monthName, format, strict) {
        var i,
        ii,
        mom,
        llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          // this is not used
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
          }
        }

        if (strict) {
          if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }

      function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
          // make the regex if we don't have it already
          mom = createUTC([2000, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
          }
          if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
          }
          // test the regex
          if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }

      // MOMENTS

      function setMonth(mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
          // No op
          return mom;
        }

        if (typeof value === 'string') {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
              return mom;
            }
          }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
      }

      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, 'Month');
        }
      }

      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }

      var defaultMonthsShortRegex = matchWord;
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }

      var defaultMonthsRegex = matchWord;
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }

      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }

        var shortPieces = [],
        longPieces = [],
        mixedPieces = [],
        i,
        mom;
        for (i = 0; i < 12; i++) {
          // make the regex if we don't have it already
          mom = createUTC([2000, i]);
          shortPieces.push(this.monthsShort(mom, ''));
          longPieces.push(this.months(mom, ''));
          mixedPieces.push(this.months(mom, ''));
          mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
      }

      function createDate(y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
          // preserve leap years using a full 400 year cycle, then reset
          date = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
      }

      function createUTCDate(y) {
        var date;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
          var args = Array.prototype.slice.call(arguments);
          // preserve leap years using a full 400 year cycle, then reset
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
      }

      // start-of-first-week - start-of-year
      function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,

        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
      }

      // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear,
        resDayOfYear;

        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }

        return {
          year: resYear,
          dayOfYear: resDayOfYear };

      }

      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek,
        resYear;

        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }

        return {
          week: resWeek,
          year: resYear };

      }

      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }

      // FORMATTING

      addFormatToken('w', ['ww', 2], 'wo', 'week');
      addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

      // ALIASES

      addUnitAlias('week', 'w');
      addUnitAlias('isoWeek', 'W');

      // PRIORITIES

      addUnitPriority('week', 5);
      addUnitPriority('isoWeek', 5);

      // PARSING

      addRegexToken('w', match1to2);
      addRegexToken('ww', match1to2, match2);
      addRegexToken('W', match1to2);
      addRegexToken('WW', match1to2, match2);

      addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
      });

      // HELPERS

      // LOCALES

      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }

      var defaultLocaleWeek = {
        dow: 0, // Sunday is the first day of the week.
        doy: 6 // The week that contains Jan 6th is the first week of the year.
      };

      function localeFirstDayOfWeek() {
        return this._week.dow;
      }

      function localeFirstDayOfYear() {
        return this._week.doy;
      }

      // MOMENTS

      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
      }

      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
      }

      // FORMATTING

      addFormatToken('d', 0, 'do', 'day');

      addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
      });

      addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
      });

      addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
      });

      addFormatToken('e', 0, 0, 'weekday');
      addFormatToken('E', 0, 0, 'isoWeekday');

      // ALIASES

      addUnitAlias('day', 'd');
      addUnitAlias('weekday', 'e');
      addUnitAlias('isoWeekday', 'E');

      // PRIORITY
      addUnitPriority('day', 11);
      addUnitPriority('weekday', 11);
      addUnitPriority('isoWeekday', 11);

      // PARSING

      addRegexToken('d', match1to2);
      addRegexToken('e', match1to2);
      addRegexToken('E', match1to2);
      addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
      });
      addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
      });
      addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
      });

      addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });

      addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
      });

      // HELPERS

      function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
          return input;
        }

        if (!isNaN(input)) {
          return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
          return input;
        }

        return null;
      }

      function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
          return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }

      // LOCALES
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }

      var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
      function localeWeekdays(m, format) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }

      var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }

      var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }

      function handleStrictParse$1(weekdayName, format, strict) {
        var i,
        ii,
        mom,
        llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];

          for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
          }
        }

        if (strict) {
          if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }

      function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
          // make the regex if we don't have it already

          mom = createUTC([2000, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
          }
          if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
          }
          // test the regex
          if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }

      // MOMENTS

      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, 'd');
        } else {
          return day;
        }
      }

      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
      }

      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }

      var defaultWeekdaysRegex = matchWord;
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }

      var defaultWeekdaysShortRegex = matchWord;
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }

      var defaultWeekdaysMinRegex = matchWord;
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }

      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }

        var minPieces = [],
        shortPieces = [],
        longPieces = [],
        mixedPieces = [],
        i,
        mom,
        minp,
        shortp,
        longp;
        for (i = 0; i < 7; i++) {
          // make the regex if we don't have it already
          mom = createUTC([2000, 1]).day(i);
          minp = this.weekdaysMin(mom, '');
          shortp = this.weekdaysShort(mom, '');
          longp = this.weekdays(mom, '');
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
      }

      // FORMATTING

      function hFormat() {
        return this.hours() % 12 || 12;
      }

      function kFormat() {
        return this.hours() || 24;
      }

      addFormatToken('H', ['HH', 2], 0, 'hour');
      addFormatToken('h', ['hh', 2], 0, hFormat);
      addFormatToken('k', ['kk', 2], 0, kFormat);

      addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });

      addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });

      addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
      });

      addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });

      function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
          return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
      }

      meridiem('a', true);
      meridiem('A', false);

      // ALIASES

      addUnitAlias('hour', 'h');

      // PRIORITY
      addUnitPriority('hour', 13);

      // PARSING

      function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
      }

      addRegexToken('a', matchMeridiem);
      addRegexToken('A', matchMeridiem);
      addRegexToken('H', match1to2);
      addRegexToken('h', match1to2);
      addRegexToken('k', match1to2);
      addRegexToken('HH', match1to2, match2);
      addRegexToken('hh', match1to2, match2);
      addRegexToken('kk', match1to2, match2);

      addRegexToken('hmm', match3to4);
      addRegexToken('hmmss', match5to6);
      addRegexToken('Hmm', match3to4);
      addRegexToken('Hmmss', match5to6);

      addParseToken(['H', 'HH'], HOUR);
      addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });

      // LOCALES

      function localeIsPM(input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return (input + '').toLowerCase().charAt(0) === 'p';
      }

      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
      function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
          return isLower ? 'pm' : 'PM';
        } else {
          return isLower ? 'am' : 'AM';
        }
      }

      // MOMENTS

      // Setting the hour should keep the time, because the user explicitly
      // specified which hour they want. So trying to maintain the same hour (in
      // a new timezone) makes sense. Adding/subtracting hours does not follow
      // this rule.
      var getSetHour = makeGetSet('Hours', true);

      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse };


      // internal storage for locale config files
      var locales = {};
      var localeFamilies = {};
      var globalLocale;

      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
      }

      // pick the locale from the array
      // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
      // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
      function chooseLocale(names) {
        var i = 0,
        j,
        next,
        locale,
        split;

        while (i < names.length) {
          split = normalizeLocale(names[i]).split('-');
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split('-') : null;
          while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
              return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
              //the next array item is better than a shallower substring of this one
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }

      function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && 'object' !== 'undefined' && module && module.exports) {
          try {
            oldLocale = globalLocale._abbr;
            var aliasedRequire = commonjsRequire;
            aliasedRequire('./locale/' + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {}
        }
        return locales[name];
      }

      // This function will load locale and then set the global locale.  If
      // no arguments are passed in, it will simply return the current global
      // locale key.
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }

          if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
          } else {
            if (typeof console !== 'undefined' && console.warn) {
              //warn user if arguments are passed but the locale could not be set
              console.warn('Locale ' + key + ' not found. Did you forget to load it?');
            }
          }
        }

        return globalLocale._abbr;
      }

      function defineLocale(name, config) {
        if (config !== null) {
          var locale,
          parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale = loadLocale(config.parentLocale);
              if (locale != null) {
                parentConfig = locale._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name: name,
                  config: config });

                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));

          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
              defineLocale(x.name, x.config);
            });
          }

          // backwards compat for now: also set the locale
          // make sure we set the locale AFTER all child locales have been
          // created, so we won't end up with the child locale set.
          getSetGlobalLocale(name);

          return locales[name];
        } else {
          // useful for testing
          delete locales[name];
          return null;
        }
      }

      function updateLocale(name, config) {
        if (config != null) {
          var locale,
          tmpLocale,
          parentConfig = baseConfig;
          // MERGE
          tmpLocale = loadLocale(name);
          if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
          }
          config = mergeConfigs(parentConfig, config);
          locale = new Locale(config);
          locale.parentLocale = locales[name];
          locales[name] = locale;

          // backwards compat for now: also set the locale
          getSetGlobalLocale(name);
        } else {
          // pass null for config to unupdate, useful for tests
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }

      // returns locale data
      function getLocale(key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }

        if (!key) {
          return globalLocale;
        }

        if (!isArray(key)) {
          //short-circuit everything else
          locale = loadLocale(key);
          if (locale) {
            return locale;
          }
          key = [key];
        }

        return chooseLocale(key);
      }

      function listLocales() {
        return keys(locales);
      }

      function checkOverflow(m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }

          getParsingFlags(m).overflow = overflow;
        }

        return m;
      }

      // Pick the first defined of two or three arguments.
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }

      function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }

      // convert an array to a date.
      // the array should mirror the parameters below
      // note: all values past the year are optional and will default to the lowest possible value.
      // [year, month, day , hour, minute, second, millisecond]
      function configFromArray(config) {
        var i,
        date,
        input = [],
        currentDate,
        expectedWeekday,
        yearToUse;

        if (config._d) {
          return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }

          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
          config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }

      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;

          // TODO: We need to take the current isoWeekYear, but that depends on
          // how we interpret now (local, utc, fixed offset). So create
          // a now version of current config (take local/utc/offset flags, and
          // create now).
          weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;

          var curWeek = weekOfYear(createLocal(), dow, doy);

          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

          // Default to current week.
          week = defaults(w.w, curWeek.week);

          if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            // local weekday -- counting starts from beginning of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            // default to beginning of week
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }

      // iso 8601 regex
      // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
      var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

      var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

      var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/],
      // YYYYMM is NOT allowed by the standard
      ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]];

      // iso time formats and regexes
      var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];

      var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

      // date from iso format
      function configFromISO(config) {
        var i,
        l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime,
        dateFormat,
        timeFormat,
        tzFormat;

        if (match) {
          getParsingFlags(config).iso = true;

          for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                // match[2] should be 'T' or space
                timeFormat = (match[2] || ' ') + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = 'Z';
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }

      // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
      var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];

        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }

        return result;
      }

      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2000 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }

      function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
      }

      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
          weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }

      var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60 };


      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          // the only allowed military tz is Z
          return 0;
        } else {
          var hm = parseInt(numOffset, 10);
          var m = hm % 100,
          h = (hm - m) / 100;
          return h * 60 + m;
        }
      }

      // date and time from ref 2822 format
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
          var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }

          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);

          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }

      // date from iso format or fallback
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }

        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
      }

      hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
      });

      // constant that refers to the ISO standard
      hooks.ISO_8601 = function () {};

      // constant that refers to the RFC 2822 form
      hooks.RFC_2822 = function () {};

      // date from string and format string
      function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
        i,
        parsedInput,
        tokens,
        token,
        skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
          token = tokens[i];
          parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
          // console.log('token', token, 'parsedInput', parsedInput,
          //         'regex', getParseRegexForToken(token, config));
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
          }
          // don't parse if it's not a known token
          if (formatTokenFunctions[token]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
          }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
      }

      function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
          // nothing to do
          return hour;
        }
        if (locale.meridiemHour != null) {
          return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
          // Fallback
          isPm = locale.isPM(meridiem);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          // this is not supposed to happen
          return hour;
        }
      }

      // date from string and array of format strings
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;

        if (config._f.length === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }

        for (i = 0; i < config._f.length; i++) {
          currentScore = 0;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);

          if (!isValid(tempConfig)) {
            continue;
          }

          // if there is any input that was not parsed add a penalty for that format
          currentScore += getParsingFlags(tempConfig).charsLeftOver;

          //or tokens
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

          getParsingFlags(tempConfig).score = currentScore;

          if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
          }
        }

        extend(config, bestMoment || tempConfig);
      }

      function configFromObject(config) {
        if (config._d) {
          return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
          return obj && parseInt(obj, 10);
        });

        configFromArray(config);
      }

      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          // Adding is smart enough around DST
          res.add(1, 'd');
          res._nextDay = undefined;
        }

        return res;
      }

      function prepareConfig(config) {
        var input = config._i,
        format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || format === undefined && input === '') {
          return createInvalid({ nullInput: true });
        }

        if (typeof input === 'string') {
          config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray(format)) {
          configFromStringAndArray(config);
        } else if (format) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }

        if (!isValid(config)) {
          config._d = null;
        }

        return config;
      }

      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          // from milliseconds
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }

      function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
          strict = locale;
          locale = undefined;
        }

        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
      }

      function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
      }

      var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      });

      var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      });

      // Pick a moment m from moments so that m[fn](other) is true for all
      // other. This relies on the function fn to be transitive.
      //
      // moments should either be an array of moment objects or an array, whose
      // first element is an array of moment objects.
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }

      // TODO: Use [].sort instead?
      function min() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
      }

      function max() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
      }

      var now = function now() {
        return Date.now ? Date.now() : +new Date();
      };

      var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

      function isDurationValid(m) {
        for (var key in m) {
          if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }

        return true;
      }

      function isValid$1() {
        return this._isValid;
      }

      function createInvalid$1() {
        return createDuration(NaN);
      }

      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days + weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months + quarters * 3 + years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
      }

      function isDuration(obj) {
        return obj instanceof Duration;
      }

      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }

      // FORMATTING

      function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
          var offset = this.utcOffset();
          var sign = '+';
          if (offset < 0) {
            offset = -offset;
            sign = '-';
          }
          return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
        });
      }

      offset('Z', ':');
      offset('ZZ', '');

      // PARSING

      addRegexToken('Z', matchShortOffset);
      addRegexToken('ZZ', matchShortOffset);
      addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });

      // HELPERS

      // timezone chunker
      // '+10:00' > ['10',  '00']
      // '-1530'  > ['-15', '30']
      var chunkOffset = /([\+\-]|\d\d)/gi;

      function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
          return null;
        }

        var chunk = matches[matches.length - 1] || [];
        var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
      }

      // Return a moment from input, that is local/utc/zone equivalent to model.
      function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
          res = model.clone();
          diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          // Use low-level api, because this fn is low-level api.
          res._d.setTime(res._d.valueOf() + diff);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }

      function getDateOffset(m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
      }

      // HOOKS

      // This function will be called whenever a moment is mutated.
      // It is intended to keep the offset in sync with the timezone.
      hooks.updateOffset = function () {};

      // MOMENTS

      // keepLocalTime = true means only change the timezone, without
      // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
      // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
      // +0200, so we adjust the time as needed, to be valid.
      //
      // Keeping the time actually adds/subtracts (one hour)
      // from the actual represented time. That is why we call updateOffset
      // a second time. In case it wants us to change the offset again
      // _changeInProgress == true case, then we have to adjust, because
      // there is no such time in the given timezone.
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
        localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, 'm');
          }
          if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset : getDateOffset(this);
        }
      }

      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== 'string') {
            input = -input;
          }

          this.utcOffset(input, keepLocalTime);

          return this;
        } else {
          return -this.utcOffset();
        }
      }

      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }

      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;

          if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
          }
        }
        return this;
      }

      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }

      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
      }

      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }

      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
          var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }

        return this._isDSTShifted;
      }

      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }

      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }

      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }

      // ASP.NET json date format regex
      var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

      // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
      // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
      // and further modified to allow for strings containing both week and day
      var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

      function createDuration(input, key) {
        var duration = input,

        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months };

        } else if (isNumber(input)) {
          duration = {};
          if (key) {
            duration[key] = input;
          } else {
            duration.milliseconds = input;
          }
        } else if (!!(match = aspNetRegex.exec(input))) {
          sign = match[1] === '-' ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign,
            h: toInt(match[HOUR]) * sign,
            m: toInt(match[MINUTE]) * sign,
            s: toInt(match[SECOND]) * sign,
            ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
          };
        } else if (!!(match = isoRegex.exec(input))) {
          sign = match[1] === '-' ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign),
            M: parseIso(match[3], sign),
            w: parseIso(match[4], sign),
            d: parseIso(match[5], sign),
            h: parseIso(match[6], sign),
            m: parseIso(match[7], sign),
            s: parseIso(match[8], sign) };

        } else if (duration == null) {
          // checks for null or undefined
          duration = {};
        } else if ((typeof duration === 'undefined' ? 'undefined' : _typeof(duration)) === 'object' && ('from' in duration || 'to' in duration)) {
          diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
          ret._locale = input._locale;
        }

        return ret;
      }

      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;

      function parseIso(inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
      }

      function positiveMomentsDifference(base, other) {
        var res = {};

        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
          --res.months;
        }

        res.milliseconds = +other - +base.clone().add(res.months, 'M');

        return res;
      }

      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }

        return res;
      }

      // TODO: remove 'name' arg after deprecation is removed
      function createAdder(direction, name) {
        return function (val, period) {
          var dur, tmp;
          //invert the arguments, but complain about it
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val;val = period;period = tmp;
          }

          val = typeof val === 'string' ? +val : val;
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }

      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

        if (!mom.isValid()) {
          // No op
          return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
          setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
          set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
          mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days || months);
        }
      }

      var add = createAdder(1, 'add');
      var subtract = createAdder(-1, 'subtract');

      function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
      }

      function calendar$1(time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
      }

      function clone() {
        return new Moment(this);
      }

      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }

      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }

      function isBetween(from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
        localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }

      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }

      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }

      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }

      function diff(input, units, asFloat) {
        var that, zoneDelta, output;

        if (!this.isValid()) {
          return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
          return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
          case 'year':
            output = monthDiff(this, that) / 12;break;
          case 'month':
            output = monthDiff(this, that);break;
          case 'quarter':
            output = monthDiff(this, that) / 3;break;
          case 'second':
            output = (this - that) / 1e3;break; // 1000
          case 'minute':
            output = (this - that) / 6e4;break; // 1000 * 60
          case 'hour':
            output = (this - that) / 36e5;break; // 1000 * 60 * 60
          case 'day':
            output = (this - that - zoneDelta) / 864e5;break; // 1000 * 60 * 60 * 24, negate dst
          case 'week':
            output = (this - that - zoneDelta) / 6048e5;break; // 1000 * 60 * 60 * 24 * 7, negate dst
          default:
            output = this - that;}


        return asFloat ? output : absFloor(output);
      }

      function monthDiff(a, b) {
        // difference in months
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),

        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2,
        adjust;

        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
          // linear across the month
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
          // linear across the month
          adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
      }

      hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
      hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

      function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
      }

      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
          // native implementation is ~50x faster, use it when we can
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
          }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
      }

      /**
         * Return a human readable representation of a moment that can
         * also be evaluated to get a new moment which is the same
         *
         * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
         */
      function inspect() {
        if (!this.isValid()) {
          return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
          zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
      }

      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }

      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }

      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }

      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }

      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }

      // If passed a locale key, it will set the locale for this
      // instance.  Otherwise, it will return the locale configuration
      // variables for this instance.
      function locale(key) {
        var newLocaleData;

        if (key === undefined) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }

      var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
        if (key === undefined) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      });

      function localeData() {
        return this._locale;
      }

      var MS_PER_SECOND = 1000;
      var MS_PER_MINUTE = 60 * MS_PER_SECOND;
      var MS_PER_HOUR = 60 * MS_PER_MINUTE;
      var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

      // actual modulo - handles negative numbers (for dates before 1970):
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }

      function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
          // preserve leap years using a full 400 year cycle, then reset
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }

      function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
          // preserve leap years using a full 400 year cycle, then reset
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }

      function startOf(units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
          return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
          case 'year':
            time = startOfDate(this.year(), 0, 1);
            break;
          case 'quarter':
            time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
            break;
          case 'month':
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case 'week':
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
            break;
          case 'isoWeek':
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
            break;
          case 'day':
          case 'date':
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case 'hour':
            time = this._d.valueOf();
            time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
            break;
          case 'minute':
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case 'second':
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;}


        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }

      function endOf(units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
          return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
          case 'year':
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case 'quarter':
            time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
            break;
          case 'month':
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case 'week':
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
            break;
          case 'isoWeek':
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
            break;
          case 'day':
          case 'date':
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case 'hour':
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
            break;
          case 'minute':
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case 'second':
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;}


        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }

      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 60000;
      }

      function unix() {
        return Math.floor(this.valueOf() / 1000);
      }

      function toDate() {
        return new Date(this.valueOf());
      }

      function toArray() {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
      }

      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds() };

      }

      function toJSON() {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
      }

      function isValid$2() {
        return isValid(this);
      }

      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }

      function invalidAt() {
        return getParsingFlags(this).overflow;
      }

      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict };

      }

      // FORMATTING

      addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
      });

      addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
      });

      function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
      }

      addWeekYearFormatToken('gggg', 'weekYear');
      addWeekYearFormatToken('ggggg', 'weekYear');
      addWeekYearFormatToken('GGGG', 'isoWeekYear');
      addWeekYearFormatToken('GGGGG', 'isoWeekYear');

      // ALIASES

      addUnitAlias('weekYear', 'gg');
      addUnitAlias('isoWeekYear', 'GG');

      // PRIORITY

      addUnitPriority('weekYear', 1);
      addUnitPriority('isoWeekYear', 1);

      // PARSING

      addRegexToken('G', matchSigned);
      addRegexToken('g', matchSigned);
      addRegexToken('GG', match1to2, match2);
      addRegexToken('gg', match1to2, match2);
      addRegexToken('GGGG', match1to4, match4);
      addRegexToken('gggg', match1to4, match4);
      addRegexToken('GGGGG', match1to6, match6);
      addRegexToken('ggggg', match1to6, match6);

      addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
      });

      addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
      });

      // MOMENTS

      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
      }

      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
      }

      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }

      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }

      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }

      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }

      // FORMATTING

      addFormatToken('Q', 0, 'Qo', 'quarter');

      // ALIASES

      addUnitAlias('quarter', 'Q');

      // PRIORITY

      addUnitPriority('quarter', 7);

      // PARSING

      addRegexToken('Q', match1);
      addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });

      // MOMENTS

      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }

      // FORMATTING

      addFormatToken('D', ['DD', 2], 'Do', 'date');

      // ALIASES

      addUnitAlias('date', 'D');

      // PRIORITY
      addUnitPriority('date', 9);

      // PARSING

      addRegexToken('D', match1to2);
      addRegexToken('DD', match1to2, match2);
      addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
      });

      addParseToken(['D', 'DD'], DATE);
      addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });

      // MOMENTS

      var getSetDayOfMonth = makeGetSet('Date', true);

      // FORMATTING

      addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

      // ALIASES

      addUnitAlias('dayOfYear', 'DDD');

      // PRIORITY
      addUnitPriority('dayOfYear', 4);

      // PARSING

      addRegexToken('DDD', match1to3);
      addRegexToken('DDDD', match3);
      addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
      });

      // HELPERS

      // MOMENTS

      function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
      }

      // FORMATTING

      addFormatToken('m', ['mm', 2], 0, 'minute');

      // ALIASES

      addUnitAlias('minute', 'm');

      // PRIORITY

      addUnitPriority('minute', 14);

      // PARSING

      addRegexToken('m', match1to2);
      addRegexToken('mm', match1to2, match2);
      addParseToken(['m', 'mm'], MINUTE);

      // MOMENTS

      var getSetMinute = makeGetSet('Minutes', false);

      // FORMATTING

      addFormatToken('s', ['ss', 2], 0, 'second');

      // ALIASES

      addUnitAlias('second', 's');

      // PRIORITY

      addUnitPriority('second', 15);

      // PARSING

      addRegexToken('s', match1to2);
      addRegexToken('ss', match1to2, match2);
      addParseToken(['s', 'ss'], SECOND);

      // MOMENTS

      var getSetSecond = makeGetSet('Seconds', false);

      // FORMATTING

      addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
      });

      addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
      });

      addFormatToken(0, ['SSS', 3], 0, 'millisecond');
      addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
      });
      addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
      });
      addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
      });
      addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
      });

      // ALIASES

      addUnitAlias('millisecond', 'ms');

      // PRIORITY

      addUnitPriority('millisecond', 16);

      // PARSING

      addRegexToken('S', match1to3, match1);
      addRegexToken('SS', match1to3, match2);
      addRegexToken('SSS', match1to3, match3);

      var token;
      for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
      }

      function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
      }

      for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
      }
      // MOMENTS

      var getSetMillisecond = makeGetSet('Milliseconds', false);

      // FORMATTING

      addFormatToken('z', 0, 0, 'zoneAbbr');
      addFormatToken('zz', 0, 0, 'zoneName');

      // MOMENTS

      function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
      }

      function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
      }

      var proto = Moment.prototype;

      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
      proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
      proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
      proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
      proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

      function createUnix(input) {
        return createLocal(input * 1000);
      }

      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }

      function preParsePostFormat(string) {
        return string;
      }

      var proto$1 = Locale.prototype;

      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;

      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;

      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;

      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;

      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;

      function get$1(format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
      }

      function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
          index = format;
          format = undefined;
        }

        format = format || '';

        if (index != null) {
          return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format, i, field, 'month');
        }
        return out;
      }

      // ()
      // (5)
      // (fmt, 5)
      // (fmt)
      // (true)
      // (true, 5)
      // (true, fmt, 5)
      // (true, fmt)
      function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
          if (isNumber(format)) {
            index = format;
            format = undefined;
          }

          format = format || '';
        } else {
          format = localeSorted;
          index = format;
          localeSorted = false;

          if (isNumber(format)) {
            index = format;
            format = undefined;
          }

          format = format || '';
        }

        var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
          return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
      }

      function listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
      }

      function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
      }

      function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
      }

      function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
      }

      function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
      }

      getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function ordinal(number) {
          var b = number % 10,
          output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
          return number + output;
        } });


      // Side effect imports

      hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
      hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

      var mathAbs = Math.abs;

      function abs() {
        var data = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);

        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);

        return this;
      }

      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;

        return duration._bubble();
      }

      // supports only 2.0-style add(1, 's') or add(duration)
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }

      // supports only 2.0-style subtract(1, 's') or subtract(duration)
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }

      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }

      function bubble() {
        var milliseconds = this._milliseconds;
        var days = this._days;
        var months = this._months;
        var data = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
          milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
          days = 0;
          months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;

        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;

        hours = absFloor(minutes / 60);
        data.hours = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days = days;
        data.months = months;
        data.years = years;

        return this;
      }

      function daysToMonths(days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
      }

      function monthsToDays(months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
      }

      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
          days = this._days + milliseconds / 864e5;
          months = this._months + daysToMonths(days);
          switch (units) {
            case 'month':
              return months;
            case 'quarter':
              return months / 3;
            case 'year':
              return months / 12;}

        } else {
          // handle milliseconds separately because of floating point math errors (issue #1867)
          days = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case 'week':
              return days / 7 + milliseconds / 6048e5;
            case 'day':
              return days + milliseconds / 864e5;
            case 'hour':
              return days * 24 + milliseconds / 36e5;
            case 'minute':
              return days * 1440 + milliseconds / 6e4;
            case 'second':
              return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond':
              return Math.floor(days * 864e5) + milliseconds;
            default:
              throw new Error('Unknown unit ' + units);}

        }
      }

      // TODO: Use this.as('ms')?
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }

      function makeAs(alias) {
        return function () {
          return this.as(alias);
        };
      }

      var asMilliseconds = makeAs('ms');
      var asSeconds = makeAs('s');
      var asMinutes = makeAs('m');
      var asHours = makeAs('h');
      var asDays = makeAs('d');
      var asWeeks = makeAs('w');
      var asMonths = makeAs('M');
      var asQuarters = makeAs('Q');
      var asYears = makeAs('y');

      function clone$1() {
        return createDuration(this);
      }

      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
      }

      function makeGetter(name) {
        return function () {
          return this.isValid() ? this._data[name] : NaN;
        };
      }

      var milliseconds = makeGetter('milliseconds');
      var seconds = makeGetter('seconds');
      var minutes = makeGetter('minutes');
      var hours = makeGetter('hours');
      var days = makeGetter('days');
      var months = makeGetter('months');
      var years = makeGetter('years');

      function weeks() {
        return absFloor(this.days() / 7);
      }

      var round = Math.round;
      var thresholds = {
        ss: 44, // a few seconds to seconds
        s: 45, // seconds to minute
        m: 45, // minutes to hour
        h: 22, // hours to day
        d: 26, // days to month
        M: 11 // months to year
      };

      // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }

      function relativeTime$1(posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds = round(duration.as('s'));
        var minutes = round(duration.as('m'));
        var hours = round(duration.as('h'));
        var days = round(duration.as('d'));
        var months = round(duration.as('M'));
        var years = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
      }

      // This function allows you to set the rounding function for relative time strings
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
          return round;
        }
        if (typeof roundingFunction === 'function') {
          round = roundingFunction;
          return true;
        }
        return false;
      }

      // This function allows you to set a threshold for relative time strings
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
          return false;
        }
        if (limit === undefined) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
          thresholds.ss = limit - 1;
        }
        return true;
      }

      function humanize(withSuffix) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
          output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
      }

      var abs$1 = Math.abs;

      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }

      function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days = abs$1(this._days);
        var months = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
          // this is the same as C#'s (Noda) and python (isodate)...
          // but not other JS (goog.date)
          return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return totalSign + 'P' + (Y ? ymSign + Y + 'Y' : '') + (M ? ymSign + M + 'M' : '') + (D ? daysSign + D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? hmsSign + h + 'H' : '') + (m ? hmsSign + m + 'M' : '') + (s ? hmsSign + s + 'S' : '');
      }

      var proto$2 = Duration.prototype;

      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;

      proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
      proto$2.lang = lang;

      // Side effect imports

      // FORMATTING

      addFormatToken('X', 0, 0, 'unix');
      addFormatToken('x', 0, 0, 'valueOf');

      // PARSING

      addRegexToken('x', matchSigned);
      addRegexToken('X', matchTimestamp);
      addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
      });
      addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
      });

      // Side effect imports


      hooks.version = '2.24.0';

      setHookCallback(createLocal);

      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;

      // currently HTML5 input type only supports 24-hour formats
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD', // <input type="date" />
        TIME: 'HH:mm', // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW', // <input type="week" />
        MONTH: 'YYYY-MM' // <input type="month" />
      };

      return hooks;
    });
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }return arr2;
    } else {
      return Array.from(arr);
    }
  }

  var vueMoment = {
    install: function install(Vue, options) {
      var moment$$1 = options && options.moment ? options.moment : moment;

      Object.defineProperties(Vue.prototype, {
        $moment: {
          get: function get() {
            return moment$$1;
          } } });



      Vue.moment = moment$$1;

      Vue.filter('moment', function () {
        var arguments$1 = arguments;

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments$1[_key];
        }

        args = Array.prototype.slice.call(args);
        var input = args.shift();
        var date = void 0;

        if (Array.isArray(input) && typeof input[0] === 'string') {
          // If input is array, assume we're being passed a format pattern to parse against.
          // Format pattern will accept an array of potential formats to parse against.
          // Date string should be at [0], format pattern(s) should be at [1]
          date = moment$$1(input[0], input[1], true);
        } else if (typeof input === 'number') {
          if (input.toString().length < 12) {
            // If input is an integer with fewer than 12 digits, assume Unix seconds...
            date = moment$$1.unix(input);
          } else {
            // ..otherwise, assume milliseconds.
            date = moment$$1(input);
          }
        } else {
          // Otherwise, throw the input at moment and see what happens...
          date = moment$$1(input);
        }

        if (!input || !date.isValid()) {
          // Log a warning if moment couldn't reconcile the input. Better than throwing an error?
          console.warn('Could not build a valid `moment` object from input.');
          return input;
        }

        function parse() {
          var arguments$1 = arguments;

          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments$1[_key2];
          }

          args = Array.prototype.slice.call(args);
          var method = args.shift();

          switch (method) {
            case 'add':
              {
                /*
                * Mutates the original moment by adding time.
                * http://momentjs.com/docs/#/manipulating/add/
                */

                var addends = args.shift().split(',').map(Function.prototype.call, String.prototype.trim);
                var obj = {};

                for (var n = 0; n < addends.length; n++) {
                  var addend = addends[n].split(' ');
                  obj[addend[1]] = addend[0];
                }
                date.add(obj);
                break;
              }

            case 'subtract':
              {
                /*
                * Mutates the original moment by subtracting time.
                * http://momentjs.com/docs/#/manipulating/subtract/
                */

                var subtrahends = args.shift().split(',').map(Function.prototype.call, String.prototype.trim);
                var _obj = {};

                for (var _n = 0; _n < subtrahends.length; _n++) {
                  var subtrahend = subtrahends[_n].split(' ');
                  _obj[subtrahend[1]] = subtrahend[0];
                }
                date.subtract(_obj);
                break;
              }

            case 'from':
              {
                /*
                * Display a moment in relative time, either from now or from a specified date.
                * http://momentjs.com/docs/#/displaying/fromnow/
                */

                var from = 'now';
                var removeSuffix = false;

                if (args[0] === 'now') {args.shift();}
                // If valid, assume it is a date we want the output computed against.
                if (moment$$1(args[0]).isValid()) {from = moment$$1(args.shift());}

                if (args[0] === true) {
                  args.shift();
                  removeSuffix = true;
                }

                if (from !== 'now') {
                  date = date.from(from, removeSuffix);
                } else {
                  date = date.fromNow(removeSuffix);
                }
                break;
              }

            case 'diff':
              {
                /*
                * Mutates the original moment by doing a difference with another date.
                * http://momentjs.com/docs/#/displaying/difference/
                */

                var referenceTime = moment$$1();
                var units = '';
                var float = false;

                if (moment$$1(args[0]).isValid()) {
                  // If valid, assume it is a date we want the output computed against.
                  referenceTime = moment$$1(args.shift());
                } else if (args[0] === null || args[0] === 'now') {
                  // If null or 'now', remove argument and proceed with default referenceTime.
                  args.shift();
                }

                if (args[0]) {units = args.shift();}

                if (args[0] === true) {float = args.shift();}

                date = date.diff(referenceTime, units, float);
                break;
              }

            case 'calendar':
              {
                /*
                * Formats a date with different strings depending on how close
                * to a certain date (today by default) the date is.
                * http://momentjs.com/docs/#/displaying/calendar-time/
                */

                var _referenceTime = moment$$1();
                var formats = {};

                if (moment$$1(args[0]).isValid()) {
                  // If valid, assume it is a date we want the output computed against.
                  _referenceTime = moment$$1(args.shift());
                } else if (args[0] === null || args[0] === 'now') {
                  // If null or 'now', remove argument and proceed with default referenceTime.
                  args.shift();
                }

                if (_typeof(args[0]) === 'object') {formats = args.shift();}

                date = date.calendar(_referenceTime, formats);
                break;
              }

            case 'utc':
              {
                /*
                * Mutates the original moment by converting to UTC
                * https://momentjs.com/docs/#/manipulating/utc/
                */
                date.utc();
                break;
              }

            case 'timezone':
              {
                /*
                * Mutates the original moment by converting to a new timezone.
                * https://momentjs.com/timezone/docs/#/using-timezones/converting-to-zone/
                */
                date.tz(args.shift());
                break;
              }

            default:
              {
                /*
                * Formats a date by taking a string of tokens and replacing
                * them with their corresponding values.
                * http://momentjs.com/docs/#/displaying/format/
                */

                var format = method;
                date = date.format(format);
              }}


          if (args.length) {parse.apply(parse, args);}
        }

        parse.apply(parse, args);

        return date;
      });

      Vue.filter('duration', function () {
        var arguments$1 = arguments;

        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments$1[_key3];
        }

        /*
          * Basic pass-through filter for leveraging moment.js's ability
          * to manipulate and display durations.
          * https://momentjs.com/docs/#/durations/
          */
        args = Array.prototype.slice.call(args);
        var input = args.shift();
        var method = args.shift();

        function createDuration(time) {
          if (!Array.isArray(time)) {time = [time];}
          var result = moment$$1.duration.apply(moment$$1, _toConsumableArray(time));
          if (!result.isValid()) {console.warn('Could not build a valid `duration` object from input.');}
          return result;
        }
        var duration = createDuration(input);

        if (method === 'add' || method === 'subtract') {
          // Generates a duration object and either adds or subtracts it
          // from our original duration.
          var durationChange = createDuration(args);
          duration[method](durationChange);
        } else if (duration && duration[method]) {
          var _duration;

          // This gives a full proxy to moment.duration functions.
          duration = (_duration = duration)[method].apply(_duration, _toConsumableArray(args));
        }

        return duration;
      });
    } };


  var vueMoment_1 = vueMoment.install;

  exports['default'] = vueMoment;
  exports.install = vueMoment_1;

  Object.defineProperty(exports, '__esModule', { value: true });

});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! (webpack)/buildin/global.js */ 2)))

/***/ }),
/* 79 */
/*!******************************************************!*\
  !*** I:/out-project/FCoinEx/static/locales/zh-CN.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var _market;function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}module.exports = {
  message: {
    tabBar: {
      market: '行情',
      trade: '交易',
      assets: '资产' },

    login: {
      email: '请输入邮箱',
      password: '请输入密码',
      username: '用户名',
      login: '登录',
      forget: '忘记密码？',
      noAccount: '您还没有注册?',
      registration: '去注册',

      welcome: '欢迎来到',
      mobileError: '手机号不正确',
      loginSuccess: '登录成功',
      pwdError: '密码格式不正确',
      pwdNotMatch: '两次密码不一致',
      registSuccess: '注册成功' },

    register: {
      registrTitle: '创建新账号',
      registrTips: '开始你在futureCoinesEx的加密货币之旅吧！',
      verification: '请输入验证码',
      email: '请输入邮箱',
      emailCode: '请输入邮箱验证码',
      password: '请输入密码',
      passwordAgain: '请再次输入密码',
      invitCode: '推荐码(可选)',
      hasAccount: '您已经有账号了， ',
      logining: '去登录',
      registration: '注册' },

    updateName: {
      title: '修改昵称',
      placeholder: '最多输入10个字符',
      tips: 'Limited  a-z、A-Z、-、0-9',
      btn: '确定' },

    updatePwd: {
      title: '修改密码',
      oldPwd: '旧密码',
      newPwd: '新密码',
      newPwdAgain: '再次输入密码',
      emailCode: '请输入邮箱验证码',
      btn: '提交' },

    user: {
      title: '我的',
      login: '请登录',
      password: '密码',
      invit: '邀请好友',
      language: '系统语言',
      community: '加入社区',
      help: '帮助中心',
      about: '关于我们',
      download: '下载APP',
      logout: '退出' },

    invit: {
      title: '邀请好友',
      friends: '我的好友数',
      totalReward: '累计奖励',
      tCode: '推荐码',
      tLink: '推荐连接',
      tReward: '邀请奖励',
      myInvit: '我的邀请',
      uid: '邀请UID',
      inviter: '邀请人' },

    index: {
      title: '市场',
      prediction: {
        title1: '充值',
        title2: '提现' },

      market: {
        title1: '币种/成交量',
        title2: '市场价',
        title3: '涨跌' } },


    common: {
      getCode: '获取验证码',
      retryCode: 'X秒重新获取',
      overCode: '重新获取',
      update: '修改',
      insert: '新增',
      delete: '删除',
      ok: '确认',
      cancel: '取消',
      copy: '复制',
      tip: '提示',
      set: '设置',
      reset: '重置',
      filter: '筛选',
      secritKey: '秘钥',
      noData: '暂无数据',
      lang: {
        en: '英文',
        zh: '中文' },

      status: '状态',
      wan: '万',
      level: '级',
      time: '时间',
      amount: '金额',
      vol: '数量',
      day: '天',
      hour: '小时',
      select: '请选择',
      open: '开启',
      stop: '暂停',
      close: '关闭',
      request: '请求中...',
      verifyTitle: '请完成安全验证',
      explain: '向右滑动完成验证',
      verifySuccess: '验证成功',
      verifyFail: '验证失败',
      nomoreText: '没有更多了',
      loadingText: '正在加载...',
      loadmoreText: '加载更多' },

    market: (_market = {
      high: '高',
      low: '低',
      vol: '量',
      amount: '额',
      chg: '波幅',
      hs: '换手',
      sz: '总市值',
      lb: '量比',
      price: '初始价格',
      relation: '相关性',
      historyHigh: '历史最高',
      historyLow: '历史最低',
      globalSz: '占全球总市值',
      ltl: '流通率',
      hsl: '换手率',
      tip1: '请根据您对该币种未来24小时内的行情判断来选择您支持的方向',
      tip2: '*每日凌晨3:00(北京时间)重置计票',
      tab1: '币种概况',
      tab2: '项目动态',
      tab3: '团队信息',
      baseInfo: '基本信息',
      releaseInfo: '发行信息',
      vouerInfo: '供应量信息',
      minerInfo: '挖矿信息',
      introInfo: '投资机构',
      linkInfo: '相关链接',
      srfxsj: '首次发行时间',
      kpjg: '首日开盘价',
      lszg: '历史最高',
      lszd: '历史最低',
      ssgl: '所属公链',
      fxfs: '首次发行方式',
      ltsz: '流通市值',
      ph: '排行',
      sjjys: '上架交易所',
      cbdzs: '持币地址数',
      zdgyl: '最大供应量',
      zgyl: '总供应量',
      ltzl: '流通总量' }, _defineProperty(_market, "ltsz",
    '流通市值'), _defineProperty(_market, "qqzxyzb",
    '全球总市值占比'), _defineProperty(_market, "csqksj",
    '创世区块时间'), _defineProperty(_market, "wkzt",
    '挖矿状态'), _defineProperty(_market, "zlzj",
    '激励机制'), _defineProperty(_market, "cksd",
    '出块速度'), _defineProperty(_market, "hxsf",
    '核心算法'), _defineProperty(_market, "jbjl",
    '减半后奖励'), _defineProperty(_market, "qkjl",
    '区块奖励'), _defineProperty(_market, "website",
    '官网'), _defineProperty(_market, "whitepager",
    '白皮书'), _defineProperty(_market, "blocksite",
    '区块站'), _market),

    lottery: {
      tip1: '您有',
      tip2: '次抽奖机会',
      tip3: '去交易' },

    wallet: {
      title: '我的资产',
      total: '总资产折合',
      recharge: '充币',
      withdraw: '提币',
      exchange: '兑换',
      avalible: '可用',
      frozen: '冻结',
      amount: '折合' },

    withdraw: {
      title: '提现',
      network: '网络',
      withdrawwAddr: '地址',
      copyBtn: '粘贴',
      inputAddr: '输入或按粘贴地址',
      money: '金额',
      balance: '当前可用余额',
      all: '全部',
      fee: '手续费',
      btn: '确定',
      safe: '提现安全确认',
      emailCode: '邮箱验证码',
      placeholder: '请输入邮箱验证码',
      loginPwd: '登录密码',
      placeholder1: '请输入登录密码',
      submitBtn: '确认提现',
      noWithdrawAddr: '请输入/粘贴提现地址',
      noAmount: '请输入提现金额',
      noEmailCode: '请输入邮箱验证码',
      noPwd: '请输入登录密码',
      withdrawSuccess: '提现成功' },

    recharge: {
      title: '充值',
      rechargeAddr: '充值地址',
      copyBtn: '复制地址',
      amount: '充值金额',
      placeholder: '请输入充值金额',
      submitBtn: '我已转账' },

    submitRecharge: {
      title: '充值凭证',
      exImg: '示列图片',
      hash: '交易哈希值',
      copyBtn: '粘贴',
      submitBtn: '确认充值',
      closeBtn: '取消',
      note: 'Note' },

    record: {
      title: '资产记录',
      rechargeList: '充值记录',
      withdrawList: '提现记录' },

    toast: {
      codeSend: '验证码已发送',
      coding: '正在获取验证码',
      inputCode: '请输入验证码',
      inputPwd: '请输入密码',
      pwdError: '登录密码不正确',
      againPwdError: '两次密码输入不一致',
      updatePwdSuccess: '登录密码修改成功',
      copySuccess: '复制成功',
      paySuccess: '付款成功',
      updateNameSuccess: '修改昵称成功' } } };

/***/ }),
/* 80 */
/*!******************************************************!*\
  !*** I:/out-project/FCoinEx/static/locales/en-US.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var _miner, _market;function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}module.exports = {
  message: {
    tabBar: {
      home: 'Home',
      miner: 'Miner',
      me: 'Me',
      news: 'News',
      wallet: 'Wallet',
      market: 'Market' },

    login: {
      inputUserName: 'Please enter your login account',
      inputEmail: 'Please enter your email',
      password: 'Please enter your login password',
      username: 'username',
      login: 'Login',
      language: 'Change language',
      langImg: '../../static/en.png',
      forget: 'Forget password',
      registration: 'Immediate registration',
      verification: 'Enter verification code',
      simplified: 'Simplified Chinese',
      coin: 'Coin',
      english: 'English',
      traditional: 'Traditional Chinese',
      rmb: 'RMB',
      dollar: 'Dollar',
      welcome: 'Welcome to',
      noAccount: 'No Account?',
      pwdRule: '8-18 digit combination of numbers and letters without special characters',
      hasAccount: 'Has Account?',
      inputInvitCode: 'Please enter Invit Code',
      logining: 'Log in now',
      mobileError: 'Incorrect mobile phone number',
      loginSuccess: 'Login succeeded',
      pwdError: 'The password format is incorrect',
      pwdNotMatch: 'The two passwords are inconsistent',
      registSuccess: 'login was successful' },

    index: {
      prediction: {
        title: 'Prediction' },

      exchange: {
        title: 'Quick Exchange' },

      stacking: {
        title: 'Staking' },

      market: {
        title1: 'Coins/Lip M.cap',
        title2: 'Global Index',
        title3: 'Chg%' },

      otc: {
        title: 'OTC',
        support: 'Support' },

      power: {
        innerTitle: 'Wanxing computing power information',
        allTitle: 'Network wide info',
        zsl: 'Final force',
        sllj: 'Monitor link',
        dqdf: 'Electricity',
        qwsl: 'Computing power',
        rsy: 'Revenue per 100t day',
        dqnd: 'Current difficulty',
        xcnd: 'Next difficulty',
        tzsj: 'Adjust time',
        bjck: 'Price' } },


    common: {
      getCode: 'Get Code',
      retryCode: 'Resend Xs',
      overCode: 'Resend',
      update: 'Update',
      insert: 'Add',
      delete: 'Delete',
      ok: 'Confirm',
      cancel: 'Cancel',
      tip: 'Tips',
      reset: 'Reset',
      set: 'Set',
      filter: 'Filter',
      copy: 'Copy',
      secritKey: 'Secret key',
      noData: 'No data',
      lang: {
        en: 'English',
        zh: 'Chinese',
        hk: '繁体' },

      status: 'Status',
      wan: 'M',
      level: 'L',
      time: 'Time',
      amount: 'Amount',
      vol: 'Volume',
      day: 'Day',
      hour: 'Hour',
      select: 'Please select',
      open: 'Open',
      stop: 'Stop',
      close: 'Close',
      request: 'Loading...',
      verifyTitle: 'Please security verification',
      explain: 'Swipe right to verification',
      verifySuccess: 'Success',
      verifyFail: 'Failed',
      nomoreText: 'No more',
      loadingText: 'Loading...',
      loadmoreText: 'Load more' },

    miner: (_miner = {
      navTitle: 'Cloud Computing Power',
      power: 'Power',
      mintTime: 'Dig Time',
      lifeCycle: 'Period',
      day: 'day',
      price: 'Power Price',
      buyVol: 'Buy Volume',
      expireTime: 'Expire time',
      statusTxt: 'Status',
      orderStatus: {
        peeding: 'Pedding',
        ing: 'Ing',
        invalid: 'Invalid' },

      producerDetail: 'Output details',
      tab1: 'Product',
      tab2: 'Hold',
      remind: 'Remainder',
      mfsl: 'Each Power',
      mfjsy: 'Daily Income',
      slgh: 'Consumption',
      hyzq: 'Cycle',
      hyjg: 'Price' }, _defineProperty(_miner, "day",
    'Day'), _defineProperty(_miner, "buy",
    'Buy'), _defineProperty(_miner, "wdsl",
    'My Power'), _defineProperty(_miner, "dqmrsy",
    'Daily revenue'), _defineProperty(_miner, "zsy",
    'Total Revenue'), _defineProperty(_miner, "zrsy",
    'Yestoday Revenue'), _defineProperty(_miner, "sldw",
    ''), _defineProperty(_miner, "wdzc",
    'My Assets'), _defineProperty(_miner, "cksy",
    'View Benefits'), _defineProperty(_miner, "kssj",
    'Start Time'), _defineProperty(_miner, "sj",
    'Time'), _defineProperty(_miner, "jsy",
    'Net Profit'), _defineProperty(_miner, "mlfs",
    'Shares'), _defineProperty(_miner, "hbfs",
    'Return'), _defineProperty(_miner, "mrcc",
    'Output'), _defineProperty(_miner, "grzh",
    'To personal account'), _defineProperty(_miner, "glf",
    'Fee'), _defineProperty(_miner, "kc",
    'Deducted from daily income'), _defineProperty(_miner, "dfyhj",
    'Preferential Tariff'), _defineProperty(_miner, "dfyj",
    'Tariff'), _defineProperty(_miner, "gdxq",
    'More'), _defineProperty(_miner, "zj",
    'Total price'), _defineProperty(_miner, "qx",
    'Cancel'), _defineProperty(_miner, "qrgm",
    'Buy'), _defineProperty(_miner, "yfk",
    'Paid'), _defineProperty(_miner, "dscpz",
    'Upload Voucher'), _defineProperty(_miner, "qxdd",
    'Cancel'), _defineProperty(_miner, "paytip",
    'Please transfer the corresponding amount to the following collection account'), _defineProperty(_miner, "fkje",
    'Payment Amount'), _defineProperty(_miner, "kfh",
    'Bank of deposit'), _defineProperty(_miner, "hm",
    'Name'), _defineProperty(_miner, "zh",
    'Account'), _defineProperty(_miner, "skbz",
    'Currency'), _defineProperty(_miner, "skrcz",
    'Region'), _defineProperty(_miner, "skrdz",
    'Address'), _defineProperty(_miner, "ckxq",
    'Search'), _defineProperty(_miner, "ddje",
    'Amount'), _defineProperty(_miner, "scz",
    'Produce'), _defineProperty(_miner, "qfk",
    'To Pay'), _defineProperty(_miner, "dsh",
    'Audit'), _defineProperty(_miner, "shtg",
    'Approved'), _defineProperty(_miner, "shjj",
    'Reject'), _defineProperty(_miner, "ysx",
    'Invalid'), _defineProperty(_miner, "fk",
    'Pay'), _defineProperty(_miner, "zc",
    'Transfer Out'), _defineProperty(_miner, "fkxx",
    'Pay Info'), _miner),

    audit: {
      status: {
        no: 'Not Audit',
        ing: 'Auditing',
        pass: 'Pass',
        reject: 'Reject' },

      tip1: 'Please upload the front and back images of your ID card',
      tip2: 'Please ensure that the content of the photo is complete and clearly visible. Only JPG and PNG formats are supported, and the picture size is less than 5m',
      tip3: 'Please upload the front image of your ID card',
      tip4: 'Please upload the image on the back of your ID card',
      submit: 'Submit' },

    my: {
      login: 'Please Login',
      sentence: 'Welcome to',
      exit: 'Logout',
      vip: 'VIP',
      sign: 'Sign',
      reward: 'Lottery',
      notice: 'Notice',
      addressBook: 'Address',
      recomment: 'Recomment',
      accountsafe: 'Account And Safe',
      auth: 'Authentication',
      order: 'My Order',
      payin: 'Payment Method',
      payinaddress: 'Address',
      businessapply: 'Acceptor Apply',
      business: 'Acceptor Console',
      agentapply: 'Agent Apply',
      agentManage: 'Agent Manage',
      help: 'Help',
      about: 'About',
      lang: 'Language',
      set: 'Setting',
      withdraw: {
        navTitle: 'Withdraw',
        tbdz: 'Address',
        sl: 'Amount',
        zxtb: 'Min Amount',
        all: 'All',
        ky: 'Available',
        sxf: 'Fee',
        sj: 'Time',
        amount: 'Amount',
        status: 'Status',
        no: 'No',
        pedding: 'Pedding',
        pass: 'Pass',
        reject: 'Reject' },

      withdrawList: {
        navTitle: 'Withdrawal Record',
        sj: 'Time',
        zcje: 'Amount',
        zchje: 'Balance' },

      address: {
        addAddress: 'Add Address',
        selectCoin: 'Please select a coin',
        inputAddr: 'Please enter the address',
        inputName: 'Please enter address name' } },


    market: (_market = {
      high: 'High',
      low: 'Low',
      vol: 'Volume',
      amount: 'Amount',
      chg: 'Chg',
      hs: '换手',
      sz: '总市值',
      lb: '量比',
      price: '初始价格',
      relation: '相关性',
      historyHigh: '历史最高',
      historyLow: '历史最低',
      globalSz: '占全球总市值',
      ltl: '流通率',
      hsl: '换手率',
      tip1: '请根据您对该币种未来24小时内的行情判断来选择您支持的方向',
      tip2: '*每日凌晨3:00(北京时间)重置计票',
      tab1: '币种概况',
      tab2: '项目动态',
      tab3: '团队信息',
      baseInfo: '基本信息',
      releaseInfo: '发行信息',
      vouerInfo: '供应量信息',
      minerInfo: '挖矿信息',
      introInfo: '投资机构',
      linkInfo: '相关链接',
      srfxsj: '首次发行时间',
      kpjg: '首日开盘价',
      lszg: '历史最高',
      lszd: '历史最低',
      ssgl: '所属公链',
      fxfs: '首次发行方式',
      ltsz: '流通市值',
      ph: '排行',
      sjjys: '上架交易所',
      cbdzs: '持币地址数',
      zdgyl: '最大供应量',
      zgyl: '总供应量',
      ltzl: '流通总量' }, _defineProperty(_market, "ltsz",
    '流通市值'), _defineProperty(_market, "qqzxyzb",
    '全球总市值占比'), _defineProperty(_market, "csqksj",
    '创世区块时间'), _defineProperty(_market, "wkzt",
    '挖矿状态'), _defineProperty(_market, "zlzj",
    '激励机制'), _defineProperty(_market, "cksd",
    '出块速度'), _defineProperty(_market, "hxsf",
    '核心算法'), _defineProperty(_market, "jbjl",
    '减半后奖励'), _defineProperty(_market, "qkjl",
    '区块奖励'), _defineProperty(_market, "website",
    '官网'), _defineProperty(_market, "whitepager",
    '白皮书'), _defineProperty(_market, "blocksite",
    '区块站'), _market),

    accountsafe: {
      title: 'Account And Safe',
      loginpwd: {
        title: 'Login Password',
        mobile: 'Mobile',
        validPlacehold: 'Input Valid Code',
        pwdPlacehold: 'Input New Password',
        againPlacehold: 'Input New Password Again',
        tip: 'The login password consists of 8-18 digits of numbers and letters without special characters' },

      tradepwd: {
        title: 'Trade Password',
        tip: 'The payment password is 6 digits' },

      googleset: {
        title: 'Google settings',
        navTitle: 'Google Authenticator Settings',
        downloadTip: 'Android Google Authenticator Download',
        bindTip: 'You are not bound yet, now bind',
        unbindTip: 'You are bound, unbind',
        bindNavTitle: 'Bind Google Authenticator',
        bindTip1: 'Add the secret key in Google Authenticator and back it up',
        bindTip2: 'Open Google Authenticator, scan the QR code below or manually enter the following key to add a verification token',
        bindTip3: 'Be sure to back up the following keys',
        bindBtn: 'I have backed up and added to the validator' } },


    notice: {
      title: 'Notice',
      detail: 'Notice Detail' },

    lottery: {
      tip1: 'Your have',
      tip2: 'change',
      tip3: 'Spend',
      tip4: 'buy',
      tip5: 'luck draw',
      tip6: 'Draw' },

    sigin: {
      title: 'Daily Check-in',
      tip1: 'Sign in for 7 consecutive days to receive the exchange Award',
      tip2: 'Day',
      tip3: 'Check in for the seventh time for 7 consecutive days or more',
      tip4: 'Activity rule',
      tip5: 'Users can get by participating in check-in activities',
      tip6: 'The first 7 days are calculated in steps, which are 1,2,3,4,5,6,7 respectively, and 7 after the seventh day',
      tip7: 'Recalculate if sign in is interrupted',
      tip8: 'The check-in time of daily update is Singapore time',
      tip9: 'The final distribution quantity is subject to the final distribution of the platform, and the final interpretation right belongs to fexcoin',
      tip10: 'Signed',
      tip11: 'Check In' },

    invit: {
      title: 'Invitation Introduction',
      tip1: 'Send to friends',
      tip2: 'Transaction',
      tip3: 'Rebate',
      tip4: 'Registration time',
      tip5: 'My code (copy)',
      tip6: 'Poster',
      tip7: 'Link',
      tip8: 'Share',
      tip9: 'Qrcode',
      tip10: 'Leaderboard',
      tip11: 'No ranking yet',
      tip12: 'Return',
      tip13: 'Save',
      tip14: 'person' },

    help: {
      title: 'Common Problem',
      account: 'Account Related',
      miner: 'Miner Related',
      tip1: 'Forget password',
      tip2: 'How to bind Google',
      tip3: 'How to real name',
      exchange: 'Exchange',
      tip4: 'How to exchange',
      tip5: 'Exchange fee',
      otc: 'OTC',
      tip6: 'How to buy',
      tip7: 'How to sell',
      tip8: 'How to become an acceptor',
      wc: 'Full extraction correlation',
      tip9: 'How to charge',
      tip10: 'How to withdraw' },

    about: {
      protocol: 'Service agreement',
      privacy: 'Privacy clause',
      law: 'Legal declaration',
      checkVer: 'Check for new version',
      currentVer: 'Current version' },

    set: {
      push: 'Message Push',
      help: 'Help Center',
      about: 'About Fex' },

    agent: {
      status: {
        padding: 'Pedding',
        pass: 'Pass',
        reject: 'Reject' },

      agreement: {
        part1: 'Please read carefully',
        part2: 'Agency contract',
        part3: 'And check confirm' },

      withdraw: {
        navTitle: 'Withdraw Record',
        sj: 'Time',
        amount: 'Amount',
        status: 'Status',
        no: 'No',
        pedding: 'Pedding',
        pass: 'Pass',
        reject: 'Reject',
        ktqyj: 'Withdraw Commission',
        zwtq: 'No Withdraw',
        qrtq: 'Withdraw',
        zhxx: 'Commission withdrawal account information',
        kfh: 'Bank of deposit',
        hm: 'Account name',
        zh: 'Accounts' },

      manage: {
        navTitle: 'Agent Manage',
        tabs: {
          tab1: 'Invite',
          tab2: 'Trade',
          tab3: 'Explain',
          tab4: 'Withdraw' },

        invit: {
          method1: 'Invitation method 1: use the following link to register as a new user',
          method2: 'Invitation method 2: enter the invitation code when registering',
          copyLink: 'Copy Link',
          copyCode: 'Copy Code',
          tip: 'The users you invite will automatically become your subordinates. After your subordinates purchase computing power, you can get corresponding rewards. If your subordinates are still subordinates, you can also get rewards between commission grades',
          yyqyh: 'Invited users',
          zcsh: 'Time' },

        trade: {
          ddje: 'Amount',
          wdxj: 'My Child',
          zje: 'Total Amount',
          xjzje: 'Child Total Amount',
          ckxq: 'Search' },

        commission: {
          dqdj: 'Current Level',
          dqyj: 'Current Commission',
          dqyjzj: 'Current Reward(Total)',
          dqyjdy: 'Current Reward(Current Month)',
          dldjsm: 'Description',
          dldj: 'Agent Leven',
          zyj: 'Total Commission',
          fybl: 'Rebate ratio' } } },



    wallet: {
      title: 'My assets',
      total: 'Total assets',
      recharge: 'Recharge',
      withdraw: 'Withdraw',
      exchange: 'Exchange',
      avalible: 'Available',
      frozen: 'Frozen',
      amount: 'Equivalent' },

    withdraw: {
      selectCoin: 'Select Coin',
      chainName: 'Chain',
      withdrawwAddr: 'Withdraw Address',
      inputAddr: 'Enter or long press the paste address',
      vol: 'Amount',
      minWithdrawVol: 'Min',
      all: 'All',
      avalible: 'Available',
      fee: 'Fees',
      inputAmount: 'Please enter amount',
      tip1: 'The minimum withdrawal amount is',
      tip2: 'In order to ensure fund security, when your account security policy is changed or your password is changed, we will manually review the withdrawal. Please wait patiently for the staff to contact by phone or email',
      tip3: 'Please make sure that the computer and browser are secure to prevent information from being tampered with or disclosed',
      status: {
        no: 'No Audit',
        pass: 'Pass',
        transfer: 'Transfer',
        fail: 'Failed',
        complete: 'Completed',
        reject: 'Reject',
        cancel: 'Cancel' },

      detail: 'Coin Detail' },

    recharge: {
      rechargeAddr: 'Deposit Address',
      qrcode: 'Save QR code to album',
      tip1: 'Please do not recharge to the above address whatever none',
      tip2: 'assets，Otherwise, the asset will not be recovered',
      tip3: 'After you recharge to the above address, you need to confirm the entire network node',
      tip4: 'Arrival after network confirmation',
      tip5: 'Minimum recharge amount',
      tip6: 'Recharge less than the minimum amount will not be credited and cannot be returned',
      tip7: 'Your recharge address will not change frequently, and you can recharge repeatedly; If there is any change, we will try our best to notify you through website announcement or email',
      tip8: 'Please make sure that the computer and browser are secure to prevent information from being tampered with or disclosed',
      status: {
        noConfirm: 'Unconfirmed',
        complete: 'Completed',
        exception: 'Exception' } },


    otc: {
      title: 'OTC',
      buyTab: 'Buy',
      sellTab: 'Sell',
      vol: 'Volume',
      limit: 'Quota',
      price: 'Price',
      buy: 'Buy',
      sell: 'Sell',
      inputAmount: 'Please enter the purchase amount',
      inputVol: 'Please enter the purchase quantity',
      byAmount: 'By amount',
      byVol: 'By volume',
      all: 'All',
      tradeVol: 'Volume',
      payAmount: 'Actual payment',
      submit: 'Confirm',
      confirm: 'Confirm order?',
      order: {
        orderRecord: 'Record',
        statusLabel: 'Status',
        typeLabel: 'Type',
        status: {
          pedding: 'Pedding',
          payed: 'Paid',
          success: 'Success',
          cancel: 'Cancel',
          appeal: 'Appeal',
          appealDone: 'Appeal completed',
          except: 'Exception' },

        plzPay: 'Please pay',
        tip1: 'Please in',
        tip2: 'minute',
        tip3: 'payment to seller within',
        tip4: 'waiting for opposite party payment,can',
        tip5: 'Appeal in minutes',
        payed: 'Paid',
        tip6: 'If the seller does not release money, you can appeal',
        tip7: 'The opposite party paid you',
        done: 'Completed',
        tip8: 'Your order has been completed',
        cancel: 'Cancel',
        tip9: 'Order cancellation cannot view payment information',
        appeal: 'In appeal',
        tip10: 'The order is under appeal',
        phone: 'Telephone',
        orderAmount: 'Amount',
        orderNo: 'Number',
        orderTime: 'Order time',
        tip11: 'Please use me',
        tip12: 'Self transfer to the following account',
        tip13: 'Payment method',
        username: 'Payee',
        account: 'Account',
        qrcode: 'Qrcode',
        bank: 'Bank of deposit',
        branch: 'Sub branch',
        tip14: 'Please do not remark BTC, usdt, exchange and other information during transfer to prevent remittance from being intercepted and bank card from being frozen',
        cancelOrder: 'Cancel',
        tip15: 'I have paid successfully',
        tip16: 'Confirm receipt and release',
        confirmCannel: 'Are you sure you want to cancel the order?',
        cannelSuccess: 'Cancellation succeeded',
        confirmPay: 'Confirm payment?',
        paySuccess: 'Mark payment successful',
        confirmComplete: 'Are you sure to release?',
        doneSuccess: 'Successful release',
        time: 'Time',
        totalAmount: 'Total',
        tradeType: 'Type',
        orderList: 'Order list' },

      advert: {
        addAdvert: 'Add ad',
        coin: 'Coin',
        payMethod: 'Payment method',
        orderType: 'Type',
        safeTip: 'Tip: selling advertising is equal to the users purchase, and buying advertising is equal to the users sale',
        minAmount: 'Min Vol',
        maxAmount: 'Max Vol',
        overtime: 'Timeout',
        inputRemark: 'Please enter a message',
        selectCoin: 'Please select a coin',
        selectFiat: 'Please select legal currency',
        selectPayType: 'Please select payment method',
        inputPrice: 'Please enter unit price',
        inputVol: 'Please enter volume',
        inputLimit: 'Please enter limit',
        limitError: 'The minimum limit cannot be greater than the maximum limit',
        selectOvertime: 'Please select a timeout',
        onlineSell: 'Online Sell',
        onlineBuy: 'Online Buy',
        advertList: 'Advertising list' },

      merchant: {
        title: 'Acceptor management',
        edit: 'Modify data',
        publish: 'Advertise',
        advertList: 'Advertising list',
        orderList: 'Order list',
        exit: 'Withdrawal acceptor',
        inputName: 'Please enter the merchant name',
        inputMobile: 'Please enter your mobile',
        inputEmail: 'Please enter email',
        margin: 'Margin',
        tip1: 'Tip: the deposit is frozen assets and will be returned when withdrawing from the acceptor',
        apply: 'Acceptor application',
        status: {
          peeding: 'Pedding',
          pass: 'Pass',
          reject: 'Reject',
          exitAudit: 'Exit audit',
          exit: 'Exited' } } },




    convert: {
      title: 'Exchange',
      outAmount: 'Out Volume',
      inAmount: 'In Volume',
      balance: 'Balance',
      fee: 'Fee',
      ratio: 'Rate',
      exchangeBtn: 'Exchange',
      outAsset: 'Out Assets',
      inAsset: 'In Assets',
      time: 'Time',
      search: 'Search',
      inputVol: 'Please enter the exchange volume',
      exchangeSuccess: 'Exchange succeeded',
      notTrasfer: 'The transaction pairs cannot be transferred to each other' },

    prediction: {
      max: 'Maximum',
      bet: 'Bet',
      up: 'Rise',
      down: 'Fall',
      pool: 'Jackpot',
      guessUp: 'Guess rise',
      guessDown: 'Guess fall',
      beted: 'Bet placed guess',
      startPrice: 'Start price',
      endPrice: 'End price',
      status: {
        betting: 'Betting',
        locking: 'Locked',
        over: 'Over' },

      locking: 'Locking...',
      settling: 'Settlement...',
      inputVol: 'Please enter quantity',
      tip1: 'Are you sure this time guess',
      betSuccess: 'Bet successful',
      betRecord: 'Betting record',
      betSide: 'Bet direction',
      guess: 'Guess',
      betVol: 'Bet quantity',
      reward: 'Forecast reward',
      roundRecord: 'Round record',
      rewardPool: 'Prize pool',
      bull: 'Bull',
      bear: 'Bear',
      lockPrice: 'Lock price',
      overPrice: 'Over price',
      recordTitle: 'Forecast record' },

    financial: {
      title: 'Financial',
      totalProfit: 'Total revenue',
      record: 'Financial records',
      myFinance: 'My financial',
      receive: 'Receive',
      regular: 'Time to rob',
      soon: 'Stay tuned for',
      the: 'The',
      phase: 'P',
      rate: 'Annual interest rate',
      period: 'Period',
      day: 'day',
      history: 'Historical events',
      status: {
        ing: 'Subscribe',
        lock: 'Locking',
        done: 'Completed',
        stop: 'Stop' },

      receiveSuccess: 'Receive income successfully',
      startVol: 'Starting quantity',
      avalibleVol: 'Remaining quantity',
      timeline: 'Timeline',
      buy: 'Buy',
      startTime: 'Revenue opening time',
      endTime: 'Revenue settlement time',
      rule: 'Rule description',
      tip1: 'What is money deposit management?',
      tip2: 'Money deposit financial management is a digital asset fixed cycle financial product launched by fexcoin platform. Each financial product project locks a certain cycle and different expected annualized income. You can freely choose the subscription quantity. After purchase, it will be locked. The income will be calculated from the agreed time. After that, the principal and income will be automatically transferred to the account to obtain the principal and interest income',
      tip3: 'How to participate',
      tip4: 'Log in to the fexcoin platform, click save money for financial management, select the required products according to your own situation, enter the amount of money, and click save now to participate in the financial management plan',
      tip5: 'Can I unlock in advance before the end of the locking period？',
      tip6: 'The financial management plan does not support unlocking in advance for the time being. It will not be unlocked automatically until the periodic lock is completed. In the future, we will launch current financial management',
      tip7: 'How to get benefits？',
      tip8: 'After the lock-in period ends, click the receive income button in money deposit and financial management, and your principal and interest will be immediately released to your account, which can be viewed in my assets',
      tip9: 'Purpose of funds？',
      tip10: 'Digital asset fixed cycle financial products launched by the platform. The funds are mainly used for the pledge and lending of digital assets, and the use of funds is transparent',
      deposit: 'Deposit Now',
      subscribeVol: 'Quantity',
      inputVol: 'Please enter the subscription quantity',
      volError: 'Subscription quantity input error',
      subscribeSuccess: 'Successful subscription',
      activity: 'Activity details',
      suscribe: 'Subscribe',
      profit: 'Profit',
      orderStatus: {
        locking: 'Locking',
        wait: 'Unclaimed',
        done: 'Completed' } },


    payType: {
      options: {
        'UnionPay': 'BankCard',
        'Alipay': 'Alipay',
        'Wechat': 'WeChat' },

      username: 'Name',
      bankNo: 'Card No',
      bankName: 'Bank',
      subBranch: 'Subbranch',
      account: 'Account',
      qrcode: 'QR code',
      tip1: 'Please upload your payment code picture (jpg/jpeg/png format, the size should not exceed 2M)',
      input: 'please enter ' },

    toast: {
      codeSend: 'Verification code sent',
      coding: 'Getting verification code',
      inputCode: 'Please input verification code',
      inputGoogleCode: 'Please input google verification code',
      inputPwd: 'Please input password',
      pwdError: 'The login password is incorrect',
      againPwdError: 'The two passwords are inconsistent',
      updatePwdSuccess: 'Login password modified successfully',
      unbindGoodsSuccess: 'Unbind Google authentication succeeded',
      bindGoodsSuccess: 'Bind Google validation succeeded',
      copySuccess: 'Copy Success',
      paySuccess: 'Pay Success',
      cancelSuccess: 'Cancel Success',
      inputAmountError: 'Please input amount',
      inputCapthError: 'Please input capital password',
      withdrawSuccess: 'Withdraw Success',
      inputName: 'Please input name',
      inputMobile: 'Please input mobile',
      inputRemakr: 'Please input remark',
      applySuccess: 'Apply Success',
      submitSuccess: 'Submit Success',
      addSuccess: 'Add Success',
      deleteSuccess: 'Delete Success',
      buySuccess: 'Buy Success',
      inputBankNo: 'Please enter bank card number',
      inputAccount: 'Please input Username',
      inputBank: 'Please enter the account bank',
      inputSubBank: 'Please enter the account opening branch' },

    popup: {
      open: 'Not yet open!',
      tips: 'tips',
      modal: 'This is a modal pop-up window!',
      confirm: 'confirm',
      cancel: 'cancel',
      loading: 'Loading...',
      exit: 'Exit',
      exittext: 'Are you sure you want to log out？',
      version: 'Version',
      vertext: 'Are you sure you want to upgrade？',
      buytext: 'Confirm purchase?',
      payedtext: 'Confirm payment?',
      canceltext: 'Are you sure you want to cancel the order?',
      setaddresstext: 'Collection address is not set, please set?',
      setpaypwdtext: 'Please set the fund password',
      deletetext: 'Are you sure you want to delete?',
      submittext: 'Are you sure you want to submit?' } } };

/***/ }),
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */
/*!****************************************************!*\
  !*** I:/out-project/FCoinEx/common/mixin/mixin.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(uni) {Object.defineProperty(exports, "__esModule", { value: true });exports.authMixin = exports.commonMixin = void 0;var _vuex = __webpack_require__(/*! vuex */ 7);function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {_defineProperty(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}




var commonMixin = {
  computed: _objectSpread(_objectSpread({},
  (0, _vuex.mapState)('user', ['loginInfo'])), {}, {
    i18n: function i18n() {
      return this.$t('message');
    } }),

  data: function data() {
    return {
      contentText: {
        contentdown: "上拉显示更多",
        contentrefresh: "正在加载...",
        contentnomore: "没有更多数据了" },

      loadText: {
        loadmore: '轻轻上拉',
        loading: '努力加载中',
        nomore: '实在没有了' } };


  },
  filters: {
    fixed: function fixed(v, scale) {
      if (v) {
        if (!scale) {
          scale = 2;
        }
        return parseFloat(v).toFixed(scale);
      }
      return v;
    } },

  onShow: function onShow() {
    this.contentText = {
      contentdown: this.i18n.common.loadmoreText,
      contentrefresh: this.i18n.common.loadingText,
      contentnomore: this.i18n.common.nomoreText };

    this.loadText = {
      loadmore: this.i18n.common.loadmoreText,
      loading: this.i18n.common.loadingText,
      nomore: this.i18n.common.nomoreText };

  },
  methods: {
    isLogin: function isLogin() {
      if (!this.loginInfo.hasLogin) {
        uni.navigateTo({
          url: '/pages/public/login' });

      } else {
        return true;
      }
    },
    navTo: function navTo(url, auth) {
      if (auth && !this.loginInfo.hasLogin) {
        uni.navigateTo({
          url: '/pages/public/login' });

        return;
      }
      uni.navigateTo({
        url: url });

    } } };exports.commonMixin = commonMixin;



var authMixin = {
  computed: _objectSpread({},
  (0, _vuex.mapState)('user', ['loginInfo'])),

  onShow: function onShow() {
    if (!this.loginInfo.hasLogin) {
      uni.navigateTo({
        url: '/pages/public/login' });

    }
  },
  methods: {} };exports.authMixin = authMixin;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["default"]))

/***/ }),
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */
/*!***************************************************************!*\
  !*** I:/out-project/FCoinEx/static/js/umychart.wechat.3.0.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";













var _umychartConsoleWechat = __webpack_require__(/*! ./umychart.console.wechat.js */ 102);


var _umychartDataWechat = __webpack_require__(/*! ./umychart.data.wechat.js */ 103);













var _umychartKlineinfoWechat = __webpack_require__(/*! ./umychart.klineinfo.wechat.js */ 105);





var _umychartCoordinatedataWechat = __webpack_require__(/*! ./umychart.coordinatedata.wechat.js */ 104);











var _umychartComplierWechat = __webpack_require__(/*! ./umychart.complier.wechat.js */ 107);
var _umychartIndexDataWechat = __webpack_require__(/*! ./umychart.index.data.wechat.js */ 108);
var _umychartHqIndexformulaWechat = __webpack_require__(/*! ./umychart.hqIndexformula.wechat.js */ 109);


var _umychartChartpaintWechat = __webpack_require__(/*! ./umychart.chartpaint.wechat.js */ 110);





































var _umychartExtendchartWechat = __webpack_require__(/*! ./umychart.extendchart.wechat.js */ 112);







var _umychartIndexWechat = __webpack_require__(/*! ./umychart.index.wechat.js */ 113);





var _umychartResourceWechat = __webpack_require__(/*! ./umychart.resource.wechat.js */ 106);





var _umychartUniappCanvasHelper = __webpack_require__(/*! ./umychart.uniapp.canvas.helper.js */ 115);

var _umychartFramesplitWechat = __webpack_require__(/*! ./umychart.framesplit.wechat.js */ 111);














var _umychartCharttitleWechat = __webpack_require__(/*! ./umychart.charttitle.wechat.js */ 114);function _createForOfIteratorHelper(o, allowArrayLike) {var it;if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = o[Symbol.iterator]();}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}










function JSCanvasElement()
{
  this.Height;
  this.Width;
  this.ID;
  this.WebGLCanvas;
  this.IsUniApp = false;
  this.CanvasNode = null;
  this.ComponentObject = null; //在自定义组件下，当前组件实例的this，表示在这个自定义组件下查找拥有 canvas-id 的 canvas ，如果省略则不在任何自定义组件内查找

  //获取画布
  this.GetContext = function ()
  {
    var canvas;
    if (this.CanvasNode && this.CanvasNode.node)
    {
      var width = this.CanvasNode.width;
      var height = this.CanvasNode.height;

      var node = this.CanvasNode.node;
      node._height = height;
      node._width = width;
      _umychartConsoleWechat.JSConsole.Chart.Log("[JSCanvasElement::GetContext] create by getContext('2d')");
      canvas = node.getContext('2d');
      var dpr = wx.getSystemInfoSync().pixelRatio;
      node.width = width * dpr;
      node.height = height * dpr;
      canvas.restore();
      canvas.save();
      canvas.scale(dpr, dpr);
      canvas.draw = function (bDraw, callback) {if (callback) callback();};
      canvas.DomNode = node;
    } else

    {
      if (this.ComponentObject) //小程序自定义组件
        canvas = wx.createCanvasContext(this.ID, this.ComponentObject);else

      canvas = wx.createCanvasContext(this.ID);
    }

    if (this.IsUniApp)
    {
      _umychartConsoleWechat.JSConsole.Chart.Log('[JSCanvasElement::GetContext] measureText() => JSUniAppCanvasHelper.MeasureText()');
      canvas.measureText = function (text) //uniapp 计算宽度需要自己计算
      {
        var width = _umychartUniappCanvasHelper.JSCommonUniApp.JSUniAppCanvasHelper.MeasureText(text, canvas);
        return { width: width };
      };

      canvas.fillText_backup = canvas.fillText; //uniapp fillText 填了最大长度就会失真, 所以去掉
      canvas.fillText = function (text, x, y, maxWidth)
      {
        canvas.fillText_backup(text, x, y);
      };
    }

    return canvas;
  };

  this.GetWebGLCanvas = function (id)
  {
    var self = this;
    var query = wx.createSelectorQuery();
    query.select(id).node().exec(function (res) {
      _umychartConsoleWechat.JSConsole.Chart.Log('[JSCanvasElement::GetWebGLCanvas] res ', res);
      self.WebGLCanvas = res[0].node;
    });
  };
}

function JSChart(element)
{
  this.JSChartContainer; //画图控件
  this.CanvasElement = element;

  this.AddEventCallback = function (obj) //事件回调  {event:事件id, callback:回调函数}
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.AddEventCallback == 'function')
    {
      _umychartConsoleWechat.JSConsole.Chart.Log('[JSChart:AddEventCallback] ', obj);
      this.JSChartContainer.AddEventCallback(obj);
    }
  };

  this.OnSize = function (option)
  {
    if (option)
    {
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(option.Width)) this.CanvasElement.Width = option.Width;
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(option.Height)) this.CanvasElement.Height = option.Height;
    }

    if (this.JSChartContainer)
    {
      if (option && option.Type == 1 && this.JSChartContainer.OnSize)
      {
        this.JSChartContainer.OnSize();
      } else

      {
        if (this.JSChartContainer.Frame) this.JSChartContainer.Frame.SetSizeChage(true);
        this.JSChartContainer.Draw();
      }
    }
  };

  //历史K线图
  this.CreateKLineChartContainer = function (option)
  {
    var chart = null;
    if (option.Type === "历史K线图横屏") chart = new KLineChartHScreenContainer(this.CanvasElement);else
    chart = new KLineChartContainer(this.CanvasElement);

    if (option.NetworkFilter) chart.NetworkFilter = option.NetworkFilter;

    if (option.KLine) //k线图的属性设置
      {
        if (option.KLine.DragMode >= 0) chart.DragMode = option.KLine.DragMode;
        if (option.KLine.Right >= 0) chart.Right = option.KLine.Right;
        if (option.KLine.Period >= 0) chart.Period = option.KLine.Period;
        if (option.KLine.MaxReqeustDataCount > 0) chart.MaxReqeustDataCount = option.KLine.MaxReqeustDataCount;
        if (option.KLine.Info && option.KLine.Info.length > 0) chart.SetKLineInfo(option.KLine.Info, false);
        if (option.KLine.Policy && option.KLine.Policy.length > 0) chart.SetPolicyInfo(option.KLine.Policy, false);
        if (option.KLine.KLineDoubleClick == false) chart.MinuteDialog = this.MinuteDialog = null;
        if (option.KLine.MaxRequestMinuteDayCount > 0) chart.MaxRequestMinuteDayCount = option.KLine.MaxRequestMinuteDayCount;
        if (option.KLine.DrawType) chart.KLineDrawType = option.KLine.DrawType;
        if (option.KLine.RightSpaceCount >= 0) chart.RightSpaceCount = option.KLine.RightSpaceCount;
        if (option.KLine.DataWidth >= 1) chart.KLineSize = { DataWidth: option.KLine.DataWidth };
      }

    if (option.SplashTitle) chart.LoadDataSplashTitle = option.SplashTitle; //设置提示信息内容
    if (!option.Windows || option.Windows.length <= 0) return null;

    if (option.Language)
    {
      if (option.Language === 'CN') chart.LanguageID = _umychartResourceWechat.JSCommonResource_JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID;else
      if (option.Language === 'EN') chart.LanguageID = _umychartResourceWechat.JSCommonResource_JSCHART_LANGUAGE_ID.LANGUAGE_ENGLISH_ID;
    }

    if (option.SourceDatatLimit) chart.SetSourceDatatLimit(option.SourceDatatLimit);
    if (option.EnableZoomUpDown) chart.EnableZoomUpDown = option.EnableZoomUpDown;
    if (option.ZoomStepPixel > 0) chart.ZoomStepPixel = option.ZoomStepPixel;
    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(option.DrawMoveWaitTime)) chart.DrawMoveWaitTime = option.DrawMoveWaitTime;
    //创建子窗口
    chart.Create(option.Windows.length);

    if (option.Border)
    {
      if (!isNaN(option.Border.Left)) chart.Frame.ChartBorder.Left = option.Border.Left;
      if (!isNaN(option.Border.Right)) chart.Frame.ChartBorder.Right = option.Border.Right;
      if (!isNaN(option.Border.Top)) chart.Frame.ChartBorder.Top = option.Border.Top;
      if (!isNaN(option.Border.Bottom)) chart.Frame.ChartBorder.Bottom = option.Border.Bottom;
    }

    if (option.KLine)
    {
      if (option.KLine.PageSize > 0)
      {
        var maxPageSize = chart.GetMaxPageSize();
        if (maxPageSize < option.KLine.PageSize) chart.PageSize = maxPageSize;else
        chart.PageSize = option.KLine.PageSize;
      }
      if (option.KLine.InfoDrawType) chart.ChartPaint[0].InfoDrawType = option.KLine.InfoDrawType;
    }

    if (option.DragDownload)
    {
      if (option.DragDownload.Day && option.DragDownload.Day.Enable == true) chart.DragDownload.Day.Enable = true;
      if (option.DragDownload.Minute && option.DragDownload.Minute.Enable == true) chart.DragDownload.Minute.Enable = true;
    }

    if (option.IsApiPeriod == true) chart.IsApiPeriod = option.IsApiPeriod;

    if (option.CorssCursorTouchEnd == true) chart.CorssCursorTouchEnd = option.CorssCursorTouchEnd;
    if (option.IsClickShowCorssCursor == true) chart.IsClickShowCorssCursor = option.IsClickShowCorssCursor;
    if (option.IsFullDraw == true) chart.IsFullDraw = option.IsFullDraw;
    if (option.CorssCursorInfo)
    {
      if (!isNaN(option.CorssCursorInfo.Left)) chart.ChartCorssCursor.ShowTextMode.Left = option.CorssCursorInfo.Left;
      if (!isNaN(option.CorssCursorInfo.Right)) chart.ChartCorssCursor.ShowTextMode.Right = option.CorssCursorInfo.Right;
      if (!isNaN(option.CorssCursorInfo.Bottom)) chart.ChartCorssCursor.ShowTextMode.Bottom = option.CorssCursorInfo.Bottom;
      if (option.CorssCursorInfo.IsShowCorss === false) chart.ChartCorssCursor.IsShowCorss = option.CorssCursorInfo.IsShowCorss;
      if (option.CorssCursorInfo.IsShowClose == true) chart.ChartCorssCursor.IsShowClose = option.CorssCursorInfo.IsShowClose; //Y轴显示收盘价
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(option.CorssCursorInfo.HPenType)) chart.ChartCorssCursor.HPenType = option.CorssCursorInfo.HPenType;
      if (option.CorssCursorInfo.VPenType > 0) chart.ChartCorssCursor.VPenType = option.CorssCursorInfo.VPenType;
    }

    if (typeof option.UpdateUICallback == 'function') //数据到达回调
      chart.UpdateUICallback = option.UpdateUICallback;

    if (option.Frame)
    {
      for (var i in option.Frame)
      {
        var item = option.Frame[i];
        if (!chart.Frame.SubFrame[i]) continue;
        if (item.SplitCount) chart.Frame.SubFrame[i].Frame.YSplitOperator.SplitCount = item.SplitCount;
        if (item.StringFormat) chart.Frame.SubFrame[i].Frame.YSplitOperator.StringFormat = item.StringFormat;
        if (!isNaN(item.Height)) chart.Frame.SubFrame[i].Height = item.Height;
        if (item.IsShowBorder == false) chart.Frame.SubFrame[i].Frame.IsShowBorder = item.IsShowBorder;
        if (item.IsShowXLine == false) chart.Frame.SubFrame[i].Frame.IsShowXLine = item.IsShowXLine;
        if (item.IsShowYLine == false) chart.Frame.SubFrame[i].Frame.IsShowYLine = item.IsShowYLine;
        if (item.XMessageAlign == 'bottom') chart.Frame.SubFrame[i].Frame.XMessageAlign = item.XMessageAlign;
        if (item.IsShowTitle == false) chart.Frame.SubFrame[i].Frame.IsShowTitle = false;
        if (item.UpdateTitleUICallback && chart.Frame.SubFrame[i].Frame.TitlePaint) chart.Frame.SubFrame[i].Frame.TitlePaint.UpdateUICallback = item.UpdateTitleUICallback;
        if (item.IsShowLeftText === false || item.IsShowLeftText === true) chart.Frame.SubFrame[i].Frame.IsShowYText[0] = item.IsShowLeftText; //显示左边刻度
        if (item.IsShowRightText === false || item.IsShowRightText === true) chart.Frame.SubFrame[i].Frame.IsShowYText[1] = item.IsShowRightText; //显示右边刻度 
        if (item.TopSpace >= 0) chart.Frame.SubFrame[i].Frame.ChartBorder.TopSpace = item.TopSpace;
        if (item.BottomSpace >= 0) chart.Frame.SubFrame[i].Frame.ChartBorder.BottomSpace = item.BottomSpace;
        if (item.Custom) chart.Frame.SubFrame[i].Frame.YSplitOperator.Custom = item.Custom;
        if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.SplitType)) chart.Frame.SubFrame[i].Frame.YSplitOperator.SplitType = item.SplitType;
        if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.FloatPrecision)) chart.Frame.SubFrame[i].Frame.YSplitOperator.FloatPrecision = item.FloatPrecision; //强制指定小数位数(主图有效)
        if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.BorderLine)) chart.Frame.SubFrame[i].Frame.BorderLine = item.BorderLine;
        if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.YTextBaseline)) chart.Frame.SubFrame[i].Frame.YTextBaseline = item.YTextBaseline;
      }
    }

    if (option.KLine)
    {
      if (option.KLine.ShowKLine == false) chart.ChartPaint[0].IsShow = false;
      if (option.KLine.IsShowMaxMinPrice == false) chart.ChartPaint[0].IsShowMaxMinPrice = false;
    }

    if (option.KLineTitle)
    {
      if (option.KLineTitle.IsShowName == false) chart.TitlePaint[0].IsShowName = false;
      if (option.KLineTitle.IsShowSettingInfo == false) chart.TitlePaint[0].IsShowSettingInfo = false;
      if (option.KLineTitle.IsShow == false) chart.TitlePaint[0].IsShow = false;
      if (option.KLineTitle.UpdateUICallback) chart.TitlePaint[0].UpdateUICallback = option.KLineTitle.UpdateUICallback;
      if (option.KLineTitle.LineCount > 1) chart.TitlePaint[0].LineCount = option.KLineTitle.LineCount;
    }

    //叠加股票 只支持叠加1个股票
    for (var i in option.Overlay)
    {
      var item = option.Overlay[i];
      if (item.Symbol)
      {
        chart.OverlayChartPaint[0].Symbol = item.Symbol;
        if (item.Color) chart.OverlayChartPaint[0].Color = item.Color;
        chart.OverlayChartPaint[0].SetOption(item);
        break;
      }
    }

    if (option.ExtendChart) //创建扩展画法
      {
        for (var i in option.ExtendChart)
        {
          var item = option.ExtendChart[i];
          chart.CreateExtendChart(item.Name, item);
        }
      }

    var scriptData = new _umychartIndexDataWechat.JSCommonIndexScript.JSIndexScript(); //系统指标

    if (option.ColorIndex) //五彩K线
      {
        var item = option.ColorIndex;
        var indexInfo = scriptData.Get(item.Index);
        if (indexInfo) chart.ColorIndex = new _umychartIndexWechat.JSCommonIndex_ScriptIndex(indexInfo.Name, indexInfo.Script, indexInfo.Args, indexInfo); //脚本执行
      }

    if (option.TradeIndex) //交易指标
      {
        var item = option.TradeIndex;
        var _indexInfo = scriptData.Get(item.Index);
        if (_indexInfo) chart.TradeIndex = new _umychartIndexWechat.JSCommonIndex_ScriptIndex(_indexInfo.Name, _indexInfo.Script, _indexInfo.Args, _indexInfo); //脚本执行
      }

    for (var i in option.Windows) //创建子窗口的指标
    {
      var item = option.Windows[i];
      if (item.Script)
      {
        chart.WindowIndex[i] = new _umychartIndexWechat.JSCommonIndex_ScriptIndex(item.Name, item.Script, item.Args, item); //脚本执行
      } else
      if (item.API) //使用API挂接指标数据 API:{ Name:指标名字, Script:指标脚本可以为空, Args:参数可以为空, Url:指标执行地址 }
        {
          var apiItem = item.API;
          chart.WindowIndex[i] = new APIScriptIndex(apiItem.Name, apiItem.Script, apiItem.Args, item);
        } else

      {
        var indexItem = JSIndexMap.Get(item.Index); //自定义指标
        if (indexItem)
        {
          chart.WindowIndex[i] = indexItem.Create();
          chart.CreateWindowIndex(i);
        } else
          //系统指标里查找
          {
            var _indexInfo2 = scriptData.Get(item.Index);
            if (!_indexInfo2) continue;

            if (item.Lock) _indexInfo2.Lock = item.Lock;
            _indexInfo2.ID = item.Index;
            var args = _indexInfo2.Args;
            if (item.Args) args = item.Args;
            chart.WindowIndex[i] = new _umychartIndexWechat.JSCommonIndex_ScriptIndex(_indexInfo2.Name, _indexInfo2.Script, args, _indexInfo2); //脚本执行
            if (item.StringFormat > 0) chart.WindowIndex[i].StringFormat = item.StringFormat;
            if (item.FloatPrecision >= 0) chart.WindowIndex[i].FloatPrecision = item.FloatPrecision;
          }
      }

      if (item.Modify != null) chart.Frame.SubFrame[i].Frame.ModifyIndex = item.Modify;
      if (item.Change != null) chart.Frame.SubFrame[i].Frame.ChangeIndex = item.Change;
      if (item.IsDrawTitleBG == true) chart.Frame.SubFrame[i].Frame.IsDrawTitleBG = item.IsDrawTitleBG;
      if (typeof item.UpdateUICallback == 'function') chart.WindowIndex[i].UpdateUICallback = item.UpdateUICallback;
      if (!isNaN(item.TitleHeight)) chart.Frame.SubFrame[i].Frame.ChartBorder.TitleHeight = item.TitleHeight;
      if (item.IsShowIndexName == false) chart.Frame.SubFrame[i].Frame.IsShowIndexName = false;
      if (item.IndexParamSpace >= 0) chart.Frame.SubFrame[i].Frame.IndexParamSpace = item.IndexParamSpace;
    }

    return chart;
  };

  //自定义指数历史K线图
  this.CreateCustomKLineChartContainer = function (option) {
    var chart = new CustomKLineChartContainer(this.CanvasElement);

    if (option.KLine) //k线图的属性设置
      {
        if (option.KLine.DragMode >= 0) chart.DragMode = option.KLine.DragMode;
        if (option.KLine.Right >= 0) chart.Right = option.KLine.Right;
        if (option.KLine.Period >= 0) chart.Period = option.KLine.Period;
        if (option.KLine.MaxReqeustDataCount > 0) chart.MaxReqeustDataCount = option.KLine.MaxReqeustDataCount;
        if (option.KLine.Info && option.KLine.Info.length > 0) chart.SetKLineInfo(option.KLine.Info, false);
        if (option.KLine.KLineDoubleClick == false) chart.MinuteDialog = this.MinuteDialog = null;
        if (option.KLine.PageSize > 0) chart.PageSize = option.KLine.PageSize;
        if (option.KLine.IsShowTooltip == false) chart.IsShowTooltip = false;
      }

    if (option.CustomStock) chart.CustomStock = option.CustomStock;
    if (option.QueryDate) chart.QueryDate = option.QueryDate;
    if (typeof option.UpdateUICallback == 'function') chart.UpdateUICallback = option.UpdateUICallback;

    if (!option.Windows || option.Windows.length <= 0) return null;

    //创建子窗口
    chart.Create(option.Windows.length);

    if (option.Border) {
      if (!isNaN(option.Border.Left)) chart.Frame.ChartBorder.Left = option.Border.Left;
      if (!isNaN(option.Border.Right)) chart.Frame.ChartBorder.Right = option.Border.Right;
      if (!isNaN(option.Border.Top)) chart.Frame.ChartBorder.Top = option.Border.Top;
      if (!isNaN(option.Border.Bottom)) chart.Frame.ChartBorder.Bottom = option.Border.Bottom;

    }

    if (option.IsShowCorssCursorInfo == false) //取消显示十字光标刻度信息
      {
        chart.ChartCorssCursor.IsShowText = option.IsShowCorssCursorInfo;
      }

    if (option.Frame) {
      for (var i in option.Frame) {
        var item = option.Frame[i];
        if (item.SplitCount) chart.Frame.SubFrame[i].Frame.YSplitOperator.SplitCount = item.SplitCount;
        if (item.StringFormat) chart.Frame.SubFrame[i].Frame.YSplitOperator.StringFormat = item.StringFormat;
        if (item.XMessageAlign == 'bottom') chart.Frame.SubFrame[i].Frame.XMessageAlign = item.XMessageAlign;
      }
    }

    if (option.KLineTitle) {
      if (option.KLineTitle.IsShowName == false) chart.TitlePaint[0].IsShowName = false;
      if (option.KLineTitle.IsShowSettingInfo == false) chart.TitlePaint[0].IsShowSettingInfo = false;
    }

    //创建子窗口的指标
    var scriptData = new _umychartIndexDataWechat.JSCommonIndexScript.JSIndexScript();
    for (var i in option.Windows) {
      var item = option.Windows[i];
      if (item.Script) {
        chart.WindowIndex[i] = new _umychartIndexWechat.JSCommonIndex_ScriptIndex(item.Name, item.Script, item.Args, item); //脚本执行
      } else
      {
        var indexItem = JSIndexMap.Get(item.Index);
        if (indexItem) {
          chart.WindowIndex[i] = indexItem.Create();
          chart.CreateWindowIndex(i);
        } else
          //系统指标里查找
          {
            var indexInfo = scriptData.Get(item.Index);
            if (!indexInfo) continue;

            if (item.Lock) indexInfo.Lock = item.Lock;
            chart.WindowIndex[i] = new _umychartIndexWechat.JSCommonIndex_ScriptIndex(indexInfo.Name, indexInfo.Script, indexInfo.Args, indexInfo); //脚本执行
          }
      }

      if (item.Modify != null)
      chart.Frame.SubFrame[i].Frame.ModifyIndex = item.Modify;
      if (item.Change != null)
      chart.Frame.SubFrame[i].Frame.ChangeIndex = item.Change;

      if (!isNaN(item.TitleHeight)) chart.Frame.SubFrame[i].Frame.ChartBorder.TitleHeight = item.TitleHeight;
    }

    return chart;
  };

  //分钟走势图
  this.CreateMinuteChartContainer = function (option)
  {
    var chart = null;
    if (option.Type === "分钟走势图横屏") chart = new MinuteChartHScreenContainer(this.CanvasElement);else
    chart = new MinuteChartContainer(this.CanvasElement);
    if (option.NetworkFilter) chart.NetworkFilter = option.NetworkFilter;

    var windowsCount = 2;
    if (option.Windows && option.Windows.length > 0) windowsCount += option.Windows.length; //指标窗口从第3个窗口开始
    if (option.EnableScrollUpDown == true) chart.EnableScrollUpDown = option.EnableScrollUpDown;

    if (option.Info && option.Info.length > 0) chart.SetMinuteInfo(option.Info, false);
    if (option.SplashTitle) chart.LoadDataSplashTitle = option.SplashTitle; //设置提示信息内容
    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(option.DrawMoveWaitTime)) chart.DrawMoveWaitTime = option.DrawMoveWaitTime;

    if (option.Language)
    {
      if (option.Language === 'CN') chart.LanguageID = _umychartResourceWechat.JSCommonResource_JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID;else
      if (option.Language === 'EN') chart.LanguageID = _umychartResourceWechat.JSCommonResource_JSCHART_LANGUAGE_ID.LANGUAGE_ENGLISH_ID;
    }

    chart.Create(windowsCount); //创建子窗口

    if (option.CorssCursorTouchEnd == true) chart.CorssCursorTouchEnd = option.CorssCursorTouchEnd;
    if (option.IsFullDraw == true) chart.IsFullDraw = option.IsFullDraw;
    if (option.CorssCursorInfo) //十字光标设置
      {
        if (!isNaN(option.CorssCursorInfo.Left)) chart.ChartCorssCursor.ShowTextMode.Left = option.CorssCursorInfo.Left;
        if (!isNaN(option.CorssCursorInfo.Right)) chart.ChartCorssCursor.ShowTextMode.Right = option.CorssCursorInfo.Right;
        if (!isNaN(option.CorssCursorInfo.Bottom)) chart.ChartCorssCursor.ShowTextMode.Bottom = option.CorssCursorInfo.Bottom;
        if (option.CorssCursorInfo.IsShowCorss === false) chart.ChartCorssCursor.IsShowCorss = option.CorssCursorInfo.IsShowCorss;
        if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsBool(option.CorssCursorInfo.IsFixXLastTime)) chart.ChartCorssCursor.IsFixXLastTime = option.CorssCursorInfo.IsFixXLastTime;
      }

    if (option.MinuteInfo) chart.CreateMinuteInfo(option.MinuteInfo);
    if (option.DayCount > 1) chart.DayCount = option.DayCount;

    if (option.Border)
    {
      if (!isNaN(option.Border.Left)) chart.Frame.ChartBorder.Left = option.Border.Left;
      if (!isNaN(option.Border.Right)) chart.Frame.ChartBorder.Right = option.Border.Right;
      if (!isNaN(option.Border.Top)) chart.Frame.ChartBorder.Top = option.Border.Top;
      if (!isNaN(option.Border.Bottom)) chart.Frame.ChartBorder.Bottom = option.Border.Bottom;
    }

    if (option.Frame)
    {
      for (var i in option.Frame)
      {
        var item = option.Frame[i];
        if (!chart.Frame.SubFrame[i]) continue;
        if (item.SplitCount) chart.Frame.SubFrame[i].Frame.YSplitOperator.SplitCount = item.SplitCount;
        if (item.StringFormat) chart.Frame.SubFrame[i].Frame.YSplitOperator.StringFormat = item.StringFormat;
        if (item.XMessageAlign == 'bottom') chart.Frame.SubFrame[i].Frame.XMessageAlign = item.XMessageAlign;
        if (item.IsShowLeftText === false || item.IsShowLeftText === true) chart.Frame.SubFrame[i].Frame.IsShowYText[0] = item.IsShowLeftText; //显示左边刻度
        if (item.IsShowRightText === false || item.IsShowRightText === true) chart.Frame.SubFrame[i].Frame.IsShowYText[1] = item.IsShowRightText; //显示右边刻度
        if (item.Height >= 0) chart.Frame.SubFrame[i].Height = item.Height;
        if (item.Custom) chart.Frame.SubFrame[i].Frame.YSplitOperator.Custom = item.Custom;
        if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.BorderLine)) chart.Frame.SubFrame[i].Frame.BorderLine = item.BorderLine;
        if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.YTextBaseline)) chart.Frame.SubFrame[i].Frame.YTextBaseline = item.YTextBaseline;
      }

      chart.UpdateXShowText();
    }

    if (option.MinuteTitle)
    {
      if (option.MinuteTitle.IsShowName == false) chart.TitlePaint[0].IsShowName = false;
      if (option.MinuteTitle.IsShow == false) chart.TitlePaint[0].IsShow = false;
      if (option.MinuteTitle.UpdateUICallback) chart.TitlePaint[0].UpdateUICallback = option.MinuteTitle.UpdateUICallback;
      if (option.MinuteTitle.LineCount > 1) chart.TitlePaint[0].LineCount = option.MinuteTitle.LineCount;
    }

    if (typeof option.UpdateUICallback == 'function') //数据到达回调
      chart.UpdateUICallback = option.UpdateUICallback;

    if (option.ExtendChart) //创建扩展画法
      {
        for (var i in option.ExtendChart) {
          var item = option.ExtendChart[i];
          chart.CreateExtendChart(item.Name, item);
        }
      }

    //叠加股票 只支持1只股票
    for (var i in option.Overlay)
    {
      var item = option.Overlay[i];
      if (item.Symbol)
      {
        chart.OverlayChartPaint[0].Symbol = item.Symbol;
        if (item.Color) chart.OverlayChartPaint[0].Color = item.Color;
        break;
      }
    }
    if (option.Overlay && option.Overlay.length)
    {
      chart.OverlayChartPaint[0].Symbol = option.Overlay[0].Symbol;
    }

    if (option.MinuteLine)
    {
      if (option.MinuteLine.IsDrawAreaPrice == false) chart.ChartPaint[0].IsDrawArea = false;
      if (option.MinuteLine.IsShowAveragePrice == false)
      {
        chart.ChartPaint[1].IsShow = false;
        chart.TitlePaint[0].IsShowAveragePrice = false; //标题栏均线也不显示
        for (var i in chart.ExtendChartPaint)
        {
          var item = chart.ExtendChartPaint[i];
          if (item.ClassName == "MinuteTooltipPaint") item.IsShowAveragePrice = false;
        }
      }
    }

    var scriptData = new _umychartIndexDataWechat.JSCommonIndexScript.JSIndexScript();
    for (var i in option.Windows) //分钟数据指标从第3个指标窗口设置
    {
      var item = option.Windows[i];
      if (item.Script)
      {
        chart.WindowIndex[2 + parseInt(i)] = new _umychartIndexWechat.JSCommonIndex_ScriptIndex(item.Name, item.Script, item.Args, item); //脚本执行
      } else

      {
        var indexItem = JSIndexMap.Get(item.Index);
        if (indexItem)
        {
          chart.WindowIndex[2 + parseInt(i)] = indexItem.Create(); //创建子窗口的指标
          chart.CreateWindowIndex(2 + parseInt(i));
        } else

        {
          var indexInfo = scriptData.Get(item.Index);
          if (!indexInfo) continue;
          var args = indexInfo.Args;
          if (item.Args) args = item.Args;
          if (item.Lock) indexInfo.Lock = item.Lock;
          chart.WindowIndex[2 + parseInt(i)] = new _umychartIndexWechat.JSCommonIndex_ScriptIndex(indexInfo.Name, indexInfo.Script, args, indexInfo); //脚本执行
          if (item.StringFormat > 0) chart.WindowIndex[2 + parseInt(i)].StringFormat = item.StringFormat;
          if (item.FloatPrecision >= 0) chart.WindowIndex[2 + parseInt(i)].FloatPrecision = item.FloatPrecision;
        }
      }

      if (!isNaN(item.TitleHeight)) chart.Frame.SubFrame[2 + parseInt(i)].Frame.ChartBorder.TitleHeight = item.TitleHeight; //指标标题高度
    }

    return chart;
  };

  //历史分钟走势图
  this.CreateHistoryMinuteChartContainer = function (option) {
    var chart = new HistoryMinuteChartContainer(this.CanvasElement);

    var windowsCount = 2;
    if (option.Windows && option.Windows.length > 0) windowsCount += option.Windows.length; //指标窗口从第3个窗口开始

    chart.Create(windowsCount); //创建子窗口

    if (option.IsShowCorssCursorInfo == false) //取消显示十字光标刻度信息
      {
        chart.ChartCorssCursor.IsShowText = option.IsShowCorssCursorInfo;
      }

    if (option.Border) {
      if (!isNaN(option.Border.Left)) chart.Frame.ChartBorder.Left = option.Border.Left;
      if (!isNaN(option.Border.Right)) chart.Frame.ChartBorder.Right = option.Border.Right;
      if (!isNaN(option.Border.Top)) chart.Frame.ChartBorder.Top = option.Border.Top;
      if (!isNaN(option.Border.Bottom)) chart.Frame.ChartBorder.Bottom = option.Border.Bottom;
    }

    if (option.Frame) {
      for (var i in option.Frame) {
        var item = option.Frame[i];
        if (item.SplitCount) chart.Frame.SubFrame[i].Frame.YSplitOperator.SplitCount = item.SplitCount;
        if (item.StringFormat) chart.Frame.SubFrame[i].Frame.YSplitOperator.StringFormat = item.StringFormat;
        if (item.XMessageAlign == 'bottom') chart.Frame.SubFrame[i].Frame.XMessageAlign = item.XMessageAlign;
      }
    }

    var scriptData = new _umychartIndexDataWechat.JSCommonIndexScript.JSIndexScript();
    for (var i in option.Windows) //分钟数据指标从第3个指标窗口设置
    {
      var item = option.Windows[i];
      if (item.Script) {
        chart.WindowIndex[2 + parseInt(i)] = new _umychartIndexWechat.JSCommonIndex_ScriptIndex(item.Name, item.Script, item.Args, item); //脚本执行
      } else
      {
        var indexItem = JSIndexMap.Get(item.Index);
        if (indexItem) {
          chart.WindowIndex[2 + parseInt(i)] = indexItem.Create(); //创建子窗口的指标
          chart.CreateWindowIndex(2 + parseInt(i));
        } else
        {
          var indexInfo = scriptData.Get(item.Index);
          if (!indexInfo) continue;

          if (item.Lock) indexInfo.Lock = item.Lock;
          chart.WindowIndex[2 + parseInt(i)] = new _umychartIndexWechat.JSCommonIndex_ScriptIndex(indexInfo.Name, indexInfo.Script, indexInfo.Args, indexInfo); //脚本执行
        }
      }

      if (!isNaN(item.TitleHeight)) chart.Frame.SubFrame[2 + parseInt(i)].Frame.ChartBorder.TitleHeight = item.TitleHeight;
    }

    chart.TradeDate = 20181009;
    if (option.HistoryMinute) {
      if (option.HistoryMinute.TradeDate) chart.TradeDate = option.HistoryMinute.TradeDate;
      if (option.HistoryMinute.IsShowName != null) chart.TitlePaint[0].IsShowName = option.HistoryMinute.IsShowName; //动态标题是否显示股票名称
      if (option.HistoryMinute.IsShowDate != null) chart.TitlePaint[0].IsShowDate = option.HistoryMinute.IsShowDate; //动态标题是否显示日期
    }

    return chart;
  };

  this.CreateKLineTrainChartContainer = function (option)
  {
    var bHScreen = option.Type == 'K线训练横屏' ? true : false;
    var chart = new KLineTrainChartContainer(this.CanvasElement, bHScreen);

    if (option.NetworkFilter) chart.NetworkFilter = option.NetworkFilter;
    if (option.IsApiPeriod == true) chart.IsApiPeriod = option.IsApiPeriod;

    if (option.KLine) //k线图的属性设置
      {
        if (option.KLine.Right >= 0) chart.Right = option.KLine.Right;
        if (option.KLine.Period >= 0) chart.Period = option.KLine.Period;
        if (option.KLine.MaxReqeustDataCount > 0) chart.MaxReqeustDataCount = option.KLine.MaxReqeustDataCount;
        if (option.KLine.Info && option.KLine.Info.length > 0) chart.SetKLineInfo(option.KLine.Info, false);
        if (option.KLine.PageSize > 0) chart.PageSize = option.KLine.PageSize;
        if (option.KLine.IsShowTooltip == false) chart.IsShowTooltip = false;
        if (option.KLine.MaxRequestMinuteDayCount > 0) chart.MaxRequestMinuteDayCount = option.KLine.MaxRequestMinuteDayCount;
        if (option.KLine.DrawType) chart.KLineDrawType = option.KLine.DrawType;
      }

    if (option.Train)
    {
      if (option.Train.DataCount) chart.TrainDataCount = option.Train.DataCount;
      if (option.Train.Callback) chart.TrainCallback = option.Train.Callback;
      if (option.Train.StartDate) chart.TrainStartDate = option.Train.StartDate;
    }

    if (!option.Windows || option.Windows.length <= 0) return null;

    //创建子窗口
    chart.Create(option.Windows.length);

    if (option.Border)
    {
      if (!isNaN(option.Border.Left)) chart.Frame.ChartBorder.Left = option.Border.Left;
      if (!isNaN(option.Border.Right)) chart.Frame.ChartBorder.Right = option.Border.Right;
      if (!isNaN(option.Border.Top)) chart.Frame.ChartBorder.Top = option.Border.Top;
      if (!isNaN(option.Border.Bottom)) chart.Frame.ChartBorder.Bottom = option.Border.Bottom;
    }

    if (option.ExtendChart) //创建扩展画法
      {
        for (var i in option.ExtendChart)
        {
          var item = option.ExtendChart[i];
          chart.CreateExtendChart(item.Name, item);
        }
      }

    if (option.IsShowCorssCursorInfo == false) chart.ChartCorssCursor.IsShowText = option.IsShowCorssCursorInfo; //取消显示十字光标刻度信息
    if (option.CorssCursorTouchEnd == true) chart.CorssCursorTouchEnd = option.CorssCursorTouchEnd;
    if (option.IsClickShowCorssCursor == true) chart.IsClickShowCorssCursor = option.IsClickShowCorssCursor;
    if (option.IsFullDraw == true) chart.IsFullDraw = option.IsFullDraw;

    if (option.CorssCursorInfo)
    {
      if (!isNaN(option.CorssCursorInfo.Left)) chart.ChartCorssCursor.ShowTextMode.Left = option.CorssCursorInfo.Left;
      if (!isNaN(option.CorssCursorInfo.Right)) chart.ChartCorssCursor.ShowTextMode.Right = option.CorssCursorInfo.Right;
      if (!isNaN(option.CorssCursorInfo.Bottom)) chart.ChartCorssCursor.ShowTextMode.Bottom = option.CorssCursorInfo.Bottom;
      if (option.CorssCursorInfo.IsShowCorss === false) chart.ChartCorssCursor.IsShowCorss = option.CorssCursorInfo.IsShowCorss;
      if (option.CorssCursorInfo.IsShowClose == true) chart.ChartCorssCursor.IsShowClose = option.CorssCursorInfo.IsShowClose; //Y轴显示收盘价
      if (option.CorssCursorInfo.HPenType > 0) chart.ChartCorssCursor.HPenType = option.CorssCursorInfo.HPenType;
      if (option.CorssCursorInfo.VPenType > 0) chart.ChartCorssCursor.VPenType = option.CorssCursorInfo.VPenType;
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsBool(option.CorssCursorInfo.IsFixXLastTime)) chart.ChartCorssCursor.IsFixXLastTime = option.CorssCursorInfo.IsFixXLastTime;
    }

    if (option.Frame)
    {
      for (var i in option.Frame)
      {
        if (!chart.Frame.SubFrame[i]) continue;
        var item = option.Frame[i];
        if (item.SplitCount) chart.Frame.SubFrame[i].Frame.YSplitOperator.SplitCount = item.SplitCount;
        if (item.StringFormat) chart.Frame.SubFrame[i].Frame.YSplitOperator.StringFormat = item.StringFormat;
        if (item.Height > 0) chart.Frame.SubFrame[i].Height = item.Height;
        if (item.IsShowLeftText === false || item.IsShowLeftText === true) chart.Frame.SubFrame[i].Frame.IsShowYText[0] = item.IsShowLeftText; //显示左边刻度
        if (item.IsShowRightText === false || item.IsShowRightText === true) chart.Frame.SubFrame[i].Frame.IsShowYText[1] = item.IsShowRightText; //显示右边刻度 
      }
    }

    if (option.KLine)
    {
      if (option.KLine.ShowKLine == false) chart.ChartPaint[0].IsShow = false;
      if (option.KLine.IsShowMaxMinPrice == false) chart.ChartPaint[0].IsShowMaxMinPrice = false;
    }

    //股票名称 日期 周期都不显示
    chart.TitlePaint[0].IsShowName = false;
    chart.TitlePaint[0].IsShowSettingInfo = false;
    chart.TitlePaint[0].IsShowDateTime = false;

    //创建子窗口的指标
    var scriptData = new _umychartIndexDataWechat.JSCommonIndexScript.JSIndexScript();
    for (var i in option.Windows)
    {
      var item = option.Windows[i];
      if (item.Script)
      {
        chart.WindowIndex[i] = new _umychartIndexWechat.JSCommonIndex_ScriptIndex(item.Name, item.Script, item.Args, item); //脚本执行
      } else

      {
        var indexItem = JSIndexMap.Get(item.Index);
        if (indexItem)
        {
          chart.WindowIndex[i] = indexItem.Create();
          chart.CreateWindowIndex(i);
        } else

        {
          var indexInfo = scriptData.Get(item.Index);
          if (!indexInfo) continue;

          if (item.Lock) indexInfo.Lock = item.Lock;
          chart.WindowIndex[i] = new _umychartIndexWechat.JSCommonIndex_ScriptIndex(indexInfo.Name, indexInfo.Script, indexInfo.Args, indexInfo); //脚本执行
        }

      }

      if (item.Modify != null) chart.Frame.SubFrame[i].Frame.ModifyIndex = item.Modify;
      if (item.Change != null) chart.Frame.SubFrame[i].Frame.ChangeIndex = item.Change;
      if (!isNaN(item.TitleHeight)) chart.Frame.SubFrame[i].Frame.ChartBorder.TitleHeight = item.TitleHeight;
    }

    return chart;
  };

  //深度图
  this.CreateDepthChartContainer = function (option)
  {
    var chart = null;
    chart = new DepthChartContainer(this.CanvasElement);
    if (option.NetworkFilter) chart.NetworkFilter = option.NetworkFilter;

    if (option.EnableScrollUpDown == true) chart.EnableScrollUpDown = option.EnableScrollUpDown;
    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsPlusNumber(option.MaxVolRate)) chart.MaxVolRate = option.MaxVolRate;
    if (option.ZoomStepPixel > 0) chart.ZoomStepPixel = option.ZoomStepPixel;

    chart.Create(option.Listener);

    if (option.Border)
    {
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(option.Border.Left)) chart.Frame.ChartBorder.Left = option.Border.Left;else
      option.Border.Left = chart.Frame.ChartBorder.Left;
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(option.Border.Right)) chart.Frame.ChartBorder.Right = option.Border.Right;else
      option.Border.Right = chart.Frame.ChartBorder.Right;
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(option.Border.Top)) chart.Frame.ChartBorder.Top = option.Border.Top;else
      option.Border.Top = chart.Frame.ChartBorder.Top;
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(option.Border.Bottom)) chart.Frame.ChartBorder.Bottom = option.Border.Bottom;else
      option.Border.Bottom = chart.Frame.ChartBorder.Bottom;
    }
    if (option.IsFullDraw == true) chart.IsFullDraw = option.IsFullDraw;

    if (option.CorssCursorTouchEnd === true) chart.CorssCursorTouchEnd = option.CorssCursorTouchEnd;

    if (option.CorssCursorInfo)
    {
      var item = option.CorssCursorInfo;
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.HPenType)) chart.ChartCorssCursor.HPenType = item.HPenType;
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.VPenType)) chart.ChartCorssCursor.VPenType = item.VPenType;
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsBool(item.IsShowTooltip)) chart.ChartCorssCursor.IsShowTooltip = item.IsShowTooltip;
    }

    if (option.Frame)
    {
      var item = option.Frame;
      if (item.SplitCount) chart.Frame.YSplitOperator.SplitCount = item.SplitCount;
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.SplitType)) chart.Frame.YSplitOperator.SplitType = item.SplitType;
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Height)) chart.Frame.Height = item.Height;
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.LineType)) chart.Frame.YSplitOperator.LineType = item.LineType;
      if (Array.isArray(item.IgnoreYValue)) chart.Frame.YSplitOperator.IgnoreYValue = item.IgnoreYValue;
      if (item.IsShowLeftText === false || item.IsShowLeftText === true)
      {
        chart.Frame.IsShowYText[0] = item.IsShowLeftText;
        chart.Frame.YSplitOperator.IsShowLeftText = item.IsShowLeftText; //显示左边刻度
      }
      if (item.IsShowRightText === false || item.IsShowRightText === true)
      {
        chart.Frame.IsShowYText[1] = item.IsShowRightText;
        chart.Frame.YSplitOperator.IsShowRightText = item.IsShowRightText; //显示右边刻度
      }

      if (item.IsShowXLine == false) chart.Frame.IsShowXLine = item.IsShowXLine;
      if (item.IsShowYLine == false) chart.Frame.IsShowYLine = item.IsShowYLine;
    }

    return chart;
  };

  //根据option内容绘制图形
  this.SetOption = function (option)
  {
    _umychartConsoleWechat.JSConsole.Chart.Log('[JSChart::SetOption]', option);
    var chart = null;
    switch (option.Type) {

      case "历史K线图":
      case '历史K线图横屏':
        chart = this.CreateKLineChartContainer(option);
        break;
      case "自定义指数历史K线图":
        chart = this.CreateCustomKLineChartContainer(option);
        break;
      case "分钟走势图":
      case "分钟走势图横屏":
        chart = this.CreateMinuteChartContainer(option);
        break;
      case "历史分钟走势图":
        chart = this.CreateHistoryMinuteChartContainer(option);
        break;
      case 'K线训练':
      case 'K线训练横屏':
        chart = this.CreateKLineTrainChartContainer(option);
        break;
      case "深度图":
        chart = this.CreateDepthChartContainer(option);
        break;
      case "简单图形":
        return this.CreateSimpleChart(option);
      case '雷达图':
      case "饼图":
        return this.CreatePieChart(option);
      case '地图':
        return this.CreateMapChart(option);
      default:
        return false;}


    if (!chart) return false;

    //是否自动更新
    if (option.IsAutoUpdate == true || option.IsAutoUpate == true) chart.IsAutoUpdate = true;
    if (option.AutoUpdateFrequency > 0) chart.AutoUpdateFrequency = option.AutoUpdateFrequency;

    //注册事件
    for (var i in option.EventCallback)
    {
      var item = option.EventCallback[i];
      chart.AddEventCallback(item);
    }

    //设置股票代码
    if (!option.Symbol) return false;
    this.JSChartContainer = chart;

    chart.Draw();
    chart.ChangeSymbol(option.Symbol);


    this.JSChartContainer.Draw();
  };

  //切换股票代码接口
  this.ChangeSymbol = function (symbol)
  {
    if (this.JSChartContainer) this.JSChartContainer.ChangeSymbol(symbol);
  };

  //K线切换指标
  this.ChangeIndex = function (windowIndex, indexName, option)
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.ChangeIndex == 'function')
    this.JSChartContainer.ChangeIndex(windowIndex, indexName, option);
  };

  //切换K线指标
  this.ChangeScriptIndex = function (windowIndex, indexData)
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.ChangeScriptIndex == 'function')
    this.JSChartContainer.ChangeScriptIndex(windowIndex, indexData);
  };

  //获取当前显示的指标信息
  this.GetIndexInfo = function ()
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.GetIndexInfo == 'function')
    return this.JSChartContainer.GetIndexInfo();else

    return [];
  };

  //K线周期切换
  this.ChangePeriod = function (period, option)
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.ChangePeriod == 'function')
    this.JSChartContainer.ChangePeriod(period, option);
  };

  //切换系统指示
  this.ChangeInstructionIndex = function (indexName)
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.ChangeInstructionIndex == 'function')
    this.JSChartContainer.ChangeInstructionIndex(indexName);
  };

  //切换自定义指示
  this.ChangeInstructionScriptIndex = function (indexData)
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.ChangeInstructionIndex == 'function')
    this.JSChartContainer.ChangeInstructionScriptIndex(indexData);
  };

  //增加一个指标窗口
  this.AddIndexWindow = function (indexName, option)
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.AddIndexWindow == 'function')
    this.JSChartContainer.AddIndexWindow(indexName, option);
  };

  //删除一个指标窗口
  this.RemoveIndexWindow = function (id)
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.RemoveIndexWindow == 'function')
    this.JSChartContainer.RemoveIndexWindow(id);
  };

  //取消指示
  this.CancelInstructionIndex = function ()
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.CancelInstructionIndex == 'function')
    this.JSChartContainer.CancelInstructionIndex();
  };

  //切换指标模板
  this.ChangeIndexTemplate = function (option)
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.ChangeIndexTemplate == 'function') {
      _umychartConsoleWechat.JSConsole.Chart.Log('[JSChart:ChangeIndexTemplate] ', option);
      this.JSChartContainer.ChangeIndexTemplate(option);
    }
  };

  //K线复权切换
  this.ChangeRight = function (right)
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.ChangeRight == 'function')
    this.JSChartContainer.ChangeRight(right);
  };

  //K线切换类型 0=实心K线 1=收盘价线 2=美国线 3=空心K线
  this.ChangeKLineDrawType = function (drawType)
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.ChangeKLineDrawType == 'function')
    this.JSChartContainer.ChangeKLineDrawType(drawType);
  };

  //切换数据类
  this.ChangMainDataControl = function (dataControl)
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.SetMainDataConotrl == 'function')
    this.JSChartContainer.SetMainDataConotrl(dataControl);
  };

  //叠加股票
  this.OverlaySymbol = function (symbol, option)
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.OverlaySymbol == 'function')
    this.JSChartContainer.OverlaySymbol(symbol, option);
  };

  //设置强制横屏
  this.ForceLandscape = function (bForceLandscape) {
    if (this.JSChartContainer) {
      _umychartConsoleWechat.JSConsole.Chart.Log("[JSChart::ForceLandscape] bForceLandscape=" + bForceLandscape);
      this.JSChartContainer.IsForceLandscape = bForceLandscape;
    }
  };

  //锁|解锁指标
  this.LockIndex = function (lockData)
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.LockIndex == 'function')
    {
      _umychartConsoleWechat.JSConsole.Chart.Log('[JSChart:LockIndex] lockData', lockData);
      this.JSChartContainer.LockIndex(lockData);
    }
  };

  //历史分钟数据 更改日期
  this.ChangeTradeDate = function (tradeDate)
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.ChangeTradeDate == 'function')
    {
      _umychartConsoleWechat.JSConsole.Chart.Log('[JSChart:ChangeTradeDate] date', tradeDate);
      this.JSChartContainer.ChangeTradeDate(tradeDate);
    }
  };

  //多日走势图
  this.ChangeDayCount = function (count)
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.ChangeDayCount == 'function')
    {
      _umychartConsoleWechat.JSConsole.Chart.Log('[JSChart:ChangeDayCount] count', count);
      this.JSChartContainer.ChangeDayCount(count);
    }
  };

  this.StopAutoUpdate = function ()
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.StopAutoUpdate == 'function') {
      _umychartConsoleWechat.JSConsole.Chart.Log("[JSChart::StopAutoUpdate] Stop.");
      this.JSChartContainer.StopAutoUpdate();
    }
  };
  this.StopAutoUpdata = this.StopAutoUpdate;

  this.ChartDestory = function ()
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.ChartDestory == 'function') {
      _umychartConsoleWechat.JSConsole.Chart.Log("[JSChart::ChartDestory]");
      this.JSChartContainer.ChartDestory();
    }
  };

  this.CreateSimpleChart = function (option)
  {
    var chart = new SimlpleChartContainer(this.CanvasElement);
    if (option.MainDataControl) chart.MainDataControl = option.MainDataControl;
    if (option.FrameType > 0) chart.FrameType = option.FrameType;
    if (!isNaN(option.SplitCount)) chart.YSplitCount = option.SplitCount;

    chart.Create();

    if (option.Border) //边框设置
      {
        if (!isNaN(option.Border.Left)) chart.Frame.ChartBorder.Left = option.Border.Left;
        if (!isNaN(option.Border.Right)) chart.Frame.ChartBorder.Right = option.Border.Right;
        if (!isNaN(option.Border.Top)) chart.Frame.ChartBorder.Top = option.Border.Top;
        if (!isNaN(option.Border.Bottom)) chart.Frame.ChartBorder.Bottom = option.Border.Bottom;
        if (!isNaN(option.Border.TitleHeight)) chart.Frame.ChartBorder.TitleHeight = option.Border.TitleHeight;
      }

    if (option.XFontType) chart.Frame.XFontType = option.XFontType;

    if (option.Frame)
    {
      if (option.Frame[0].MaxDistanceWidth) chart.Frame.MaxDistanceWidth = option.Frame[0].MaxDistanceWidth;
      if (option.Frame[0].IsShowBorder != null) chart.Frame.IsShowBorder = option.Frame[0].IsShowBorder;
      if (option.Frame[0].StringFormat) chart.Frame.YSplitOperator.StringFormat = option.Frame[0].StringFormat;
      if (option.Frame[0].FloatPrecision >= 0) chart.Frame.YSplitOperator.FloatPrecision = option.Frame[0].FloatPrecision;
      if (option.Frame[0].IgnoreYValue) chart.Frame.YSplitOperator.IgnoreYValue = option.Frame[0].IgnoreYValue;
    }

    chart.Draw();
    chart.RequestData();

    this.JSChartContainer = chart;
    this.JSChartContainer.Draw();
  };

  //创建饼图
  this.CreatePieChart = function (option) {
    var chart = new PieChartContainer(this.CanvasElement);
    if (option.MainDataControl) chart.MainDataControl = option.MainDataControl;

    if (option.Radius) chart.Radius = option.Radius;

    chart.Create();

    if (option.Border) //边框设置
      {
        if (!isNaN(option.Border.Left)) chart.Frame.ChartBorder.Left = option.Border.Left;
        if (!isNaN(option.Border.Right)) chart.Frame.ChartBorder.Right = option.Border.Right;
        if (!isNaN(option.Border.Top)) chart.Frame.ChartBorder.Top = option.Border.Top;
        if (!isNaN(option.Border.Bottom)) chart.Frame.ChartBorder.Bottom = option.Border.Bottom;
      }

    if (option.Frame) {
      if (option.Frame[0].IsShowBorder == false) chart.Frame.IsShowBorder = option.Frame[0].IsShowBorder;
    }

    chart.Draw();
    chart.RequestData();

    this.JSChartContainer = chart;
    this.JSChartContainer.Draw();

  };

  //中国地图
  this.CreateMapChart = function (option) {
    var chart = new MapChartContainer(this.CanvasElement);
    if (option.MainDataControl) chart.MainDataControl = option.MainDataControl;

    chart.Create();

    if (option.Border) //边框设置
      {
        if (!isNaN(option.Border.Left)) chart.Frame.ChartBorder.Left = option.Border.Left;
        if (!isNaN(option.Border.Right)) chart.Frame.ChartBorder.Right = option.Border.Right;
        if (!isNaN(option.Border.Top)) chart.Frame.ChartBorder.Top = option.Border.Top;
        if (!isNaN(option.Border.Bottom)) chart.Frame.ChartBorder.Bottom = option.Border.Bottom;
      }

    if (option.Frame) {
      if (option.Frame[0].IsShowBorder == false) chart.Frame.IsShowBorder = option.Frame[0].IsShowBorder;
    }

    chart.Draw();
    chart.RequestData();

    this.JSChartContainer = chart;
    this.JSChartContainer.Draw();
  };

  this.OnTouchStart = function (e) {
    if (this.JSChartContainer) this.JSChartContainer.ontouchstart(e);
  };

  this.OnTouchMove = function (e) {
    if (this.JSChartContainer) this.JSChartContainer.ontouchmove(e);
  };

  this.OnTouchEnd = function (e)
  {
    if (this.JSChartContainer) this.JSChartContainer.ontouchend(e);
  };

  this.SaveToImage = function (callback)
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.SaveToImage == 'function')
    this.JSChartContainer.SaveToImage(callback);
  };

  this.EnableSplashScreen = function (option)
  {
    if (this.JSChartContainer && typeof this.JSChartContainer.EnableSplashScreen == 'function')
    this.JSChartContainer.EnableSplashScreen(option);
  };

}

//初始化
JSChart.Init = function (uielement) {
  _umychartConsoleWechat.JSConsole.Chart.Log('[JSChart.Init] uielement', uielement);
  var jsChartControl = new JSChart(uielement);
  jsChartControl.OnSize();

  return jsChartControl;
};

JSChart.SetDomain = function (domain, cacheDomain) {
  if (domain) {
    _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Domain = domain;

    _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.StockHistoryDayApiUrl = domain + "/API/StockHistoryDay"; //历史数据api
    _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.MarketLongShortApiUrl = domain + "/API/FactorTiming"; //市场多空
    _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.MarketAttentionApiUrl = domain + "/API/MarketAttention"; //市场关注度
    _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.MarketHeatApiUrl = domain + "/API/MarketHeat"; //行业,指数热度

  }

  if (cacheDomain) _umychartResourceWechat.JSCommonResource_Global_JSChartResource.CacheDomain = cacheDomain;

  _umychartComplierWechat.JSCommonComplier.JSComplier.SetDomain(domain, cacheDomain); //编译器数据api域名修改  
};

//自定义风格
JSChart.SetStyle = function (style) {
  if (style) _umychartResourceWechat.JSCommonResource_Global_JSChartResource.SetStyle(style);
};

JSChart.GetResource = function () //获取颜色配置 (设置配必须啊在JSChart.Init()之前)
{
  return _umychartResourceWechat.JSCommonResource_Global_JSChartResource;
};

JSChart.GetKLineZoom = function () //K线缩放配置
{
  return ZOOM_SEED;
};

JSChart.GetChinaFuturesTimeData = function () //获取国内期货交易时间配置
{
  return _umychartCoordinatedataWechat.JSCommonCoordinateData_Global_FuturesTimeData;
};

JSChart.GetInternalTimeData = function (name) //内置品种交易时间
{
  switch (name) {

    case "NYMEXTimeData": //纽约商业交易所
      return _umychartCoordinatedataWechat.JSCommonCoordinateData_Global_NYMEXTimeData;
    case "COMEXTimeData": //纽约商品交易所
      return _umychartCoordinatedataWechat.JSCommonCoordinateData_Global_COMEXTimeData;
    case "NYBOTTimeData": //纽约期货交易所
      return _umychartCoordinatedataWechat.JSCommonCoordinateData_Global_NYBOTTimeData;
    case "CBOTTimeData": //芝加哥期货交易所
      return _umychartCoordinatedataWechat.JSCommonCoordinateData_Global_CBOTTimeData;
    case "LMETimeData": //伦敦金属交易所
      return _umychartCoordinatedataWechat.JSCommonCoordinateData_Global_LMETimeData;
    case "FuturesTimeData": //国内期货
      return _umychartCoordinatedataWechat.JSCommonCoordinateData_Global_FuturesTimeData;
    default:
      return null;}

};

var JSCHART_OPERATOR_ID =
{
  OP_SCROLL_LEFT: 1,
  OP_SCROLL_RIGHT: 2,
  OP_ZOOM_OUT: 3, //缩小
  OP_ZOOM_IN: 4, //放大
  OP_GOTO_HOME: 5 //第1页数据
};

/*
       图形控件
   */
function JSChartContainer(uielement)
{
  this.ClassName = 'JSChartContainer';
  var _self = this;
  this.Frame; //框架画法
  this.ChartPaint = new Array(); //图形画法
  this.ChartPaintEx = []; //图形扩展画法
  this.ChartInfo = new Array(); //K线上信息地雷
  this.ChartInfoPaint; //信息地理
  this.ExtendChartPaint = new Array(); //扩展画法
  this.TitlePaint = new Array(); //标题画法
  this.OverlayChartPaint = new Array(); //叠加信息画法
  this.ChartDrawPicture = new Array(); //画图工具
  this.CurrentChartDrawPicture = null; //当前的画图工具
  this.SelectChartDrawPicture = null; //当前选中的画图
  this.ChartCorssCursor; //十字光标
  this.IsClickShowCorssCursor = false; //手势点击显示十字光标
  this.ChartSplashPaint = null; //等待提示
  this.LoadDataSplashTitle = '数据加载中';
  this.Canvas = uielement.GetContext("2d"); //画布
  this.UIElement = uielement;
  this.MouseDrag;
  this.DragMode = 1; //拖拽模式 0 禁止拖拽 1 数据拖拽 2 区间选择
  this.PhoneTouchInfo; //手机手势信息 {Start:起始点, End:结束点}
  this.EnableScrollUpDown = false; //是否可以上下滚动图形(手机端才有)

  this.TouchTimer = null; //触屏定时器
  this.LastDrawStatus; //最后一次画的状态
  this.LastDrawID = 1; //最后一次画的ID
  this.SnapshotType = 0;

  this.CursorIndex = 0; //十字光标X轴索引
  this.LastPoint = new Point(); //鼠标位置
  this.IsForceLandscape = false; //是否强制横屏
  this.CorssCursorTouchEnd = false; //手离开屏幕自动隐藏十字光标
  this.EnableAnimation = false; //是否开启动画

  //坐标轴风格方法 double-更加数值型分割  price-更加股票价格分割
  this.FrameSplitData = new Map();
  this.FrameSplitData.set("double", new _umychartFramesplitWechat.JSCommonSplit_SplitData());
  this.FrameSplitData.set("price", new _umychartFramesplitWechat.JSCommonSplit_PriceSplitData());

  this.UpdateUICallback; //数据到达通知前端
  this.IsOnTouch = false; //当前是否正式手势操作
  this.IsFullDraw = false; //是否使用重绘模式 (可能会卡)

  this.LanguageID = _umychartResourceWechat.JSCommonResource_JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID;

  //公共函数转发,不然要导出麻烦
  this.FormatDateString = _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatDateString;
  this.FormatValueString = _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatValueString;
  this.ToFixedPoint = ToFixedPoint;
  this.ToFixedRect = ToFixedRect;
  this.FormatTimeString = _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatTimeString;

  //this.JSCHART_EVENT_ID = JSCHART_EVENT_ID;

  //事件回调
  this.mapEvent = new Map(); //通知外部调用 key:JSCHART_EVENT_ID value:{Callback:回调,}
  this.NetworkFilter; //网络请求回调 function(data, callback);
  this.IsDestroy = false; //是否已经销毁了

  //手势移动 十字光标
  this.LastMovePoint;
  this.DrawMoveTimer = null;
  this.DrawMoveWaitTime = 60;

  this.ChartDestory = function () //销毁
  {
    this.IsDestroy = true;
    this.StopAutoUpdate();
  };

  this.AddEventCallback = function (object) //设置事件回调 {event:事件id, callback:回调函数}
  {
    if (!object || !object.event || !object.callback) return;

    var data = { Callback: object.callback, Source: object };
    this.mapEvent.set(object.event, data);
  };

  this.RemoveEventCallback = function (eventid)
  {
    if (!this.mapEvent.has(eventid)) return;
    this.mapEvent.delete(eventid);
  };

  this.GetEvent = function (eventId)
  {
    if (!this.mapEvent.has(eventId)) return null;
    var item = this.mapEvent.get(eventId);
    return item;
  };

  this.GetEventCallback = this.GetEvent;

  this.GetIndexEvent = function () {return this.GetEvent(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.RECV_INDEX_DATA);}; //接收指标数据
  this.GetBarrageEvent = function () {return this.GetEvent(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.BARRAGE_PLAY_END);}; //获取弹幕事件
  this.GetEnableSplashEvent = function () {return this.GetEvent(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.ON_ENABLE_SPLASH_DRAW);}; //开启/关闭文字提示信息事件

  //判断是单个手指
  this.IsPhoneDragging = function (e)
  {
    // JSConsole.Chart.Log(e);
    var changed = e.changedTouches.length;
    var touching = e.touches.length;

    return changed == 1 && touching == 1;
  };

  //是否是2个手指操所
  this.IsPhonePinching = function (e)
  {
    var changed = e.changedTouches.length;
    var touching = e.touches.length;

    return (changed == 1 || changed == 2) && touching == 2;
  };

  this.IsSingleTouch = function (e) //是否是单点触屏
  {
    var touchCount = e.touches.length;
    return touchCount == 1;
  };

  this.GetToucheData = function (e, isForceLandscape)
  {
    var touches = new Array();
    for (var i = 0; i < e.touches.length; ++i)
    {
      var item = e.touches[i];
      if (isForceLandscape)
      {
        touches.push({ clientX: item.y, clientY: item.x, pageX: item.y, pageY: item.x });
      } else

      {
        touches.push({ clientX: item.x, clientY: item.y, pageX: item.x, pageY: item.y });
      }
    }

    return touches;
  };

  this.ClearDrawMoveTimer = function ()
  {
    if (this.DrawMoveTimer != null)
    {
      clearTimeout(this.DrawMoveTimer);
      this.DrawMoveTimer = null;
    }
  };

  this.ClearTouchTimer = function ()
  {
    if (this.TouchTimer != null)
    {
      clearTimeout(this.TouchTimer);
      this.TouchTimer = null;
    }
  };

  //手机拖拽
  this.ontouchstart = function (e)
  {
    if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

    var jsChart = this;
    //if (jsChart.DragMode == 0) return;

    jsChart.IsOnTouch = true;
    jsChart.PhonePinch = null;

    if (this.IsPhoneDragging(e))
    {
      if (jsChart.TryClickLock || this.TryClickIndexTitle)
      {
        var touches = this.GetToucheData(e, jsChart.IsForceLandscape);
        var x = touches[0].clientX;
        var y = touches[0].clientY;
        if (jsChart.TryClickLock && jsChart.TryClickLock(x, y)) return;
        if (jsChart.TryClickIndexTitle && jsChart.TryClickIndexTitle(x, y)) return;
      }

      //长按2秒,十字光标
      if (this.TouchTimer != null) clearTimeout(this.TouchTimer);
      if (this.ChartCorssCursor.IsShow == true)
      {
        this.TouchTimer = setTimeout(function () {
          if (drag.Click.X == drag.LastMove.X && drag.Click.Y == drag.LastMove.Y) //手指没有移动，出现十字光标
            {
              var mouseDrag = jsChart.MouseDrag;
              jsChart.MouseDrag = null;
              //移动十字光标
              var x = drag.Click.X;
              var y = drag.Click.Y;
              if (jsChart.IsForceLandscape) y = jsChart.UIElement.Height - drag.Click.Y; //强制横屏Y计算
              jsChart.OnMouseMove(x, y, e);
            }

        }, 800);
      }

      var drag =
      {
        "Click": {},
        "LastMove": {} //最后移动的位置
      };

      var touches = this.GetToucheData(e, jsChart.IsForceLandscape);

      drag.Click.X = touches[0].clientX;
      drag.Click.Y = touches[0].clientY;
      drag.LastMove.X = touches[0].clientX;
      drag.LastMove.Y = touches[0].clientY;

      if (jsChart.DragMode == 1) jsChart.MouseDrag = drag;

      this.PhoneTouchInfo = { Start: { X: touches[0].clientX, Y: touches[0].clientY }, End: { X: touches[0].clientX, Y: touches[0].clientY } };

      if (jsChart.IsClickShowCorssCursor)
      {
        var x = drag.Click.X;
        var y = drag.Click.Y;
        jsChart.OnMouseMove(x, y, e, true);
      }

      this.TouchEvent({ EventID: _umychartDataWechat.JSCommon_JSCHART_EVENT_ID.ON_PHONE_TOUCH, FunctionName: "OnTouchStart" }, e);
    } else
    if (this.IsPhonePinching(e))
    {
      var phonePinch = { "Start": {}, "Last": {} };
      var touches = this.GetToucheData(e, jsChart.IsForceLandscape);
      phonePinch.Start = { "X": touches[0].pageX, "Y": touches[0].pageY, "X2": touches[1].pageX, "Y2": touches[1].pageY };
      phonePinch.Last = { "X": touches[0].pageX, "Y": touches[0].pageY, "X2": touches[1].pageX, "Y2": touches[1].pageY };
      jsChart.PhonePinch = phonePinch;
    }
  };


  this.ontouchmove = function (e)
  {var _this = this;
    if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

    var jsChart = this;
    var touches = this.GetToucheData(e, jsChart.IsForceLandscape);

    if (this.IsPhoneDragging(e))
    {
      var drag = jsChart.MouseDrag;
      if (drag == null)
      {
        var x = touches[0].clientX;
        var y = touches[0].clientY;
        this.LastMovePoint = { X: x, Y: y };
        if (this.DrawMoveTimer) return;
        this.DrawMoveTimer = setTimeout(function ()
        {
          if (!_this.LastMovePoint) return;
          _this.OnMouseMove(_this.LastMovePoint.X, _this.LastMovePoint.Y, e);
          _this.DrawMoveTimer = null;
        }, this.DrawMoveWaitTime);

      } else

      {
        var moveSetp = Math.abs(drag.LastMove.X - touches[0].clientX);
        moveSetp = parseInt(moveSetp);
        if (jsChart.DragMode == 1) //数据左右拖拽
          {
            if (moveSetp < 5) return;
            var isLeft = true;
            if (drag.LastMove.X < touches[0].clientX) isLeft = false; //右移数据

            if (jsChart.DataMove(moveSetp, isLeft))
            {
              jsChart.UpdataDataoffset();
              jsChart.UpdatePointByCursorIndex();
              jsChart.UpdateFrameMaxMin();
              jsChart.ResetFrameXYSplit();
              jsChart.Draw();
            } else

            {
              if (jsChart.DragDownloadData) jsChart.DragDownloadData();
            }

            drag.LastMove.X = touches[0].clientX;
            drag.LastMove.Y = touches[0].clientY;
          }
      }

      if (this.PhoneTouchInfo)
      {
        this.PhoneTouchInfo.End.X = touches[0].clientX;
        this.PhoneTouchInfo.End.Y = touches[0].clientY;
      }
    } else
    if (this.IsPhonePinching(e))
    {
      var phonePinch = jsChart.PhonePinch;
      if (!phonePinch) return;

      if (this.EnableZoomUpDown && this.EnableZoomUpDown.Touch === false) return;

      var yHeight = Math.abs(touches[0].pageY - touches[1].pageY);
      var yLastHeight = Math.abs(phonePinch.Last.Y - phonePinch.Last.Y2);
      var yStep = yHeight - yLastHeight;
      var xHeight = Math.abs(touches[0].pageX - touches[1].pageX);
      var xLastHeight = Math.abs(phonePinch.Last.X - phonePinch.Last.X2);
      var xStep = xHeight - xLastHeight;
      var minStep = this.ZoomStepPixel;
      if (Math.abs(yStep) < minStep && Math.abs(xStep) < minStep) return;

      var step = yStep;
      if (Math.abs(yStep) < minStep) step = xStep;

      if (step > 0) //放大
        {
          var cursorIndex = {};
          cursorIndex.Index = parseInt(Math.abs(jsChart.CursorIndex - 0.5).toFixed(0));
          if (!jsChart.Frame.ZoomUp(cursorIndex)) return;
          jsChart.CursorIndex = cursorIndex.Index;
          jsChart.UpdatePointByCursorIndex();
          jsChart.UpdataDataoffset();
          jsChart.UpdateFrameMaxMin();
          jsChart.ResetFrameXYSplit();
          jsChart.Draw();
        } else
        //缩小
        {
          var cursorIndex = {};
          cursorIndex.Index = parseInt(Math.abs(jsChart.CursorIndex - 0.5).toFixed(0));
          if (!jsChart.Frame.ZoomDown(cursorIndex)) return;
          jsChart.CursorIndex = cursorIndex.Index;
          jsChart.UpdataDataoffset();
          jsChart.UpdatePointByCursorIndex();
          jsChart.UpdateFrameMaxMin();
          jsChart.ResetFrameXYSplit();
          jsChart.Draw();
        }

      phonePinch.Last = { "X": touches[0].pageX, "Y": touches[0].pageY, "X2": touches[1].pageX, "Y2": touches[1].pageY };
    }
  };

  this.ontouchend = function (e)
  {
    if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

    this.IsOnTouch = false;
    this.LastMovePoint = null;
    _umychartConsoleWechat.JSConsole.Chart.Log('[JSChartContainer:ontouchend] IsOnTouch=' + this.IsOnTouch + ' LastDrawStatus=' + this.LastDrawStatus);
    this.ClearDrawMoveTimer();
    this.ClearTouchTimer();
    this.TouchEvent({ EventID: _umychartDataWechat.JSCommon_JSCHART_EVENT_ID.ON_PHONE_TOUCH, FunctionName: "OnTouchEnd" }, e);
    this.Draw(); //手放开 重新绘制  
  };

  this.TouchEvent = function (obj, e)
  {
    var eventID = obj.EventID;
    var event = this.GetEvent(eventID);
    if (!event || !event.Callback) return false;

    var drag = this.PhoneTouchInfo;
    if (!drag || !drag.Start || !drag.End) return false;

    var clientX = drag.End.X;
    var clientY = drag.End.Y;
    var x = drag.End.X;
    var y = drag.End.Y;

    var data =
    {
      X: clientX, Y: clientY, FrameID: -1, FunctionName: obj.FunctionName,
      Drag:
      {
        Start: { X: drag.Start.X, Y: drag.Start.Y },
        End: { X: drag.End.X, Y: drag.End.Y } } };



    var isInClient = false;
    var rtClient = new _umychartDataWechat.JSCommon_Rect(this.Frame.ChartBorder.GetLeft(), this.Frame.ChartBorder.GetTop(), this.Frame.ChartBorder.GetWidth(), this.Frame.ChartBorder.GetHeight());
    isInClient = rtClient.IsPointIn(x, y);

    if (isInClient)
    {
      var yValueExtend = {};
      var yValue = this.Frame.GetYData(y, yValueExtend);

      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(yValueExtend.FrameID) && yValueExtend.FrameID >= 0)
      {
        var xValue = this.Frame.GetXData(x);
        data.FrameID = yValueExtend.FrameID;
        data.Data = { X: xValue, Y: yValue };
      }
    }

    event.Callback(event, data, this);
    return true;
  };

  this.FullDraw = function (drawType)
  {var _this2 = this;
    var self = this;
    this.Canvas.clearRect(0, 0, this.UIElement.Width, this.UIElement.Height);

    this.Frame.SetDrawOtherChart(function ()
    {
      for (var i in _this2.ExtendChartPaint)
      {
        var item = _this2.ExtendChartPaint[i];
        if (item.IsCallbackDraw) item.Draw();
      }
    });

    this.Frame.Draw(); //框架 

    if (this.Frame.DrawCustomVertical)
    {
      var eventCVericalDraw = this.GetEvent(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.ON_CUSTOM_VERTICAL_DRAW);
      this.Frame.DrawCustomVertical(eventCVericalDraw);
    }

    if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash) //动画
      {
        this.Frame.DrawInsideHorizontal();
        this.ChartSplashPaint.Draw();
        this.LastDrawStatus = 'FullDraw';
        this.Canvas.draw();
        return;
      }

    for (var i in this.ChartPaint) //图形
    {
      var item = this.ChartPaint[i];
      if (item.IsDrawFirst) item.Draw();
    }

    for (var i in this.ChartPaint) //图形2 框架内图形
    {
      var item = this.ChartPaint[i];
      if (!item.IsDrawFirst) item.Draw();
    }

    for (var i in this.ChartPaintEx) //扩展图形
    {
      var item = this.ChartPaintEx[i];
      item.Draw();
    }

    for (var i in this.OverlayChartPaint) //叠加股票
    {
      var item = this.OverlayChartPaint[i];
      item.Draw();
    }

    if (this.Frame.DrawInsideHorizontal) this.Frame.DrawInsideHorizontal(); //框架内部坐标
    if (this.Frame.DrawCustomHorizontal) this.Frame.DrawCustomHorizontal();
    if (this.ChartInfoPaint) this.ChartInfoPaint.Draw();
    this.Frame.DrawLock();

    var bOnTouchDraw = drawType == 'DrawDynamicInfo' || this.IsOnTouch;
    if (bOnTouchDraw)
    {
      if (self.ChartCorssCursor) //十字光标
        {
          self.ChartCorssCursor.LastPoint = self.LastPoint;
          self.ChartCorssCursor.CursorIndex = self.CursorIndex;
          self.ChartCorssCursor.Draw();
        }
    }

    var eventTitleDraw = this.GetEvent(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.ON_TITLE_DRAW);
    var eventIndexTitleDraw = this.GetEvent(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.ON_INDEXTITLE_DRAW);
    for (var i in self.TitlePaint) //标题
    {
      var item = self.TitlePaint[i];
      if (!item.IsDynamic) continue;

      if (item.ClassName == 'DynamicChartTitlePainting') item.OnDrawEvent = eventIndexTitleDraw;else
      item.OnDrawEvent = eventTitleDraw;

      item.CursorIndex = self.CursorIndex;
      if (!bOnTouchDraw) //手势离开屏幕 去最后一个数据
        {
          if (this.ChartPaint[0] && this.ChartPaint[0].Data && this.ChartPaint[0].Data.Data)
          {
            var hisData = this.ChartPaint[0].Data;
            var dataCount = hisData.Data.length;
            if (dataCount > 0) item.CursorIndex = dataCount - 1 - hisData.DataOffset;
          }
        }

      if (item.FullDraw) item.FullDraw();
    }

    if (bOnTouchDraw)
    {
      for (var i in this.ExtendChartPaint) //动态扩展图形   在动态标题以后画
      {
        var item = this.ExtendChartPaint[i];
        if (item.IsCallbackDraw) continue;
        item.LatestPoint = { X: this.LastPoint.X, Y: this.LastPoint.Y };
        if (item.IsDynamic && item.DrawAfterTitle) item.Draw();
      }
    }

    this.LastDrawStatus = 'FullDraw';
    this.Canvas.draw(false);
  };

  this.Draw = function ()
  {var _this3 = this;
    if (this.IsFullDraw)
    {
      this.FullDraw('Draw');
      return;
    }

    if (this.IsOnTouch == true && (this.ClassName == 'MinuteChartContainer' || this.ClassName == 'MinuteChartHScreenContainer')) return;

    var self = this;
    this.Canvas.clearRect(0, 0, this.UIElement.Width, this.UIElement.Height);

    this.Frame.SetDrawOtherChart(function ()
    {
      for (var i in _this3.ExtendChartPaint)
      {
        var item = _this3.ExtendChartPaint[i];
        if (item.IsCallbackDraw) item.Draw();
      }
    });

    //框架 
    this.Frame.Draw();

    if (this.Frame.DrawCustomVertical)
    {
      var eventCVericalDraw = this.GetEvent(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.ON_CUSTOM_VERTICAL_DRAW);
      this.Frame.DrawCustomVertical(eventCVericalDraw);
    }

    if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash)
    {
      this.Frame.DrawInsideHorizontal();
      this.ChartSplashPaint.Draw();
      this.LastDrawStatus = 'Draw';
      this.Canvas.draw();
      return;
    }

    for (var i in this.ChartPaint)
    {
      var item = this.ChartPaint[i];
      if (item.IsDrawFirst) item.Draw();
    }

    //框架内图形
    for (var i in this.ChartPaint)
    {
      var item = this.ChartPaint[i];
      if (!item.IsDrawFirst) item.Draw();
    }

    for (var i in this.ChartPaintEx)
    {
      var item = this.ChartPaintEx[i];
      item.Draw();
    }

    //叠加股票
    for (var i in this.OverlayChartPaint)
    {
      var item = this.OverlayChartPaint[i];
      item.Draw();
    }

    //框架外图形
    for (var i in this.ExtendChartPaint)
    {
      var item = this.ExtendChartPaint[i];
      if (item.IsCallbackDraw) continue;
      if (!item.IsDynamic && !item.IsAnimation) item.Draw();
    }

    //框架内部坐标
    if (this.Frame.DrawInsideHorizontal) this.Frame.DrawInsideHorizontal();
    if (this.Frame.DrawCustomHorizontal) this.Frame.DrawCustomHorizontal();
    if (this.ChartInfoPaint) this.ChartInfoPaint.Draw();
    this.Frame.DrawLock();

    var eventTitleDraw = this.GetEvent(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.ON_TITLE_DRAW);
    var eventIndexTitleDraw = this.GetEvent(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.ON_INDEXTITLE_DRAW);
    for (var i in this.TitlePaint)
    {
      var item = this.TitlePaint[i];
      if (!item.IsDynamic) continue;

      if (item.ClassName == 'DynamicChartTitlePainting') item.OnDrawEvent = eventIndexTitleDraw;else
      item.OnDrawEvent = eventTitleDraw;

      if (typeof item.DrawTitle == 'function') item.DrawTitle();
    }

    this.LastDrawStatus = 'Draw';

    if (this.IsOnTouch) //手势移动的时候不保存图片
      {
        this.Canvas.draw(false);
      } else

    {
      ++this.LastDrawID;
      //坑!!.画图是异步, 保存当前屏图放在回调里面
      //JSConsole.Chart.Log('[JSChartContainer:Draw][ID=' + this.UIElement.ID + '] draw and save snapshot. DrawID=' + this.LastDrawID + ' .....');
      var lastDrawID = this.LastDrawID;
      this.Canvas.draw(false, function ()
      {
        //if (lastDrawID == self.LastDrawID) 
        self.Frame.Snapshot(self.SnapshotType); //只保存最后一次的截图
        //JSConsole.Chart.Log('[JSChartContainer:Draw] finish. DrawID('+ lastDrawID +','+ self.LastDrawID +')');
      });
    }

    //JSConsole.Chart.Log('[JSChartContainer:Draw][ID=' + this.UIElement.ID + '] draw dynamic info ......');
    //动态标题都不画了(Canvas.draw 异步画的,如果下面再画会被截屏进去) 只有数据移动的时候在画
  };

  //画动态信息
  this.TempImage = null;
  this.DrawDynamicInfo = function ()
  {
    if (this.IsFullDraw)
    {
      this.FullDraw('DrawDynamicInfo');
      return;
    }

    var self = this;
    var width = this.Frame.ChartBorder.GetChartWidth();
    var height = this.Frame.ChartBorder.GetChartHeight();

    if (self.SnapshotType == 1)
    {
      if (this.Frame.ScreenImageData == null) return;
      wx.canvasPutImageData({
        canvasId: this.UIElement.ID,
        x: 0, y: 0, width: width, height: height,
        data: this.Frame.ScreenImageData,
        success: function success(res) {self.DrawDynamicChart(true);} });

    } else

    {
      if (this.Frame.ScreenImagePath == null) return;
      if (self.Canvas && self.Canvas.DomNode) //新版本2D画布
        {
          //JSConsole.Chart.Log("[DrawDynamicInfo] ScreenImagePath ", this.Frame.ScreenImagePath);
          if (!this.TempImage) this.TempImage = self.Canvas.DomNode.createImage(); //新版本的必须要装成image类 比较坑
          this.TempImage.src = this.Frame.ScreenImagePath;
          //JSConsole.Chart.Log("[DrawDynamicInfo] tempImage ", this.TempImage);
          this.TempImage.onload = function ()
          {
            //JSConsole.Chart.Log("[DrawDynamicInfo] onload ", self.TempImage);
            self.Canvas.clearRect(0, 0, width, height);
            self.Canvas.drawImage(self.TempImage, 0, 0, width, height);
            self.DrawDynamicChart(false);
          };
        } else

      {
        self.Canvas.drawImage(this.Frame.ScreenImagePath, 0, 0, width, height);
        self.DrawDynamicChart(false);
      }

    }
  };

  this.DrawDynamicChart = function (bReserve)
  {
    var self = this;
    if (self.ChartCorssCursor)
    {
      self.ChartCorssCursor.LastPoint = self.LastPoint;
      self.ChartCorssCursor.CursorIndex = self.CursorIndex;
      self.ChartCorssCursor.Draw();
    }

    for (var i in self.TitlePaint)
    {
      var item = self.TitlePaint[i];
      if (!item.IsDynamic) continue;

      item.CursorIndex = self.CursorIndex;
      item.Draw();
    }

    for (var i in this.ExtendChartPaint) //动态扩展图形   在动态标题以后画
    {
      var item = this.ExtendChartPaint[i];
      if (item.IsDynamic && item.DrawAfterTitle) item.Draw();
    }

    if (this.EnableAnimation)
    {
      for (var i in this.ExtendChartPaint) //动画
      {
        var item = this.ExtendChartPaint[i];
        if (item.IsAnimation === true) item.Draw();
      }
    }

    this.LastDrawStatus = 'DrawDynamicInfo';
    _umychartConsoleWechat.JSConsole.Chart.Log('[JSChartContainer:DrawDynamicChart][ID=' + this.UIElement.ID + '] draw .....');
    self.Canvas.draw(bReserve, function () {
      _umychartConsoleWechat.JSConsole.Chart.Log('[JSChartContainer:DrawDynamicChart] finish.');
    });
  };

  this.DrawAnimation = function () //绘制动画 如弹幕
  {var _this4 = this;
    if (!this.EnableAnimation) return;

    if (this.Frame.ScreenImagePath && !this.IsOnTouch)
    {
      for (var i in this.ExtendChartPaint)
      {
        var item = this.ExtendChartPaint[i];
        if (item.IsAnimation === true) item.IsMoveStep = true; //移动弹幕
      }

      this.DrawDynamicInfo();
    }

    var self = this;
    this.UIElement.WebGLCanvas.requestAnimationFrame(function () {_this4.DrawAnimation();});
  };

  this.StartAnimation = function (option)
  {var _this5 = this;
    _umychartConsoleWechat.JSConsole.Chart.Log('[JSChartContainer::StartAnimation] ', this.UIElement.WebGLCanvas);
    if (!this.UIElement.WebGLCanvas) return;

    var bCreated = false; //是否已经创建了弹幕画法
    var barrageData = null;
    for (var i in this.ExtendChartPaint)
    {
      var item = this.ExtendChartPaint[i];
      if (item.ClassName === 'BarragePaint')
      {
        bCreated = true;
        barrageData = item.BarrageList;
        break;
      }
    }

    if (!bCreated)
    {
      var chart = new _umychartExtendchartWechat.JSCommonExtendChartPaint_BarragePaint();
      chart.Canvas = this.Canvas;
      chart.ChartBorder = this.Frame.ChartBorder;
      chart.ChartFrame = this.Frame;
      chart.HQChart = this;
      chart.SetOption(option);
      this.ExtendChartPaint.push(chart);
      barrageData = chart.BarrageList;
    }

    this.EnableAnimation = true;
    var self = this;

    this.UIElement.WebGLCanvas.requestAnimationFrame(function () {_this5.DrawAnimation();});
    return barrageData;
  };

  this.StopAnimation = function ()
  {
    this.EnableAnimation = false;
    this.DrawDynamicInfo();
  };

  this.OnMouseMove = function (x, y, e, bFullDraw)
  {
    var lastY = this.LastPoint.Y;
    this.LastPoint.X = x;
    this.LastPoint.Y = y;
    var lastCursorIndex = this.CursorIndex;
    this.CursorIndex = this.Frame.GetXData(x);
    if (this.ClassName == "KLineChartContainer" || this.ClassName == "KLineChartHScreenContainer")
    {
      if (lastCursorIndex == this.CursorIndex && Math.abs(lastY - y) < 1) return; //一个一个数据移动
    } else

    {
      if (parseInt(lastCursorIndex - 0.5) == parseInt(this.CursorIndex - 0.5) && Math.abs(lastY - y) < 1) return; //一个一个数据移动
    }

    if (bFullDraw)
    {
      this.FullDraw();
    } else

    {
      if (this.IsForceLandscape) this.Draw(); //横屏图片太大不让贴,分两张图贴,多次截图的函数是坏的, 直接重画了
      else this.DrawDynamicInfo();
    }
  };


  this.OnDoubleClick = function (x, y, e)
  {
    //JSConsole.Chart.Log(e);
  };

  this.UpdatePointByCursorIndex = function ()
  {
    this.LastPoint.X = this.Frame.GetXFromIndex(this.CursorIndex);

    var index = Math.abs(this.CursorIndex - 0.5);
    index = parseInt(index.toFixed(0));
    if (this.ClassName == 'KLineChartContainer') index = this.CursorIndex;
    var data = this.Frame.Data;
    if (data.DataOffset + index >= data.Data.length)
    {
      return;
    }
    var close = data.Data[data.DataOffset + index].Close;

    this.LastPoint.Y = this.Frame.GetYFromData(close);
  };

  this.ResetFrameXYSplit = function ()
  {
    if (typeof this.Frame.ResetXYSplit == 'function') this.Frame.ResetXYSplit();
  };

  this.UpdateFrameMaxMin = function ()
  {
    var frameMaxMinData = new Array();
    var chartPaint = new Array();

    for (var i in this.ChartPaint)
    {
      var item = this.ChartPaint[i];
      if (item.IsShow == false) continue; //隐藏的图形不计算
      chartPaint.push(item);
    }
    for (var i in this.OverlayChartPaint)
    {
      chartPaint.push(this.OverlayChartPaint[i]);
    }

    for (var i in chartPaint)
    {
      var paint = chartPaint[i];
      var range = paint.GetMaxMin();
      if (range == null || range.Max == null || range.Min == null) continue;
      var frameItem = null;
      for (var j in frameMaxMinData)
      {
        if (frameMaxMinData[j].Frame == paint.ChartFrame)
        {
          frameItem = frameMaxMinData[j];
          break;
        }
      }

      if (frameItem)
      {
        if (frameItem.Range.Max < range.Max) frameItem.Range.Max = range.Max;
        if (frameItem.Range.Min > range.Min) frameItem.Range.Min = range.Min;
      } else

      {
        frameItem = {};
        frameItem.Frame = paint.ChartFrame;
        frameItem.Range = range;
        frameMaxMinData.push(frameItem);
      }
    }

    for (var i in frameMaxMinData)
    {
      var item = frameMaxMinData[i];
      if (!item.Frame || !item.Range) continue;
      if (item.Range.Max == null || item.Range.Min == null) continue;
      if (item.Frame.YSpecificMaxMin)
      {
        item.Frame.HorizontalMax = item.Frame.YSpecificMaxMin.Max;
        item.Frame.HorizontalMin = item.Frame.YSpecificMaxMin.Min;
      } else

      {
        item.Frame.HorizontalMax = item.Range.Max;
        item.Frame.HorizontalMin = item.Range.Min;
      }
      item.Frame.XYSplit = true;
    }
  };

  this.DataMoveLeft = function () {
    var data = null;
    if (!this.Frame.Data) data = this.Frame.Data;else
    data = this.Frame.SubFrame[0].Frame.Data;
    if (!data) return false;
    if (data.DataOffset <= 0) return false;
    --data.DataOffset;
    return true;
  };

  this.DataMoveRight = function () {
    var data = null;
    if (!this.Frame.Data) data = this.Frame.Data;else
    data = this.Frame.SubFrame[0].Frame.Data;
    if (!data) return false;

    var xPointcount = 0;
    if (this.Frame.XPointCount) xPointcount = this.Frame.XPointCount;else
    xPointcount = this.Frame.SubFrame[0].Frame.XPointCount;
    if (!xPointcount) return false;

    if (xPointcount + data.DataOffset >= data.Data.length) return false;

    ++data.DataOffset;
    return true;
  };

  this.UpdataDataoffset = function () {
    var data = null;
    if (this.Frame.Data)
    data = this.Frame.Data;else

    data = this.Frame.SubFrame[0].Frame.Data;

    if (!data) return;

    for (var i in this.ChartPaint) {
      var item = this.ChartPaint[i];
      if (!item.Data) continue;
      item.Data.DataOffset = data.DataOffset;
    }

    for (var i in this.OverlayChartPaint) {
      var item = this.OverlayChartPaint[i];
      if (!item.Data) continue;
      item.Data.DataOffset = data.DataOffset;
    }
  };

  this.DataMove = function (step, isLeft)
  {
    step = parseInt(step / this.StepPixel);
    if (step <= 0) return false;

    var data = null;
    if (!this.Frame.Data) data = this.Frame.Data;else
    data = this.Frame.SubFrame[0].Frame.Data;
    if (!data) return false;

    var xPointcount = 0;
    if (this.Frame.XPointCount) xPointcount = this.Frame.XPointCount;else
    xPointcount = this.Frame.SubFrame[0].Frame.XPointCount;
    if (!xPointcount) return false;

    if (isLeft) //-->
      {
        if (this.RightSpaceCount > 0)
        {
          if (xPointcount + data.DataOffset >= data.Data.length + this.RightSpaceCount - 1) return false;

          data.DataOffset += step;

          if (data.DataOffset + xPointcount >= data.Data.length + this.RightSpaceCount)
          data.DataOffset = data.Data.length - (xPointcount - this.RightSpaceCount);
        } else

        {
          if (xPointcount + data.DataOffset >= data.Data.length) return false;

          data.DataOffset += step;

          if (data.DataOffset + xPointcount >= data.Data.length)
          data.DataOffset = data.Data.length - xPointcount;
        }
        return true;
      } else
      //<--
      {
        if (data.DataOffset <= 0) return false;

        data.DataOffset -= step;
        if (data.DataOffset < 0) data.DataOffset = 0;

        return true;
      }
  };

  //获取鼠标在当前子窗口id
  this.GetSubFrameIndex = function (x, y) {
    if (!this.Frame.SubFrame || this.Frame.SubFrame.length <= 0) return -1;

    for (var i in this.Frame.SubFrame) {
      var frame = this.Frame.SubFrame[i].Frame;
      var left = frame.ChartBorder.GetLeft();
      var top = frame.ChartBorder.GetTop();
      var height = frame.ChartBorder.GetHeight();
      var width = frame.ChartBorder.GetWidth();

      this.Canvas.rect(left, top, width, height);
      if (this.Canvas.isPointInPath(x, y)) return parseInt(i);

    }
    return 0;
  };

  //根据X坐标获取数据索引
  this.GetDataIndexByPoint = function (x) {
    var frame = this.Frame;
    if (this.Frame.SubFrame && this.Frame.SubFrame.length > 0) frame = this.Frame.SubFrame[0].Frame;

    var data = null;
    if (this.Frame.Data)
    data = this.Frame.Data;else

    data = this.Frame.SubFrame[0].Frame.Data;

    if (!data || !frame) return;

    var index = parseInt(frame.GetXData(x));

    //JSConsole.Chart.Log('x='+ x +' date='+data.Data[data.DataOffset+index].Date);
    return data.DataOffset + index;
  };

  this.SaveToImage = function (callback)
  {
    var width = this.UIElement.Width;
    var height = this.UIElement.Height;;
    _umychartConsoleWechat.JSConsole.Chart.Log('[JSChartContainer::SaveToImage]', this.UIElement);

    wx.canvasToTempFilePath({
      x: 0,
      y: 0,
      width: width,
      height: height,
      canvasId: this.UIElement.ID,
      success: function success(res)
      {
        var data = { ImagePath: res.tempFilePath, Width: width, Height: height };
        if (typeof callback == 'function') callback(data);
      } });

  };

  //全屏提示信息 { Title:提示信息, Draw:false/true 是否立即重绘, }
  this.EnableSplashScreen = function (option)
  {
    if (!this.ChartSplashPaint) return;
    if (!option) return;

    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsString(option.Title)) this.ChartSplashPaint.SetTitle(option.Title);
    this.ChartSplashPaint.EnableSplash(true);

    if (option.Draw === false) return;
    this.Draw();
  };

  //增加一个指标窗口
  this.AddIndexWindow = function (indexName, option)
  {var _this6 = this;
    //查找系统指标
    var scriptData = new _umychartIndexDataWechat.JSCommonIndexScript.JSIndexScript();
    var indexInfo = scriptData.Get(indexName);
    if (!indexInfo) return;

    var index = this.Frame.SubFrame.length;
    var subFrame = this.CreateSubFrameItem(index);
    this.Frame.SubFrame[index] = subFrame;
    var titlePaint = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicChartTitlePainting();
    titlePaint.Frame = this.Frame.SubFrame[index].Frame;
    titlePaint.Canvas = this.Canvas;
    titlePaint.LanguageID = this.LanguageID;
    titlePaint.GetEventCallback = function (id) {return _this6.GetEventCallback(id);};
    this.TitlePaint[index + 1] = titlePaint;

    if (option)
    {
      if (option.Window)
      {
        var item = option.Window;
        if (item.IsDrawTitleBG == true) subFrame.Frame.IsDrawTitleBG = item.IsDrawTitleBG;
      }

      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(option.TitleHeight)) subFrame.Frame.ChartBorder.TitleHeight = option.TitleHeight;
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsBool(option.IsShowTitleArraw)) subFrame.Frame.IsShowTitleArraw = option.IsShowTitleArraw;
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsBool(option.IsShowIndexName)) subFrame.Frame.IsShowIndexName = option.IsShowIndexName;
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsBool(option.IsShowOverlayIndexName)) subFrame.Frame.IsShowOverlayIndexName = option.IsShowOverlayIndexName;
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(option.IndexParamSpace)) subFrame.Frame.IndexParamSpace = option.IndexParamSpace;
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsBool(option.IsShowXLine)) subFrame.Frame.IsShowXLine = option.IsShowXLine;
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsBool(option.IsShowYLine)) subFrame.Frame.IsShowYLine = option.IsShowYLine;
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsBool(option.IsShowIndexTitle)) subFrame.Frame.IsShowIndexTitle = option.IsShowIndexTitle;
    }

    //最后一个显示X轴坐标
    for (var i = 0; i < this.Frame.SubFrame.length; ++i)
    {
      var item = this.Frame.SubFrame[i].Frame;
      if (i == this.Frame.SubFrame.length - 1) item.XSplitOperator.ShowText = true;else
      item.XSplitOperator.ShowText = false;
    }

    this.UpdataDataoffset(); //更新数据偏移  
    this.Frame.SetSizeChage(true);
    if (this.UpdateXShowText) this.UpdateXShowText();
    this.ResetFrameXYSplit();
    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Draw();

    var indexData =
    {
      Name: indexInfo.Name, Script: indexInfo.Script, Args: indexInfo.Args, ID: indexName,
      //扩展属性 可以是空
      KLineType: indexInfo.KLineType, YSpecificMaxMin: indexInfo.YSpecificMaxMin, YSplitScale: indexInfo.YSplitScale,
      FloatPrecision: indexInfo.FloatPrecision, Condition: indexInfo.Condition, StringFormat: indexInfo.StringFormat,
      OutName: indexInfo.OutName };


    if (option)
    {
      if (option.FloatPrecision >= 0) indexData.FloatPrecision = option.FloatPrecision;
      if (option.StringFormat > 0) indexData.StringFormat = option.StringFormat;
      if (option.Args) indexData.Args = option.Args;
    }

    this.WindowIndex[index] = new _umychartIndexWechat.JSCommonIndex_ScriptIndex(indexData.Name, indexData.Script, indexData.Args, indexData); //脚本执行
    if (this.ClassName == "MinuteChartContainer" || this.ClassName == "MinuteChartHScreenContainer")
    var bindData = this.SourceData;else

    var bindData = this.ChartPaint[0].Data;

    this.BindIndexData(index, bindData); //执行脚本
  };

}

function ToFixed(number, precision)
{
  var b = 1;
  if (isNaN(number)) return number;
  if (number < 0) b = -1;
  var multiplier = Math.pow(10, precision);
  var value = Math.round(Math.abs(number) * multiplier) / multiplier * b;

  if (/^(\d+(?:\.\d+)?)(e)([\-]?\d+)$/.test(value))
  var s = value.toFixed2(precision);else

  var s = value.toString();
  var rs = s.indexOf('.');
  if (rs < 0 && precision > 0)
  {
    rs = s.length;
    s += '.';
  }

  while (s.length <= rs + precision)
  {
    s += '0';
  }

  return s;
}

Number.prototype.toFixed2 = Number.prototype.toFixed; //备份下老的

Number.prototype.toFixed = function (precision) {
  return ToFixed(this, precision);
};

function Guid()
{
  function S4()
  {
    return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);
  }
  return S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4();
}

function GetScrollPosition() {
  var scrollPos = {};
  var scrollTop = 0;
  var scrollLeft = 0;
  if (document.documentElement && document.documentElement.scrollTop) {
    scrollTop = document.documentElement.scrollTop;
    scrollLeft = document.documentElement.scrollLeft;
  } else if (document.body) {
    scrollTop = document.body.scrollTop;
    scrollLeft = document.body.scrollLeft;
  }

  scrollPos.Top = scrollTop;
  scrollPos.Left = scrollLeft;
  return scrollPos;
}

//修正线段有毛刺
function ToFixedPoint(value) {
  //return value;
  return parseInt(value) + 0.5;
}

function ToFixedRect(value) {
  //return value;
  // With a bitwise or.
  //rounded = (0.5 + somenum) | 0;
  // A double bitwise not.
  //rounded = ~~ (0.5 + somenum);
  // Finally, a left bitwise shift.
  var rounded;
  return rounded = 0.5 + value << 0;
}



function Point() {
  this.X;
  this.Y;
}

function SelectRectData() {
  this.Data; //主数据
  this.JSChartContainer; //行情控件

  this.Start; //数据起始位子
  this.End; //数据结束位置

  this.XStart; //X坐标起始位置
  this.XEnd; //X位置结束为止
}

//边框信息
function ChartBorder()
{
  this.UIElement;

  //四周间距
  this.Left = 50;
  this.Right = 80;
  this.Top = 50;
  this.Bottom = 50;
  this.TitleHeight = 15; //标题高度
  //上下间距
  this.TopSpace = 0;
  this.BottomSpace = 0;

  this.LeftExtendWidth = 0; //左边扩展图形宽度
  this.RightExtendWidth = 0;

  this.GetBorder = function ()
  {
    var data =
    {
      Left: this.Left,
      LeftEx: this.Left + this.LeftExtendWidth,
      Right: this.UIElement.width - this.Right,
      RightEx: this.UIElement.width - this.Right - this.RightExtendWidth,

      Top: this.Top,
      TopEx: this.Top + this.TitleHeight + this.TopSpace,
      TopTitle: this.Top + this.TitleHeight,
      Bottom: this.UIElement.height - this.Bottom,
      BottomEx: this.UIElement.height - this.Bottom - this.BottomSpace,

      ChartWidth: this.UIElement.width,
      ChartHeight: this.UIElement.height };


    return data;
  };

  this.GetHScreenBorder = function ()
  {
    var data =
    {
      Left: this.Left,
      LeftEx: this.Left + this.BottomSpace,

      Right: this.UIElement.width - this.Right,
      RightEx: this.UIElement.width - this.Right - this.TitleHeight - this.TopSpace,
      RightTitle: this.UIElement.width - this.Right - this.TitleHeight,

      Top: this.Top,
      TopEx: this.Top + this.LeftExtendWidth,
      Bottom: this.UIElement.height - this.Bottom,
      BottomEx: this.UIElement.height - this.Bottom - this.RightExtendWidth,

      ChartWidth: this.UIElement.width,
      ChartHeight: this.UIElement.height };


    return data;
  };

  this.GetChartWidth = function () {
    return this.UIElement.Width;
  };

  this.GetChartHeight = function () {
    return this.UIElement.Height;
  };

  this.GetLeft = function () {
    return this.Left;
  };

  this.GetRight = function () {
    return this.UIElement.Width - this.Right;
  };

  this.GetTop = function () {
    return this.Top;
  };

  this.GetTopEx = function () //去掉标题,上面间距
  {
    return this.Top + this.TitleHeight + this.TopSpace;
  };

  this.GetTopTitle = function () //去掉标题
  {
    return this.Top + this.TitleHeight;
  };

  this.GetBottom = function () {
    return this.UIElement.Height - this.Bottom;
  };

  this.GetBottomEx = function () {
    return this.UIElement.Height - this.Bottom - this.BottomSpace;
  };

  this.GetWidth = function () {
    return this.UIElement.Width - this.Left - this.Right;
  };

  this.GetHeight = function () {
    return this.UIElement.Height - this.Top - this.Bottom;
  };

  this.GetHeightEx = function () //去掉标题的高度 上下间距
  {
    return this.UIElement.Height - this.Top - this.Bottom - this.TitleHeight - this.TopSpace - this.BottomSpace;
  };

  this.GetRightEx = function () //横屏去掉标题高度的 上面间距
  {
    return this.UIElement.Width - this.Right - this.TitleHeight - this.TopSpace;
  };

  this.GetWidthEx = function () //横屏去掉标题宽度 上下间距
  {
    return this.UIElement.Width - this.Left - this.Right - this.TitleHeight - this.TopSpace - this.BottomSpace;
  };

  this.GetLeftEx = function () //横屏
  {
    return this.Left + this.BottomSpace;
  };

  this.GetRightTitle = function () //横屏
  {
    return this.UIElement.Width - this.Right - this.TitleHeight;
  };

  this.GetTitleHeight = function () {
    return this.TitleHeight;
  };
}

function IChartFramePainting()
{
  this.HorizontalInfo = new Array(); //Y轴
  this.VerticalInfo = new Array(); //X轴
  this.ClassName = 'IChartFramePainting';
  this.Canvas; //画布

  this.Identify; //窗口标识

  this.ChartBorder;
  this.PenBorder = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameBorderPen; //边框颜色
  this.TitleBGColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameTitleBGColor; //标题背景色
  this.IsShow = true; //是否显示
  this.SizeChange = true; //大小是否改变
  this.XYSplit = true; //XY轴坐标信息改变

  this.HorizontalMax; //Y轴最大值
  this.HorizontalMin; //Y轴最小值
  this.XPointCount = 10; //X轴数据个数

  this.YSplitOperator; //Y轴分割
  this.XSplitOperator; //X轴分割
  this.Data; //主数据

  this.YSpecificMaxMin = null; //指定Y轴最大最小值
  this.YSplitScale = null; //固定分割刻度数组 [2,5,8]

  this.IsShowBorder = true; //是否显示边框
  this.IsShowIndexName = true; //是否显示指标名字
  this.IndexParamSpace = 2; //指标参数数值显示间距

  //上锁信息
  this.IsLocked = false; //是否上锁
  this.LockPaint = null;

  this.BorderLine = null; //1=上 2=下 4=左 8=右

  this.Draw = function ()
  {
    this.DrawFrame();
    this.DrawBorder();

    this.SizeChange = false;
    this.XYSplit = false;
  };

  this.DrawFrame = function () {};

  //画边框
  this.DrawBorder = function ()
  {
    if (!this.IsShowBorder) return;

    var left = ToFixedPoint(this.ChartBorder.GetLeft());
    var top = ToFixedPoint(this.ChartBorder.GetTop());
    var right = ToFixedPoint(this.ChartBorder.GetRight());
    var bottom = ToFixedPoint(this.ChartBorder.GetBottom());
    var width = right - left;
    var height = bottom - top;
    if (this.BorderLine == null)
    {
      this.Canvas.strokeStyle = this.PenBorder;
      this.Canvas.strokeRect(left, top, width, height);
    } else
    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(this.BorderLine))
    {
      this.Canvas.strokeStyle = this.PenBorder;
      this.Canvas.beginPath();

      if ((this.BorderLine & 1) > 0) //上
        {
          this.Canvas.moveTo(left, top);
          this.Canvas.lineTo(right, top);
        }

      if ((this.BorderLine & 2) > 0) //下
        {
          this.Canvas.moveTo(left, bottom);
          this.Canvas.lineTo(right, bottom);
        }

      if ((this.BorderLine & 4) > 0) //左
        {
          this.Canvas.moveTo(left, top);
          this.Canvas.lineTo(left, bottom);
        }

      if ((this.BorderLine & 8) > 0) //右
        {
          this.Canvas.moveTo(right, top);
          this.Canvas.lineTo(right, bottom);
        }

      this.Canvas.stroke();
    }
  };

  //画标题背景色
  this.DrawTitleBG = function () {
    /* 指标信息背景色不画,画了感觉框架变小了
                                  if (this.ChartBorder.TitleHeight<=0) return;
                                    var left=ToFixedPoint(this.ChartBorder.GetLeft());
                                  var top=ToFixedPoint(this.ChartBorder.GetTop());
                                  var right=ToFixedPoint(this.ChartBorder.GetRight());
                                  var bottom=ToFixedPoint(this.ChartBorder.GetTopEx());
                                  var width=right-left;
                                  var height=bottom-top;
                                    this.Canvas.fillStyle=this.TitleBGColor;
                                  this.Canvas.fillRect(left,top,width,height);
                                  */


  };

  this.DrawLock = function () {
    if (this.IsLocked) {
      if (this.LockPaint == null) this.LockPaint = new _umychartChartpaintWechat.JSCommonChartPaint_ChartLock();

      this.LockPaint.Canvas = this.Canvas;
      this.LockPaint.ChartBorder = this.ChartBorder;
      this.LockPaint.ChartFrame = this;
      this.LockPaint.Draw();
    }
  };

  //设施上锁
  this.SetLock = function (lockData) {
    if (!lockData) //空数据不上锁
      {
        this.IsLocked = false;
        return;
      }

    this.IsLocked = true;
    if (!this.LockPaint) this.LockPaint = new _umychartChartpaintWechat.JSCommonChartPaint_ChartLock(); //创建锁

    if (lockData.Callback) this.LockPaint.Callback = lockData.Callback; //回调
    if (lockData.IndexName) this.LockPaint.IndexName = lockData.IndexName; //指标名字
    if (lockData.ID) this.LockPaint.LockID = lockData.ID; //锁ID
    if (lockData.BG) this.LockPaint.BGColor = lockData.BG; //背景色 
    if (lockData.Text) this.LockPaint.Title = lockData.Text;
    if (lockData.TextColor) this.LockPaint.TextColor = lockData.TextColor;
    if (lockData.Font) this.LockPaint.Font = lockData.Font;
    if (lockData.Count) this.LockPaint.LockCount = lockData.Count;
  };
}


//空框架只画边框
function NoneFrame()
{
  this.newMethod = IChartFramePainting; //派生
  this.newMethod();
  delete this.newMethod;
  this.ClassName = 'NoneFrame';

  this.Snapshot = function () {};

  this.DrawInsideHorizontal = function () {};

  this.SetSizeChage = function (sizeChange)
  {
    this.SizeChange = sizeChange;

    //画布的位置
    this.Position =
    {
      X: this.ChartBorder.UIElement.offsetLeft,
      Y: this.ChartBorder.UIElement.offsetTop,
      W: this.ChartBorder.UIElement.clientWidth,
      H: this.ChartBorder.UIElement.clientHeight };

  };
}

function AverageWidthFrame()
{
  this.newMethod = IChartFramePainting; //派生
  this.newMethod();
  delete this.newMethod;
  this.ClassName = 'AverageWidthFrame';

  this.DataWidth = 50;
  this.DistanceWidth = 10;
  this.MinXDistance = 30; //X轴刻度最小间距
  this.MinYDistance = 10;
  this.XMessageAlign = 'top'; //X轴刻度文字上下对齐方式
  this.IsShowTitle = true; //是否显示动态标题
  this.IsShowYText = [true, true]; //是否显示Y轴坐标坐标 [0=左侧] [1=右侧]
  this.XBottomOffset = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Frame.XBottomOffset; //X轴文字显示向下偏移
  this.YTextTopOffset = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Frame.YTopOffset; //Y轴顶部文字向下偏移
  this.YTextPosition = [0, 0], //是坐标否强制画在内部 [0=左侧] [1=右侧] 1=OUT" , 2=INSIDE
  this.IsShowXLine = true; //是否显示X轴刻度线
  this.IsShowYLine = true;
  this.YTextBaseline = 0; //0=居中 1=上部 (目前就支持内部刻度)

  this.ShortYLineLength = 5;
  this.ShortXLineLength = 5;

  this.DrawOtherChart; //其他画法调用

  this.DrawFrame = function ()
  {
    if (this.XPointCount > 0)
    {
      this.DistanceWidth = this.ChartBorder.GetWidth() / (4 * this.XPointCount);
      this.DataWidth = 2 * this.DistanceWidth;
    }

    this.DrawHorizontal();
    this.DrawVertical();
  };

  this.GetYFromData = function (value)
  {
    if (value <= this.HorizontalMin) return this.ChartBorder.GetBottomEx();
    if (value >= this.HorizontalMax) return this.ChartBorder.GetTopEx();

    var height = this.ChartBorder.GetHeightEx() * (value - this.HorizontalMin) / (this.HorizontalMax - this.HorizontalMin);
    return this.ChartBorder.GetBottomEx() - height;
  };

  //Y刻度画在内部
  this.DrawInsideHorizontal = function ()
  {
    if (this.IsHScreen === true) return; //横屏不画
    if (this.IsShowYText[0] === false && this.IsShowYText[1] === false) return;

    var left = this.ChartBorder.GetLeft();
    var right = this.ChartBorder.GetRight();
    var bottom = this.ChartBorder.GetBottom();
    var top = this.ChartBorder.GetTopTitle();
    var borderRight = this.ChartBorder.Right;
    var borderLeft = this.ChartBorder.Left;
    var titleHeight = this.ChartBorder.TitleHeight;
    if (borderLeft >= 10) return;

    if (borderLeft < 10 && this.IsShowYText[0] === true || borderRight < 10 && this.IsShowYText[1] === true)
    {
      var yPrev = null; //上一个坐标y的值
      for (var i = this.HorizontalInfo.length - 1; i >= 0; --i) //从上往下画分割线
      {
        var item = this.HorizontalInfo[i];
        if (!item) continue;
        var y = this.GetYFromData(item.Value);
        if (y != null && yPrev != null && Math.abs(y - yPrev) < this.MinYDistance) continue; //两个坐标在近了 就不画了

        //坐标信息 左边 间距小于10 画在内部
        if (item.Message[0] != null && borderLeft < 10 && this.IsShowYText[0] === true)
        {
          if (item.Font != null) this.Canvas.font = item.Font;
          this.Canvas.fillStyle = item.TextColor;
          this.Canvas.textAlign = "left";
          var yText = y;
          if (y >= bottom - 2)
          {
            this.Canvas.textBaseline = 'bottom';
          } else
          if (y <= top + 2)
          {
            this.Canvas.textBaseline = 'top';
            yText += this.YTextTopOffset;
          } else

          {
            if (this.YTextBaseline == 1) this.Canvas.textBaseline = "bottom";else
            this.Canvas.textBaseline = "middle";
          }
          var textObj = { X: left, Y: yText, Text: { BaseLine: this.Canvas.textBaseline, Font: this.Canvas.font, Value: item.Message[0] } };
          if (!this.IsOverlayMaxMin || !this.IsOverlayMaxMin(textObj)) this.Canvas.fillText(item.Message[0], left + 1, yText);
        }

        if (item.Message[1] != null && borderRight < 10 && this.IsShowYText[1] === true)
        {
          if (item.Font != null) this.Canvas.font = item.Font;
          this.Canvas.fillStyle = item.TextColor;
          this.Canvas.textAlign = "right";
          var yText = y;
          if (y >= bottom - 2)
          {
            this.Canvas.textBaseline = 'bottom';
          } else
          if (y <= top + 2)
          {
            this.Canvas.textBaseline = 'top';
            yText += this.YTextTopOffset;
          } else

          {
            if (this.YTextBaseline == 1) this.Canvas.textBaseline = "bottom";else
            this.Canvas.textBaseline = "middle";
          }
          var textWidth = this.Canvas.measureText(item.Message[1]).width;
          var textObj = { X: right - textWidth, Y: yText, Text: { BaseLine: this.Canvas.textBaseline, TextAlign: this.Canvas.textAlign, Font: this.Canvas.font, Value: item.Message[1] } };
          if (!this.IsOverlayMaxMin || !this.IsOverlayMaxMin(textObj))
          this.Canvas.fillText(item.Message[1], right - 1, yText);
        }

        yPrev = y;
      }
    }
  };

  //画Y轴
  this.DrawHorizontal = function ()
  {
    var left = this.ChartBorder.GetLeft();
    var right = this.ChartBorder.GetRight();
    var bottom = this.ChartBorder.GetBottom();
    var top = this.ChartBorder.GetTopTitle();
    var borderRight = this.ChartBorder.Right;
    var borderLeft = this.ChartBorder.Left;
    var titleHeight = this.ChartBorder.TitleHeight;

    this.Canvas.save();
    var yPrev = null; //上一个坐标y的值
    for (var i = this.HorizontalInfo.length - 1; i >= 0; --i) //从上往下画分割线
    {
      var item = this.HorizontalInfo[i];
      var y = this.GetYFromData(item.Value);
      if (y != null && yPrev != null && Math.abs(y - yPrev) < this.MinYDistance) continue; //两个坐标在近了 就不画了

      var yFixed = ToFixedPoint(y);
      if (bottom != y && this.IsShowYLine) //和底部线段重叠了就不绘制
        {
          if (item.LineType == 2)
          {
            this.Canvas.strokeStyle = item.LineColor;
            this.Canvas.setLineDash([5, 5]);
            this.Canvas.beginPath();
            this.Canvas.moveTo(left, yFixed);
            this.Canvas.lineTo(right, yFixed);
            this.Canvas.stroke();
            this.Canvas.setLineDash([]);
          } else
          if (item.LineType == 3) //只在刻度边上画一个短横线
            {

            } else
          if (item.LineType > 0)
          {
            this.Canvas.strokeStyle = item.LineColor;
            if (_umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameYLineDash)
            {
              this.Canvas.setLineDash(_umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameYLineDash); //虚线
              this.Canvas.beginPath();
              this.Canvas.moveTo(left, yFixed);
              this.Canvas.lineTo(right, yFixed);
              this.Canvas.stroke();
              this.Canvas.setLineDash([]);
            } else

            {
              this.Canvas.beginPath();
              this.Canvas.moveTo(left, yFixed);
              this.Canvas.lineTo(right, yFixed);
              this.Canvas.stroke();
            }
          }
        }
      var yText = y;
      if (y >= bottom - 2)
      {
        this.Canvas.textBaseline = 'bottom';
      } else
      if (y <= top + 2)
      {
        this.Canvas.textBaseline = 'top';
        yText += this.YTextTopOffset;
      } else

      {
        this.Canvas.textBaseline = "middle";
      }

      //坐标信息 左边 间距小于10 不画坐标
      this.Canvas.fillStyle = item.TextColor;
      this.Canvas.strokeStyle = item.TextColor;
      if (item.Message[0] != null && borderLeft > 10 && this.IsShowYText[0] === true)
      {
        if (item.Font != null) this.Canvas.font = item.Font;

        this.Canvas.textAlign = "right";
        this.Canvas.fillText(item.Message[0], left - 2, yText);
      }

      //坐标信息 右边 间距小于10 不画坐标
      if (item.Message[1] != null && borderRight > 10 && this.IsShowYText[1] === true)
      {
        if (item.Font != null) this.Canvas.font = item.Font;

        var xText = right;
        if (item.LineType == 3)
        {
          var lineLength = this.ShortYLineLength;
          this.Canvas.beginPath();
          this.Canvas.moveTo(xText, yFixed);
          this.Canvas.lineTo(xText + lineLength, yFixed);
          this.Canvas.stroke();

          xText += lineLength;
        }

        this.Canvas.textAlign = "left";
        this.Canvas.fillText(item.Message[1], xText + 2, yText);
      }

      yPrev = y;
    }

    this.Canvas.restore();
  };

  this.GetXFromIndex = function (index)
  {
    var count = this.XPointCount;

    if (count == 1)
    {
      if (index == 0) return this.ChartBorder.GetLeft();else
      return this.ChartBorder.GetRight();
    } else
    if (count <= 0)
    {
      return this.ChartBorder.GetLeft();
    } else
    if (index >= count)
    {
      return this.ChartBorder.GetRight();
    } else

    {
      var offset = this.ChartBorder.GetLeft() + this.ChartBorder.GetWidth() * index / count;
      return offset;
    }
  };

  //画X轴
  this.DrawVertical = function ()
  {
    var top = this.ChartBorder.GetTopTitle();
    var bottom = this.ChartBorder.GetBottom();
    var right = this.ChartBorder.GetRight();

    if (this.ChartBorder.Bottom <= 5) return; //高度不够 不显示

    var yText = bottom;
    if (this.XMessageAlign == 'bottom') yText = this.ChartBorder.GetChartHeight();else
    this.XMessageAlign = 'top';

    var xPrev = null; //上一个坐标x的值
    var xPrevTextRight = null;
    for (var i in this.VerticalInfo)
    {
      var x = this.GetXFromIndex(this.VerticalInfo[i].Value);
      if (x > right) break;
      if (xPrev != null && Math.abs(x - xPrev) < this.MinXDistance) continue;

      var item = this.VerticalInfo[i];
      var xFixed = ToFixedPoint(x);
      if (this.IsShowXLine && item.LineType > 0)
      {
        if (item.LineType == 2)
        {
          this.Canvas.strokeStyle = item.LineColor;
          this.Canvas.setLineDash([5, 5]);
          this.Canvas.beginPath();
          this.Canvas.moveTo(xFixed, top);
          this.Canvas.lineTo(xFixed, bottom);
          this.Canvas.stroke();
          this.Canvas.setLineDash([]);
        } else
        if (item.LineType == 3)
        {

        } else
        if (item.LineType > 0)
        {
          if (_umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameXLineDash)
          {
            this.Canvas.strokeStyle = item.LineColor;
            this.Canvas.beginPath();
            this.Canvas.setLineDash(_umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameXLineDash);
            this.Canvas.moveTo(xFixed, top);
            this.Canvas.lineTo(xFixed, bottom);
            this.Canvas.stroke();
            this.Canvas.setLineDash([]);
          } else

          {
            this.Canvas.strokeStyle = item.LineColor;
            this.Canvas.beginPath();
            this.Canvas.moveTo(xFixed, top);
            this.Canvas.lineTo(xFixed, bottom);
            this.Canvas.stroke();
          }
        }

      }

      if (this.VerticalInfo[i].Message[0] != null && this.ChartBorder.Bottom > 5)
      {
        var xTextRight = null;
        var xTextLeft = null;
        if (this.VerticalInfo[i].Font != null)
        this.Canvas.font = this.VerticalInfo[i].Font;
        this.Canvas.fillStyle = item.TextColor;
        this.Canvas.strokeStyle = item.TextColor;

        var testWidth = this.Canvas.measureText(this.VerticalInfo[i].Message[0]).width;
        if (x < testWidth / 2)
        {
          this.Canvas.textAlign = "left";
          this.Canvas.textBaseline = this.XMessageAlign;
          xTextRight = x + testWidth;
          xTextLeft = x;
        } else
        if (x + testWidth / 2 >= this.ChartBorder.GetChartWidth())
        {
          this.Canvas.textAlign = "right";
          this.Canvas.textBaseline = this.XMessageAlign;
          xTextRight = x + testWidth;
          xTextLeft = x;
        } else

        {
          this.Canvas.textAlign = "center";
          this.Canvas.textBaseline = this.XMessageAlign;
          xTextRight = x + testWidth / 2;
          xTextLeft = x - testWidth / 2;
        }

        if (xPrevTextRight != null && xPrevTextRight > xTextLeft) continue;

        var yText = bottom;
        if (item.LineType == 3)
        {
          var lineLength = this.ShortXLineLength;
          this.Canvas.beginPath();
          this.Canvas.moveTo(xFixed, yText);
          this.Canvas.lineTo(xFixed, yText + lineLength);
          this.Canvas.stroke();

          yText += lineLength + 2;
        }

        this.Canvas.fillText(this.VerticalInfo[i].Message[0], x, yText + this.XBottomOffset);
        xPrevTextRight = xTextRight;
      }

      xPrev = x;
    }
  };

  this.GetYData = function (y) //Y坐标转y轴数值
  {
    if (y < this.ChartBorder.GetTopEx()) return this.HorizontalMax;
    if (y > this.ChartBorder.GetBottomEx()) return this.HorizontalMin;

    return (this.ChartBorder.GetBottomEx() - y) / this.ChartBorder.GetHeightEx() * (this.HorizontalMax - this.HorizontalMin) + this.HorizontalMin;
  };

  this.GetXData = function (x) //X坐标转x轴数值
  {
    if (x <= this.ChartBorder.GetLeft()) return 0;
    if (x >= this.ChartBorder.GetRight()) return this.XPointCount;

    return (x - this.ChartBorder.GetLeft()) * (this.XPointCount * 1.0 / this.ChartBorder.GetWidth());
  };

  this.DrawCustomItem = function (item) //显示自定义刻度
  {
    //if (this.IsHScreen === true) return;  //横屏不画
    if (!item.Message[1] && !item.Message[0]) return;
    if (item.Value > this.HorizontalMax || item.Value < this.HorizontalMin) return;

    var left = this.ChartBorder.GetLeft();
    var right = this.ChartBorder.GetRight();
    var bottom = this.ChartBorder.GetBottom();
    var top = this.ChartBorder.GetTopTitle();
    var borderRight = this.ChartBorder.Right;
    var borderLeft = this.ChartBorder.Left;
    var titleHeight = this.ChartBorder.TitleHeight;

    if (this.IsHScreen)
    {
      borderLeft = this.ChartBorder.Top;
      borderRight = this.ChartBorder.Bottom;
      top = this.ChartBorder.GetTop();
      bottom = this.ChartBorder.GetBottom();
    }

    var textHeight = 18;
    var y = this.GetYFromData(item.Value);

    if (item.Message[0])
    {
      if (borderLeft < 10)
      {
        if (item.Font != null) this.Canvas.font = item.Font;
        this.Canvas.textAlign = "left";
        this.Canvas.textBaseline = "middle";
        var textWidth = this.Canvas.measureText(item.Message[0]).width + 2;
        var bgColor = item.LineColor;
        var rgb = this.RGBToStruct(item.LineColor);
        if (rgb) bgColor = "rgba(".concat(rgb.R, ", ").concat(rgb.G, ", ").concat(rgb.B, ", ").concat(_umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLatestPrice.BGAlpha, ")"); //内部刻度 背景增加透明度
        this.Canvas.fillStyle = bgColor;
        if (this.IsHScreen)
        {
          var bgTop = top;
          var textLeft = y - textHeight / 2 - 1;
          this.Canvas.fillRect(textLeft, bgTop, textHeight, textWidth);
          this.DrawHScreenText({ X: y, Y: bgTop }, { Text: item.Message[0], Color: item.TextColor, XOffset: 1, YOffset: 2 });
          this.DrawLine(bgTop + textWidth, bottom, y, item.LineColor, item.LineType);
        } else

        {
          var bgTop = y - textHeight / 2 - 1;
          var textLeft = left + 1;
          this.Canvas.fillRect(textLeft, bgTop, textWidth, textHeight);
          this.Canvas.fillStyle = item.TextColor;
          this.Canvas.fillText(item.Message[0], textLeft + 1, y);
          this.DrawLine(textLeft + textWidth, right, y, item.LineColor, item.LineType);
        }
      } else

      {
        if (item.Font != null) this.Canvas.font = item.Font;
        this.Canvas.textAlign = "right";
        this.Canvas.textBaseline = "middle";
        var textWidth = this.Canvas.measureText(item.Message[0]).width + 2;
        this.Canvas.fillStyle = item.LineColor;
        if (this.IsHScreen)
        {
          var bgTop = top - textWidth;
          var textLeft = y - textHeight / 2 - 1;
          this.Canvas.fillRect(textLeft, bgTop, textHeight, textWidth);
          this.DrawHScreenText({ X: y, Y: bgTop }, { Text: item.Message[0], Color: item.TextColor, XOffset: 1, YOffset: 2 });
          this.DrawLine(bgTop + textWidth, bottom, y, item.LineColor, item.LineType);
        } else

        {
          var bgTop = y - textHeight / 2 - 1;
          this.Canvas.fillRect(left - textWidth, bgTop, textWidth, textHeight);
          this.Canvas.fillStyle = item.TextColor;
          this.Canvas.fillText(item.Message[0], left - 1, y);
          this.DrawLine(left, right, y, item.LineColor, item.LineType);
        }
      }
    } else
    if (item.Message[1])
    {
      if (borderRight < 10)
      {
        if (item.Font != null) this.Canvas.font = item.Font;
        this.Canvas.textAlign = "left";
        this.Canvas.textBaseline = "middle";
        var textWidth = this.Canvas.measureText(item.Message[1]).width + 2;
        var bgColor = item.LineColor;
        var rgb = this.RGBToStruct(item.LineColor);
        if (rgb) bgColor = "rgba(".concat(rgb.R, ", ").concat(rgb.G, ", ").concat(rgb.B, ", ").concat(_umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLatestPrice.BGAlpha, ")"); //内部刻度 背景增加透明度
        this.Canvas.fillStyle = bgColor;
        if (this.IsHScreen)
        {
          var bgTop = bottom - textWidth;
          var textLeft = y - textHeight / 2 - 1;
          this.Canvas.fillRect(textLeft, bgTop, textHeight, textWidth);
          this.DrawHScreenText({ X: y, Y: bgTop }, { Text: item.Message[1], Color: item.TextColor, XOffset: 1, YOffset: 2 });
          this.DrawLine(top, bgTop, y, item.LineColor, item.LineType);
        } else

        {
          var bgTop = y - textHeight / 2 - 1;
          var textLeft = right - textWidth;
          this.Canvas.fillRect(textLeft, bgTop, textWidth, textHeight);
          this.Canvas.fillStyle = item.TextColor;
          this.Canvas.fillText(item.Message[1], textLeft + 1, y);
          this.DrawLine(left, textLeft, y, item.LineColor, item.LineType);
        }

      } else

      {
        if (item.Font != null) this.Canvas.font = item.Font;
        this.Canvas.textAlign = "left";
        this.Canvas.textBaseline = "middle";
        var textWidth = this.Canvas.measureText(item.Message[1]).width + 2;
        this.Canvas.fillStyle = item.LineColor;
        if (this.IsHScreen)
        {
          var bgTop = bottom;
          var textLeft = y - textHeight / 2 - 1;
          this.Canvas.fillRect(textLeft, bgTop, textHeight, textWidth);
          this.DrawHScreenText({ X: y, Y: bgTop }, { Text: item.Message[1], Color: item.TextColor, XOffset: 1, YOffset: 2 });
          this.DrawLine(top, bgTop, y, item.LineColor, item.LineType);
        } else

        {
          var bgTop = y - textHeight / 2 - 1;
          this.Canvas.fillRect(right, bgTop, textWidth, textHeight);
          this.Canvas.fillStyle = item.TextColor;
          this.Canvas.fillText(item.Message[1], right + 1, y);
          this.DrawLine(left, right, y, item.LineColor, item.LineType);
        }
      }
    }
  };

  this.DrawLine = function (left, right, y, color, lineType)
  {
    if (lineType == -1) return;

    if (lineType == 0)
    {
      this.Canvas.strokeStyle = color;
      this.Canvas.beginPath();
      if (this.IsHScreen)
      {
        this.Canvas.moveTo(ToFixedPoint(y), left);
        this.Canvas.lineTo(ToFixedPoint(y), right);
      } else

      {
        this.Canvas.moveTo(left, ToFixedPoint(y));
        this.Canvas.lineTo(right, ToFixedPoint(y));
      }
      this.Canvas.stroke();
    } else

    {
      this.DrawDotLine(left, right, y, color);
    }
  };

  this.DrawDotLine = function (left, right, y, color)
  {
    this.Canvas.save();
    this.Canvas.strokeStyle = color;
    this.Canvas.setLineDash([5, 5]); //虚线
    this.Canvas.beginPath();
    if (this.IsHScreen)
    {
      this.Canvas.moveTo(ToFixedPoint(y), left);
      this.Canvas.lineTo(ToFixedPoint(y), right);
    } else

    {
      this.Canvas.moveTo(left, ToFixedPoint(y));
      this.Canvas.lineTo(right, ToFixedPoint(y));
    }
    this.Canvas.stroke();
    this.Canvas.restore();
  };

  this.RGBToStruct = function (rgb)
  {
    if (/^(rgb|RGB)/.test(rgb))
    {
      var aColor = rgb.replace(/(?:\(|\)|rgb|RGB)*/g, "").split(",");
      var result = {};
      if (aColor.length != 3) return null;

      result.R = Number(aColor[0]);
      result.G = Number(aColor[1]);
      result.B = Number(aColor[2]);
      return result;
    }
    return null;
  };

  this.DrawHScreenText = function (center, data)
  {
    this.Canvas.textAlign = "left";
    this.Canvas.textBaseline = "middle";
    this.Canvas.fillStyle = data.Color;

    this.Canvas.save();
    this.Canvas.translate(center.X, center.Y);
    this.Canvas.rotate(90 * Math.PI / 180);
    this.Canvas.fillText(data.Text, data.XOffset, data.YOffset);
    this.Canvas.restore();
  };
}

function MinuteFrame()
{
  this.newMethod = AverageWidthFrame; //派生
  this.newMethod();
  delete this.newMethod;
  this.ClassName = 'MinuteFrame';

  this.MinXDistance = 10;
  this.CustomHorizontalInfo = [];

  this.DrawFrame = function ()
  {
    this.SplitXYCoordinate();

    this.DrawTitleBG();
    this.DrawHorizontal();
    this.DrawVertical();
  };

  //分割x,y轴坐标信息
  this.SplitXYCoordinate = function ()
  {
    if (this.XYSplit == false) return;
    if (this.YSplitOperator != null) this.YSplitOperator.Operator();
    if (this.XSplitOperator != null) this.XSplitOperator.Operator();
  };

  this.GetXFromIndex = function (index)
  {
    var count = this.XPointCount - 1;

    if (count == 1)
    {
      if (index == 0) return this.ChartBorder.GetLeft();else
      return this.ChartBorder.GetRight();
    } else
    if (count <= 0)
    {
      return this.ChartBorder.GetLeft();
    } else
    if (index >= count)
    {
      return this.ChartBorder.GetRight();
    } else

    {
      var offset = this.ChartBorder.GetLeft() + this.ChartBorder.GetWidth() * index / count;
      return offset;
    }
  };

  //X坐标转x轴数值
  this.GetXData = function (x)
  {
    if (x <= this.ChartBorder.GetLeft()) return 0;
    if (x >= this.ChartBorder.GetRight()) return this.XPointCount;

    return (x - this.ChartBorder.GetLeft()) * (this.XPointCount * 1.0 / this.ChartBorder.GetWidth());
  };

  this.DrawCustomHorizontal = function () //Y轴刻度定制显示
  {
    for (var i in this.CustomHorizontalInfo)
    {
      var item = this.CustomHorizontalInfo[i];
      switch (item.Type) {

        case 0:
        case 1:
          this.DrawCustomItem(item); //自定义刻度
          break;}

    }
  };
}

function MinuteHScreenFrame()
{
  this.newMethod = MinuteFrame; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = 'MinuteHScreenFrame';
  this.IsHScreen = true; //是否是横屏

  //画标题背景色
  this.DrawTitleBG = function ()
  {
    /*
    if (this.ChartBorder.TitleHeight <= 0) return;
      var left = ToFixedPoint(this.ChartBorder.GetRightEx());
    var top = ToFixedPoint(this.ChartBorder.GetTop());
    var bottom = ToFixedPoint(this.ChartBorder.GetBottom());
    var width = this.ChartBorder.TitleHeight;
    var height = bottom - top;
      this.Canvas.fillStyle = this.TitleBGColor;
    this.Canvas.fillRect(left, top, width, height);
    */


  };

  this.DrawInsideHorizontal = function ()
  {
  };

  //Y坐标转y轴数值
  this.GetYData = function (x)
  {
    if (x < this.ChartBorder.GetLeftEx()) return this.HorizontalMin;
    if (x > this.ChartBorder.GetRightEx()) return this.HorizontalMax;

    return (x - this.ChartBorder.GetLeftEx()) / this.ChartBorder.GetWidthEx() * (this.HorizontalMax - this.HorizontalMin) + this.HorizontalMin;
  };

  //X坐标转x轴数值
  this.GetXData = function (y)
  {
    if (y <= this.ChartBorder.GetTop()) return 0;
    if (y >= this.ChartBorder.GetBottom()) return this.XPointCount;

    var count = this.XPointCount - 1;
    return (y - this.ChartBorder.GetTop()) * (count * 1.0 / this.ChartBorder.GetHeight());
  };

  this.GetXFromIndex = function (index)
  {
    var count = this.XPointCount - 1;

    if (count == 1)
    {
      if (index == 0) return this.ChartBorder.GetTop();else
      return this.ChartBorder.GetBottom();
    } else
    if (count <= 0)
    {
      return this.ChartBorder.GetTop();
    } else
    if (index >= count)
    {
      return this.ChartBorder.GetBottom();
    } else

    {
      var offset = this.ChartBorder.GetTop() + this.ChartBorder.GetHeight() * index / count;
      return offset;
    }
  };


  this.GetYFromData = function (value)
  {
    if (value <= this.HorizontalMin) return this.ChartBorder.GetLeft();
    if (value >= this.HorizontalMax) return this.ChartBorder.GetRightEx();

    var width = this.ChartBorder.GetWidthEx() * (value - this.HorizontalMin) / (this.HorizontalMax - this.HorizontalMin);
    return this.ChartBorder.GetLeft() + width;
  };

  //画Y轴
  this.DrawHorizontal = function ()
  {
    var top = this.ChartBorder.GetTop();
    var bottom = this.ChartBorder.GetBottom();
    var left = this.ChartBorder.GetLeft();
    var right = this.ChartBorder.GetRight();
    var borderTop = this.ChartBorder.Top;
    var borderBottom = this.ChartBorder.Bottom;

    var yPrev = null; //上一个坐标y的值
    for (var i = this.HorizontalInfo.length - 1; i >= 0; --i) //从左往右画分割线
    {
      var item = this.HorizontalInfo[i];
      var y = this.GetYFromData(item.Value);
      if (y != null && Math.abs(y - yPrev) < this.MinYDistance) continue; //两个坐标在近了 就不画了

      this.Canvas.strokeStyle = item.LineColor;
      this.Canvas.beginPath();
      this.Canvas.moveTo(ToFixedPoint(y), top);
      this.Canvas.lineTo(ToFixedPoint(y), bottom);
      this.Canvas.stroke();

      if (y >= right - 2)
      {
        this.Canvas.textBaseline = 'top';
        y = right;
      } else
      if (y <= left + 2)
      {
        this.Canvas.textBaseline = 'bottom';
        y = left;
        if (y != null && Math.abs(y - yPrev) < 2 * this.MinYDistance) continue; //两个坐标在近了 就不画了
      } else

      {
        this.Canvas.textBaseline = "middle";
      }

      //坐标信息 左边 间距小于10 不画坐标
      if (item.Message[0] != null && borderTop > 10)
      {
        if (item.Font != null) this.Canvas.font = item.Font;

        this.Canvas.fillStyle = item.TextColor;
        this.Canvas.textAlign = "right";
        //this.Canvas.textBaseline = "middle";

        var xText = y,yText = top;
        this.Canvas.save();
        this.Canvas.translate(xText, yText);
        this.Canvas.rotate(90 * Math.PI / 180);
        this.Canvas.fillText(item.Message[0], -2, 0);
        this.Canvas.restore();
      }

      //坐标信息 右边 间距小于10 不画坐标
      if (item.Message[1] != null && borderBottom > 10)
      {
        if (item.Font != null) this.Canvas.font = item.Font;

        this.Canvas.fillStyle = item.TextColor;
        this.Canvas.textAlign = "left";
        //this.Canvas.textBaseline = "middle";
        var xText = y,yText = bottom;
        this.Canvas.save();
        this.Canvas.translate(xText, yText);
        this.Canvas.rotate(90 * Math.PI / 180);
        this.Canvas.fillText(item.Message[1], 2, 0);
        this.Canvas.restore();
      }

      yPrev = y;
    }
  };

  //画X轴
  this.DrawVertical = function () {
    var left = this.ChartBorder.GetLeft();
    var right = this.ChartBorder.GetRightEx();
    var bottom = this.ChartBorder.GetBottom();

    var xPrev = null; //上一个坐标x的值
    for (var i in this.VerticalInfo) {
      var x = this.GetXFromIndex(this.VerticalInfo[i].Value);
      if (x > bottom) break;
      if (xPrev != null && Math.abs(x - xPrev) < this.MinXDistance) continue;

      this.Canvas.strokeStyle = this.VerticalInfo[i].LineColor;
      this.Canvas.beginPath();
      this.Canvas.moveTo(left, ToFixedPoint(x));
      this.Canvas.lineTo(right, ToFixedPoint(x));
      this.Canvas.stroke();

      if (this.VerticalInfo[i].Message[0] != null) {
        if (this.VerticalInfo[i].Font != null)
        this.Canvas.font = this.VerticalInfo[i].Font;

        this.Canvas.fillStyle = this.VerticalInfo[i].TextColor;
        var testWidth = this.Canvas.measureText(this.VerticalInfo[i].Message[0]).width;
        if (x < testWidth / 2) {
          this.Canvas.textAlign = "left";
          this.Canvas.textBaseline = "top";
        } else
        if (x + testWidth / 2 >= this.ChartBorder.GetChartHeight()) {
          this.Canvas.textAlign = "right";
          this.Canvas.textBaseline = "top";
        } else
        {
          this.Canvas.textAlign = "center";
          this.Canvas.textBaseline = "top";
        }

        var xText = left,yText = x;
        this.Canvas.save();
        this.Canvas.translate(xText, yText);
        this.Canvas.rotate(90 * Math.PI / 180);
        this.Canvas.fillText(this.VerticalInfo[i].Message[0], 0, 0);
        this.Canvas.restore();
      }

      xPrev = x;
    }
  };
}

//K线框架
function KLineFrame()
{
  this.newMethod = AverageWidthFrame; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = 'KLineFrame';
  this.ToolbarID = Guid(); //工具条Div id
  this.ModifyIndex = true; //是否显示'改参数'菜单
  this.ChangeIndex = true; //是否显示'换指标'菜单
  this.CustomHorizontalInfo = [];

  this.LastCalculateStatus = { Width: 0, XPointCount: 0 }; //最后一次计算宽度的状态

  //定制X轴刻度 
  //Type:0,  Date:, Time: , Name:名字,       Line:{ Color:线段颜色, Type:线段类型 0 直线 1 虚线 }
  //Type: 1, Space: 第几个空白间距, Name:名字, Line: { Color: 线段颜色, Type: 线段类型 0 直线 1 虚线 }
  this.CustomVerticalInfo = [];
  this.DrawCustomVerticalEvent;
  this.RightSpaceCount = 0;

  this.DrawFrame = function ()
  {
    //JSConsole.Chart.Log('[KLineFrame::DrawFrame]', this.SizeChange);
    this.SplitXYCoordinate();
    if (this.SizeChange == true) this.CalculateDataWidth();
    if (this.DrawOtherChart) this.DrawOtherChart();

    this.DrawTitleBG();
    this.DrawHorizontal();
    this.DrawVertical();
  };

  this.GetXFromIndex = function (index)
  {
    if (index < 0) index = 0;
    if (index > this.xPointCount - 1) index = this.xPointCount - 1;

    var offset = this.ChartBorder.GetLeft() + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLeftMargin + this.DistanceWidth / 2 + this.DataWidth / 2;
    for (var i = 1; i <= index; ++i) {offset += this.DistanceWidth + this.DataWidth;}
    return offset;
  };

  //X坐标转x轴数值
  this.GetXData = function (x)
  {
    if (x <= this.ChartBorder.GetLeft()) return 0;
    if (x >= this.ChartBorder.GetRight()) return this.XPointCount - 1;

    var left = this.ChartBorder.GetLeft() + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLeftMargin;
    var right = this.ChartBorder.GetRight() - _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameRightMargin;
    var distanceWidth = this.DistanceWidth;
    var dataWidth = this.DataWidth;

    var index = 0;
    var xPoint = left + distanceWidth / 2 + dataWidth + distanceWidth;
    while (xPoint < right && index < 10000 && index + 1 < this.XPointCount) //自己算x的数值
    {
      if (xPoint > x) break;
      xPoint += dataWidth + distanceWidth;
      ++index;
    }

    //var test=(x-this.ChartBorder.GetLeft())*(this.XPointCount*1.0/this.ChartBorder.GetWidth());
    return index;
  };

  this.DrawCustomHorizontal = function () //Y轴刻度定制显示
  {
    for (var i in this.CustomHorizontalInfo)
    {
      var item = this.CustomHorizontalInfo[i];
      switch (item.Type) {

        case 0: //最新价格刻度
        case 1: //固定价格刻度
          this.DrawCustomItem(item);
          break;}

    }
  };

  this.DrawCustomVerticalItem = function (item) {
    this.Canvas.save();
    if (item.Data.Line.Type == 1) this.Canvas.setLineDash([5, 5]); //虚线
    this.Canvas.strokeStyle = item.Data.Line.Color;
    this.Canvas.beginPath();
    if (item.IsHScreen) {
      this.Canvas.moveTo(item.Top, ToFixedPoint(item.X));
      this.Canvas.lineTo(item.Bottom, ToFixedPoint(item.X));
    } else
    {
      this.Canvas.moveTo(ToFixedPoint(item.X), item.Top);
      this.Canvas.lineTo(ToFixedPoint(item.X), item.Bottom);
    }
    this.Canvas.stroke();
    this.Canvas.restore();
  };

  this.DrawCustomVertical = function () //X轴定制刻度显示
  {
    if (!this.CustomVerticalInfo) return;
    if (this.CustomVerticalInfo.length <= 0) return;
    if (!this.Data) return;

    var isHScreen = this.IsHScreen;
    var top = this.ChartBorder.GetTopEx();
    var bottom = this.ChartBorder.GetBottomEx();

    var dataWidth = this.DataWidth;
    var distanceWidth = this.DistanceWidth;
    var xOffset = this.ChartBorder.GetLeft() + distanceWidth / 2.0 + 2.0;

    if (isHScreen)
    {
      xOffset = this.ChartBorder.GetTop() + distanceWidth / 2.0 + 2.0;
      top = this.ChartBorder.GetLeftEx();
      bottom = this.ChartBorder.GetRightEx();
    }

    var j = 0;
    for (var i = this.Data.DataOffset; i < this.Data.Data.length && j < this.XPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth)
    {
      var kItem = this.Data.Data[i];
      for (var k in this.CustomVerticalInfo)
      {
        var item = this.CustomVerticalInfo[k];
        if (item.Type != 0) continue;

        if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Time))
        {
          if (kItem.Date != item.Date || kItem.Time != item.Time) continue;
        } else

        {
          if (kItem.Date != item.Date) continue;
        }

        var left = xOffset;
        var right = xOffset + dataWidth;
        var x = left + (right - left) / 2;

        var DrawData = { X: x, Top: top, Bottom: bottom, Data: item, IsHScreen: isHScreen };
        this.DrawCustomVerticalItem(DrawData);
        if (this.DrawCustomVerticalEvent)
        this.DrawCustomVerticalEvent.Callback(this.DrawCustomVerticalEvent, DrawData, this);

        break;
      }
    }

    for (var i = 1; j < this.XPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth)
    {
      for (var k in this.CustomVerticalInfo)
      {
        var item = this.CustomVerticalInfo[k];
        if (item.Type != 1) continue;
        if (item.Space != i) continue;

        var left = xOffset;
        var right = xOffset + dataWidth;
        var x = left + (right - left) / 2;

        var DrawData = { X: x, Top: top, Bottom: bottom, Data: item, IsHScreen: isHScreen };
        this.DrawCustomVerticalItem(DrawData);
        if (this.DrawCustomVerticalEvent)
        this.DrawCustomVerticalEvent.Callback(this.DrawCustomVerticalEvent, DrawData, this);

        break;
      }
    }
  };

  this.CalculateDataWidth = function () //计算数据宽度
  {
    if (this.XPointCount < 2) return;
    var width = this.GetFrameWidth() - _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameMargin; //预留4个像素 防止最后1个柱子不够画

    if (this.ZoomIndex >= 0 && this.LastCalculateStatus.Width == width && this.LastCalculateStatus.XPointCount == this.XPointCount) //宽度没变 尝试使用原来的柱子宽度
      {
        var caclWidth = this.DistanceWidth / 2 + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLeftMargin + (this.DataWidth + this.DistanceWidth) * (this.XPointCount - 1);
        var caclWidth2 = (this.DataWidth + this.DistanceWidth) * this.XPointCount;
        if (caclWidth <= width) //当前的柱子宽度够用 就不调整了
          return;
      }

    this.LastCalculateStatus.Width = width;
    this.LastCalculateStatus.XPointCount = this.XPointCount;

    for (var i = 0; i < ZOOM_SEED.length; ++i)
    {
      var barWidth = ZOOM_SEED[i][0]; //数据宽度
      var distanceWidth = ZOOM_SEED[i][1]; //间距宽度
      if ((ZOOM_SEED[i][0] + ZOOM_SEED[i][1]) * this.XPointCount < width)
      {
        this.ZoomIndex = i;
        this.DataWidth = ZOOM_SEED[i][0];
        this.DistanceWidth = ZOOM_SEED[i][1];
        this.TrimKLineDataWidth(width);

        _umychartConsoleWechat.JSConsole.Chart.Log("[KLineFrame::CalculateDataWidth] ZoomIndex=".concat(this.ZoomIndex, " DataWidth=").concat(this.DataWidth, " DistanceWidth=").concat(this.DistanceWidth));
        return;
      }
    }

    //太多了 就平均分了
    this.ZoomIndex = ZOOM_SEED.length - 1;
    this.DataWidth = width / this.XPointCount;
    this.DistanceWidth = 0;
  };

  this.OnSize = function (obj)
  {
    var width = this.GetFrameWidth() - _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameMargin;
    var xPointCount = 0;
    var y = this.DistanceWidth / 2 + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLeftMargin + (this.DataWidth + this.DistanceWidth);
    for (; y < width; y += this.DataWidth + this.DistanceWidth, ++xPointCount) {}

    obj.CurCount = this.XPointCount;
    obj.CalcCount = xPointCount;
    obj.DataWidth = this.DataWidth;
    obj.DistanceWidth = this.DistanceWidth;
    obj.Changed = false;

    this.LastCalculateStatus.Width = width;
    if (obj.CurCount == obj.CalcCount) return obj;

    this.XPointCount = xPointCount;
    this.LastCalculateStatus.XPointCount = this.XPointCount;
    if (this.Data)
    {
      this.Data.DataOffset += obj.CurCount - obj.CalcCount;
      if (this.Data.DataOffset < 0) this.Data.DataOffset = 0;
      obj.Changed = true;
    }
    return obj;
  };

  this.SetDataWidth = function (dataWidth)
  {
    var zoomIndex = ZOOM_SEED.length - 1;
    for (var i in ZOOM_SEED)
    {
      var item = ZOOM_SEED[i];
      if (item[0] <= dataWidth)
      {
        zoomIndex = parseInt(i) - 1;
        break;
      }
    }

    this.ZoomIndex = zoomIndex;
    this.DataWidth = ZOOM_SEED[this.ZoomIndex][0];
    this.DistanceWidth = ZOOM_SEED[this.ZoomIndex][1];
    var width = this.GetFrameWidth() - _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameMargin;
    var xPointCount = 0;
    var y = this.DistanceWidth / 2 + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLeftMargin + (this.DataWidth + this.DistanceWidth);
    for (; y <= width; y += this.DataWidth + this.DistanceWidth, ++xPointCount) {}

    this.XPointCount = xPointCount;
    this.LastCalculateStatus.XPointCount = this.XPointCount;
    this.LastCalculateStatus.Width = width;

    var obj = { XPointCount: this.XPointCount, DataWidth: this.DataWidth, DistanceWidth: this.DistanceWidth };
    return obj;
  };

  this.TrimKLineDataWidth = function (width)
  {
    var zoom = ZOOM_SEED[this.ZoomIndex];
    var dataWidth = ZOOM_SEED[this.ZoomIndex][0];
    var distanceWidth = ZOOM_SEED[this.ZoomIndex][1];
    if (dataWidth == 1 && distanceWidth == 0)
    {
      this.DataWidth = width / this.XPointCount;
      return;
    }

    if (zoom[0] < 4) //最后2个缩放,调整间距不调整数据宽度, 数据都是画竖线的
      {
        while (true)
        {
          if ((this.DistanceWidth + this.DataWidth) * this.XPointCount + this.DistanceWidth > width)
          {
            this.DistanceWidth -= 0.01;
            break;
          }
          this.DistanceWidth += 0.01;
        }
      } else

    {
      while (true)
      {
        if ((this.DistanceWidth + this.DataWidth) * this.XPointCount + this.DistanceWidth > width)
        {
          this.DataWidth -= 0.01;
          break;
        }
        this.DataWidth += 0.01;
      }
    }
  };

  this.IsOverlayMaxMin = function (obj) //当前坐标信息 是否覆盖最大 最小值输出
  {
    if (!this.ChartKLine) return false;
    if (!this.ChartKLine.Max || !this.ChartKLine.Min) return false;

    var textWidth = this.Canvas.measureText(obj.Text.Value).width + 4; //刻度文字宽度
    var max = this.ChartKLine.Max,min = this.ChartKLine.Min;
    var isOverlayMax = false,isOverlayMin = false;
    var textHeight = 20; //字体高度
    if (max.X >= obj.X && max.X <= obj.X + textWidth)
    {
      var y1 = max.Y + textHeight,y2 = max.Y - textHeight;
      if (y1 >= obj.Y - textHeight && y1 <= obj.Y + textHeight || y2 >= obj.Y - textHeight && y2 <= obj.Y + textHeight)
      isOverlayMax = true;
    }

    if (isOverlayMax == true) return true;

    if (min.X >= obj.X && min.X <= obj.X + textWidth) //最小值X 坐标不在 刻度文字范围内
      {
        var y1 = min.Y + textHeight,y2 = min.Y - textHeight;
        if (y1 >= obj.Y - textHeight && y1 <= obj.Y + textHeight || y2 >= obj.Y - textHeight && y2 <= obj.Y + textHeight)
        isOverlayMin = true;
      }

    return isOverlayMax || isOverlayMin;
  };

  //分割x,y轴坐标信息
  this.SplitXYCoordinate = function ()
  {
    if (this.XYSplit == false) return;
    if (this.YSplitOperator != null) this.YSplitOperator.Operator();
    if (this.XSplitOperator != null) this.XSplitOperator.Operator();
  };

  this.CalculateCount = function (zoomIndex)
  {
    var width = this.GetFrameWidth() - _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameMargin;
    return parseInt(width / (ZOOM_SEED[zoomIndex][0] + ZOOM_SEED[zoomIndex][1]));
  };

  this.ZoomUp = function (cursorIndex)
  {
    if (this.ZoomIndex <= 0) return false;
    if (this.Data.DataOffset < 0) return false;
    var dataCount = this.Data.Data.length;
    var maxDataCount = dataCount + this.RightSpaceCount;

    var rightSpaceCount = 0;
    var lastDataIndex = this.Data.DataOffset + this.XPointCount - 1; //最右边的数据索引
    var lastCursorIndex = this.Data.DataOffset + cursorIndex.Index;

    if (lastDataIndex >= dataCount)
    {
      rightSpaceCount = lastDataIndex - (this.Data.Data.length - 1); //计算右边预留空间
      lastDataIndex = this.Data.Data.length - 1;
      if (rightSpaceCount > this.RightSpaceCount) rightSpaceCount = this.RightSpaceCount;
    }

    var xPointCount = this.CalculateCount(this.ZoomIndex - 1);

    --this.ZoomIndex;
    this.XPointCount = xPointCount;
    if (xPointCount >= maxDataCount)
    {
      xPointCount = maxDataCount;
      this.XPointCount = xPointCount;
      this.Data.DataOffset = 0;
    } else

    {
      this.XPointCount = xPointCount;
      this.Data.DataOffset = lastDataIndex - (this.XPointCount - rightSpaceCount) + 1;
    }

    this.DataWidth = ZOOM_SEED[this.ZoomIndex][0];
    this.DistanceWidth = ZOOM_SEED[this.ZoomIndex][1];
    var width = this.GetFrameWidth() - _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameMargin;
    this.TrimKLineDataWidth(width);

    this.LastCalculateStatus.XPointCount = this.XPointCount;
    cursorIndex.Index = lastCursorIndex - this.Data.DataOffset;

    return true;
  };

  this.ZoomDown = function (cursorIndex)
  {
    if (this.ZoomIndex + 1 >= ZOOM_SEED.length) return false;
    if (this.Data.DataOffset < 0) return false;
    var dataCount = this.Data.Data.length;
    var maxDataCount = dataCount + this.RightSpaceCount;
    if (this.XPointCount >= dataCount) return false;

    var rightSpaceCount = 0;
    var lastDataIndex = this.Data.DataOffset + this.XPointCount - 1; //最右边的数据索引
    if (lastDataIndex >= this.Data.Data.length)
    {
      rightSpaceCount = lastDataIndex - (this.Data.Data.length - 1); //计算右边预留空间
      lastDataIndex = this.Data.Data.length - 1;
      if (rightSpaceCount > this.RightSpaceCount) rightSpaceCount = this.RightSpaceCount;
    }

    var xPointCount = this.CalculateCount(this.ZoomIndex + 1);
    var lastCursorIndex = this.Data.DataOffset + cursorIndex.Index;

    ++this.ZoomIndex;
    if (xPointCount >= maxDataCount)
    {
      xPointCount = maxDataCount;
      this.XPointCount = xPointCount;
      this.Data.DataOffset = 0;
    } else

    {
      this.XPointCount = xPointCount;
      this.Data.DataOffset = lastDataIndex - (this.XPointCount - rightSpaceCount) + 1;
    }

    this.DataWidth = ZOOM_SEED[this.ZoomIndex][0];
    this.DistanceWidth = ZOOM_SEED[this.ZoomIndex][1];
    var width = this.GetFrameWidth() - _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameMargin;
    this.TrimKLineDataWidth(width);

    this.LastCalculateStatus.XPointCount = this.XPointCount;
    cursorIndex.Index = lastCursorIndex - this.Data.DataOffset;

    return true;
  };

  this.GetFrameWidth = function ()
  {
    if (this.IsHScreen) return this.ChartBorder.GetHeight();
    return this.ChartBorder.GetWidth();
  };
}

//K线横屏框架
function KLineHScreenFrame()
{
  this.newMethod = KLineFrame; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = 'KLineHScreenFrame';
  this.IsHScreen = true; //是否是横屏

  this.DrawInsideHorizontal = function ()
  {
    if (this.IsShowYText[0] === false && this.IsShowYText[1] === false) return;

    var left = this.ChartBorder.GetLeft();
    var right = this.ChartBorder.GetRightEx();
    var top = this.ChartBorder.GetTop();
    var bottom = this.ChartBorder.GetBottom();
    var borderTop = this.ChartBorder.Top;
    var borderBottom = this.ChartBorder.Bottom;
    var titleHeight = this.ChartBorder.TitleHeight;
    var pixelTatio = 1;

    var isDrawLeft = (borderTop < 10 * pixelTatio || this.YTextPosition[0] == 2) && this.IsShowYText[0] === true;
    var isDrawRight = (borderBottom < 10 * pixelTatio || this.YTextPosition[1] == 2) && this.IsShowYText[1] === true;

    if (isDrawLeft || isDrawRight)
    {
      var yPrev = null; //上一个坐标y的值
      for (var i = this.HorizontalInfo.length - 1; i >= 0; --i) //从上往下画分割线
      {
        var item = this.HorizontalInfo[i];
        var y = this.GetYFromData(item.Value);
        if (y != null && yPrev != null && Math.abs(y - yPrev) < this.MinYDistance) continue; //两个坐标在近了 就不画了

        //坐标信息 左边 间距小于10 画在内部
        if (item.Message[0] != null && isDrawLeft)
        {
          if (item.Font != null) this.Canvas.font = item.Font;
          this.Canvas.fillStyle = item.TextColor;
          this.Canvas.textAlign = "left";
          if (y >= right - 2) this.Canvas.textBaseline = 'top';else
          if (y <= left + 2) this.Canvas.textBaseline = 'bottom';else
          this.Canvas.textBaseline = "middle";

          var textObj = { X: left, Y: y, Text: { BaseLine: this.Canvas.textBaseline, TextAlign: this.Canvas.textAlign, Font: this.Canvas.font, Value: item.Message[0] } };
          var xText = y,yText = top;
          this.Canvas.save();
          this.Canvas.translate(xText, yText);
          this.Canvas.rotate(90 * Math.PI / 180);
          this.Canvas.fillText(item.Message[0], -2, 0);
          this.Canvas.restore();
        }

        if (item.Message[1] != null && isDrawRight)
        {
          if (item.Font != null) this.Canvas.font = item.Font;
          this.Canvas.fillStyle = item.TextColor;
          this.Canvas.textAlign = "right";
          if (y >= right - 2) this.Canvas.textBaseline = 'top';else
          if (y <= left + 2) this.Canvas.textBaseline = 'bottom';else
          this.Canvas.textBaseline = "middle";
          var textWidth = this.Canvas.measureText(item.Message[1]).width;
          var textObj = { X: right - textWidth, Y: y, Text: { BaseLine: this.Canvas.textBaseline, TextAlign: this.Canvas.textAlign, Font: this.Canvas.font, Value: item.Message[1] } };

          var xText = y,yText = bottom;
          this.Canvas.save();
          this.Canvas.translate(xText, yText);
          this.Canvas.rotate(90 * Math.PI / 180);
          this.Canvas.fillText(item.Message[1], 2, 0);
          this.Canvas.restore();
        }
        yPrev = y;
      }
    }
  };

  //画标题背景色
  this.DrawTitleBG = function ()
  {
    /*
    if (this.ChartBorder.TitleHeight <= 0) return;
      var left = ToFixedPoint(this.ChartBorder.GetRightEx());
    var top = ToFixedPoint(this.ChartBorder.GetTop());
    var bottom = ToFixedPoint(this.ChartBorder.GetBottom());
    var width = this.ChartBorder.TitleHeight;
    var height = bottom - top;
      this.Canvas.fillStyle = this.TitleBGColor;
    this.Canvas.fillRect(left, top, width, height);
    */


  };

  this.GetYFromData = function (value)
  {
    if (value <= this.HorizontalMin) return this.ChartBorder.GetLeftEx();
    if (value >= this.HorizontalMax) return this.ChartBorder.GetRightEx();

    var width = this.ChartBorder.GetWidthEx() * (value - this.HorizontalMin) / (this.HorizontalMax - this.HorizontalMin);
    return this.ChartBorder.GetLeftEx() + width;
  };

  //画Y轴
  this.DrawHorizontal = function ()
  {
    var top = this.ChartBorder.GetTop();
    var bottom = this.ChartBorder.GetBottom();
    var borderTop = this.ChartBorder.Top;
    var borderBottom = this.ChartBorder.Bottom;
    var left = this.ChartBorder.GetLeft();

    var yPrev = null; //上一个坐标y的值
    for (var i = this.HorizontalInfo.length - 1; i >= 0; --i) //从左往右画分割线
    {
      var item = this.HorizontalInfo[i];
      var y = this.GetYFromData(item.Value);
      if (y != null && Math.abs(y - yPrev) < 15) continue; //两个坐标在近了 就不画了

      if (y != left)
      {
        if (item.LineType == 2)
        {
          this.Canvas.strokeStyle = item.LineColor;
          this.Canvas.setLineDash([5, 5]); //虚线
          this.Canvas.beginPath();
          this.Canvas.moveTo(ToFixedPoint(y), top);
          this.Canvas.lineTo(ToFixedPoint(y), bottom);
          this.Canvas.stroke();
          this.Canvas.setLineDash([]);
        } else
        if (item.LineType > 0)
        {
          this.Canvas.strokeStyle = item.LineColor;
          if (_umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameYLineDash)
          {
            this.Canvas.setLineDash(_umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameYLineDash); //虚线
            this.Canvas.beginPath();
            this.Canvas.moveTo(ToFixedPoint(y), top);
            this.Canvas.lineTo(ToFixedPoint(y), bottom);
            this.Canvas.stroke();
            this.Canvas.setLineDash([]);
          } else

          {
            this.Canvas.beginPath();
            this.Canvas.moveTo(ToFixedPoint(y), top);
            this.Canvas.lineTo(ToFixedPoint(y), bottom);
            this.Canvas.stroke();
          }
        }
      }

      //坐标信息 左边 间距小于10 不画坐标
      if (item.Message[0] != null && borderTop > 10)
      {
        if (item.Font != null) this.Canvas.font = item.Font;

        this.Canvas.fillStyle = item.TextColor;
        this.Canvas.textAlign = "right";
        this.Canvas.textBaseline = "middle";

        var xText = y,yText = top;
        this.Canvas.save();
        this.Canvas.translate(xText, yText);
        this.Canvas.rotate(90 * Math.PI / 180);
        this.Canvas.fillText(item.Message[0], -2, 0);
        this.Canvas.restore();
      }

      //坐标信息 右边 间距小于10 不画坐标
      if (item.Message[1] != null && borderBottom > 10)
      {
        if (item.Font != null) this.Canvas.font = item.Font;

        this.Canvas.fillStyle = item.TextColor;
        this.Canvas.textAlign = "left";
        this.Canvas.textBaseline = "middle";
        var xText = y,yText = bottom;
        this.Canvas.save();
        this.Canvas.translate(xText, yText);
        this.Canvas.rotate(90 * Math.PI / 180);
        this.Canvas.fillText(item.Message[1], 2, 0);
        this.Canvas.restore();
      }

      yPrev = y;
    }
  };

  this.GetXFromIndex = function (index)
  {
    if (index < 0) index = 0;
    if (index > this.xPointCount - 1) index = this.xPointCount - 1;

    var offset = this.ChartBorder.GetTop() + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLeftMargin + this.DistanceWidth / 2 + this.DataWidth / 2;
    for (var i = 1; i <= index; ++i)
    {
      offset += this.DistanceWidth + this.DataWidth;
    }

    return offset;
  };

  //画X轴
  this.DrawVertical = function ()
  {
    var left = this.ChartBorder.GetLeft();
    var right = this.ChartBorder.GetRightTitle();
    var bottom = this.ChartBorder.GetBottom();

    var xPrev = null; //上一个坐标x的值
    for (var i in this.VerticalInfo)
    {
      var x = this.GetXFromIndex(this.VerticalInfo[i].Value);
      if (x >= bottom) break;
      if (xPrev != null && Math.abs(x - xPrev) < 80) continue;
      var item = this.VerticalInfo[i];
      if (item.LineType == 2)
      {
        this.Canvas.setLineDash([5, 5]);
        this.Canvas.beginPath();
        this.Canvas.moveTo(left, ToFixedPoint(x));
        this.Canvas.lineTo(right, ToFixedPoint(x));
        this.Canvas.stroke();
        this.Canvas.setLineDash([]);
      } else
      if (item.LineType > 0)
      {
        this.Canvas.strokeStyle = item.LineColor;
        if (_umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameXLineDash)
        {
          this.Canvas.setLineDash(_umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameXLineDash);
          this.Canvas.beginPath();
          this.Canvas.moveTo(left, ToFixedPoint(x));
          this.Canvas.lineTo(right, ToFixedPoint(x));
          this.Canvas.stroke();
          this.Canvas.setLineDash([]);
        } else

        {
          this.Canvas.beginPath();
          this.Canvas.moveTo(left, ToFixedPoint(x));
          this.Canvas.lineTo(right, ToFixedPoint(x));
          this.Canvas.stroke();
        }
      }

      if (this.VerticalInfo[i].Message[0] != null)
      {
        if (this.VerticalInfo[i].Font != null)
        this.Canvas.font = this.VerticalInfo[i].Font;

        this.Canvas.fillStyle = this.VerticalInfo[i].TextColor;
        var testWidth = this.Canvas.measureText(this.VerticalInfo[i].Message[0]).width;
        if (x < testWidth / 2)
        {
          this.Canvas.textAlign = "left";
          this.Canvas.textBaseline = "top";
        } else

        {
          this.Canvas.textAlign = "center";
          this.Canvas.textBaseline = "top";
        }

        var xText = left,yText = x;
        this.Canvas.save();
        this.Canvas.translate(xText, yText);
        this.Canvas.rotate(90 * Math.PI / 180);
        this.Canvas.fillText(this.VerticalInfo[i].Message[0], 0, this.XBottomOffset);
        this.Canvas.restore();
      }

      xPrev = x;
    }
  };

  //Y坐标转y轴数值
  this.GetYData = function (x)
  {
    if (x < this.ChartBorder.GetLeftEx()) return this.HorizontalMin;
    if (x > this.ChartBorder.GetRightEx()) return this.HorizontalMax;

    return (x - this.ChartBorder.GetLeftEx()) / this.ChartBorder.GetWidthEx() * (this.HorizontalMax - this.HorizontalMin) + this.HorizontalMin;
  };

  //X坐标转x轴数值
  this.GetXData = function (y)
  {
    if (y <= this.ChartBorder.GetTop()) return 0;
    if (y >= this.ChartBorder.GetBottom()) return this.XPointCount - 1;

    var distanceWidth = this.DistanceWidth;
    var dataWidth = this.DataWidth;
    var left = this.ChartBorder.GetTop() + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLeftMargin;
    var right = this.ChartBorder.GetBottom() - _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameRightMargin;

    var index = 0;
    var xPoint = left + distanceWidth / 2 + dataWidth + distanceWidth;
    while (xPoint < right && index < 10000 && index + 1 < this.XPointCount) //自己算x的数值
    {
      if (xPoint >= y) break;
      xPoint += dataWidth + distanceWidth;
      ++index;
    }

    return index;
  };

}

function SubFrameItem()
{
  this.Frame;
  this.Height;
}

//行情框架
function HQTradeFrame()
{
  this.ClassName = 'HQTradeFrame';
  this.SubFrame = new Array(); //SubFrameItem 数组
  this.SizeChange = true; //大小是否改变
  this.ChartBorder;
  this.Canvas; //画布
  this.ScreenImagePath; //截图路径  
  this.ScreenImageData = null; //截图数据         
  this.Data; //主数据
  this.Position; //画布的位置
  this.SizeChange = true;
  this.SnapshotID = 0;
  this.CurrentSnapshotID = 0;
  this.SnapshotStatus = 0; //0空闲 1工作


  this.CalculateChartBorder = function () //计算每个子框架的边框信息
  {
    if (this.SubFrame.length <= 0) return;

    var top = this.ChartBorder.GetTop();
    var height = this.ChartBorder.GetHeight();
    var totalHeight = 0;

    for (var i in this.SubFrame)
    {
      var item = this.SubFrame[i];
      totalHeight += item.Height;
    }

    for (var i in this.SubFrame)
    {
      var item = this.SubFrame[i];
      item.Frame.ChartBorder.Top = top;
      item.Frame.ChartBorder.Left = this.ChartBorder.Left;
      item.Frame.ChartBorder.Right = this.ChartBorder.Right;
      var frameHeight = height * (item.Height / totalHeight) + top;
      item.Frame.ChartBorder.Bottom = this.ChartBorder.GetChartHeight() - frameHeight;
      top = frameHeight;
    }

  };

  this.Draw = function ()
  {
    if (this.SizeChange === true) this.CalculateChartBorder();

    for (var i in this.SubFrame)
    {
      var item = this.SubFrame[i];
      if (item.Height <= 0) continue;

      item.Frame.Draw();
    }

    this.SizeChange = false;
  };

  this.DrawLock = function ()
  {
    for (var i in this.SubFrame)
    {
      var item = this.SubFrame[i];
      item.Frame.DrawLock();
    }
  };

  this.DrawInsideHorizontal = function () {
    for (var i in this.SubFrame) {
      var item = this.SubFrame[i];
      item.Frame.DrawInsideHorizontal();
    }
  };

  this.DrawCustomHorizontal = function () //定制Y坐标
  {
    for (var i in this.SubFrame)
    {
      var item = this.SubFrame[i];
      if (item.Frame.DrawCustomHorizontal) item.Frame.DrawCustomHorizontal();
    }
  };

  this.DrawCustomVertical = function (event) //定制X坐标
  {
    for (var i in this.SubFrame)
    {
      var item = this.SubFrame[i];
      item.Frame.DrawCustomVerticalEvent = event;
      if (item.Frame.DrawCustomVertical) item.Frame.DrawCustomVertical();
    }
  };

  this.SetSizeChage = function (sizeChange)
  {
    this.SizeChange = sizeChange;

    for (var i in this.SubFrame)
    {
      var item = this.SubFrame[i];
      item.Frame.SizeChange = sizeChange;
    }

    //画布的位置
    this.Position =
    {
      X: this.ChartBorder.UIElement.offsetLeft,
      Y: this.ChartBorder.UIElement.offsetTop,
      W: this.ChartBorder.UIElement.clientWidth,
      H: this.ChartBorder.UIElement.clientHeight };

  };

  this.SetDrawOtherChart = function (callback) //在画完框架以后调用的扩展画法
  {
    for (var i in this.SubFrame)
    {
      var item = this.SubFrame[i];
      item.Frame.DrawOtherChart = callback;
    }
  };

  this.Snapshot = function (type)
  {
    if (type == 1) this.SnapshotImageData();else
    this.SnapshotImagePath();
  };

  //图形快照
  this.SnapshotImagePath = function ()
  {
    var self = this;
    var width = this.ChartBorder.GetChartWidth();
    var height = this.ChartBorder.GetChartHeight();

    //JSConsole.Chart.Log('[HQTradeFrame::SnapshotImageData][ID=' + this.ChartBorder.UIElement.ID + '] invoke canvasToTempFilePath' + '(width=' + width + ',height=' + height + ')' + ' SnapshotStatus='+ this.SnapshotStatus);
    //if (this.SnapshotStatus==1) return;

    ++this.SnapshotID;
    var id = this.SnapshotID;
    this.SnapshotStatus = 1;
    if (this.Canvas && this.Canvas.DomNode) //新版2D画布
      {
        wx.canvasToTempFilePath({
          x: 0,
          y: 0,
          width: width,
          height: height,
          canvas: this.Canvas.DomNode,
          success: function success(res) {
            self.ScreenImagePath = res.tempFilePath;
            self.SnapshotStatus = 0;
            self.CurrentSnapshotID = id;
            _umychartConsoleWechat.JSConsole.Chart.Log("[HQTradeFrame::SnapshotImagePath] SnapshotID(".concat(self.SnapshotID, ", ").concat(self.CurrentSnapshotID, "), Path=").concat(res.tempFilePath));
          } });

      } else

    {
      wx.canvasToTempFilePath({
        x: 0,
        y: 0,
        width: width,
        height: height,
        canvasId: this.ChartBorder.UIElement.ID,
        success: function success(res) {
          self.ScreenImagePath = res.tempFilePath;
          self.SnapshotStatus = 0;
          self.CurrentSnapshotID = id;
          //JSConsole.Chart.Log('[HQTradeFrame::SnapshotImagePath] SnapshotID(' + self.SnapshotID + ',' + self.CurrentSnapshotID + ') Path ='+ res.tempFilePath);
        } });

    }
  };

  this.SnapshotImageData = function ()
  {
    var self = this;
    var width = this.ChartBorder.GetChartWidth();
    var height = this.ChartBorder.GetChartHeight();

    _umychartConsoleWechat.JSConsole.Chart.Log("[HQTradeFrame::SnapshotImageData][ID=".concat(this.ChartBorder.UIElement.ID, " invoke canvasGetImageData(").concat(width, ", ").concat(height, ") SnapshotStatus=").concat(this.SnapshotStatus));
    ++this.SnapshotID;
    var id = this.SnapshotID;
    this.SnapshotStatus = 1;

    wx.canvasGetImageData({
      canvasId: this.ChartBorder.UIElement.ID,
      x: 0,
      y: 0,
      width: width,
      height: height,
      success: function success(res)
      {
        self.ScreenImageData = res.data;
        self.SnapshotStatus = 0;
        self.CurrentSnapshotID = id;
        _umychartConsoleWechat.JSConsole.Chart.Log("[HQTradeFrame::SnapshotImageData] SnapshotID=".concat(self.SnapshotID, ", CurrentSnapshotID=").concat(self.CurrentSnapshotID, ", size=").concat(res.data.length));
      } });

  };

  this.GetXData = function (x) {return this.SubFrame[0].Frame.GetXData(x);};

  this.GetYData = function (y, outObject) //outObject 可以保存返回的额外数据) 
  {
    var frame;
    for (var i in this.SubFrame)
    {
      var item = this.SubFrame[i];
      var left = item.Frame.ChartBorder.GetLeft();
      var top = item.Frame.ChartBorder.GetTopEx();
      var width = item.Frame.ChartBorder.GetWidth();
      var height = item.Frame.ChartBorder.GetHeightEx();

      var rtItem = new _umychartDataWechat.JSCommon_Rect(left, top, width, height);
      if (rtItem.IsPointIn(left, y))
      {
        frame = item.Frame;
        if (outObject) outObject.FrameID = i;
        break;
      }
    }

    if (frame != null)
    {
      var yValue = frame.GetYData(y);
      if (frame.YSplitOperator.CoordinateType == 1) //百分比坐标 右边显示百分比信息
        {
          var firstOpenPrice = frame.YSplitOperator.GetFirstOpenPrice();
          outObject.RightYValue = ((yValue - firstOpenPrice) / firstOpenPrice * 100).toFixed(2) + '%';
        }
      return yValue;
    }
  };

  this.GetXFromIndex = function (index) {return this.SubFrame[0].Frame.GetXFromIndex(index);};

  this.GetYFromData = function (value) {return this.SubFrame[0].Frame.GetYFromData(value);};

  this.ZoomUp = function (cursorIndex)
  {
    var result = this.SubFrame[0].Frame.ZoomUp(cursorIndex);
    this.UpdateAllFrame();

    return result;
  };

  this.ZoomDown = function (cursorIndex)
  {
    var result = this.SubFrame[0].Frame.ZoomDown(cursorIndex);
    this.UpdateAllFrame();

    return result;
  };

  this.SetDataWidth = function (dataWidth)
  {
    var obj = this.SubFrame[0].Frame.SetDataWidth(dataWidth);
    this.UpdateAllFrame();
    return obj;
  };

  this.OnSize = function ()
  {
    var obj = {};
    this.SubFrame[0].Frame.OnSize(obj);
    this.UpdateAllFrame();
    return obj;
  };

  this.UpdateAllFrame = function ()
  {
    var mainFrame = this.SubFrame[0].Frame;
    for (var i = 1; i < this.SubFrame.length; ++i)
    {
      var item = this.SubFrame[i];
      item.Frame.XPointCount = mainFrame.XPointCount;
      item.Frame.ZoomIndex = mainFrame.ZoomIndex;
      item.Frame.DataWidth = mainFrame.DataWidth;
      item.Frame.DistanceWidth = mainFrame.DistanceWidth;
      item.Frame.LastCalculateStatus.Width = mainFrame.LastCalculateStatus.Width;
      item.Frame.LastCalculateStatus.XPointCount = mainFrame.LastCalculateStatus.XPointCount;
    }
  };

  //设置重新计算刻度坐标
  this.ResetXYSplit = function ()
  {
    for (var i in this.SubFrame)
    {
      this.SubFrame[i].Frame.XYSplit = true;
    }
  };

  this.GetCurrentPageSize = function () //获取当前页显示的数据个数
  {
    if (this.SubFrame.length <= 0) return null;
    var item = this.SubFrame[0];
    if (!item || !item.Frame) return null;

    return item.Frame.XPointCount;
  };
}

//行情框架横屏
function HQTradeHScreenFrame() {
  this.newMethod = HQTradeFrame; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = 'HQTradeHScreenFrame';
  this.IsHScreen = true; //是否是横屏

  this.CalculateChartBorder = function () //计算每个子框架的边框信息
  {
    if (this.SubFrame.length <= 0) return;

    var right = this.ChartBorder.Right;
    var left = this.ChartBorder.GetRight();
    var width = this.ChartBorder.GetWidth();
    var totalHeight = 0;

    for (var i in this.SubFrame) {
      var item = this.SubFrame[i];
      totalHeight += item.Height;
    }

    for (var i in this.SubFrame) {
      var item = this.SubFrame[i];
      item.Frame.ChartBorder.Top = this.ChartBorder.Top;
      item.Frame.ChartBorder.Bottom = this.ChartBorder.Bottom;

      var frameWidth = width * (item.Height / totalHeight);
      item.Frame.ChartBorder.Right = right;
      item.Frame.ChartBorder.Left = left - frameWidth;

      right += frameWidth;
      left -= frameWidth;
    }
  };

  this.GetYData = function (x, outObject) {
    var frame;
    for (var i in this.SubFrame) {
      var item = this.SubFrame[i];
      var left = item.Frame.ChartBorder.GetLeftEx();
      var top = item.Frame.ChartBorder.GetTop();
      var width = item.Frame.ChartBorder.GetWidthEx();
      var height = item.Frame.ChartBorder.GetHeight();

      var rtItem = new _umychartDataWechat.JSCommon_Rect(left, top, width, height);
      if (rtItem.IsPointIn(x, top)) {
        frame = item.Frame;
        if (outObject) outObject.FrameID = i;
        break;
      }
    }

    if (frame != null) return frame.GetYData(x);
  };
}

//深度图框架
function DepthChartFrame()
{
  this.newMethod = AverageWidthFrame; //派生
  this.newMethod();
  delete this.newMethod;

  this.ScreenImageData; //截图
  this.Position; //画布的位置
  this.ClassName = "DepthChartFrame";

  //X轴价格 最大,最小
  this.VerticalRange = { Max: null, Min: null, Center: null, MaxDiffer: null, Differ: null, Step: 0.05 };
  this.AskPrice;
  this.BidPrice;
  this.MinZoom = 0.05; //最小缩放

  this.SetPriceList = function (aryAskPrice, aryBidPrice)
  {
    this.AskPrice = aryAskPrice;
    this.BidPrice = aryBidPrice;
  };

  this.SetDrawOtherChart = function (callback) //在画完框架以后调用的扩展画法
  {

  };

  this.DrawFrame = function ()
  {
    this.SplitXYCoordinate();
    this.DrawHorizontal();
    this.DrawVertical();
  };

  this.GetXFromIndex = function (value)
  {
    var left = this.ChartBorder.GetLeft();
    var right = this.ChartBorder.GetRight();
    var width = this.ChartBorder.GetWidth();
    var offset = width * (value - this.VerticalRange.Min) / (this.VerticalRange.Max - this.VerticalRange.Min);
    return left + offset;
  };

  this.GetXData = function (x)
  {
    var left = this.ChartBorder.GetLeft();
    var right = this.ChartBorder.GetRight();
    var width = this.ChartBorder.GetWidth();

    return (x - left) / width * (this.VerticalRange.Max - this.VerticalRange.Min) + this.VerticalRange.Min;
  };

  this.GetXFromPrice = function (price)
  {
    var isAskPrice = false;
    var find = this.GetPrice(this.BidPrice, price);
    if (find == null)
    {
      find = this.GetPrice(this.AskPrice, price);
      isAskPrice = true;
    }

    if (find == null)
    {
      if (this.BidPrice && Array.isArray(this.BidPrice) && this.BidPrice.length > 0)
      {
        var minPrice = this.BidPrice[0];
        if (price < minPrice)
        {
          isAskPrice = false;
          find = minPrice;
        }
      }
    }

    if (find == null)
    {
      if (this.AskPrice && Array.isArray(this.AskPrice) && this.AskPrice.length > 0)
      {
        var maxPrice = this.AskPrice[this.AskPrice.length - 1];
        if (price > maxPrice)
        {
          isAskPrice = true;
          find = maxPrice;
        }
      }
    }

    if (find == null) return null;

    var x = this.GetXFromIndex(find);

    return { X: x, Price: find, IsAsk: isAskPrice };
  };

  this.GetPrice = function (aryPrice, price)
  {
    if (!aryPrice || !Array.isArray(aryPrice) || aryPrice.length <= 0) return null;

    if (price < aryPrice[0] || price > aryPrice[aryPrice.length - 1]) return null;

    var lastPrice = null;
    for (var i in aryPrice)
    {
      var item = aryPrice[i];
      if (price == item)
      {
        return item;
      }

      if (price < item)
      return lastPrice;

      lastPrice = item;
    }
  };

  //分割x,y轴坐标信息
  this.SplitXYCoordinate = function ()
  {
    if (this.XYSplit == false) return;
    if (this.YSplitOperator != null) this.YSplitOperator.Operator();
    if (this.XSplitOperator != null) this.XSplitOperator.Operator();
  };

  //图形快照
  this.Snapshot = function ()
  {
    this.ScreenImageData = this.Canvas.getImageData(0, 0, this.ChartBorder.GetChartWidth(), this.ChartBorder.GetChartHeight());
  };

  this.SetSizeChage = function (sizeChange)
  {
    this.SizeChange = sizeChange;

    //画布的位置
    this.Position = {
      X: this.ChartBorder.UIElement.offsetLeft,
      Y: this.ChartBorder.UIElement.offsetTop,
      W: this.ChartBorder.UIElement.clientWidth,
      H: this.ChartBorder.UIElement.clientHeight };

  };

  this.ZoomUp = function () //放大
  {
    var xRange = this.VerticalRange;
    var differ = xRange.Differ;
    var minDiffer = xRange.MaxDiffer * this.MinZoom;
    if (differ < minDiffer) return false;

    var offsetDiffer = xRange.Differ * xRange.Step;
    differ -= offsetDiffer;
    xRange.Differ = differ;
    xRange.Min = xRange.Center - xRange.Differ;
    xRange.Max = xRange.Center + xRange.Differ;

    return true;
  };

  this.ZoomDown = function () //缩小
  {
    var xRange = this.VerticalRange;
    var differ = xRange.Differ;
    if (differ == xRange.MaxDiffer) return false;

    var offsetDiffer = xRange.Differ * xRange.Step;
    differ += offsetDiffer;
    if (differ > xRange.MaxDiffer) differ = xRange.MaxDiffer;

    xRange.Differ = differ;
    xRange.Min = xRange.Center - xRange.Differ;
    xRange.Max = xRange.Center + xRange.Differ;

    return true;
  };
}

//一般的图形框架
function SimpleChartFrame() {
  this.newMethod = AverageWidthFrame; //派生
  this.newMethod();
  delete this.newMethod;

  this.ScreenImageData; //截图
  this.Position; //画布的位置

  this.IsShowBorder = false; //是否显示边框
  this.IsShowVertical = false; //是否显示X轴
  this.XFontType = 0; //X轴文本文字类型

  this.MaxDistanceWidth = 4;

  this.BarCount = 0; //多柱子个数

  this.Draw = function () {
    this.DrawFrame();
    if (this.IsShowBorder) this.DrawBorder();

    this.SizeChange = false;
    this.XYSplit = false;
  };

  this.DrawFrame = function () {
    if (this.XPointCount > 0) {
      var dInterval = this.ChartBorder.GetWidth() / (10 * this.XPointCount); //分6份, 数据4 间距2
      this.DistanceWidth = 4 * dInterval;
      this.DataWidth = 6 * dInterval;

      if (this.DistanceWidth > this.MaxDistanceWidth) {
        this.DistanceWidth = this.MaxDistanceWidth;
        dInterval = this.ChartBorder.GetWidth() / this.XPointCount;
        this.DataWidth = dInterval - this.MaxDistanceWidth;
      }
    }

    this.SplitXYCoordinate();
    this.DrawHorizontal();
    this.DrawVertical();
  };

  this.GetXFromIndex = function (index) {
    if (index < 0) index = 0;
    if (index > this.xPointCount - 1) index = this.xPointCount - 1;

    var offset = this.ChartBorder.GetLeft() + 2 + this.DistanceWidth / 2 + this.DataWidth / 2;
    for (var i = 1; i <= index; ++i) {
      offset += this.DistanceWidth + this.DataWidth;
    }

    return offset;
  };

  //分割x,y轴坐标信息
  this.SplitXYCoordinate = function () {
    if (this.XYSplit == false) return;
    if (this.YSplitOperator != null) this.YSplitOperator.Operator();
    if (this.XSplitOperator != null) this.XSplitOperator.Operator();
  };

  //画X轴
  this.DrawVertical = function () {
    var top = this.ChartBorder.GetTopEx();
    var bottom = this.ChartBorder.GetBottom();
    var right = this.ChartBorder.GetRight();

    var xPrev = null; //上一个坐标x的值
    for (var i in this.VerticalInfo) {
      var x = this.GetXFromIndex(this.VerticalInfo[i].Value);
      if (x >= right) break;
      if (this.XFontType == 1) {
        if (xPrev != null && Math.abs(x - xPrev) < 20) continue;
      } else
      {
        if (xPrev != null && Math.abs(x - xPrev) < 60) continue;
      }

      if (this.IsShowVertical) {
        this.Canvas.strokeStyle = this.VerticalInfo[i].LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ToFixedPoint(x), top);
        this.Canvas.lineTo(ToFixedPoint(x), bottom);
        this.Canvas.stroke();
      }

      if (this.VerticalInfo[i].Message[0] != null) {
        if (this.VerticalInfo[i].Font != null)
        this.Canvas.font = this.VerticalInfo[i].Font;

        this.Canvas.fillStyle = this.VerticalInfo[i].TextColor;
        var testWidth = this.Canvas.measureText(this.VerticalInfo[i].Message[0]).width;
        if (x < testWidth / 2) {
          this.Canvas.textAlign = "left";
          this.Canvas.textBaseline = "top";
        } else
        {
          this.Canvas.textAlign = "center";
          this.Canvas.textBaseline = "top";
        }

        if (this.XFontType == 1) {
          this.Canvas.textAlign = "left";
          this.Canvas.textBaseline = "middle";
          this.Canvas.save();
          this.Canvas.translate(x, bottom);
          this.Canvas.rotate(90 * Math.PI / 180);
          this.Canvas.fillText(this.VerticalInfo[i].Message[0], 2, 0);
          this.Canvas.restore();
        } else

        this.Canvas.fillText(this.VerticalInfo[i].Message[0], x, bottom);
      }

      xPrev = x;
    }
  };

  //图形快照
  this.Snapshot = function () {
    var self = this;
    var width = this.ChartBorder.GetChartWidth();
    var height = this.ChartBorder.GetChartHeight();

    _umychartConsoleWechat.JSConsole.Chart.Log('[SimpleChartFrame::Snapshot][ID=' + this.ChartBorder.UIElement.ID + '] invoke canvasToTempFilePath' + '(width=' + width + ',height=' + height + ')');

    wx.canvasToTempFilePath({
      x: 0,
      y: 0,
      width: width,
      height: height,
      canvasId: this.ChartBorder.UIElement.ID,
      success: function success(res) {
        self.ScreenImagePath = res.tempFilePath;
        _umychartConsoleWechat.JSConsole.Chart.Log(res.tempFilePath);
      } });

  };

  this.SetSizeChage = function (sizeChange) {
    this.SizeChange = sizeChange;

    //画布的位置
    this.Position = {
      X: this.ChartBorder.UIElement.offsetLeft,
      Y: this.ChartBorder.UIElement.offsetTop,
      W: this.ChartBorder.UIElement.clientWidth,
      H: this.ChartBorder.UIElement.clientHeight };

  };
}

//旋转90度坐标
function Rotate90SimpleChartFrame() {
  this.newMethod = SimpleChartFrame; //派生
  this.newMethod();
  delete this.newMethod;

  this.DrawFrame = function () {
    if (this.XPointCount > 0) {
      var dInterval = this.ChartBorder.GetHeightEx() / (10 * this.XPointCount); //分10份, 数据4 间距6
      this.DistanceWidth = 4 * dInterval;
      this.DataWidth = 6 * dInterval;

      if (this.DistanceWidth > this.MaxDistanceWidth) {
        this.DistanceWidth = this.MaxDistanceWidth;
        dInterval = this.ChartBorder.GetHeightEx() / this.XPointCount;
        this.DataWidth = dInterval - this.MaxDistanceWidth;
      }
    }

    this.SplitXYCoordinate();
    this.DrawHorizontal();
    this.DrawVertical();
  };

  this.GetXFromIndex = function (value) {
    if (value <= this.HorizontalMin) return this.ChartBorder.GetLeft();
    if (value >= this.HorizontalMax) return this.ChartBorder.GetRight();

    var width = this.ChartBorder.GetWidth() * (value - this.HorizontalMin) / (this.HorizontalMax - this.HorizontalMin);
    return this.ChartBorder.GetLeft() + width;
  };

  this.GetYFromData = function (index) {
    if (index < 0) index = 0;
    if (index > this.xPointCount - 1) index = this.xPointCount - 1;

    var offset = this.ChartBorder.GetBottom() - 2 - this.DistanceWidth / 2 - this.DataWidth / 2;
    for (var i = 1; i <= index; ++i) {
      offset -= this.DistanceWidth + this.DataWidth;
    }

    return offset;
  };

  //画Y轴
  this.DrawHorizontal = function () {
    var top = this.ChartBorder.GetTopEx();
    var bottom = this.ChartBorder.GetBottom();
    var right = this.ChartBorder.GetRight();
    var left = this.ChartBorder.GetLeft();

    var yPrev = null; //上一个坐标y的值
    for (var i in this.VerticalInfo) {
      var item = this.VerticalInfo[i];
      var y = this.GetYFromData(item.Value);
      if (y != null && yPrev != null && Math.abs(y - yPrev) < 15) continue; //两个坐标在近了 就不画了

      if (item.Message[0] != null) {
        if (this.VerticalInfo[i].Font != null)
        this.Canvas.font = item.Font;

        this.Canvas.fillStyle = item.TextColor;
        this.Canvas.textAlign = "right";
        this.Canvas.textBaseline = "middle";
        this.Canvas.fillText(item.Message[0], left - 2, y);
      }
      yPrev = y;
    }
  };

  //画X轴
  this.DrawVertical = function () {
    var top = this.ChartBorder.GetTopEx();
    var bottom = this.ChartBorder.GetBottom();
    var right = this.ChartBorder.GetRight();
    var left = this.ChartBorder.GetLeft();

    var yText = bottom;
    if (this.XMessageAlign == 'bottom')
    yText = this.ChartBorder.GetChartHeight();else
    this.XMessageAlign = 'top';

    var xPrev = null; //上一个坐标x的值
    var xPrevTextRight = null;
    for (var i in this.HorizontalInfo) {
      var item = this.HorizontalInfo[i];
      var x = this.GetXFromIndex(item.Value);
      if (x > right) break;
      if (xPrev != null && Math.abs(x - xPrev) < this.MinXDistance) continue;

      if (this.IsShowXLine) {
        this.Canvas.strokeStyle = item.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ToFixedPoint(x), top);
        this.Canvas.lineTo(ToFixedPoint(x), bottom);
        this.Canvas.stroke();
      }

      if (item.Message[0] != null) {
        var xTextRight = null;
        var xTextLeft = null;
        if (item.Font != null)
        this.Canvas.font = item.Font;

        this.Canvas.fillStyle = item.TextColor;

        var testWidth = this.Canvas.measureText(item.Message[0]).width;
        if (x < testWidth / 2) {
          this.Canvas.textAlign = "left";
          this.Canvas.textBaseline = this.XMessageAlign;
          xTextRight = x + testWidth;
          xTextLeft = x;
        } else
        {
          this.Canvas.textAlign = "center";
          this.Canvas.textBaseline = this.XMessageAlign;
          xTextRight = x + testWidth / 2;
          xTextLeft = x - testWidth / 2;
        }

        if (xPrevTextRight != null && xPrevTextRight > xTextLeft) continue;

        //JSConsole.Chart.Log('[AverageWidthFrame::DrawVertical]', this.Canvas.fillStyle,x, yText);

        this.Canvas.fillText(item.Message[0], x, yText);
        xPrevTextRight = xTextRight;
      }

      xPrev = x;
    }
  };

}

function TooltipData() //提示信息
{
  this.ChartPaint;
  this.Data;
}

//缩放因子
var ZOOM_SEED = //0=柱子宽度  1=间距
[
[48, 10], [44, 10],
[40, 9], [36, 9],
[32, 8], [28, 8],
[24, 7], [20, 7],
[18, 6], [16, 6],
[14, 5], [12, 5],
[8, 4], [4, 4], [3, 3],
[3, 1], [2, 1], [1, 1], [1, 0]
/*
                               [49, 10], [46, 9], [43, 8],
                               [41, 7.5], [39, 7], [37, 6],
                               [31, 5.5], [27, 5], [23, 4.5],
                               [21, 4], [18, 3.5], [16, 3],
                               [13, 2.5], [11, 2], [8, 1.5],
                               [6, 1], [3, 0.6], [2.2, 0.5],
                               */
//太多了卡,
//[1.1,0.3],
//[0.9,0.2],	[0.7,0.15],
//[0.6,0.12],	[0.5,0.1],	[0.4,0.08],
//[0.3,0.06],	[0.2,0.04],	[0.1,0.02]
];




//线段 多数据(一个X点有多条Y数据) 支持横屏
function ChartLineMultiData() {
  this.newMethod = _umychartChartpaintWechat.JSCommonChartPaint_IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.Color = "rgb(255,193,37)"; //线段颜色

  this.Draw = function () {
    if (this.NotSupportMessage) {
      this.DrawNotSupportmessage();
      return;
    }

    if (!this.Data || !this.Data.Data) return;

    var isHScreen = this.ChartFrame.IsHScreen === true;
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var chartright = this.ChartBorder.GetRight();
    if (isHScreen) chartright = this.ChartBorder.GetBottom();
    var xPointCount = this.ChartFrame.XPointCount;

    var bFirstPoint = true;
    var drawCount = 0;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j) {
      var aryValue = this.Data.Data[i];
      if (aryValue == null) continue;

      var x = this.ChartFrame.GetXFromIndex(j);
      if (x > chartright) break;

      for (var index in aryValue) {
        var value = aryValue[index].Value;
        var y = this.ChartFrame.GetYFromData(value);

        if (bFirstPoint) {
          this.Canvas.strokeStyle = this.Color;
          this.Canvas.beginPath();
          if (isHScreen) this.Canvas.moveTo(y, x);else
          this.Canvas.moveTo(x, y);
          bFirstPoint = false;
        } else
        {
          if (isHScreen) this.Canvas.lineTo(y, x);else
          this.Canvas.lineTo(x, y);
        }

        ++drawCount;
      }
    }

    if (drawCount > 0) this.Canvas.stroke();
  };

  this.GetMaxMin = function () {
    var xPointCount = this.ChartFrame.XPointCount;
    var range = {};
    range.Min = null;
    range.Max = null;

    if (!this.Data || !this.Data.Data) return range;

    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j) {
      var aryValue = this.Data.Data[i];
      if (aryValue == null) continue;

      for (var index in aryValue) {
        var value = aryValue[index].Value;
        if (range.Max == null) range.Max = value;
        if (range.Min == null) range.Min = value;

        if (range.Max < value) range.Max = value;
        if (range.Min > value) range.Min = value;
      }
    }

    return range;
  };
}

//直线 水平直线 只有1个数据 支持横屏
function ChartStraightLine() {
  this.newMethod = _umychartChartpaintWechat.JSCommonChartPaint_IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.Color = "rgb(255,193,37)"; //线段颜色

  this.Draw = function () {
    if (!this.Data || !this.Data.Data) return;
    if (this.Data.Data.length != 1) return;

    var isHScreen = this.ChartFrame.IsHScreen;
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var chartright = this.ChartBorder.GetRight();
    if (isHScreen) chartright = this.ChartBorder.GetTop();
    var xPointCount = this.ChartFrame.XPointCount;

    var yValue = this.Data.Data[0];
    var y = this.ChartFrame.GetYFromData(yValue);
    var xLeft = this.ChartFrame.GetXFromIndex(0);
    var xRight = this.ChartFrame.GetXFromIndex(xPointCount - 1);

    var yFix = parseInt(y.toString()) + 0.5;
    this.Canvas.beginPath();
    if (isHScreen) {
      this.Canvas.moveTo(yFix, xLeft);
      this.Canvas.lineTo(yFix, xRight);
    } else
    {
      this.Canvas.moveTo(xLeft, yFix);
      this.Canvas.lineTo(xRight, yFix);
    }
    this.Canvas.strokeStyle = this.Color;
    this.Canvas.stroke();
  };

  this.GetMaxMin = function () {
    var xPointCount = this.ChartFrame.XPointCount;
    var range = {};
    range.Min = null;
    range.Max = null;

    if (!this.Data || !this.Data.Data) return range;
    if (this.Data.Data.length != 1) return range;

    range.Min = this.Data.Data[0];
    range.Max = this.Data.Data[0];

    return range;
  };
}

//分钟线叠加 支持横屏
function ChartOverlayMinutePriceLine() {
  this.newMethod = _umychartChartpaintWechat.JSCommonChartPaint_IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.Color = "rgb(65,105,225)";
  this.MainData; //主图数据
  this.MainYClose; //主图股票的前收盘价

  this.Name = "ChartOverlayMinutePriceLine";
  this.Title;
  this.Symbol; //叠加的股票代码
  this.YClose; //叠加的股票前收盘

  this.Draw = function () {
    if (this.NotSupportMessage) {
      this.DrawNotSupportmessage();
      return;
    }

    var isHScreen = this.ChartFrame.IsHScreen === true;
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var chartright = this.ChartBorder.GetRight();
    if (isHScreen === true) chartright = this.ChartBorder.GetBottom();
    var xPointCount = this.ChartFrame.XPointCount;
    var minuteCount = this.ChartFrame.MinuteCount;

    var bFirstPoint = true;
    var drawCount = 0;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j) {
      var value = this.Data.Data[i].Close;
      if (value == null) continue;
      var showValue = value / this.YClose * this.MainYClose;

      var x = this.ChartFrame.GetXFromIndex(j);
      var y = this.ChartFrame.GetYFromData(showValue);

      if (bFirstPoint) {
        this.Canvas.strokeStyle = this.Color;
        this.Canvas.beginPath();
        if (isHScreen) this.Canvas.moveTo(y, x);else
        this.Canvas.moveTo(x, y);
        bFirstPoint = false;
      } else
      {
        if (isHScreen) this.Canvas.lineTo(y, x);else
        this.Canvas.lineTo(x, y);
      }

      ++drawCount;

      if (drawCount >= minuteCount) //上一天的数据和这天地数据线段要断开
        {
          bFirstPoint = true;
          this.Canvas.stroke();
          drawCount = 0;
        }
    }

    if (drawCount > 0) this.Canvas.stroke();
  };

  this.GetMaxMin = function () {
    var xPointCount = this.ChartFrame.XPointCount;
    var range = {};
    if (this.YClose == null) return range;

    range.Min = this.MainYClose;
    range.Max = this.MainYClose;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j) {
      var value = this.Data.Data[i].Close;
      if (value == null) continue;
      var value = value / this.YClose * this.MainYClose;
      if (range.Max == null) range.Max = value;
      if (range.Min == null) range.Min = value;

      if (range.Max < value) range.Max = value;
      if (range.Min > value) range.Min = value;
    }

    if (range.Max == this.MainYClose && range.Min == this.MainYClose) {
      range.Max = this.MainYClose + this.MainYClose * 0.1;
      range.Min = this.MainYClose - this.MainYClose * 0.1;
      return range;
    }

    var distance = Math.max(Math.abs(this.MainYClose - range.Max), Math.abs(this.MainYClose - range.Min));
    range.Max = this.MainYClose + distance;
    range.Min = this.MainYClose - distance;

    return range;
  };
}

//基础图形的XY坐标互换柱子
function ChartXYSubBar() {
  this.newMethod = ChartBar; //派生
  this.newMethod();
  delete this.newMethod;

  this.BarID = 0;

  this.Draw = function () {
    if (this.NotSupportMessage) {
      this.DrawNotSupportmessage();
      return;
    }

    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var chartTop = this.ChartBorder.GetTopEx();
    var xPointCount = this.ChartFrame.XPointCount;
    var yOffset = this.ChartBorder.GetBottom() - distanceWidth / 2.0 - 2.0;

    var xMiddle = this.ChartFrame.GetXFromIndex(0); //0 刻度

    if (dataWidth >= 4) {
      var barCount = this.ChartFrame.BarCount;
      var subBarWidth = dataWidth;
      var subBarOffset = 0;
      if (barCount > 0) //多柱子需要把框架柱子宽度的平均分割
        {
          subBarWidth = dataWidth / barCount;
          subBarOffset = subBarWidth * this.BarID;
          //JSConsole.Chart.Log('[ChartXYSubBar::Draw] ', subBarWidth, this.BarID, subBarOffset);
        }

      xMiddle = ToFixedRect(xMiddle); //调整为整数
      for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, yOffset -= dataWidth + distanceWidth) {
        var value = this.Data.Data[i];
        if (value == null || value == 0) continue;

        var yBottom = yOffset + subBarOffset;
        var yTop = yOffset + subBarOffset - dataWidth;
        if (yBottom < chartTop) break;

        var x = this.ChartFrame.GetXFromIndex(value);

        if (value > 0) {
          this.Canvas.fillStyle = this.UpBarColor;
          var barWidth = ToFixedRect(Math.abs(x - xMiddle));
          var barHeight = subBarWidth;
          if (Math.abs(chartTop - yBottom) < dataWidth) subBarWidth = Math.abs(chartTop - yBottom); //最后一根柱子可能会超出框架
          this.Canvas.fillRect(xMiddle, ToFixedRect(yTop), barWidth, ToFixedRect(barHeight + 0.5));
        } else
        {
          this.Canvas.fillStyle = this.DownBarColor;
          //高度调整为整数
          var _barWidth = ToFixedRect(Math.abs(x - xMiddle));
          var _barHeight = subBarWidth;
          if (Math.abs(chartTop - yBottom) < subBarWidth) _barHeight = Math.abs(chartTop - yBottom); //最后一根柱子可能会超出框架
          this.Canvas.fillRect(xMiddle, ToFixedRect(yTop), -_barWidth, ToFixedRect(_barHeight + 0.5));
        }


      }
    } else
      //太细了 直接画柱子
      {
        for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, yOffset -= dataWidth + distanceWidth) {
          var value = this.Data.Data[i];
          if (value == null || value == 0) continue;

          var yBottom = yOffset;
          var yTop = yOffset - dataWidth;
          if (yTop < chartTop) break;

          var x = this.ChartFrame.GetXFromIndex(value);
          var y = this.ChartFrame.GetYFromData(j);

          if (value > 0) this.Canvas.strokeStyle = this.UpBarColor;else
          this.Canvas.strokeStyle = this.DownBarColor;

          this.Canvas.beginPath();
          this.Canvas.moveTo(ToFixedPoint(x), y);
          this.Canvas.lineTo(ToFixedPoint(xMiddle), y);
          this.Canvas.stroke();
        }
      }
  };
}

function ChartSubBar() {
  this.newMethod = ChartBar; //派生
  this.newMethod();
  delete this.newMethod;

  this.BarID = 0;

  this.Draw = function () {
    if (this.NotSupportMessage) {
      this.DrawNotSupportmessage();
      return;
    }

    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var chartright = this.ChartBorder.GetRight();
    var xPointCount = this.ChartFrame.XPointCount;
    var xOffset = this.ChartBorder.GetLeft() + distanceWidth / 2.0 + 2.0;


    var yBottom = this.ChartFrame.GetYFromData(0);
    if (dataWidth >= 4) {
      var barCount = this.ChartFrame.BarCount;
      var subBarWidth = dataWidth;
      var subBarOffset = 0;
      if (barCount > 0) //多柱子需要把框架柱子宽度的平均分割
        {
          subBarWidth = dataWidth / barCount;
          subBarOffset = subBarWidth * this.BarID;
          //JSConsole.Chart.Log('[ChartSubBar::Draw] ', subBarWidth, this.BarID, subBarOffset);
        }

      yBottom = ToFixedRect(yBottom); //调整为整数
      for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth) {
        var value = this.Data.Data[i];
        if (value == null || value == 0) continue;

        var left = xOffset + subBarOffset;
        var right = xOffset + subBarOffset + subBarWidth;
        if (left > chartright) break;

        var x = this.ChartFrame.GetXFromIndex(j);
        var y = this.ChartFrame.GetYFromData(value);

        if (value > 0) {
          this.Canvas.fillStyle = this.UpBarColor;
          //高度调整为整数
          var height = ToFixedRect(Math.abs(yBottom - y));
          var barWidth = subBarWidth;
          if (chartright - left < subBarWidth) barWidth = chartright - left;
          if (yBottom - y > 0) y = yBottom - height;else
          y = yBottom + height;
          this.Canvas.fillRect(ToFixedRect(left), y, ToFixedRect(barWidth), height);
        } else
        {
          this.Canvas.fillStyle = this.DownBarColor;
          //高度调整为整数
          var _height = ToFixedRect(Math.abs(yBottom - y));
          var _barWidth2 = subBarWidth;
          if (chartright - left < subBarWidth) _barWidth2 = chartright - left;
          if (yBottom - y > 0) y = yBottom - _height;else
          y = yBottom + _height;
          this.Canvas.fillRect(ToFixedRect(left), y, ToFixedRect(subBarWidth), -_height);
        }
      }
    } else
      //太细了 直接画柱子
      {
        for (var _i = this.Data.DataOffset, _j = 0; _i < this.Data.Data.length && _j < xPointCount; ++_i, ++_j, xOffset += dataWidth + distanceWidth) {
          var value = this.Data.Data[_i];
          if (value == null || value == 0) continue;

          var left = xOffset;
          var right = xOffset + dataWidth;
          if (right > chartright) break;

          var x = this.ChartFrame.GetXFromIndex(_j);
          var y = this.ChartFrame.GetYFromData(value);

          if (value > 0) this.Canvas.strokeStyle = this.UpBarColor;else
          this.Canvas.strokeStyle = this.DownBarColor;

          this.Canvas.beginPath();
          this.Canvas.moveTo(ToFixedPoint(x), y);
          this.Canvas.lineTo(ToFixedPoint(x), yBottom);
          this.Canvas.stroke();
        }
      }
  };
}

//柱子 支持横屏
function ChartBar() {
  this.newMethod = _umychartChartpaintWechat.JSCommonChartPaint_IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.UpBarColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.UpBarColor;
  this.DownBarColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DownBarColor;

  this.Draw = function () {
    if (this.NotSupportMessage) {
      this.DrawNotSupportmessage();
      return;
    }

    var isHScreen = this.ChartFrame.IsHScreen === true;
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var chartright = this.ChartBorder.GetRight();
    if (isHScreen) chartright = this.ChartBorder.GetBottom();
    var xPointCount = this.ChartFrame.XPointCount;
    var xOffset = this.ChartBorder.GetLeft() + distanceWidth / 2.0 + 2.0;
    if (isHScreen) xOffset = this.ChartBorder.GetTop() + distanceWidth / 2.0 + 2.0;

    var bFirstPoint = true;
    var drawCount = 0;
    var yBottom = this.ChartFrame.GetYFromData(0);
    if (dataWidth >= 4) {
      yBottom = ToFixedRect(yBottom); //调整为整数
      for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth) {
        var value = this.Data.Data[i];
        if (value == null || value == 0) continue;

        var left = xOffset;
        var right = xOffset + dataWidth;
        if (right > chartright) break;

        var x = this.ChartFrame.GetXFromIndex(j);
        var y = this.ChartFrame.GetYFromData(value);

        if (value > 0) {
          this.Canvas.fillStyle = this.UpBarColor;
          if (isHScreen) {
            var height = ToFixedRect(Math.abs(yBottom - y)); //高度调整为整数
            y = Math.min(yBottom, y);
            this.Canvas.fillRect(y, ToFixedRect(left), height, ToFixedRect(dataWidth));
          } else
          {
            var _height2 = ToFixedRect(Math.abs(yBottom - y)); //高度调整为整数
            if (yBottom - y > 0) y = yBottom - _height2;else
            y = yBottom + _height2;
            this.Canvas.fillRect(ToFixedRect(left), y, ToFixedRect(dataWidth), _height2);
          }
        } else
        {
          this.Canvas.fillStyle = this.DownBarColor;
          //高度调整为整数
          var _height3 = ToFixedRect(Math.abs(yBottom - y));
          if (yBottom - y > 0) y = yBottom - _height3;else
          y = yBottom + _height3;
          this.Canvas.fillRect(ToFixedRect(left), y, ToFixedRect(dataWidth), -_height3);
        }
      }
    } else
      //太细了 直接画柱子
      {
        for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth) {
          var value = this.Data.Data[i];
          if (value == null || value == 0) continue;

          var left = xOffset;
          var right = xOffset + dataWidth;
          if (right > chartright) break;

          var x = this.ChartFrame.GetXFromIndex(j);
          var y = this.ChartFrame.GetYFromData(value);

          if (value > 0) this.Canvas.strokeStyle = this.UpBarColor;else
          this.Canvas.strokeStyle = this.DownBarColor;

          this.Canvas.beginPath();
          if (isHScreen) {
            this.Canvas.moveTo(y, ToFixedPoint(x));
            this.Canvas.lineTo(yBottom, ToFixedPoint(x));
          } else
          {
            this.Canvas.moveTo(ToFixedPoint(x), y);
            this.Canvas.lineTo(ToFixedPoint(x), yBottom);
          }
          this.Canvas.stroke();
        }
      }
  };

  this.GetMaxMin = function () {
    var xPointCount = this.ChartFrame.XPointCount;
    var range = {};
    range.Min = 0;
    range.Max = null;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j) {
      var value = this.Data.Data[i];
      if (range.Max == null) range.Max = value;
      if (range.Max < value) range.Max = value;
      if (range.Min > value) range.Min = value;
    }

    return range;
  };
}






/////////////////////////////////////////////////////////////////////////////////
//
function IChangeStringFormat() {
  this.Data;
  this.Value; //数据
  this.Text; //输出字符串

  this.Operator = function () {
    return false;
  };
}


function HQPriceStringFormat()
{
  this.newMethod = IChangeStringFormat; //派生
  this.newMethod();
  delete this.newMethod;

  this.Symbol;
  this.FrameID;
  this.LanguageID = _umychartResourceWechat.JSCommonResource_JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID;
  this.PercentageText; //百分比
  this.RValue; //右边值
  this.RText;

  this.Operator = function ()
  {
    this.RText = null;
    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsString(this.RValue)) this.RText = this.RValue;
    if (!this.Value) return false;

    var defaultfloatPrecision = 2; //价格小数位数 
    if (this.FrameID == 0) //第1个窗口显示原始价格
      {
        var defaultfloatPrecision = _umychartCoordinatedataWechat.JSCommonCoordinateData.GetfloatPrecision(this.Symbol);
        this.Text = this.Value.toFixed(defaultfloatPrecision);
      } else

    {
      this.Text = _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatValueString(this.Value, defaultfloatPrecision, this.LanguageID);
    }

    return true;
  };
}

function HQDateStringFormat()
{
  this.newMethod = IChangeStringFormat; //派生
  this.newMethod();
  delete this.newMethod;

  this.Operator = function ()
  {
    if (!_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(this.Value) || this.Value < 0) return false;
    if (!this.Data) return false;

    var index = this.Value;
    index = parseInt(index.toFixed(0));
    if (this.Data.DataOffset + index >= this.Data.Data.length) return false;

    var currentData = this.Data.Data[this.Data.DataOffset + index];
    var date = currentData.Date;
    this.Text = _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatDateString(date);
    if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(this.Data.Period, true)) // 分钟周期
      {
        var time = _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatTimeString(currentData.Time);
        this.Text = this.Text + " " + time;
      } else
    if (_umychartDataWechat.JSCommon_ChartData.IsSecondPeriod(this.Data.Period))
    {
      var time = _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatTimeString(currentData.Time, "HH:MM:SS");
      this.Text = this.Text + " " + time;
    }

    return true;
  };
}

function HQMinuteTimeStringFormat()
{
  this.newMethod = IChangeStringFormat; //派生
  this.newMethod();
  delete this.newMethod;

  this.Frame;
  this.Symbol;

  this.Operator = function ()
  {
    if (this.Value == null || isNaN(this.Value)) return false;

    var index = Math.abs(this.Value);
    index = parseInt(index.toFixed(0));
    var showIndex = index;
    if (this.Frame && this.Frame.MinuteCount) showIndex = index % this.Frame.MinuteCount;

    var timeStringData = _umychartCoordinatedataWechat.JSCommonCoordinateData.MinuteTimeStringData;
    var timeData = timeStringData.GetTimeData(this.Symbol);
    if (!timeData) return false;

    if (showIndex < 0) showIndex = 0;else
    if (showIndex > timeData.length) showIndex = timeData.length - 1;
    if (this.Frame && index >= this.Frame.XPointCount)
    showIndex = timeData.length - 1;

    var time = timeData[showIndex];
    this.Text = _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatTimeString(time);
    return true;
  };
}


/*
      画图工具
  */
function IChartDrawPicture() {
  this.Frame;
  this.Canvas;
  this.Point = new Array(); //画图的点
  this.Value = new Array(); //XValue,YValue
  this.PointCount = 2; //画点的个数
  this.Status = 0; //0 开始画 1 完成第1个点  2 完成第2个点    10 完成 20 移动
  this.MovePointIndex = null; //移动哪个点 0-10 对应Point索引  100 整体移动

  this.LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DrawPicture.LineColor[0]; //线段颜色
  this.PointColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DrawPicture.PointColor[0];

  this.Draw = function () {

  };

  //Point => Value
  this.PointToValue = function () {
    if (!this.Frame) return false;
    var data = this.Frame.Data;
    if (!data) return false;

    for (var i in this.Point) {
      var item = this.Point[i];
      var xValue = parseInt(this.Frame.GetXData(item.X)) + data.DataOffset;
      var yValue = this.Frame.GetYData(item.Y);

      this.Value[i] = {};
      this.Value[i].XValue = xValue;
      this.Value[i].YValue = yValue;
    }

    return true;
  };

  this.IsPointIn = function (x, y) {
    return false;
  };

  //Value => Point
  this.ValueToPoint = function () {
    if (!this.Frame) return false;
    var data = this.Frame.Data;
    if (!data) return false;

    this.Point = [];
    for (var i in this.Value) {
      var item = this.Value[i];
      var pt = new Point();
      pt.X = this.Frame.GetXFromIndex(item.XValue - data.DataOffset);
      pt.Y = this.Frame.GetYFromData(item.YValue);
      this.Point[i] = pt;
    }
  };

  //xStep,yStep 移动的偏移量
  this.Move = function (xStep, yStep) {
    if (this.Status != 20) return fasle;
    if (!this.Frame) return false;
    var data = this.Frame.Data;
    if (!data) return false;

    if (this.MovePointIndex == 100) //整体移动
      {
        for (var i in this.Point) {
          this.Point[i].X += xStep;
          this.Point[i].Y += yStep;
        }
      } else
    if (this.MovePointIndex == 0 || this.MovePointIndex == 1) {
      this.Point[this.MovePointIndex].X += xStep;
      this.Point[this.MovePointIndex].Y += yStep;
    }
  };

  this.ClipFrame = function () {
    var left = this.Frame.ChartBorder.GetLeft();
    var top = this.Frame.ChartBorder.GetTopEx();
    var width = this.Frame.ChartBorder.GetWidth();
    var height = this.Frame.ChartBorder.GetHeightEx();

    this.Canvas.save();
    this.Canvas.beginPath();
    this.Canvas.rect(left, top, width, height);
    this.Canvas.clip();
  };

  //计算需要画的点的坐标
  this.CalculateDrawPoint = function () {
    if (this.Status < 2) return null;
    if (!this.Point.length || !this.Frame) return null;

    var drawPoint = new Array();
    if (this.Status == 10) {
      var data = this.Frame.Data;
      if (!data) return null;

      for (var i in this.Value) {
        var item = this.Value[i];
        var pt = new Point();
        pt.X = this.Frame.GetXFromIndex(item.XValue - data.DataOffset);
        pt.Y = this.Frame.GetYFromData(item.YValue);
        drawPoint.push(pt);
      }
    } else
    {
      drawPoint = this.Point;
    }

    return drawPoint;
  };

  this.DrawPoint = function (aryPoint) {
    if (!aryPoint || aryPoint.length <= 0) return;

    //画点
    this.ClipFrame();
    for (var i in aryPoint) {
      var item = aryPoint[i];

      this.Canvas.beginPath();
      this.Canvas.arc(item.X, item.Y, 5, 0, 360, false);
      this.Canvas.fillStyle = this.PointColor; //填充颜色
      this.Canvas.fill(); //画实心圆
      this.Canvas.closePath();
    }

    this.Canvas.restore();
  };
}

/*
      画图工具-线段
  */

function ChartDrawPictureLine() {
  this.newMethod = IChartDrawPicture; //派生
  this.newMethod();
  delete this.newMethod;

  this.Draw = function () {
    var drawPoint = this.CalculateDrawPoint();
    if (!drawPoint) return;

    this.ClipFrame();

    for (var i in drawPoint) {
      var item = drawPoint[i];
      if (i == 0) {
        this.Canvas.beginPath();
        this.Canvas.moveTo(item.X, item.Y);
      } else
      {
        this.Canvas.lineTo(item.X, item.Y);
      }

    }

    this.Canvas.strokeStyle = this.LineColor;
    this.Canvas.stroke();
    this.Canvas.closePath();
    this.Canvas.restore();

    //画点
    this.DrawPoint(drawPoint);
  };


  //0-10 鼠标对应的点索引   100=鼠标在正个图形上  -1 鼠标不在图形上
  this.IsPointIn = function (x, y) {
    if (!this.Frame || this.Status != 10) return -1;

    var data = this.Frame.Data;
    if (!data) return -1;

    //是否在点上
    var aryPoint = new Array();
    for (var i in this.Value) {
      var item = this.Value[i];
      var pt = new Point();
      pt.X = this.Frame.GetXFromIndex(item.XValue - data.DataOffset);
      pt.Y = this.Frame.GetYFromData(item.YValue);

      this.Canvas.beginPath();
      this.Canvas.arc(pt.X, pt.Y, 5, 0, 360);
      //JSConsole.Chart.Log('['+i+']'+'x='+x+' y='+y+' dataX='+pt.X+" dataY="+pt.Y);
      if (this.Canvas.isPointInPath(x, y))
      return i;

      aryPoint.push(pt);
    }

    //是否在线段上
    this.Canvas.beginPath();
    this.Canvas.moveTo(aryPoint[0].X, aryPoint[0].Y + 5);
    this.Canvas.lineTo(aryPoint[0].X, aryPoint[0].Y - 5);
    this.Canvas.lineTo(aryPoint[1].X, aryPoint[1].Y - 5);
    this.Canvas.lineTo(aryPoint[1].X, aryPoint[1].Y + 5);
    this.Canvas.closePath();
    if (this.Canvas.isPointInPath(x, y))
    return 100;

    return -1;
  };
}

/*
      画图工具-射线
  */
function ChartDrawPictureHaflLine() {
  this.newMethod = IChartDrawPicture; //派生
  this.newMethod();
  delete this.newMethod;

  this.Draw = function () {
    var drawPoint = this.CalculateDrawPoint();
    if (!drawPoint || drawPoint.length != 2) return;

    this.ClipFrame();

    this.Canvas.beginPath();
    this.Canvas.moveTo(drawPoint[0].X, drawPoint[0].Y);
    this.Canvas.lineTo(drawPoint[1].X, drawPoint[1].Y);

    var endPoint = this.CalculateEndPoint(drawPoint);
    this.Canvas.lineTo(endPoint.X, endPoint.Y);

    this.Canvas.strokeStyle = this.LineColor;
    this.Canvas.stroke();
    this.Canvas.closePath();
    this.Canvas.restore();

    //画点
    this.DrawPoint(drawPoint);
  };

  this.CalculateEndPoint = function (aryPoint) {
    var left = this.Frame.ChartBorder.GetLeft();
    var right = this.Frame.ChartBorder.GetRight();

    var a = aryPoint[1].X - aryPoint[0].X;
    var b = aryPoint[1].Y - aryPoint[0].Y;

    if (a > 0) {
      var a1 = right - aryPoint[0].X;
      var b1 = a1 * b / a;
      var y = b1 + aryPoint[0].Y;

      var pt = new Point();
      pt.X = right;
      pt.Y = y;
      return pt;
    } else
    {
      var a1 = aryPoint[0].X - left;
      var b1 = a1 * b / Math.abs(a);
      var y = b1 + aryPoint[0].Y;

      var pt = new Point();
      pt.X = left;
      pt.Y = y;
      return pt;
    }
  };


  //0-10 鼠标对应的点索引   100=鼠标在正个图形上  -1 鼠标不在图形上
  this.IsPointIn = function (x, y) {
    if (!this.Frame || this.Status != 10) return -1;

    var data = this.Frame.Data;
    if (!data) return -1;

    //是否在点上
    var aryPoint = new Array();
    for (var i in this.Value) {
      var item = this.Value[i];
      var pt = new Point();
      pt.X = this.Frame.GetXFromIndex(item.XValue - data.DataOffset);
      pt.Y = this.Frame.GetYFromData(item.YValue);

      this.Canvas.beginPath();
      this.Canvas.arc(pt.X, pt.Y, 5, 0, 360);
      //JSConsole.Chart.Log('['+i+']'+'x='+x+' y='+y+' dataX='+pt.X+" dataY="+pt.Y);
      if (this.Canvas.isPointInPath(x, y))
      return i;

      aryPoint.push(pt);
    }

    //是否在线段上
    this.Canvas.beginPath();
    this.Canvas.moveTo(aryPoint[0].X, aryPoint[0].Y + 5);
    this.Canvas.lineTo(aryPoint[0].X, aryPoint[0].Y - 5);
    this.Canvas.lineTo(aryPoint[1].X, aryPoint[1].Y - 5);
    this.Canvas.lineTo(aryPoint[1].X, aryPoint[1].Y + 5);
    this.Canvas.closePath();
    if (this.Canvas.isPointInPath(x, y))
    return 100;

    return -1;
  };
}

/*
      画图工具-矩形
  */
function ChartDrawPictureRect() {
  this.newMethod = IChartDrawPicture; //派生
  this.newMethod();
  delete this.newMethod;

  this.Draw = function () {
    var drawPoint = this.CalculateDrawPoint();
    if (!drawPoint || drawPoint.length != 2) return;

    this.ClipFrame();

    this.Canvas.beginPath();
    this.Canvas.rect(drawPoint[0].X, drawPoint[0].Y, drawPoint[1].X - drawPoint[0].X, drawPoint[1].Y - drawPoint[0].Y);

    this.Canvas.strokeStyle = this.LineColor;
    this.Canvas.stroke();
    this.Canvas.closePath();
    this.Canvas.restore();

    //画点
    this.DrawPoint(drawPoint);
  };

  //0-10 鼠标对应的点索引   100=鼠标在正个图形上  -1 鼠标不在图形上
  this.IsPointIn = function (x, y) {
    if (!this.Frame || this.Status != 10) return -1;

    var data = this.Frame.Data;
    if (!data) return -1;

    //是否在点上
    var aryPoint = new Array();
    for (var i in this.Value) {
      var item = this.Value[i];
      var pt = new Point();
      pt.X = this.Frame.GetXFromIndex(item.XValue - data.DataOffset);
      pt.Y = this.Frame.GetYFromData(item.YValue);

      this.Canvas.beginPath();
      this.Canvas.arc(pt.X, pt.Y, 5, 0, 360);
      //JSConsole.Chart.Log('['+i+']'+'x='+x+' y='+y+' dataX='+pt.X+" dataY="+pt.Y);
      if (this.Canvas.isPointInPath(x, y))
      return i;

      aryPoint.push(pt);
    }

    //是否在矩形边框上
    var linePoint = [{ X: aryPoint[0].X, Y: aryPoint[0].Y }, { X: aryPoint[1].X, Y: aryPoint[0].Y }];
    if (this.IsPointInLine(linePoint, x, y))
    return 100;

    linePoint = [{ X: aryPoint[1].X, Y: aryPoint[0].Y }, { X: aryPoint[1].X, Y: aryPoint[1].Y }];
    if (this.IsPointInLine2(linePoint, x, y))
    return 100;

    linePoint = [{ X: aryPoint[1].X, Y: aryPoint[1].Y }, { X: aryPoint[0].X, Y: aryPoint[1].Y }];
    if (this.IsPointInLine(linePoint, x, y))
    return 100;

    linePoint = [{ X: aryPoint[0].X, Y: aryPoint[1].Y }, { X: aryPoint[0].X, Y: aryPoint[0].Y }];
    if (this.IsPointInLine2(linePoint, x, y))
    return 100;

    return -1;
  };

  //点是否在线段上 水平线段
  this.IsPointInLine = function (aryPoint, x, y) {
    this.Canvas.beginPath();
    this.Canvas.moveTo(aryPoint[0].X, aryPoint[0].Y + 5);
    this.Canvas.lineTo(aryPoint[0].X, aryPoint[0].Y - 5);
    this.Canvas.lineTo(aryPoint[1].X, aryPoint[1].Y - 5);
    this.Canvas.lineTo(aryPoint[1].X, aryPoint[1].Y + 5);
    this.Canvas.closePath();
    if (this.Canvas.isPointInPath(x, y))
    return true;
  };

  //垂直线段
  this.IsPointInLine2 = function (aryPoint, x, y) {
    this.Canvas.beginPath();
    this.Canvas.moveTo(aryPoint[0].X - 5, aryPoint[0].Y);
    this.Canvas.lineTo(aryPoint[0].X + 5, aryPoint[0].Y);
    this.Canvas.lineTo(aryPoint[1].X + 5, aryPoint[1].Y);
    this.Canvas.lineTo(aryPoint[1].X - 5, aryPoint[1].Y);
    this.Canvas.closePath();
    if (this.Canvas.isPointInPath(x, y))
    return true;
  };
}

/*
      画图工具-弧形
  */
function ChartDrawPictureArc() {
  this.newMethod = IChartDrawPicture; //派生
  this.newMethod();
  delete this.newMethod;

  this.Draw = function () {
    var drawPoint = this.CalculateDrawPoint();
    if (!drawPoint || drawPoint.length != 2) return;

    this.ClipFrame();

    //this.Canvas.beginPath();
    //this.Canvas.rect(drawPoint[0].X,drawPoint[0].Y,drawPoint[1].X-drawPoint[0].X,drawPoint[1].Y-drawPoint[0].Y);
    if (drawPoint[0].X < drawPoint[1].X && drawPoint[0].Y > drawPoint[1].Y) // 第一象限
      {
        var a = drawPoint[1].X - drawPoint[0].X;
        var b = drawPoint[0].Y - drawPoint[1].Y;
        var step = a > b ? 1 / a : 1 / b;
        var xcenter = drawPoint[0].X;
        var ycenter = drawPoint[1].Y;
        this.Canvas.beginPath();
        this.Canvas.moveTo(drawPoint[0].X, drawPoint[0].Y);
        for (var i = 1.5 * Math.PI; i < 2 * Math.PI; i += step) {
          this.Canvas.lineTo(xcenter + a * Math.cos(i), ycenter + b * Math.sin(i) * -1);
        }
        for (var j = 0; j <= 0.5 * Math.PI; j += step) {
          this.Canvas.lineTo(xcenter + a * Math.cos(j), ycenter + b * Math.sin(j) * -1);
        }
      } else
    if (drawPoint[0].X > drawPoint[1].X && drawPoint[0].Y > drawPoint[1].Y) // 第二象限
      {
        var a = drawPoint[0].X - drawPoint[1].X;
        var b = drawPoint[0].Y - drawPoint[1].Y;
        var step = a > b ? 1 / a : 1 / b;
        var xcenter = drawPoint[1].X;
        var ycenter = drawPoint[0].Y;
        this.Canvas.beginPath();
        this.Canvas.moveTo(drawPoint[0].X, drawPoint[0].Y);
        for (var i = 0; i <= Math.PI; i += step) {
          this.Canvas.lineTo(xcenter + a * Math.cos(i), ycenter + b * Math.sin(i) * -1);
        }
      } else
    if (drawPoint[0].X > drawPoint[1].X && drawPoint[0].Y < drawPoint[1].Y) // 第三象限
      {
        var a = drawPoint[0].X - drawPoint[1].X;
        var b = drawPoint[1].Y - drawPoint[0].Y;
        var step = a > b ? 1 / a : 1 / b;
        var xcenter = drawPoint[0].X;
        var ycenter = drawPoint[1].Y;
        this.Canvas.beginPath();
        this.Canvas.moveTo(drawPoint[0].X, drawPoint[0].Y);
        for (var i = 0.5 * Math.PI; i <= 1.5 * Math.PI; i += step) {
          this.Canvas.lineTo(xcenter + a * Math.cos(i), ycenter + b * Math.sin(i) * -1);
        }
      } else
    if (drawPoint[0].X < drawPoint[1].X && drawPoint[0].Y < drawPoint[1].Y) // 第四象限
      {
        var a = drawPoint[1].X - drawPoint[0].X;
        var b = drawPoint[1].Y - drawPoint[0].Y;
        var step = a > b ? 1 / a : 1 / b;
        var xcenter = drawPoint[1].X;
        var ycenter = drawPoint[0].Y;
        this.Canvas.beginPath();
        this.Canvas.moveTo(drawPoint[0].X, drawPoint[0].Y);
        for (var i = Math.PI; i <= 2 * Math.PI; i += step) {
          this.Canvas.lineTo(xcenter + a * Math.cos(i), ycenter + b * Math.sin(i) * -1);
        }
      }


    this.Canvas.strokeStyle = this.LineColor;
    this.Canvas.stroke();
    //this.Canvas.closePath();
    this.Canvas.restore();

    //画点
    this.DrawPoint(drawPoint);
  };

  //0-10 鼠标对应的点索引   100=鼠标在正个图形上  -1 鼠标不在图形上
  this.IsPointIn = function (x, y) {
    if (!this.Frame || this.Status != 10) return -1;

    var data = this.Frame.Data;
    if (!data) return -1;

    //是否在点上
    var aryPoint = new Array();
    for (var i in this.Value) {
      var item = this.Value[i];
      var pt = new Point();
      pt.X = this.Frame.GetXFromIndex(item.XValue - data.DataOffset);
      pt.Y = this.Frame.GetYFromData(item.YValue);

      this.Canvas.beginPath();
      this.Canvas.arc(pt.X, pt.Y, 5, 0, 360);
      //JSConsole.Chart.Log('['+i+']'+'x='+x+' y='+y+' dataX='+pt.X+" dataY="+pt.Y);
      if (this.Canvas.isPointInPath(x, y))
      return i;

      aryPoint.push(pt);
    }

    //是否在弧线上
    var ArcPoint = [{ X: aryPoint[0].X, Y: aryPoint[0].Y }, { X: aryPoint[1].X, Y: aryPoint[1].Y }];
    if (this.IsPointInArc(ArcPoint, x, y))
    return 100;

    return -1;
  };
  this.IsPointInArc = function (aryPoint, x, y) {
    if (aryPoint.length != 2)
    return false;
    if (aryPoint[0].X < aryPoint[1].X && aryPoint[0].Y > aryPoint[1].Y) // 第一象限
      {
        var a = aryPoint[1].X - aryPoint[0].X;
        var b = aryPoint[0].Y - aryPoint[1].Y;
        var step = a > b ? 1 / a : 1 / b;
        var ainer = a * 0.8;
        var biner = b * 0.8;
        var stepiner = ainer > biner ? 1 / ainer : 1 / biner;
        var xcenter = aryPoint[0].X;
        var ycenter = aryPoint[1].Y;
        this.Canvas.beginPath();
        this.Canvas.moveTo(aryPoint[0].X, aryPoint[0].Y);
        for (var i = 1.5 * Math.PI; i < 2 * Math.PI; i += step) {
          this.Canvas.lineTo(xcenter + a * Math.cos(i), ycenter + b * Math.sin(i) * -1);
        }
        for (var j = 0; j <= 0.5 * Math.PI; j += step) {
          this.Canvas.lineTo(xcenter + a * Math.cos(j), ycenter + b * Math.sin(j) * -1);
        }
        for (var k = 0.5 * Math.PI; k >= 0; k -= stepiner) {
          this.Canvas.lineTo(xcenter + ainer * Math.cos(k), ycenter + biner * Math.sin(j) * -1);
        }
        for (var l = 2 * Math.PI; l >= 1.5 * Math.PI; l -= stepiner) {
          this.Canvas.lineTo(xcenter + ainer * Math.cos(l), ycenter + biner * Math.sin(l) * -1);
        }
        this.Canvas.closePath();
      } else
    if (aryPoint[0].X > aryPoint[1].X && aryPoint[0].Y > aryPoint[1].Y) // 第二象限
      {
        var a = aryPoint[0].X - aryPoint[1].X;
        var b = aryPoint[0].Y - aryPoint[1].Y;
        var step = a > b ? 1 / a : 1 / b;
        var ainer = a * 0.8;
        var biner = b * 0.8;
        var stepiner = ainer > biner ? 1 / ainer : 1 / biner;
        var xcenter = aryPoint[1].X;
        var ycenter = aryPoint[0].Y;
        this.Canvas.beginPath();
        this.Canvas.moveTo(aryPoint[0].X, aryPoint[0].Y);
        for (var i = 0; i <= Math.PI; i += step) {
          this.Canvas.lineTo(xcenter + a * Math.cos(i), ycenter + b * Math.sin(i) * -1);
        }
        for (var j = Math.PI; j >= 0; j -= stepiner) {
          this.Canvas.lineTo(xcenter + ainer * Math.cos(j), ycenter + biner * Math.sin(j) * -1);
        }
        this.Canvas.closePath();
      } else
    if (aryPoint[0].X > aryPoint[1].X && aryPoint[0].Y < aryPoint[1].Y) // 第三象限
      {
        var a = aryPoint[0].X - aryPoint[1].X;
        var b = aryPoint[1].Y - aryPoint[0].Y;
        var step = a > b ? 1 / a : 1 / b;
        var ainer = a * 0.8;
        var biner = b * 0.8;
        var stepiner = ainer > biner ? 1 / ainer : 1 / biner;
        var xcenter = aryPoint[0].X;
        var ycenter = aryPoint[1].Y;
        this.Canvas.beginPath();
        this.Canvas.moveTo(aryPoint[0].X, aryPoint[0].Y);
        for (var i = 0.5 * Math.PI; i <= 1.5 * Math.PI; i += step) {
          this.Canvas.lineTo(xcenter + a * Math.cos(i), ycenter + b * Math.sin(i) * -1);
        }
        for (var j = 1.5 * Math.PI; j >= 0.5 * Math.PI; j -= stepiner) {
          this.Canvas.lineTo(xcenter + ainer * Math.cos(j), ycenter + biner * Math.sin(j) * -1);
        }
        this.Canvas.closePath();
      } else
    if (aryPoint[0].X < aryPoint[1].X && aryPoint[0].Y < aryPoint[1].Y) // 第四象限
      {
        var a = aryPoint[1].X - aryPoint[0].X;
        var b = aryPoint[1].Y - aryPoint[0].Y;
        var step = a > b ? 1 / a : 1 / b;
        var ainer = a * 0.8;
        var biner = b * 0.8;
        var stepiner = ainer > biner ? 1 / ainer : 1 / biner;
        var xcenter = aryPoint[1].X;
        var ycenter = aryPoint[0].Y;
        this.Canvas.beginPath();
        this.Canvas.moveTo(aryPoint[0].X, aryPoint[0].Y);
        for (var i = Math.PI; i <= 2 * Math.PI; i += step) {
          this.Canvas.lineTo(xcenter + a * Math.cos(i), ycenter + b * Math.sin(i) * -1);
        }
        for (var j = 2 * Math.PI; j >= Math.PI; j -= stepiner) {
          this.Canvas.lineTo(xcenter + ainer * Math.cos(j), ycenter + biner * Math.sin(j) * -1);
        }
        this.Canvas.closePath();
      }
    if (this.Canvas.isPointInPath(x, y))
    return true;else

    return false;

  };

}

/*
      指标列表 指标信息都在这里,不够后面再加字段
  */
function JSIndexMap() {

}

JSIndexMap.Get = function (id) {
  var indexMap = new Map(
  [
  //公司自己的指标
  ["市场多空", { IsMainIndex: false, Create: function Create() {return new MarketLongShortIndex();} }],
  ["市场择时", { IsMainIndex: false, Create: function Create() {return new MarketTimingIndex();} }],
  ["市场关注度", { IsMainIndex: false, Create: function Create() {return new MarketAttentionIndex();} }],
  ["指数热度", { IsMainIndex: false, Create: function Create() {return new MarketHeatIndex();} }],
  ["自定义指数热度", { IsMainIndex: false, Create: function Create() {return new CustonIndexHeatIndex();}, Name: '自定义指数热度' }],
  ["财务粉饰", { IsMainIndex: false, Create: function Create() {return new BenfordIndex();} }]

  //能图指标
  //["能图-趋势", { IsMainIndex: false, Create: function () { return new LighterIndex1() }, Name: '大盘/个股趋势' }],
  //["能图-位置研判", { IsMainIndex: false, Create: function () { return new LighterIndex2() }, Name: '位置研判' }],
  //["能图-点位研判", { IsMainIndex: false, Create: function () { return new LighterIndex3() }, Name: '点位研判' }],
  //["能图-资金分析", { IsMainIndex: false, Create: function () { return new LighterIndex4() }, Name: '资金分析' }],
  //["能图-市场关注度", { IsMainIndex: false, Create: function () { return new LighterIndex5() }, Name: '市场关注度' }]
  ]);


  return indexMap.get(id);
};

/////////////////////////////////////////////////////////////////////////////////////////////
//  K线图 控件
//  this.ChartPaint[0] K线画法 这个不要修改
//
//
function KLineChartContainer(uielement)
{
  var _self = this;
  this.newMethod = JSChartContainer; //派生
  this.newMethod(uielement);
  delete this.newMethod;

  this.ClassName = 'KLineChartContainer';
  this.WindowIndex = new Array();
  this.ColorIndex; //五彩K线
  this.TradeIndex; //交易指标/专家系统
  this.Symbol;
  this.Name;
  this.Period = 0; //周期 0=日线 1=周线 2=月线 3=年线 4=1分钟 5=5分钟 6=15分钟 7=30分钟 8=60分钟 9=季线 10=分笔线 11=120分钟 12=240分钟
  this.IsApiPeriod = false; //使用API计算周期
  this.Right = 0; //复权 0 不复权 1 前复权 2 后复权
  this.SourceData; //原始的历史数据
  this.MaxReqeustDataCount = 3000; //数据个数
  this.MaxRequestMinuteDayCount = 5; //分钟数据请求的天数
  this.PageSize = 200; //每页数据个数
  this.KLineDrawType = 0; //0=K线 1=收盘价线 2=美国线
  this.LoadDataSplashTitle = '下载历史数据';
  this.IsAutoUpdate = false; //是否自动更新行情数据
  this.AutoUpdateFrequency = 30000; //30秒更新一次数据
  this.AutoUpdateTimer; //自动定时器
  this.RightSpaceCount = 1;
  this.SourceDataLimit = new Map(); //每个周期缓存数据最大个数 key=周期 value=最大个数  
  this.KLineSize = null; //{ DataWidth:, }

  this.StepPixel = 4; //移动一个数据需要的像素
  this.ZoomStepPixel = 5; //放大缩小手势需要的最小像素
  this.EnableZoomUpDown = null; //是否手势/键盘/鼠标允许缩放{ Touch:true/false, Mouse:true/false, Keyboard:true/false, Wheel:true/false }

  this.DragDownload = {
    Day: { Enable: false, IsEnd: false, Status: 0 }, //日线数据拖拽下载(暂不支持) Status: 0空闲 1 下载中
    Minute: { Enable: false, IsEnd: false, status: 0 } //分钟数据拖拽下载
  };

  this.KLineApiUrl = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Domain + "/API/KLine2"; //历史K线api地址
  this.MinuteKLineApiUrl = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Domain + '/API/KLine3'; //历史分钟数据
  this.RealtimeApiUrl = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Domain + "/API/Stock"; //实时行情api地址
  this.KLineMatchUrl = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Domain + "/API/KLineMatch"; //形态匹配
  this.DragMinuteKLineApiUrl = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Domain + '/API/KLine4'; //拖动数据下载
  this.DragKLineApiUrl = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Domain + '/API/KLine5'; //拖动日K数据下载

  this.BeforeBindMainData = null; //function(funcName)   在BindMainData() 调用前回调用
  this.AfterBindMainData = null; //function(funcName)   在BindMainData() 调用前后调用

  this.ResetDragDownload = function ()
  {
    this.DragDownload.Day.Status = 0;
    this.DragDownload.Day.IsEnd = false;

    this.DragDownload.Minute.Status = 0;
    this.DragDownload.Minute.isEnd = false;
  };

  this.ChartOperator = function (obj) //图形控制函数 {ID:JSCHART_OPERATOR_ID, ...参数 }
  {
    var id = obj.ID;
    if (id === JSCHART_OPERATOR_ID.OP_SCROLL_LEFT || id === JSCHART_OPERATOR_ID.OP_SCROLL_RIGHT) //左右移动 { Step:移动数据个数 }
      {
        var isLeft = id === JSCHART_OPERATOR_ID.OP_SCROLL_LEFT ? true : false;
        var step = 1;
        if (obj.Step > 0) step = obj.Step;
        if (this.DataMove(step * this.StepPixel, isLeft)) //每次移动一个数据
          {
            this.UpdataDataoffset();
            this.UpdatePointByCursorIndex();
            this.UpdateFrameMaxMin();
            this.ResetFrameXYSplit();
            this.Draw();
          } else

        {
          if (id === JSCHART_OPERATOR_ID.OP_SCROLL_RIGHT && this.DragDownloadData)
          this.DragDownloadData();
        }
      } else
    if (id === JSCHART_OPERATOR_ID.OP_ZOOM_IN || id === JSCHART_OPERATOR_ID.OP_ZOOM_OUT) //缩放
      {
        var cursorIndex = {};
        cursorIndex.Index = parseInt(Math.abs(this.CursorIndex - 0.5).toFixed(0));
        if (id === JSCHART_OPERATOR_ID.OP_ZOOM_IN)
        {
          if (!this.Frame.ZoomUp(cursorIndex)) return;
        } else

        {
          if (!this.Frame.ZoomDown(cursorIndex)) return;
        }
        this.CursorIndex = cursorIndex.Index;
        this.UpdataDataoffset();
        this.UpdatePointByCursorIndex();
        this.UpdateFrameMaxMin();
        this.Draw();
      } else
    if (id === JSCHART_OPERATOR_ID.OP_GOTO_HOME) //返回最新
      {
        var hisData = null;
        if (!this.Frame.Data) hisData = this.Frame.Data;else
        hisData = this.Frame.SubFrame[0].Frame.Data;
        if (!hisData) return; //数据还没有到达

        var showCount = this.PageSize;
        //var pageSize = this.GetMaxMinPageSize();
        //if (pageSize.Max < showCount) showCount = pageSize.Max;
        //else if (pageSize.Min > showCount) showCount = pageSize.Min;

        for (var i in this.Frame.SubFrame) //设置一屏显示的数据个数
        {
          var item = this.Frame.SubFrame[i].Frame;
          item.XPointCount = showCount;
        }

        var index = hisData.Data.length - showCount;
        hisData.DataOffset = index;
        this.CursorIndex = 0;

        this.LastPoint.X = null;
        this.LastPoint.Y = null;

        _umychartConsoleWechat.JSConsole.Chart.Log("[KLineChartContainer::ChartOperator] OP_GOTO_HOME, dataOffset=".concat(hisData.DataOffset, " CursorIndex=").concat(this.CursorIndex, " PageSize=").concat(showCount));

        this.UpdataDataoffset(); //更新数据偏移
        this.UpdateFrameMaxMin(); //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();
        this.UpdatePointByCursorIndex(); //更新十字光标位子
      }
  };

  //创建windowCount 窗口个数
  this.Create = function (windowCount)
  {
    this.UIElement.JSChartContainer = this;

    //创建十字光标
    this.ChartCorssCursor = new _umychartChartpaintWechat.JSCommonChartPaint_ChartCorssCursor();
    this.ChartCorssCursor.Canvas = this.Canvas;
    this.ChartCorssCursor.StringFormatX = new HQDateStringFormat();
    this.ChartCorssCursor.StringFormatY = new HQPriceStringFormat();
    this.ChartCorssCursor.StringFormatY.LanguageID = this.LanguageID;

    //创建等待提示
    this.ChartSplashPaint = new _umychartChartpaintWechat.JSCommonChartPaint_ChartSplashPaint();
    this.ChartSplashPaint.Canvas = this.Canvas;
    this.ChartSplashPaint.SplashTitle = this.LoadDataSplashTitle;
    this.ChartSplashPaint.HQChart = this;

    //创建框架容器
    this.Frame = new HQTradeFrame();
    this.Frame.ChartBorder = new ChartBorder();
    this.Frame.ChartBorder.UIElement = this.UIElement;
    this.Frame.ChartBorder.Top = 30;
    this.Frame.ChartBorder.Left = 5;
    this.Frame.ChartBorder.Bottom = 20;
    this.Frame.Canvas = this.Canvas;
    this.ChartCorssCursor.Frame = this.Frame; //十字光标绑定框架
    this.ChartSplashPaint.Frame = this.Frame;

    this.CreateChildWindow(windowCount);
    this.CreateMainKLine();

    //子窗口动态标题
    for (var i in this.Frame.SubFrame)
    {
      var titlePaint = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicChartTitlePainting();
      titlePaint.Frame = this.Frame.SubFrame[i].Frame;
      titlePaint.Canvas = this.Canvas;
      titlePaint.LanguageID = this.LanguageID;
      this.Frame.SubFrame[i].Frame.TitlePaint = titlePaint;
      this.TitlePaint.push(titlePaint);
    }
  };

  //创建子窗口
  this.CreateChildWindow = function (windowCount)
  {var _this7 = this;
    for (var i = 0; i < windowCount; ++i)
    {
      var border = new ChartBorder();
      border.UIElement = this.UIElement;

      var frame = new KLineFrame();
      frame.Canvas = this.Canvas;
      frame.ChartBorder = border;
      frame.Identify = i; //窗口序号
      frame.RightSpaceCount = this.RightSpaceCount; //右边

      frame.HorizontalMax = 20;
      frame.HorizontalMin = 10;

      if (i == 0)
      {
        frame.YSplitOperator = new _umychartFramesplitWechat.JSCommonSplit_FrameSplitKLinePriceY();
        frame.YSplitOperator.FrameSplitData = this.FrameSplitData.get('price');
        frame.YSplitOperator.FrameSplitData2 = this.FrameSplitData.get('double');
        frame.YSplitOperator.GetEventCallback = function (id) {return _this7.GetEventCallback(id);};
        border.BottomSpace = 12; //主图上下留空间
        border.TopSpace = 12;
      } else

      {
        frame.YSplitOperator = new _umychartFramesplitWechat.JSCommonSplit_FrameSplitY();
        frame.YSplitOperator.FrameSplitData = this.FrameSplitData.get('double');
        frame.YSplitOperator.LanguageID = this.LanguageID;
        frame.YSplitOperator.GetEventCallback = function (id) {return _this7.GetEventCallback(id);};
      }

      frame.YSplitOperator.Frame = frame;
      frame.YSplitOperator.ChartBorder = border;
      frame.XSplitOperator = new _umychartFramesplitWechat.JSCommonSplit_FrameSplitKLineX();
      frame.XSplitOperator.Frame = frame;
      frame.XSplitOperator.ChartBorder = border;

      if (i != windowCount - 1) frame.XSplitOperator.ShowText = false;

      for (var j = frame.HorizontalMin; j <= frame.HorizontalMax; j += 1)
      {
        frame.HorizontalInfo[j] = new _umychartFramesplitWechat.JSCommonSplit_CoordinateInfo();
        frame.HorizontalInfo[j].Value = j;
        if (i == 0 && j == frame.HorizontalMin) continue;

        frame.HorizontalInfo[j].Message[1] = j.toString();
        frame.HorizontalInfo[j].Font = "14px 微软雅黑";
      }

      var subFrame = new SubFrameItem();
      subFrame.Frame = frame;
      if (i == 0) subFrame.Height = 20;else
      subFrame.Height = 10;

      this.Frame.SubFrame[i] = subFrame;
    }
  };

  this.CreateSubFrameItem = function (id)
  {
    var border = new ChartBorder();
    border.UIElement = this.UIElement;

    var frame = new KLineFrame();
    frame.Canvas = this.Canvas;
    frame.ChartBorder = border;
    frame.Identify = id; //窗口序号

    if (this.ModifyIndexDialog) frame.ModifyIndexEvent = this.ModifyIndexDialog.DoModal; //绑定菜单事件
    if (this.ChangeIndexDialog) frame.ChangeIndexEvent = this.ChangeIndexDialog.DoModal;

    frame.HorizontalMax = 20;
    frame.HorizontalMin = 10;
    frame.YSplitOperator = new _umychartFramesplitWechat.JSCommonSplit_FrameSplitY();
    frame.YSplitOperator.LanguageID = this.LanguageID;
    frame.YSplitOperator.FrameSplitData = this.FrameSplitData.get('double');
    frame.YSplitOperator.Frame = frame;
    frame.YSplitOperator.ChartBorder = border;
    frame.XSplitOperator = new _umychartFramesplitWechat.JSCommonSplit_FrameSplitKLineX();
    frame.XSplitOperator.Frame = frame;
    frame.XSplitOperator.ChartBorder = border;
    frame.XSplitOperator.ShowText = false;

    //K线数据绑定
    var xPointCouont = this.Frame.SubFrame[0].Frame.XPointCount;
    frame.XPointCount = xPointCouont;
    frame.Data = this.ChartPaint[0].Data;

    for (var j = frame.HorizontalMin; j <= frame.HorizontalMax; j += 1)
    {
      frame.HorizontalInfo[j] = new _umychartFramesplitWechat.JSCommonSplit_CoordinateInfo();
      frame.HorizontalInfo[j].Value = j;
      frame.HorizontalInfo[j].Message[1] = j.toString();
      frame.HorizontalInfo[j].Font = "14px 微软雅黑";
    }

    var subFrame = new SubFrameItem();
    subFrame.Frame = frame;
    subFrame.Height = 10;

    return subFrame;
  };

  //创建主图K线画法
  this.CreateMainKLine = function ()
  {
    var kline = new _umychartChartpaintWechat.JSCommonChartPaint_ChartKLine();
    kline.Canvas = this.Canvas;
    kline.ChartBorder = this.Frame.SubFrame[0].Frame.ChartBorder;
    kline.ChartFrame = this.Frame.SubFrame[0].Frame;
    kline.Name = "Main-KLine";
    kline.DrawType = this.KLineDrawType;

    this.ChartPaint[0] = kline;

    this.TitlePaint[0] = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicKLineTitlePainting();
    this.TitlePaint[0].Frame = this.Frame.SubFrame[0].Frame;
    this.TitlePaint[0].Canvas = this.Canvas;
    this.TitlePaint[0].LanguageID = this.LanguageID;

    //主图叠加画法
    var paint = new _umychartChartpaintWechat.JSCommonChartPaint_ChartOverlayKLine();
    paint.Canvas = this.Canvas;
    paint.ChartBorder = this.Frame.SubFrame[0].Frame.ChartBorder;
    paint.ChartFrame = this.Frame.SubFrame[0].Frame;
    paint.Name = "Overlay-KLine";
    paint.DrawType = this.KLineDrawType;
    this.OverlayChartPaint[0] = paint;

  };

  //绑定主图K线数据
  this.BindMainData = function (hisData, showCount)
  {
    this.ChartPaint[0].Data = hisData;
    this.ChartPaint[0].Symbol = this.Symbol;

    if (this.KLineSize)
    {
      if (this.KLineSize.DataWidth == null)
      {
        showCount = this.Frame.SubFrame[0].Frame.XPointCount - this.RightSpaceCount;
      } else

      {
        var obj = this.Frame.SetDataWidth(this.KLineSize.DataWidth);
        showCount = obj.XPointCount - this.RightSpaceCount;
        this.KLineSize.DataWidth = null;
      }
    }

    for (var i in this.Frame.SubFrame)
    {
      var item = this.Frame.SubFrame[i].Frame;
      item.XPointCount = showCount + this.RightSpaceCount;
      item.Data = this.ChartPaint[0].Data;

      item.XSplitOperator.Symbol = this.Symbol;
      item.XSplitOperator.Period = this.Period;
    }

    this.TitlePaint[0].Data = this.ChartPaint[0].Data; //动态标题
    this.TitlePaint[0].Symbol = this.Symbol;
    this.TitlePaint[0].Name = this.Name;
    this.TitlePaint[0].Period = this.Period;

    this.ChartCorssCursor.StringFormatX.Data = this.ChartPaint[0].Data; //十字光标
    this.Frame.Data = this.ChartPaint[0].Data;

    this.OverlayChartPaint[0].MainData = this.ChartPaint[0].Data; //K线叠加

    var dataOffset = hisData.Data.length - showCount;
    if (dataOffset < 0) dataOffset = 0;
    this.ChartPaint[0].Data.DataOffset = dataOffset;

    this.ChartCorssCursor.StringFormatY.Symbol = this.Symbol;

    this.CursorIndex = showCount;
    if (this.CursorIndex + dataOffset >= hisData.Data.length) this.CursorIndex = hisData.Data.length - 1 - dataOffset;
    if (this.CursorIndex < 0) this.CursorIndex = 0; //不一定对啊
  };

  this.UpdateMainData = function (hisData, lastDataCount) //更新主图数据(不会放大缩小数据)
  {
    var frameHisdata = null;
    if (!this.Frame.Data) frameHisdata = this.Frame.Data;else
    if (this.Frame.SubFrame && this.Frame.SubFrame[0]) frameHisdata = this.Frame.SubFrame[0].Frame.Data;
    if (!frameHisdata) return;

    var xPointCount = this.Frame.SubFrame[0].Frame.XPointCount; //当前一屏能显示的数据个数
    var newDataCount = 0;
    if (lastDataCount > 0 && hisData.Data.length > lastDataCount)
    {
      newDataCount = hisData.Data.length - lastDataCount;
      _umychartConsoleWechat.JSConsole.Chart.Log("[KLineChartContainer::UpdateMainData]  [count=".concat(lastDataCount, "->").concat(hisData.Data.length, "], [newDataCount=").concat(newDataCount, "]"));
    }

    this.ChartPaint[0].Data = hisData;
    this.ChartPaint[0].Symbol = this.Symbol;
    if (hisData.Data.length > xPointCount) //不满一屏的, 不需要调整索引
      this.ChartPaint[0].Data.DataOffset = frameHisdata.DataOffset + newDataCount; //加上数据增加的个数
    for (var i in this.Frame.SubFrame)
    {
      var item = this.Frame.SubFrame[i].Frame;
      item.Data = this.ChartPaint[0].Data;
      if (i == 0)
      {
        item.YSplitOperator.Symbol = this.Symbol;
        item.YSplitOperator.Data = this.ChartPaint[0].Data; //K线数据
        item.YSplitOperator.Period = this.Period; //周期
      }
    }

    this.TitlePaint[0].Data = this.ChartPaint[0].Data; //动态标题
    this.TitlePaint[0].Symbol = this.Symbol;
    this.TitlePaint[0].Name = this.Name;

    this.ChartCorssCursor.StringFormatX.Data = this.ChartPaint[0].Data; //十字光标
    this.Frame.Data = this.ChartPaint[0].Data;

    for (var i in this.OverlayChartPaint) //主图股票数据绑定到叠加股票上
    {
      var item = this.OverlayChartPaint[i];
      item.MainData = this.ChartPaint[0].Data;
    }

    this.ChartCorssCursor.StringFormatY.Symbol = this.Symbol;
  };

  //创建指定窗口指标
  this.CreateWindowIndex = function (windowIndex)
  {
    this.WindowIndex[windowIndex].Create(this, windowIndex);
  };

  this.BindIndexData = function (windowIndex, hisData)
  {
    if (!this.WindowIndex[windowIndex]) return;

    if (typeof this.WindowIndex[windowIndex].RequestData == "function") //数据需要另外下载的.
      {
        this.WindowIndex[windowIndex].RequestData(this, windowIndex, hisData);
        return;
      }
    if (typeof this.WindowIndex[windowIndex].ExecuteScript == 'function') //脚本指标
      {
        this.WindowIndex[windowIndex].ExecuteScript(this, windowIndex, hisData);
        return;
      }

    this.WindowIndex[windowIndex].BindData(this, windowIndex, hisData);
  };

  //执行指示(专家指示 五彩K线)
  this.BindInstructionIndexData = function (hisData)
  {
    if (this.ColorIndex && typeof this.ColorIndex.ExecuteScript == 'function') //五彩K线
      {
        this.ColorIndex.ExecuteScript(this, 0, hisData);
      }

    if (this.TradeIndex && typeof this.TradeIndex.ExecuteScript == 'function') //交易指标
      {
        this.TradeIndex.ExecuteScript(this, 0, hisData);
      }
  };

  //获取子窗口的所有画法
  this.GetChartPaint = function (windowIndex)
  {
    var paint = new Array();
    for (var i in this.ChartPaint)
    {
      if (i == 0) continue; //第1个K线数据除外
      var item = this.ChartPaint[i];
      if (item.ChartFrame == this.Frame.SubFrame[windowIndex].Frame)
      paint.push(item);
    }

    return paint;
  };

  this.AutoUpdateEvent = function (bStart) //自定更新事件, 是给websocket使用
  {
    var eventID = bStart ? _umychartDataWechat.JSCommon_JSCHART_EVENT_ID.RECV_START_AUTOUPDATE : _umychartDataWechat.JSCommon_JSCHART_EVENT_ID.RECV_STOP_AUTOUPDATE;
    if (!this.mapEvent.has(eventID)) return;

    var self = this;
    var event = this.mapEvent.get(eventID);
    var data = { Stock: { Symbol: this.Symbol, Name: this.Name, Right: this.Right, Period: this.Period } };
    if (bStart)
    {
      data.Callback = function (data) //数据到达更新回调
      {
        if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(self.Period, true)) self.RecvRealtimeData(data);else
        if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(self.Period, true)) self.RecvMinuteRealtimeData(data);else
        if (_umychartDataWechat.JSCommon_ChartData.IsSecondPeriod(self.Period)) self.RecvMinuteRealtimeData(data);
      };
    }
    event.Callback(event, data, this);
  };

  this.RequestHistoryData = function ()
  {
    var self = this;
    this.CancelAutoUpdate();
    this.ChartSplashPaint.SetTitle(this.LoadDataSplashTitle);
    this.ChartSplashPaint.EnableSplash(true);
    this.ResetDragDownload();
    this.Draw();

    if (this.NetworkFilter)
    {
      var obj =
      {
        Name: 'KLineChartContainer::RequestHistoryData', //类名::
        Explain: '日K数据',
        Request: {
          Url: self.KLineApiUrl, Type: 'POST',
          Data: { symbol: self.Symbol, count: self.MaxReqeustDataCount, field: ["name", "symbol", "yclose", "open", "price", "high", "low", "vol"] } },

        Self: this,
        PreventDefault: false };

      this.NetworkFilter(obj, function (data) {
        self.ChartSplashPaint.EnableSplash(false);
        self.RecvHistoryData(data);
        self.AutoUpdateEvent(true);
        self.AutoUpdate();
      });

      if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求
    }

    wx.request({
      url: this.KLineApiUrl,
      data:
      {
        "field": ["name", "symbol", "yclose", "open", "price", "high", "low", "vol"],
        "symbol": self.Symbol,
        "start": -1,
        "count": self.MaxReqeustDataCount },

      method: 'POST',
      dataType: 'json',
      success: function success(data) {
        self.ChartSplashPaint.EnableSplash(false);
        self.RecvHistoryData(data);
        self.AutoUpdateEvent(true);
        self.AutoUpdate();
      } });

  };

  this.RecvHistoryData = function (recvData)
  {
    var data = recvData.data;
    var aryDayData = KLineChartContainer.JsonDataToHistoryData(data);

    //原始数据
    var sourceData = new _umychartDataWechat.JSCommon_ChartData();
    sourceData.Data = aryDayData;
    sourceData.DataType = 0; //0=日线数据 1=分钟数据
    sourceData.Symbol = data.symbol;
    this.SourceData = sourceData;

    if (this.BeforeBindMainData) this.BeforeBindMainData("RecvHistoryData");

    //显示的数据
    var bindData = new _umychartDataWechat.JSCommon_ChartData();
    bindData.Data = aryDayData;
    bindData.Right = this.Right;
    bindData.Period = this.Period;
    bindData.DataType = 0;

    if (bindData.Right > 0 && !this.IsApiPeriod) //复权
      {
        var rightData = bindData.GetRightDate(bindData.Right);
        bindData.Data = rightData;
      }

    if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(bindData.Period, false) && !this.IsApiPeriod) //周期数据
      {
        var periodData = bindData.GetPeriodData(bindData.Period);
        bindData.Data = periodData;
      }

    //绑定数据
    this.Symbol = data.symbol;
    this.Name = data.name;
    this.BindMainData(bindData, this.PageSize);
    if (this.AfterBindMainData) this.AfterBindMainData("RecvHistoryData");
    this.Frame.SetSizeChage(true); //数据到达通知坐标框架
    this.BindInstructionIndexData(bindData); //执行指示脚本

    var firstSubFrame; //主窗口
    for (var i = 0; i < this.Frame.SubFrame.length; ++i) //执行指标
    {
      if (i == 0) firstSubFrame = this.Frame.SubFrame[i].Frame;
      this.BindIndexData(i, bindData);
    }

    if (firstSubFrame && firstSubFrame.YSplitOperator)
    {
      firstSubFrame.YSplitOperator.Symbol = this.Symbol; //绑定代码
      firstSubFrame.YSplitOperator.Data = this.ChartPaint[0].Data; //K线数据
    }

    //请求叠加数据 (主数据下载完再下载))
    this.ReqeustKLineInfoData();
    this.RequestOverlayHistoryData();

    //刷新画图
    this.UpdataDataoffset(); //更新数据偏移
    this.UpdatePointByCursorIndex(); //更新十字光标位子
    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Frame.SetSizeChage(true);
    this.Draw();

    if (this.mapEvent.has(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.RECV_HISTROY_DATA))
    {
      var event = this.mapEvent.get(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.RECV_HISTROY_DATA);
      var data = { HistoryData: bindData, Stock: { Symbol: this.Symbol, Name: this.Name } };
      event.Callback(event, data, this);
    } else
      //老的回调暂时保留
      {
        if (typeof this.UpdateUICallback == 'function') this.UpdateUICallback('RecvHistroyData', this); //单词拼写错误, 请使用下面的回调
        if (typeof this.UpdateUICallback == 'function') this.UpdateUICallback('RecvHistoryData', this);
      }
  };

  this.ReqeustHistoryMinuteData = function ()
  {
    var self = this;
    this.CancelAutoUpdate();
    this.ChartSplashPaint.SetTitle(this.LoadDataSplashTitle);
    this.ChartSplashPaint.EnableSplash(true);
    this.ResetDragDownload();
    this.Draw();

    if (this.NetworkFilter)
    {
      var obj =
      {
        Name: 'KLineChartContainer::ReqeustHistoryMinuteData', //类名
        Explain: '1分钟K线数据',
        Request:
        {
          Url: self.MinuteKLineApiUrl, Type: 'POST', Data: {
            symbol: self.Symbol, count: self.MaxRequestMinuteDayCount,
            field: ["name", "symbol", "yclose", "open", "price", "high", "low", "vol"] } },


        Self: this,
        PreventDefault: false };

      this.NetworkFilter(obj, function (data) {
        self.ChartSplashPaint.EnableSplash(false);
        self.RecvMinuteHistoryData(data);
        self.AutoUpdateEvent(true);
        self.AutoUpdate();
      });
      if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求
    }

    wx.request({
      url: this.MinuteKLineApiUrl,
      data:
      {
        "field": ["name", "symbol", "yclose", "open", "price", "high", "low", "vol"],
        "symbol": self.Symbol,
        "start": -1,
        "count": self.MaxRequestMinuteDayCount },

      method: 'POST',
      dataType: "json",
      success: function success(data)
      {
        self.ChartSplashPaint.EnableSplash(false);
        self.RecvMinuteHistoryData(data);
        self.AutoUpdateEvent(true);
        self.AutoUpdate();
      } });

  };

  this.RecvMinuteHistoryData = function (recvData)
  {
    var data = recvData.data;
    var aryDayData = KLineChartContainer.JsonDataToMinuteHistoryData(data);

    //原始数据
    var sourceData = new _umychartDataWechat.JSCommon_ChartData();
    sourceData.Data = aryDayData;
    sourceData.DataType = 1; //0=日线数据 1=分钟数据
    sourceData.Symbol = data.symbol;
    this.SourceData = sourceData;
    if (this.BeforeBindMainData) this.BeforeBindMainData("RecvMinuteHistoryData");

    //显示的数据
    var bindData = new _umychartDataWechat.JSCommon_ChartData();
    bindData.Data = aryDayData;
    bindData.Right = this.Right;
    bindData.Period = this.Period;
    bindData.DataType = 1;
    bindData.Symbol = data.symbol;

    if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(bindData.Period, false) && !this.IsApiPeriod) //周期数据
      {
        var periodData = sourceData.GetPeriodData(bindData.Period);
        bindData.Data = periodData;
      }

    //绑定数据
    this.Symbol = data.symbol;
    this.Name = data.name;
    this.BindMainData(bindData, this.PageSize);
    if (this.AfterBindMainData) this.AfterBindMainData("RecvMinuteHistoryData");
    this.Frame.SetSizeChage(true);
    this.BindInstructionIndexData(bindData); //执行指示脚本

    var firstSubFrame; //主窗口
    for (var i = 0; i < this.Frame.SubFrame.length; ++i)
    {
      if (i == 0) firstSubFrame = this.Frame.SubFrame[i].Frame;
      this.BindIndexData(i, bindData);
    }

    if (firstSubFrame && firstSubFrame.YSplitOperator)
    {
      firstSubFrame.YSplitOperator.Symbol = this.Symbol; //绑定代码
      firstSubFrame.YSplitOperator.Data = this.ChartPaint[0].Data; //K线数据
    }

    this.OverlayChartPaint[0].Data = null; //分钟数据不支持叠加 清空

    //刷新画图
    this.UpdataDataoffset(); //更新数据偏移
    this.UpdatePointByCursorIndex(); //更新十字光标位子
    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Frame.SetSizeChage(true);
    this.Draw();

    if (this.mapEvent.has(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.RECV_HISTROY_DATA))
    {
      var event = this.mapEvent.get(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.RECV_HISTROY_DATA);
      var data = { HistoryData: bindData, Stock: { Symbol: this.Symbol, Name: this.Name } };
      event.Callback(event, data, this);
    } else

    {
      if (typeof this.UpdateUICallback == 'function') this.UpdateUICallback('RecvMinuteHistoryData', this);
    }
  };

  //请求实时行情数据
  this.RequestRealtimeData = function ()
  {
    var self = this;

    if (this.NetworkFilter)
    {
      var obj =
      {
        Name: 'KLineChartContainer::RequestRealtimeData', //类名::函数名
        Explain: '当天最新日线数据',
        Request:
        {
          Url: self.RealtimeApiUrl, Data: {
            symbol: [self.Symbol],
            field: ["name", "symbol", "yclose", "open", "price", "high", "low", "vol", "amount", "date", "time"] },
          Type: 'POST' },

        Self: this,
        PreventDefault: false };

      this.NetworkFilter(obj, function (data) {
        self.RecvRealtimeData(data);
        self.AutoUpdate();
      });

      if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求
    }

    wx.request({
      url: this.RealtimeApiUrl,
      data:
      {
        "field": ["name", "symbol", "yclose", "open", "price", "high", "low", "vol", "amount", "date", "time"],
        "symbol": [self.Symbol],
        "start": -1 },

      method: 'POST',
      dataType: "json",
      async: true,
      success: function success(data) {
        self.RecvRealtimeData(data);
        self.AutoUpdate();
      } });

  };

  this.RecvRealtimeData = function (recvdata)
  {
    if (this.IsOnTouch == true) return; //正在操作中不更新数据
    var data = recvdata.data;
    if (!data || !data.stock || !data.stock[0] || this.Symbol != data.stock[0].symbol)
    {
      _umychartConsoleWechat.JSConsole.Chart.Log('[KLineChartContainer::RecvRealtimeData] recvdata error', recvdata);
      return;
    }

    var realtimeData = KLineChartContainer.JsonDataToRealtimeData(data);
    var item = this.SourceData.Data[this.SourceData.Data.length - 1]; //最新的一条数据
    var lastDataCount = this.GetHistoryDataCount(); //保存下上一次的数据个数

    if (item.Date == realtimeData.Date) //实时行情数据更新
      {
        //JSConsole.Chart.Log('[KLineChartContainer::RecvRealtimeData] update kline by minute data', realtimeData);
        item.Close = realtimeData.Close;
        item.High = realtimeData.High;
        item.Low = realtimeData.Low;
        item.Vol = realtimeData.Vol;
        item.Amount = realtimeData.Amount;
      } else
    if (item.Date < realtimeData.Date) //新增加数据
      {
        //JSConsole.Chart.Log('[KLineChartContainer::RecvRealtimeData] insert kline by minute data', realtimeData);
        var newItem = new _umychartDataWechat.JSCommon_HistoryData();
        newItem.YClose = realtimeData.YClose;
        newItem.Open = realtimeData.Open;
        newItem.Close = realtimeData.Close;
        newItem.High = realtimeData.High;
        newItem.Low = realtimeData.Low;
        newItem.Vol = realtimeData.Vol;
        newItem.Amount = realtimeData.Amount;
        newItem.Date = realtimeData.Date;
        //没有前收盘就用上一个数据的收盘价
        if (!_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(newItem.YClose) && this.SourceData.Data.length > 0)
        newItem.YClose = this.SourceData.Data[this.SourceData.Data.length - 1].YClose;

        this.SourceData.Data.push(newItem);
      } else

    {
      return;
    }

    var bindData = new _umychartDataWechat.JSCommon_ChartData();
    bindData.Data = this.SourceData.Data;
    bindData.Period = this.Period;
    bindData.Right = this.Right;
    bindData.DataType = this.SourceData.DataType;
    bindData.Symbol = this.Symbol;

    if (bindData.Right > 0 && _umychartDataWechat.JSCommon_ChartData.IsDayPeriod(bindData.Period, true) && !this.IsApiPeriod) //复权(日线数据才复权)
      {
        var rightData = bindData.GetRightDate(bindData.Right);
        bindData.Data = rightData;
      }

    if (!this.IsApiPeriod)
    {
      if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(bindData.Period, false) || _umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(bindData.Period, false)) //周期数据 (0= 日线,4=1分钟线 不需要处理)
        {
          var periodData = bindData.GetPeriodData(bindData.Period);
          bindData.Data = periodData;
        }
    }

    //绑定数据
    this.UpdateMainData(bindData, lastDataCount);
    this.Frame.SetSizeChage(true);
    this.BindInstructionIndexData(bindData); //执行指示脚本

    for (var i = 0; i < this.Frame.SubFrame.length; ++i) {
      this.BindIndexData(i, bindData);
    }

    //刷新画图
    this.UpdataDataoffset(); //更新数据偏移
    this.UpdatePointByCursorIndex(); //更新十字光标位子
    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Frame.SetSizeChage(true);
    this.Draw();

    this.SendKLineUpdateEvent(bindData);
  };

  this.GetHistoryDataCount = function ()
  {
    var frameHisdata = null;
    if (!this.Frame.Data) frameHisdata = this.Frame.Data;else
    if (this.Frame.SubFrame && this.Frame.SubFrame[0]) frameHisdata = this.Frame.SubFrame[0].Frame.Data;
    if (!frameHisdata) return -1;
    var lastDataCount = frameHisdata.Data.length; //上一个的数据长度
    return lastDataCount;
  };

  this.RequestMinuteRealtimeData = function ()
  {
    var self = this;
    if (this.NetworkFilter)
    {
      var obj =
      {
        Name: 'KLineChartContainer::RequestMinuteRealtimeData', //类名::
        Explain: '当天1分钟K线数据',
        Request: {
          Url: self.RealtimeApiUrl, Data: {
            symbol: [self.Symbol],
            field: ["name", "symbol", "price", "yclose", "minutecount", "minute", "date", "time"] },
          Type: 'POST' },

        Self: this,
        PreventDefault: false };

      this.NetworkFilter(obj, function (data) {
        self.RecvMinuteRealtimeData(data);
        self.AutoUpdate();
      });

      if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求
    }

    wx.request({
      url: this.RealtimeApiUrl,
      data:
      {
        "field": ["name", "symbol", "price", "yclose", "minutecount", "minute", "date", "time"],
        "symbol": [self.Symbol],
        "start": -1 },

      method: 'POST',
      dataType: "json",
      async: true,
      success: function success(data) {
        self.RecvMinuteRealtimeData(data);
        self.AutoUpdate();
      } });

  };

  this.SetSourceDatatLimit = function (aryLimit)
  {
    this.SourceDataLimit = new Map();
    for (var i in aryLimit)
    {
      var item = aryLimit[i];
      this.SourceDataLimit.set(item.Period, item.MaxCount); //每个周期缓存数据最大个数 key=周期 value=最大个数 
      _umychartConsoleWechat.JSConsole.Chart.Log("[KLineChartContainer::SetSourceDatatLimit] Period=".concat(item.Period, ", MaxCount=").concat(item.MaxCount));
    }
  };

  this.ReduceSourceData = function ()
  {
    if (!this.SourceDataLimit) return;
    if (!this.SourceDataLimit.has(this.Period)) return;

    var limitCount = this.SourceDataLimit.get(this.Period);
    if (limitCount < 50) return;

    var frameHisdata = null;
    if (!this.Frame.Data) frameHisdata = this.Frame.Data;else
    if (this.Frame.SubFrame && this.Frame.SubFrame[0]) frameHisdata = this.Frame.SubFrame[0].Frame.Data;
    if (!frameHisdata) return;

    var dataOffset = frameHisdata.DataOffset;
    var removeCount = 0;
    while (this.SourceData.Data.length > limitCount)
    {
      this.SourceData.Data.shift();
      --dataOffset;
      ++removeCount;
    }

    if (removeCount > 0)
    {
      if (dataOffset < 0) dataOffset = 0;
      frameHisdata.DataOffset = dataOffset;
      _umychartConsoleWechat.JSConsole.Chart.Log("[KLineChartContainer::ReduceSourceData] remove data ".concat(removeCount, ", dataOffset=").concat(dataOffset));
    }
  };

  this.RecvMinuteRealtimeData = function (recvData)
  {
    var data = recvData.data;
    if (this.IsOnTouch == true) return; //正在操作中不更新数据
    if (data.ver == 2.0)
    {
      this.RecvMinuteRealtimeDataV2(data); //v2.0数据版本
      return;
    }

    if (!data.stock || !data.stock[0] || this.Symbol != data.stock[0].symbol) return;
    var realtimeData = KLineChartContainer.JsonDataToMinuteRealtimeData(data);
    if (!realtimeData) return;
    if (this.IsApiPeriod) this.ReduceSourceData(); //减少数据
    var lastDataCount = this.GetHistoryDataCount(); //保存下上一次的数据个数
    var lastSourceDataCount = this.SourceData.Data.length;
    if (!this.SourceData.MergeMinuteData(realtimeData)) return;
    _umychartConsoleWechat.JSConsole.Chart.Log("[KLineChartContainer::RecvMinuteRealtimeData] update kline by 1 minute data [".concat(lastSourceDataCount, "->").concat(this.SourceData.Data.length, "]"));

    var bindData = new _umychartDataWechat.JSCommon_ChartData();
    bindData.Data = this.SourceData.Data;
    bindData.Period = this.Period;
    bindData.Right = this.Right;
    bindData.DataType = this.SourceData.DataType;
    bindData.Symbol = this.Symbol;

    if (bindData.Right > 0 && _umychartDataWechat.JSCommon_ChartData.IsDayPeriod(bindData.Period, true) && !this.IsApiPeriod) //复权(日线数据才复权)
      {
        var rightData = bindData.GetRightDate(bindData.Right);
        bindData.Data = rightData;
      }

    if (!this.IsApiPeriod)
    {
      if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(bindData.Period, false) || _umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(bindData.Period, false)) //周期数据 (0= 日线,4=1分钟线 不需要处理)
        {
          var periodData = bindData.GetPeriodData(bindData.Period);
          bindData.Data = periodData;
        }
    }

    //绑定数据
    this.UpdateMainData(bindData, lastDataCount);
    this.Frame.SetSizeChage(true);
    this.BindInstructionIndexData(bindData); //执行指示脚本

    for (var i = 0; i < this.Frame.SubFrame.length; ++i) {
      this.BindIndexData(i, bindData);
    }

    //刷新画图
    this.UpdataDataoffset(); //更新数据偏移
    this.UpdatePointByCursorIndex(); //更新十字光标位子
    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Frame.SetSizeChage(true);
    this.Draw();

    this.SendKLineUpdateEvent(bindData);
  };

  this.RecvMinuteRealtimeDataV2 = function (data) //新版本的
  {
    if (this.IsOnTouch == true) return; //正在操作中不更新数据
    var aryMinuteData = KLineChartContainer.JsonDataToMinuteHistoryData(data);
    if (!aryMinuteData || aryMinuteData.length <= 0) return;
    if (this.IsApiPeriod) this.ReduceSourceData(); //减少数据
    var lastDataCount = this.GetHistoryDataCount(); //保存下上一次的数据个数

    if (!this.SourceData.MergeMinuteData(aryMinuteData)) return;

    _umychartConsoleWechat.JSConsole.Chart.Log("[KLineChartContainer::RecvMinuteRealtimeDataV2] update kline by 1 minute data [".concat(lastDataCount, "->").concat(this.SourceData.Data.length, "]"));

    var bindData = new _umychartDataWechat.JSCommon_ChartData();
    bindData.Data = this.SourceData.Data;
    bindData.Period = this.Period;
    bindData.Right = this.Right;
    bindData.DataType = this.SourceData.DataType;
    bindData.Symbol = this.Symbol;

    if (bindData.Right > 0 && _umychartDataWechat.JSCommon_ChartData.IsDayPeriod(bindData.Period, true) && !this.IsApiPeriod) //复权(日线数据才复权)
      {
        var rightData = bindData.GetRightDate(bindData.Right);
        bindData.Data = rightData;
      }

    if ((_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(bindData.Period, false) || _umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(bindData.Period, false)) && !this.IsApiPeriod) //周期数据 (0= 日线,4=1分钟线 不需要处理)
      {
        var periodData = bindData.GetPeriodData(bindData.Period);
        bindData.Data = periodData;
      }

    //绑定数据
    this.UpdateMainData(bindData, lastDataCount);
    this.Frame.SetSizeChage(true);
    this.BindInstructionIndexData(bindData); //执行指示脚本

    for (var i = 0; i < this.Frame.SubFrame.length; ++i) {
      this.BindIndexData(i, bindData);
    }

    //刷新画图
    this.UpdataDataoffset(); //更新数据偏移
    this.UpdatePointByCursorIndex(); //更新十字光标位子
    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Frame.SetSizeChage(true);
    this.Draw();

    this.SendKLineUpdateEvent(bindData);
  };

  this.SendKLineUpdateEvent = function (bindData)
  {
    var event = this.GetEvent(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.RECV_KLINE_UPDATE_DATA);
    if (event && event.Callback)
    {
      var data = { HistoryData: bindData, Stock: { Symbol: this.Symbol, Name: this.Name } };
      event.Callback(event, data, this);
      return true;
    }

    return false;
  };

  //周期切换
  this.ChangePeriod = function (period, option)
  {
    var isChangeKLineDrawType = false;
    var right = null; //复权
    if (option && option.KLine)
    {
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(option.KLine.DrawType)) isChangeKLineDrawType = true;
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(option.KLine.Right)) right = option.KLine.Right;
    };

    if (this.Period == period)
    {
      if (isChangeKLineDrawType) this.ChangeKLineDrawType(option.KLine.DrawType);
      return;
    }

    if (isChangeKLineDrawType) this.ChangeKLineDrawType(option.KLine.DrawType, false); //切换K线类型, 不重绘

    var isDataTypeChange = true;
    if (this.SourceData)
    {
      var isDataTypeChange = false;
      if (period > _umychartDataWechat.JSCommon_CUSTOM_DAY_PERIOD_START && period <= _umychartDataWechat.JSCommon_CUSTOM_DAY_PERIOD_END)
      {
        if (this.SourceData.DataType != 0) isDataTypeChange = true;
      } else
      if (period > _umychartDataWechat.JSCommon_CUSTOM_MINUTE_PERIOD_START && period <= _umychartDataWechat.JSCommon_CUSTOM_MINUTE_PERIOD_END ||
      period > _umychartDataWechat.JSCommon_CUSTOM_SECOND_PERIOD_START && period <= _umychartDataWechat.JSCommon_CUSTOM_SECOND_PERIOD_END)
      {
        if (this.SourceData.DataType != 1) isDataTypeChange = true;
      } else

      {
        switch (period) {

          case 0: //日线
          case 1: //周
          case 2: //月
          case 3: //年
          case 21: //双周
            if (this.SourceData.DataType != 0) isDataTypeChange = true;
            break;
          case 4: //1分钟
          case 5: //5分钟
          case 6: //15分钟
          case 7: //30分钟
          case 8: //60分钟
          case 11: //2小时
          case 12: //4小时
            if (this.SourceData.DataType != 1) isDataTypeChange = true;
            break;}

      }
    }

    this.Period = period;
    if (right != null) this.Right = right;
    if (isDataTypeChange == false && !this.IsApiPeriod)
    {
      this.Update();
      return;
    }

    if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(this.Period, true))
    {
      this.CancelAutoUpdate(); //先停止更新
      this.AutoUpdateEvent(false);
      this.RequestHistoryData(); //请求日线数据
      //this.ReqeustKLineInfoData();
    } else
    if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(this.Period, true) || _umychartDataWechat.JSCommon_ChartData.IsSecondPeriod(this.Period))
    {
      this.CancelAutoUpdate(); //先停止更新
      this.AutoUpdateEvent(false);
      this.ReqeustHistoryMinuteData(); //请求分钟数据
    }
  };

  //复权切换
  this.ChangeRight = function (right)
  {
    if (IsIndexSymbol(this.Symbol)) return; //指数没有复权

    if (right < 0 || right > 2) return;

    if (this.Right == right) return;

    this.Right = right;

    if (!this.IsApiPeriod)
    {
      this.Update();
      return;
    } else

    {
      if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(this.Period, true))
      {
        this.CancelAutoUpdate(); //先停止更新
        this.AutoUpdateEvent(false);
        this.RequestHistoryData(); //请求日线数据
        //this.ReqeustKLineInfoData();
      } else
      if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(this.Period, true) || _umychartDataWechat.JSCommon_ChartData.IsSecondPeriod(this.Period))
      {
        this.CancelAutoUpdate(); //先停止更新
        this.AutoUpdateEvent(false);
        this.ReqeustHistoryMinuteData(); //请求分钟数据
      }
    }
  };

  //删除某一个窗口的指标
  this.DeleteIndexPaint = function (windowIndex) {
    var paint = new Array(); //踢出当前窗口的指标画法
    for (var i in this.ChartPaint) {
      var item = this.ChartPaint[i];

      if (i == 0 || item.ChartFrame != this.Frame.SubFrame[windowIndex].Frame)
      paint.push(item);
    }


    this.Frame.SubFrame[windowIndex].Frame.YSpecificMaxMin = null; //清空指定最大最小值
    this.Frame.SubFrame[windowIndex].Frame.IsLocked = false; //解除上锁
    this.Frame.SubFrame[windowIndex].Frame.YSplitScale = null; //清空固定刻度

    this.ChartPaint = paint;

    //清空东条标题
    var titleIndex = windowIndex + 1;
    this.TitlePaint[titleIndex].Data = [];
    this.TitlePaint[titleIndex].Title = null;
  };


  this.ShowKLine = function (isShow) //显示隐藏主图K线
  {
    if (this.ChartPaint.length <= 0 || !this.ChartPaint[0]) return;
    this.ChartPaint[0].IsShow = isShow;
  };

  this.SetInstructionData = function (type, instructionData) //设置指示数据
  {
    if (this.ChartPaint.length <= 0 || !this.ChartPaint[0]) return;
    if (type == 2) //五彩K线
      {
        this.ChartPaint[0].ColorData = instructionData.Data;
      } else
    if (type == 1) //专家指示
      {
        this.ChartPaint[0].TradeData = { Sell: instructionData.Sell, Buy: instructionData.Buy };
      }
  };

  this.ChangeInstructionIndex = function (indexName)
  {
    var scriptData = new _umychartIndexDataWechat.JSCommonIndexScript.JSIndexScript();
    var indexInfo = scriptData.Get(indexName);
    if (!indexInfo) return;
    if (indexInfo.InstructionType != 1 && indexInfo.InstructionType != 2) return;

    this.ChangeInstructionScriptIndex(indexInfo);

  };

  this.ChangeInstructionScriptIndex = function (indexData)
  {
    if (indexData.InstructionType == 1) //交易系统
      {
        this.TradeIndex = new _umychartIndexWechat.JSCommonIndex_ScriptIndex(indexData.Name, indexData.Script, indexData.Args, indexData); //脚本执行
      } else
    if (indexData.InstructionType == 2) //五彩K线
      {
        this.ColorIndex = new _umychartIndexWechat.JSCommonIndex_ScriptIndex(indexData.Name, indexData.Script, indexData.Args, indexData); //脚本执行
      } else

    {
      return;
    }

    var bindData = this.ChartPaint[0].Data;
    this.BindInstructionIndexData(bindData);

    this.UpdataDataoffset(); //更新数据偏移
    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Draw();
  };

  this.CancelInstructionIndex = function () //取消指示数据
  {
    if (this.ChartPaint.length <= 0 || !this.ChartPaint[0]) return;

    this.ColorIndex = null;
    this.TradeIndex = null;
    this.ChartPaint[0].ColorData = null; //五彩K线数据取消掉
    this.ChartPaint[0].TradeData = null; //交易系统数据取消

    this.UpdataDataoffset(); //更新数据偏移
    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Draw();
  };

  //切换成 脚本指标
  this.ChangeScriptIndex = function (windowIndex, indexData)
  {
    this.DeleteIndexPaint(windowIndex);
    this.WindowIndex[windowIndex] = new _umychartIndexWechat.JSCommonIndex_ScriptIndex(indexData.Name, indexData.Script, indexData.Args, indexData); //脚本执行

    var bindData = this.ChartPaint[0].Data;
    this.BindIndexData(windowIndex, bindData); //执行脚本

    this.UpdataDataoffset(); //更新数据偏移
    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Draw();
  };

  //切换api指标
  this.ChangeAPIIndex = function (windowIndex, indexData)
  {
    this.DeleteIndexPaint(windowIndex);
    //使用API挂接指标数据 API:{ Name:指标名字, Script:指标脚本可以为空, Args:参数可以为空, Url:指标执行地址 }
    var apiItem = indexData.API;
    this.WindowIndex[windowIndex] = new APIScriptIndex(apiItem.Name, apiItem.Script, apiItem.Args, indexData);

    var bindData = this.ChartPaint[0].Data;
    this.BindIndexData(windowIndex, bindData); //执行脚本

    this.UpdataDataoffset(); //更新数据偏移
    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Draw();
  };


  //切换指标 指定切换窗口指标
  this.ChangeIndex = function (windowIndex, indexName, option)
  {
    if (option && option.API) //切换api指标
      return this.ChangeAPIIndex(windowIndex, option);

    var indexItem = JSIndexMap.Get(indexName);
    if (!indexItem)
    {
      //查找系统指标
      var scriptData = new _umychartIndexDataWechat.JSCommonIndexScript.JSIndexScript();
      var indexInfo = scriptData.Get(indexName);
      if (!indexInfo) return;
      if (indexInfo.IsMainIndex)
      {
        windowIndex = 0; //主图指标只能在主图显示
      } else

      {
        if (windowIndex == 0) windowIndex = 1; //幅图指标,不能再主图显示
      }
      var indexData = indexInfo;
      if (option)
      {
        if (option.FloatPrecision >= 0) indexData.FloatPrecision = option.FloatPrecision;
        if (option.StringFormat > 0) indexData.StringFormat = option.StringFormat;
        if (option.Args) indexData.Args = option.Args;
      }

      return this.ChangeScriptIndex(windowIndex, indexData);
    }

    //主图指标
    if (indexItem.IsMainIndex)
    {
      if (windowIndex > 0) windowIndex = 0; //主图指标只能在主图显示
    } else

    {
      if (windowIndex == 0) windowIndex = 1; //幅图指标,不能再主图显示
    }

    var paint = new Array(); //踢出当前窗口的指标画法
    for (var i in this.ChartPaint)
    {
      var item = this.ChartPaint[i];
      if (i == 0 || item.ChartFrame != this.Frame.SubFrame[windowIndex].Frame) paint.push(item);
    }

    //清空指定最大最小值
    this.Frame.SubFrame[windowIndex].Frame.YSpecificMaxMin = null;
    this.Frame.SubFrame[windowIndex].Frame.YSplitScale = null;

    this.ChartPaint = paint;

    //清空东条标题
    var titleIndex = windowIndex + 1;
    this.TitlePaint[titleIndex].Data = [];
    this.TitlePaint[titleIndex].Title = null;

    this.WindowIndex[windowIndex] = indexItem.Create();
    this.CreateWindowIndex(windowIndex);

    var bindData = this.ChartPaint[0].Data;
    this.BindIndexData(windowIndex, bindData);

    this.UpdataDataoffset(); //更新数据偏移
    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Draw();
  };

  this.ChangeKLineDrawType = function (drawType, isDraw)
  {
    if (this.KLineDrawType == drawType) return;

    this.KLineDrawType = drawType;
    for (var i in this.ChartPaint)
    {
      var item = this.ChartPaint[i];
      if (i == 0) item.DrawType = this.KLineDrawType;else
      if (item.ClassName == 'ChartVolStick') item.KLineDrawType = this.KLineDrawType;
    }

    if (this.OverlayChartPaint[0]) this.OverlayChartPaint[0].DrawType = this.KLineDrawType; //叠加K线修改

    if (isDraw == false) return;

    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Frame.SetSizeChage(true);
    this.Draw();
  };

  //获取当天的显示的指标
  this.GetIndexInfo = function ()
  {
    var aryIndex = [];
    for (var i in this.WindowIndex)
    {
      var item = this.WindowIndex[i];
      var info = { Name: item.Name };
      if (item.ID) info.ID = item.ID;
      aryIndex.push(info);
    }

    return aryIndex;
  };

  this.ChangeIndexTemplate = function (option) //切换指标模板 可以设置指标窗口个数 每个窗口的指标
  {
    if (!option.Windows) return;
    var count = option.Windows.length;
    if (count <= 0) return;
    var currentLength = this.Frame.SubFrame.length;

    var period = null,right = null;
    if (option.KLine)
    {
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(option.KLine.Period) && option.KLine.Period != this.Period) period = option.KLine.Period; //周期
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(option.KLine.Right) && option.KLine.Right != this.Right) right = option.KLine.Right; //复权
    }

    var bRefreshData = period != null || right != null;

    //清空所有的指标图型
    for (var i = 0; i < currentLength; ++i)
    {
      this.DeleteIndexPaint(i);
      var frame = this.Frame.SubFrame[i];
      frame.YSpecificMaxMin = null;
      frame.IsLocked = false;
      frame.YSplitScale = null;
    }

    if (currentLength > count)
    {
      this.Frame.SubFrame.splice(count, currentLength - count);
      this.WindowIndex.splice(count, currentLength - count);
    } else

    {
      for (var i = currentLength; i < count; ++i) //创建新的指标窗口
      {
        var subFrame = this.CreateSubFrameItem(i);
        this.Frame.SubFrame[i] = subFrame;
        var titlePaint = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicChartTitlePainting();
        titlePaint.Frame = this.Frame.SubFrame[i].Frame;
        titlePaint.Canvas = this.Canvas;
        titlePaint.LanguageID = this.LanguageID;
        this.TitlePaint[i + 1] = titlePaint;
      }
    }

    var systemScript = new _umychartIndexDataWechat.JSCommonIndexScript.JSIndexScript();
    var bindData = this.ChartPaint[0].Data;
    for (var i = 0; i < count; ++i)
    {
      var windowIndex = i;
      var item = option.Windows[i];
      var frameItem = null;
      if (option.Frame && option.Frame.length > i) frameItem = option.Frame[i];
      var titleIndex = windowIndex + 1;
      this.TitlePaint[titleIndex].Data = [];
      this.TitlePaint[titleIndex].Title = null;

      if (item.Script) //自定义指标
        {
          this.WindowIndex[i] = new _umychartIndexWechat.JSCommonIndex_ScriptIndex(item.Name, item.Script, item.Args, item); //脚本执行
          if (!bRefreshData) this.BindIndexData(windowIndex, bindData); //执行脚本
        } else

      {
        var indexID = item.Index;
        var indexItem = JSIndexMap.Get(indexID);
        if (indexItem)
        {
          this.WindowIndex[i] = indexItem.Create();
          this.CreateWindowIndex(windowIndex);
          if (!bRefreshData) this.BindIndexData(windowIndex, bindData);
        } else

        {
          var indexInfo = systemScript.Get(indexID);
          if (indexInfo)
          {
            var args = indexInfo.Args;
            if (option.Windows[i].Args) args = option.Windows[i].Args;
            var indexData =
            {
              Name: indexInfo.Name, Script: indexInfo.Script, Args: args, ID: indexID,
              //扩展属性 可以是空
              KLineType: indexInfo.KLineType, YSpecificMaxMin: indexInfo.YSpecificMaxMin, YSplitScale: indexInfo.YSplitScale,
              FloatPrecision: indexInfo.FloatPrecision, Condition: indexInfo.Condition,
              OutName: indexInfo.OutName };


            this.WindowIndex[i] = new _umychartIndexWechat.JSCommonIndex_ScriptIndex(indexData.Name, indexData.Script, indexData.Args, indexData); //脚本执行
            if (!bRefreshData) this.BindIndexData(windowIndex, bindData); //执行脚本
          }
        }
      }

      if (item.IndexParamSpace >= 0) this.Frame.SubFrame[i].Frame.IndexParamSpace = item.IndexParamSpace;
      if (item.IsDrawTitleBG == true) this.Frame.SubFrame[i].Frame.IsDrawTitleBG = item.IsDrawTitleBG;

      if (frameItem)
      {
        if (frameItem.SplitCount) this.Frame.SubFrame[i].Frame.YSplitOperator.SplitCount = frameItem.SplitCount;
        if (frameItem.IsShowBorder == false) this.Frame.SubFrame[i].Frame.IsShowBorder = frameItem.IsShowBorder;
        if (frameItem.IsShowXLine === false || frameItem.IsShowXLine === true) this.Frame.SubFrame[i].Frame.IsShowXLine = frameItem.IsShowXLine;
        if (frameItem.IsShowYLine === false || frameItem.IsShowYLine === true) this.Frame.SubFrame[i].Frame.IsShowYLine = frameItem.IsShowYLine;

        if (frameItem.IsShowLeftText === false || item.IsShowLeftText === true) this.Frame.SubFrame[i].Frame.IsShowYText[0] = frameItem.IsShowLeftText; //显示左边刻度
        if (frameItem.IsShowRightText === false || item.IsShowRightText === true) this.Frame.SubFrame[i].Frame.IsShowYText[1] = frameItem.IsShowRightText; //显示右边刻度 
      }
    }

    //最后一个显示X轴坐标
    for (var i = 0; i < this.Frame.SubFrame.length; ++i)
    {
      var item = this.Frame.SubFrame[i].Frame;
      if (i == this.Frame.SubFrame.length - 1) item.XSplitOperator.ShowText = true;else
      item.XSplitOperator.ShowText = false;
    }

    if (!bRefreshData)
    {
      this.UpdataDataoffset(); //更新数据偏移
      this.Frame.SetSizeChage(true);
      this.ResetFrameXYSplit();
      this.UpdateFrameMaxMin(); //调整坐标最大 最小值
      this.Draw();
    } else

    {
      this.Frame.SetSizeChage(true);
      if (period != null) this.ChangePeriod(period, option);else
      if (right != null) this.ChangeRight(right);
    }
  };

  this.RemoveIndexWindow = function (id)
  {
    _umychartConsoleWechat.JSConsole.Chart.Log('[KLineChartContainer::RemoveIndexWindow] remove id', id);
    if (id == 0) return;
    if (!this.Frame.SubFrame) return;
    if (id >= this.Frame.SubFrame.length) return;

    var delFrame = this.Frame.SubFrame[id].Frame;
    this.DeleteIndexPaint(id);
    this.Frame.SubFrame.splice(id, 1);
    this.WindowIndex.splice(id, 1);
    this.TitlePaint.splice(id + 1, 1); //删除对应的动态标题

    for (var i = 0; i < this.Frame.SubFrame.length; ++i)
    {
      var item = this.Frame.SubFrame[i].Frame;
      if (i == this.Frame.SubFrame.length - 1) item.XSplitOperator.ShowText = true;else
      item.XSplitOperator.ShowText = false;

      item.Identify = i;
    }

    if (this.ChartDrawPicture.length > 0)
    {
      var aryDrawPicture = [];
      for (var i = 0; i < this.ChartDrawPicture.length; ++i)
      {
        var item = this.ChartDrawPicture[i];
        if (item.Frame == delFrame) continue;
        aryDrawPicture.push(item);
      }
      this.ChartDrawPicture = aryDrawPicture;
    }

    this.Frame.SetSizeChage(true);
    this.UpdateFrameMaxMin();
    this.ResetFrameXYSplit();
    this.Draw();
  };

  this.CreateExtendChart = function (name, option) //创建扩展图形
  {
    var chart;
    switch (name) {

      case 'KLineTooltip':
        if (option.Create && typeof option.Create == 'function') chart = option.Create();else
        chart = new _umychartExtendchartWechat.JSCommonExtendChartPaint_KLineTooltipPaint();
        chart.Canvas = this.Canvas;
        chart.ChartBorder = this.Frame.ChartBorder;
        chart.ChartFrame = this.Frame;
        chart.HQChart = this;
        option.LanguageID = this.LanguageID;
        chart.SetOption(option);
        this.ExtendChartPaint.push(chart);
        return chart;
      case '背景图':
        chart = new _umychartExtendchartWechat.JSCommonExtendChartPaint_BackgroundPaint();
        chart.Canvas = this.Canvas;
        chart.ChartBorder = this.Frame.ChartBorder;
        chart.ChartFrame = this.Frame;
        chart.HQChart = this;
        chart.SetOption(option);
        this.ExtendChartPaint.push(chart);
        return chart;
      default:
        return null;}

  };

  //锁|解锁指标 { Index:指标名字,IsLocked:是否要锁上,Callback:回调 }
  this.LockIndex = function (lockData) {
    if (!lockData) return;
    if (!lockData.IndexName) return;

    for (var i in this.WindowIndex) {
      var item = this.WindowIndex[i];
      if (!item) conintue;
      if (item.Name == lockData.IndexName) {
        item.SetLock(lockData);
        this.Update();
        break;
      }
    }
  };

  this.TryClickLock = function (x, y)
  {
    for (var i in this.Frame.SubFrame)
    {
      var item = this.Frame.SubFrame[i];
      if (!item.Frame.IsLocked) continue;
      if (!item.Frame.LockPaint) continue;

      var tooltip = new TooltipData();
      if (!item.Frame.LockPaint.GetTooltipData(x, y, tooltip)) continue;

      tooltip.HQChart = this;
      if (tooltip.Data.Callback) tooltip.Data.Callback(tooltip);
      return true;
    }
    return false;
  };

  this.TryClickIndexTitle = function (x, y)
  {
    for (var i in this.TitlePaint)
    {
      var item = this.TitlePaint[i];
      if (!item.IsClickTitle) continue;
      if (!item.IsClickTitle(x, y)) continue;

      var data = { Point: { X: x, Y: y }, Title: item.Title, FrameID: item.Frame.Identify };
      _umychartConsoleWechat.JSConsole.Chart.Log('[KLineChartContainer::TryClickIndexTitle] click title ', data);

      var event = this.GetEvent(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.ON_CLICK_INDEXTITLE);
      if (event && event.Callback) event.Callback(event, data, this);

      return true;
    }

    return false;
  };

  this.StopAutoUpdate = function ()
  {
    this.IsAutoUpdate = false;
    this.CancelAutoUpdate();
    this.AutoUpdateEvent(false);
  };

  this.Update = function ()
  {
    if (!this.SourceData) return;
    if (this.BeforeBindMainData) this.BeforeBindMainData('Update');

    var bindData = new _umychartDataWechat.JSCommon_ChartData();
    bindData.Data = this.SourceData.Data;
    bindData.Period = this.Period;
    bindData.Right = this.Right;
    bindData.DataType = this.SourceData.DataType;
    bindData.Symbol = this.Symbol;

    if (bindData.Right > 0 && _umychartDataWechat.JSCommon_ChartData.IsDayPeriod(bindData.Period, true)) //复权(日线数据才复权)
      {
        var rightData = bindData.GetRightDate(bindData.Right);
        bindData.Data = rightData;
      }

    if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(bindData.Period, false) || _umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(bindData.Period, false)) //周期数据 (0= 日线,4=1分钟线 不需要处理))
      {
        var periodData = bindData.GetPeriodData(bindData.Period);
        bindData.Data = periodData;
      }

    //绑定数据
    this.BindMainData(bindData, this.PageSize);
    if (this.AfterBindMainData) this.AfterBindMainData("Update");

    for (var i = 0; i < this.Frame.SubFrame.length; ++i) {
      this.BindIndexData(i, bindData);
    }

    //叠加数据周期调整
    if (this.OverlayChartPaint[0].SourceData)
    {
      if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(this.Period, true)) //分钟不支持 清空掉
        {
          this.OverlayChartPaint[0].Data = null;
        } else

      {
        var bindData = new _umychartDataWechat.JSCommon_ChartData();
        bindData.Data = this.OverlayChartPaint[0].SourceData.Data;
        bindData.Period = this.Period;
        bindData.Right = this.Right;

        if (bindData.Right > 0 && !IsIndexSymbol(this.OverlayChartPaint[0].Symbol)) //复权数据
          {
            var rightData = bindData.GetRightDate(bindData.Right);
            bindData.Data = rightData;
          }

        var aryOverlayData = this.SourceData.GetOverlayData(bindData.Data); //和主图数据拟合以后的数据
        bindData.Data = aryOverlayData;

        if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(bindData.Period, false)) //周期数据
          {
            var periodData = bindData.GetPeriodData(bindData.Period);
            bindData.Data = periodData;
          }

        this.OverlayChartPaint[0].Data = bindData;
      }
    }

    this.ReqeustKLineInfoData();

    //刷新画图
    this.UpdataDataoffset(); //更新数据偏移
    this.UpdatePointByCursorIndex(); //更新十字光标位子
    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Frame.SetSizeChage(true);
    this.Draw();
  };

  //切换股票代码
  this.ChangeSymbol = function (symbol)
  {
    this.CancelAutoUpdate(); //先停止更新
    this.AutoUpdateEvent(false);
    this.Symbol = symbol;
    if (IsIndexSymbol(symbol)) this.Right = 0; //指数没有复权

    if (this.Frame && this.Frame.SubFrame) //清空指标
      {
        for (var i = 0; i < this.Frame.SubFrame.length; ++i) {
          this.DeleteIndexPaint(i);}
      }

    if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(this.Period, true))
    {
      this.RequestHistoryData(); //请求日线数据
      //this.ReqeustKLineInfoData();
    } else
    if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(this.Period, true) || _umychartDataWechat.JSCommon_ChartData.IsSecondPeriod(this.Period))
    {
      this.ReqeustHistoryMinuteData(); //请求分钟数据
    }
  };

  this.ReqeustKLineInfoData = function ()
  {
    if (this.ChartPaint.length > 0)
    {
      var klinePaint = this.ChartPaint[0];
      klinePaint.InfoData = new Map();
    }

    //信息地雷信息
    for (var i in this.ChartInfo)
    {
      this.ChartInfo[i].RequestData(this);
    }
  };

  //设置K线信息地雷
  this.SetKLineInfo = function (aryInfo, bUpdate)
  {
    this.ChartInfo = []; //清空信息地雷
    for (var i in aryInfo)
    {
      var infoItem = _umychartKlineinfoWechat.JSCommon_JSKLineInfoMap.Get(aryInfo[i]);
      if (!infoItem) continue;
      var item = infoItem.Create();
      item.MaxReqeustDataCount = this.MaxReqeustDataCount;
      this.ChartInfo.push(item);
    }

    if (bUpdate == true) this.ReqeustKLineInfoData();
  };

  this.SetPolicyInfo = function (aryPolicy, bUpdate)
  {
    if (!aryPolicy || !aryPolicy.length) return;
    var infoItem = _umychartKlineinfoWechat.JSCommon_JSKLineInfoMap.Get('策略选股');
    if (!infoItem) return;
    var policyInfo = infoItem.Create();
    policyInfo.SetPolicyList(aryPolicy);
    policyInfo.MaxReqeustDataCount = this.MaxReqeustDataCount;
    this.ChartInfo.push(policyInfo);

    if (bUpdate == true) this.ReqeustKLineInfoData();
  };

  //叠加股票
  this.OverlaySymbol = function (symbol, option)
  {
    var paint = this.OverlayChartPaint[0];
    if (!paint.MainData) return false;

    paint.Symbol = symbol;
    if (option)
    {
      if (paint.Color) paint.Color = option.Color;
    }
    if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(this.Period, true)) this.RequestOverlayHistoryData(); //请求日线数据

    return true;
  };

  this.GetRequestDataCount = function () //K线请求数据个数　(由于可以拖拽下载历史数据,所有原来固定个数的就不能用了)
  {
    var result = { MaxRequestDataCount: this.MaxReqeustDataCount, MaxRequestMinuteDayCount: this.MaxRequestMinuteDayCount };

    if (!this.SourceData || !this.SourceData.Data || this.SourceData.Data.length <= 0) return result;

    if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(this.Period, true))
    {
      var lCount = this.SourceData.Data.length;
      if (lCount > result.MaxRequestDataCount) result.MaxRequestDataCount = lCount;
    } else
    if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(this.Period, true))
    {

    }

    return result;
  };

  this.RequestOverlayHistoryData = function ()
  {
    if (!this.OverlayChartPaint.length) return;

    var symbol = this.OverlayChartPaint[0].Symbol;
    if (!symbol) return;

    var self = this;
    var dataCount = this.GetRequestDataCount();
    var firstDate = this.SourceData.Data[0].Date;
    if (this.NetworkFilter)
    {
      var obj =
      {
        Name: 'KLineChartContainer::RequestOverlayHistoryData', //类名::
        Explain: '叠加股票日K线数据',
        Request: {
          Url: self.KLineApiUrl, Data: {
            symbol: symbol, count: dataCount.MaxRequestDataCount, "first": { date: firstDate },
            field: ["name", "symbol", "yclose", "open", "price", "high", 'vol', 'amount'] },
          Type: 'POST' },

        Self: this,
        PreventDefault: false };

      this.NetworkFilter(obj, function (data) {
        self.RecvOverlayHistoryData(data);
      });

      if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求
    }

    //请求数据
    wx.request({
      url: this.KLineApiUrl,
      data:
      {
        "field": ["name", "symbol", "yclose", "open", "price", "high"],
        "symbol": symbol,
        "start": -1,
        "count": this.MaxReqeustDataCount },

      method: 'POST',
      dataType: "json",
      async: true,
      success: function success(data) {
        self.RecvOverlayHistoryData(data);
      } });

  };

  this.RecvOverlayHistoryData = function (recvData)
  {
    var data = recvData.data;
    var aryDayData = KLineChartContainer.JsonDataToHistoryData(data);

    //原始叠加数据
    var sourceData = new _umychartDataWechat.JSCommon_ChartData();
    sourceData.Data = aryDayData;

    var bindData = new _umychartDataWechat.JSCommon_ChartData();
    bindData.Data = aryDayData;
    bindData.Period = this.Period;
    bindData.Right = this.Right;

    if (bindData.Right > 0 && !IsIndexSymbol(data.symbol)) //复权数据 ,指数没有复权)
      {
        var rightData = bindData.GetRightDate(bindData.Right);
        bindData.Data = rightData;
      }

    var aryOverlayData = this.SourceData.GetOverlayData(bindData.Data); //和主图数据拟合以后的数据
    bindData.Data = aryOverlayData;

    if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(bindData.Period, false)) //周期数据
      {
        var periodData = bindData.GetPeriodData(bindData.Period);
        bindData.Data = periodData;
      }

    this.OverlayChartPaint[0].Data = bindData;
    this.OverlayChartPaint[0].SourceData = sourceData;
    this.OverlayChartPaint[0].Title = data.name;
    this.OverlayChartPaint[0].Symbol = data.symbol;
    this.Frame.SubFrame[0].Frame.YSplitOperator.CoordinateType = 1; //调整为百份比坐标

    this.UpdataDataoffset(); //更新数据偏移
    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Frame.SetSizeChage(true);
    this.Draw();
  };

  //取消叠加股票
  this.ClearOverlaySymbol = function ()
  {
    this.OverlayChartPaint[0].Symbol = null;
    this.OverlayChartPaint[0].Data = null;
    this.OverlayChartPaint[0].SourceData = null;
    this.OverlayChartPaint[0].TooltipRect = [];
    this.Frame.SubFrame[0].Frame.YSplitOperator.CoordinateType = 0; //调整一般坐标

    this.UpdateFrameMaxMin();
    this.Draw();
  };

  //创建画图工具
  this.CreateChartDrawPicture = function (name) {
    return false;
  };

  this.SetChartDrawPictureFirstPoint = function (x, y) {
    var drawPicture = this.CurrentChartDrawPicture;
    if (!drawPicture) return false;
    if (!this.Frame.SubFrame || this.Frame.SubFrame.length <= 0) return false;

    for (var i in this.Frame.SubFrame) {
      var frame = this.Frame.SubFrame[i].Frame;
      var left = frame.ChartBorder.GetLeft();
      var top = frame.ChartBorder.GetTopEx();
      var height = frame.ChartBorder.GetHeight();
      var width = frame.ChartBorder.GetWidth();

      this.Canvas.rect(left, top, width, height);
      if (this.Canvas.isPointInPath(x, y)) {
        drawPicture.Frame = frame;
        break;
      }
    }

    if (!drawPicture.Frame) return false;

    drawPicture.Point[0] = new Point();
    drawPicture.Point[0].X = x - this.UIElement.getBoundingClientRect().left;
    drawPicture.Point[0].Y = y - this.UIElement.getBoundingClientRect().top;
    drawPicture.Status = 1; //第1个点完成
  };

  this.SetChartDrawPictureSecondPoint = function (x, y) {
    var drawPicture = this.CurrentChartDrawPicture;
    if (!drawPicture) return false;

    drawPicture.Point[1] = new Point();
    drawPicture.Point[1].X = x - this.UIElement.getBoundingClientRect().left;
    drawPicture.Point[1].Y = y - this.UIElement.getBoundingClientRect().top;

    drawPicture.Status = 2; //设置第2个点
  };

  //xStep,yStep 移动的偏移量
  this.MoveChartDrawPicture = function (xStep, yStep) {
    var drawPicture = this.CurrentChartDrawPicture;
    if (!drawPicture) return false;

    //JSConsole.Chart.Log("xStep="+xStep+" yStep="+yStep);
    drawPicture.Move(xStep, yStep);

    return true;
  };

  this.FinishChartDrawPicturePoint = function () {
    var drawPicture = this.CurrentChartDrawPicture;
    if (!drawPicture) return false;
    if (drawPicture.PointCount != drawPicture.Point.length) return false;

    drawPicture.Status = 10; //完成
    drawPicture.PointToValue();

    this.ChartDrawPicture.push(drawPicture);
    this.CurrentChartDrawPicture = null;

    return true;
  };

  this.FinishMoveChartDrawPicture = function () {
    var drawPicture = this.CurrentChartDrawPicture;
    if (!drawPicture) return false;
    if (drawPicture.PointCount != drawPicture.Point.length) return false;

    drawPicture.Status = 10; //完成
    drawPicture.PointToValue();

    this.CurrentChartDrawPicture = null;
    return true;
  };

  //清空所有的画线工具
  this.ClearChartDrawPicture = function (drawPicture) {
    if (!drawPicture) {
      this.ChartDrawPicture = [];
      this.Draw();
    } else
    {
      for (var i in this.ChartDrawPicture) {
        if (this.ChartDrawPicture[i] == drawPicture) {
          this.ChartDrawPicture.splice(i, 1);
          this.Draw();
        }
      }
    }
  };

  //更新信息地雷
  this.UpdataChartInfo = function ()
  {
    //TODO: 根据K线数据日期来做map, 不在K线上的合并到下一个k线日期里面
    var mapInfoData = new Map();
    if (this.Period == 0) //日线数据 根据日期
      {
        for (var i in this.ChartInfo)
        {
          var infoData = this.ChartInfo[i].Data;
          for (var j in infoData)
          {
            var item = infoData[j];
            if (mapInfoData.has(item.Date.toString()))
            mapInfoData.get(item.Date.toString()).Data.push(item);else

            mapInfoData.set(item.Date.toString(), { Data: new Array(item) });
          }
        }
      } else
    if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(this.Period, false))
    {
      mapInfoData = new Map();
      var hisData = this.ChartPaint[0].Data;
      if (hisData && hisData.Data && hisData.Data.length > 0)
      {
        var fristKItem = hisData.Data[0];
        var aryInfo = [];
        for (var i in this.ChartInfo)
        {
          var infoItem = this.ChartInfo[i];
          for (var j in infoItem.Data)
          {
            var item = infoItem.Data[j];
            if (item.Date >= fristKItem.Date) //在K线范围内的才显示
              aryInfo.push(item);
          }
        }
        aryInfo.sort(function (a, b) {return a.Date - b.Date;}); //排序

        for (var i = 0; i < hisData.Data.length;)
        {
          var kItem = hisData.Data[i]; //K线数据
          if (aryInfo.length <= 0) break;

          var infoItem = aryInfo[0];
          if (kItem.Date < infoItem.Date)
          {
            ++i;
            continue;
          }

          //信息地雷日期<K线上的日期 就是属于这个K线上的
          if (mapInfoData.has(kItem.Date.toString()))
          mapInfoData.get(kItem.Date.toString()).Data.push(infoItem);else

          mapInfoData.set(kItem.Date.toString(), { Data: new Array(infoItem) });

          aryInfo.shift();
          //JSConsole.Chart.Log('[KLineChartContainer::UpdataChartInfo]',item);
        }
      }
    }

    var klinePaint = this.ChartPaint[0];
    klinePaint.InfoData = mapInfoData;
    var titlePaint = this.TitlePaint[0];
    if (titlePaint) titlePaint.InfoData = mapInfoData;
  };

  //更新窗口指标
  this.UpdateWindowIndex = function (index)
  {
    var bindData = new _umychartDataWechat.JSCommon_ChartData();
    bindData.Data = this.SourceData.Data;
    bindData.Period = this.Period;
    bindData.Right = this.Right;

    if (this.IsApiPeriod)
    {

    } else

    {
      if (bindData.Right > 0) //复权
        {
          var rightData = bindData.GetRightDate(bindData.Right);
          bindData.Data = rightData;
        }

      if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(bindData.Period, false) || _umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(bindData.Period, false)) //周期数据
        {
          var periodData = bindData.GetPeriodData(bindData.Period);
          bindData.Data = periodData;
        }
    }

    this.WindowIndex[index].BindData(this, index, bindData);

    this.UpdataDataoffset(); //更新数据偏移
    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Draw();
  };

  //修改参数指标
  this.ChangeWindowIndexParam = function (index) {
    this.WindowIndex[index].Index[0].Param += 1;
    this.WindowIndex[index].Index[1].Param += 1;

    this.UpdateWindowIndex(index);
  };

  this.OnDoubleClick = function (x, y, e)
  {
    var tooltip = new TooltipData();
    for (var i in this.ChartPaint)
    {
      var item = this.ChartPaint[i];
      if (item.GetTooltipData(x, y, tooltip))
      break;
    }

    if (!tooltip.Data) return;
    e.data = { Chart: this, Tooltip: tooltip };
  };

  this.CancelAutoUpdate = function () //关闭停止更新
  {
    if (typeof this.AutoUpdateTimer == 'number')
    {
      clearTimeout(this.AutoUpdateTimer);
      this.AutoUpdateTimer = undefined;
    }
  };

  //数据自动更新
  this.AutoUpdate = function (waitTime) //waitTime 更新时间
  {
    this.CancelAutoUpdate();
    if (!this.IsAutoUpdate) return;
    if (!this.Symbol) return;
    if (this.IsDestroy) return;

    var self = this;
    var marketStatus = _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.GetMarketStatus(this.Symbol);
    if (marketStatus == 0 || marketStatus == 3) return; //闭市,盘后

    var frequency = this.AutoUpdateFrequency;
    if (marketStatus == 1) //盘前
      {
        this.AutoUpdateTimer = setTimeout(function () {self.AutoUpdate();}, frequency);
      } else
    if (marketStatus == 2) //盘中
      {
        this.AutoUpdateTimer = setTimeout(function ()
        {
          if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(self.Period, true))
          {
            self.RequestRealtimeData(); //更新最新行情
            //self.ReqeustKLineInfoData();
          } else
          if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(self.Period, true) || _umychartDataWechat.JSCommon_ChartData.IsSecondPeriod(self.Period))
          {
            self.RequestMinuteRealtimeData(); //请求分钟数据
          }
        }, frequency);
      }
  };

  this.GetMaxPageSize = function ()
  {
    var width = this.Frame.ChartBorder.GetWidth();
    var barWidth = ZOOM_SEED[ZOOM_SEED.length - 1][0] + ZOOM_SEED[ZOOM_SEED.length - 1][1];
    var pageSize = parseInt(width / barWidth) - 8;
    _umychartConsoleWechat.JSConsole.Chart.Log("[KLineChartContainer::GetMaxPageSize] width=".concat(width, " barWidth=").concat(barWidth, " pageSize=").concat(pageSize));
    return pageSize;
  };

  //数据拖拽下载
  this.DragDownloadData = function ()
  {
    var data = null;
    if (!this.Frame.Data) data = this.Frame.Data;else
    data = this.Frame.SubFrame[0].Frame.Data;
    if (!data) return false;
    if (data.DataOffset > 0) return;

    if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(this.Period, true)) //下载分钟数据
      {
        _umychartConsoleWechat.JSConsole.Chart.Log("[KLineChartContainer.DragDownloadData] Minute:[Enable=".concat(this.DragDownload.Minute.Enable, ", IsEnd=").concat(this.DragDownload.Minute.IsEnd, ", Status=").concat(this.DragDownload.Minute.Status, "]"));
        if (!this.DragDownload.Minute.Enable) return;
        if (this.DragDownload.Minute.IsEnd) return; //全部下载完了
        if (this.DragDownload.Minute.Status != 0) return;
        this.RequestDragMinuteData();
      } else
    if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(this.Period, true)) // 下载日线
      {
        _umychartConsoleWechat.JSConsole.Chart.Log("[KLineChartContainer.DragDownloadData] Day:[Enable=".concat(this.DragDownload.Minute.Enable, ", IsEnd=").concat(this.DragDownload.Minute.IsEnd, ", Status=").concat(this.DragDownload.Minute.Status, "]"));
        if (!this.DragDownload.Day.Enable) return;
        if (this.DragDownload.Day.IsEnd) return; //全部下载完了
        if (this.DragDownload.Day.Status != 0) return;
        this.RequestDragDayData();
      }
  };

  this.RequestDragMinuteData = function ()
  {
    var self = this;
    this.AutoUpdateEvent(false, 'KLineChartContainer::RequestDragMinuteData'); //停止自动更新
    this.CancelAutoUpdate();
    var download = this.DragDownload.Minute;
    download.Status = 1;
    var firstItem = this.SourceData.Data[0]; //最新的一条数据
    var postData =
    {
      "field": ["name", "symbol", "yclose", "open", "price", "high", "low", "vol"],
      "symbol": self.Symbol,
      "enddate": firstItem.Date,
      "endtime": firstItem.Time,
      "count": self.MaxRequestMinuteDayCount,
      "first": { date: firstItem.Date, time: firstItem.Time } };


    if (this.NetworkFilter) {
      var obj =
      {
        Name: 'KLineChartContainer::RequestDragMinuteData', //类名::函数
        Explain: '拖拽1分钟K线数据下载',
        Request: { Url: this.DragMinuteKLineApiUrl, Type: 'POST', Data: postData, Period: this.Period },
        DragDownload: download,
        Self: this,
        PreventDefault: false };

      this.NetworkFilter(obj, function (data) {
        self.RecvDragMinuteData(data);
        download.Status = 0;
        self.AutoUpdateEvent(true, 'KLineChartContainer::RequestDragMinuteData'); //自动更新
        self.AutoUpdate();
      });

      if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求
    }

    wx.request({
      url: this.DragMinuteKLineApiUrl,
      data: postData,
      method: 'POST',
      dataType: "json",
      async: true,
      success: function success(data) {
        self.RecvDragMinuteData(data);
        download.Status = 0;
        self.AutoUpdateEvent(true, 'KLineChartContainer::RequestDragMinuteData'); //自动更新
        self.AutoUpdate();
      } });

  };

  this.RecvDragMinuteData = function (recvdata)
  {
    var data = recvdata.data;
    var aryDayData = KLineChartContainer.JsonDataToMinuteHistoryData(data);
    var lastDataCount = this.GetHistoryDataCount(); //保存下上一次的数据个数

    for (var i in aryDayData) //数据往前插
    {
      var item = aryDayData[i];
      this.SourceData.Data.splice(i, 0, item);
    }

    var bindData = new _umychartDataWechat.JSCommon_ChartData();
    bindData.Data = this.SourceData.Data;
    bindData.Period = this.Period;
    bindData.Right = this.Right;
    bindData.DataType = this.SourceData.DataType;
    bindData.Symbol = this.Symbol;

    if (!this.IsApiPeriod)
    {
      if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(bindData.Period, false) || _umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(bindData.Period, false)) //周期数据 (0= 日线,4=1分钟线 不需要处理)
        {
          var periodData = bindData.GetPeriodData(bindData.Period);
          bindData.Data = periodData;
        }
    }

    //绑定数据
    this.UpdateMainData(bindData, lastDataCount);
    this.BindInstructionIndexData(bindData); //执行指示脚本

    for (var i = 0; i < this.Frame.SubFrame.length; ++i)
    {
      this.BindIndexData(i, bindData);
    }

    //刷新画图
    this.UpdataDataoffset(); //更新数据偏移
    this.UpdatePointByCursorIndex(); //更新十字光标位子
    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Frame.SetSizeChage(true);
    this.Draw();
  };

  this.RequestDragDayData = function ()
  {
    var self = this;
    this.AutoUpdateEvent(false, 'KLineChartContainer::RequestDragDayData'); //停止自动更新
    this.CancelAutoUpdate();
    var download = this.DragDownload.Day;
    download.Status = 1;
    var firstItem = this.SourceData.Data[0]; //最新的一条数据
    var postData =
    {
      "field": ["name", "symbol", "yclose", "open", "price", "high", "low", "vol"],
      "symbol": self.Symbol,
      "enddate": firstItem.Date,
      "count": self.MaxReqeustDataCount,
      "first": { date: firstItem.Date } };


    if (this.NetworkFilter) {
      var obj =
      {
        Name: 'KLineChartContainer::RequestDragDayData', //类名::函数
        Explain: '拖拽日K数据下载',
        Request: { Url: this.DragKLineApiUrl, Type: 'POST', Data: postData, Period: this.Period, Right: this.Right },
        DragDownload: download,
        Self: this,
        PreventDefault: false };

      this.NetworkFilter(obj, function (data) {
        self.RecvDragDayData(data);
        download.Status = 0;
        self.AutoUpdateEvent(true, 'KLineChartContainer::RequestDragDayData'); //自动更新
        self.AutoUpdate();
      });

      if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求
    }

    wx.request({
      url: this.DragKLineApiUrl,
      data: postData,
      method: 'POST',
      dataType: "json",
      async: true,
      success: function success(data) {
        self.RecvDragDayData(data);
        download.Status = 0;
        self.AutoUpdateEvent(true, 'KLineChartContainer::RequestDragDayData'); //自动更新
        self.AutoUpdate();
      } });

  };

  this.RecvDragDayData = function (recvdata)
  {
    var data = recvdata.data;
    var aryDayData = KLineChartContainer.JsonDataToHistoryData(data);
    if (!aryDayData || aryDayData.length <= 0)
    {
      this.DragDownload.Day.IsEnd = true; //下完了
      return;
    }

    var lastDataCount = this.GetHistoryDataCount(); //保存下上一次的数据个数

    for (var i in aryDayData) //数据往前插
    {
      var item = aryDayData[i];
      this.SourceData.Data.splice(i, 0, item);
    }

    var bindData = new _umychartDataWechat.JSCommon_ChartData();
    bindData.Data = this.SourceData.Data;
    bindData.Period = this.Period;
    bindData.Right = this.Right;
    bindData.DataType = this.SourceData.DataType;
    bindData.Symbol = this.Symbol;

    if (!this.IsApiPeriod)
    {
      if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(bindData.Period, false) || _umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(bindData.Period, false)) //周期数据 (0= 日线,4=1分钟线 不需要处理)
        {
          var periodData = bindData.GetPeriodData(bindData.Period);
          bindData.Data = periodData;
        }
    }

    //绑定数据
    this.UpdateMainData(bindData, lastDataCount);
    this.BindInstructionIndexData(bindData); //执行指示脚本

    for (var i = 0; i < this.Frame.SubFrame.length; ++i)
    {
      this.BindIndexData(i, bindData);
    }

    //刷新画图
    this.UpdataDataoffset(); //更新数据偏移
    this.UpdatePointByCursorIndex(); //更新十字光标位子
    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Frame.SetSizeChage(true);
    this.Draw();
  };

  this.SetCustomVerical = function (windowId, data)
  {
    if (!this.Frame) return;
    if (windowId >= this.Frame.SubFrame.length) return;

    var item = this.Frame.SubFrame[windowId];
    if (item.Frame) item.Frame.CustomVerticalInfo = data;
  };

  this.OnSize = function ()
  {
    if (!this.Frame) return;
    if (!this.Frame.OnSize) return;

    var obj = this.Frame.OnSize();
    this.Frame.SetSizeChage(true);
    if (obj.Changed)
    {
      this.UpdataDataoffset();
      this.UpdatePointByCursorIndex();
      this.UpdateFrameMaxMin();
    }

    this.Draw();
  };
}

//API 返回数据 转化为array[]
KLineChartContainer.JsonDataToHistoryData = function (data)
{
  var list = data.data;
  var aryDayData = new Array();
  if (!list) return aryDayData;

  var upperSymbol = null;
  if (data.symbol) upperSymbol = data.symbol.toUpperCase();
  var isFutures = false; //是否是期货
  isFutures = _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsChinaFutures(upperSymbol);

  var date = 0,yclose = 1,open = 2,high = 3,low = 4,close = 5,vol = 6,amount = 7,position = 8;
  for (var i = 0; i < list.length; ++i)
  {
    var item = new _umychartDataWechat.JSCommon_HistoryData();
    var jsData = list[i];
    item.Date = jsData[date];
    item.Open = jsData[open];
    item.YClose = jsData[yclose];
    item.Close = jsData[close];
    item.High = jsData[high];
    item.Low = jsData[low];
    item.Vol = jsData[vol]; //原始单位股
    item.Amount = jsData[amount];
    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(jsData[position])) item.Position = jsData[position]; //期货持仓

    if (!_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Open)) continue;

    aryDayData.push(item);
  }

  return aryDayData;
};

KLineChartContainer.JsonDataToRealtimeData = function (data)
{
  var symbol = data.stock[0].symbol;
  var upperSymbol = symbol.toUpperCase();
  var isSHSZ = _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol);

  var item = new _umychartDataWechat.JSCommon_HistoryData();
  item.Date = data.stock[0].date;
  item.Open = data.stock[0].open;
  item.YClose = data.stock[0].yclose;
  item.High = data.stock[0].high;
  item.Low = data.stock[0].low;
  item.Vol = data.stock[0].vol; //单位股
  item.Amount = data.stock[0].amount;
  item.Close = data.stock[0].price;
  if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(data.stock[0].position)) item.Position = data.stock[0].position; //持仓量
  return item;
};

KLineChartContainer.JsonDataToMinuteRealtimeData = function (data)
{
  var symbol = data.stock[0].symbol;
  var upperSymbol = symbol.toUpperCase();
  var isSHSZ = _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol);
  var isFutures = _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsChinaFutures(upperSymbol);
  var aryMinuteData = new Array();
  var preClose = data.stock[0].yclose; //前一个数据价格
  var date = data.stock[0].date;
  if (isFutures && data.stock[0].yclearing) preClose = data.stock[0].yclearing; //期货使用昨结算价

  for (var i in data.stock[0].minute)
  {
    var jsData = data.stock[0].minute[i];
    var item = new _umychartDataWechat.JSCommon_HistoryData();

    item.Close = jsData.price;
    item.Open = jsData.open;
    item.High = jsData.high;
    item.Low = jsData.low;
    item.Vol = jsData.vol; //单位股
    item.Amount = jsData.amount;
    if (jsData.date > 0) item.Date = jsData.date;else
    item.Date = date;
    item.Time = jsData.time;
    item.YClose = preClose;
    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(jsData.position)) item.Position = jsData.position; //持仓量

    if (!_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Close)) //当前没有价格 使用上一个价格填充
      {
        item.Close = preClose;
        item.Open = item.High = item.Low = item.Close;
      }

    //价格是0的 都用空
    if (!_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Open)) item.Open = null;
    if (!_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Close)) item.Close = null;
    if (!_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.High)) item.High = null;
    if (!_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Low)) item.Low = null;

    //上次价格
    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(jsData.price)) preClose = jsData.price;

    aryMinuteData[i] = item;
  }

  return aryMinuteData;
};

//API 返回数据 转化为array[]
KLineChartContainer.JsonDataToMinuteHistoryData = function (data)
{
  var upperSymbol = null;
  if (data.symbol) upperSymbol = data.symbol.toUpperCase();
  var isSHSZ = false;
  if (upperSymbol) isSHSZ = _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol);
  var isFutures = false; //是否是期货
  if (upperSymbol) isFutures = _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsChinaFutures(upperSymbol);

  var list = data.data;
  var aryDayData = new Array();
  var date = 0,yclose = 1,open = 2,high = 3,low = 4,close = 5,vol = 6,amount = 7,time = 8,position = 9;
  for (var i = 0; i < list.length; ++i)
  {
    var item = new _umychartDataWechat.JSCommon_HistoryData();
    var jsData = list[i];
    item.Date = jsData[date];
    item.Open = jsData[open];
    item.YClose = jsData[yclose];
    item.Close = jsData[close];
    item.High = jsData[high];
    item.Low = jsData[low];
    item.Vol = jsData[vol]; //原始单位股
    item.Amount = jsData[amount];
    item.Time = jsData[time];
    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(jsData[position])) item.Position = jsData[position]; //期货持仓

    aryDayData.push(item);
  }

  return aryDayData;
};


///////////////////////////////////////////////////////////////////////////////////////////
//  走势图
//
function MinuteChartContainer(uielement)
{
  this.newMethod = JSChartContainer; //派生
  this.newMethod(uielement);
  delete this.newMethod;

  this.ClassName = 'MinuteChartContainer';
  this.WindowIndex = new Array();
  this.Symbol;
  this.Name;
  this.SourceData; //原始的历史数据
  this.OverlaySourceData; //叠加的原始数据
  this.IsAutoUpdate = false; //是否自动更新行情数据
  this.AutoUpdateFrequency = 30000; //30秒更新一次数据
  this.AutoUpdateTimer; //更新定时器
  this.TradeDate = 0; //行情交易日期
  this.LoadDataSplashTitle = '下载分钟数据';
  this.UpdateUICallback; //数据到达回调

  this.DayCount = 1; //显示几天的数据
  this.DayData; //多日分钟数据

  this.MinuteApiUrl = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Domain + "/API/Stock";
  this.HistoryMinuteApiUrl = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Domain + "/API/StockMinuteData"; //历史分钟数据

  //手机拖拽
  this.ontouchstart = function (e)
  {var _this8 = this;
    if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

    this.IsOnTouch = true;
    var jsChart = this;
    if (jsChart.DragMode == 0) return;

    if (this.IsPhoneDragging(e))
    {
      if (jsChart.TryClickLock)
      {
        var touches = this.GetToucheData(e, jsChart.IsForceLandscape);
        var x = touches[0].clientX;
        var y = touches[0].clientY;
        if (jsChart.TryClickLock(x, y)) return;
      }

      //长按2秒,十字光标
      this.ClearTouchTimer();

      var drag =
      {
        "Click": {},
        "LastMove": {} //最后移动的位置
      };

      var touches = this.GetToucheData(e, jsChart.IsForceLandscape);

      drag.Click.X = touches[0].clientX;
      drag.Click.Y = touches[0].clientY;
      drag.LastMove.X = touches[0].clientX;
      drag.LastMove.Y = touches[0].clientY;

      var T_ShowCorssCursor = function T_ShowCorssCursor()
      {
        if (_this8.ChartCorssCursor.IsShow === true) //移动十字光标
          {
            var x = drag.Click.X;
            var y = drag.Click.Y;
            if (jsChart.IsForceLandscape) y = jsChart.UIElement.Height - drag.Click.Y; //强制横屏Y计算
            jsChart.OnMouseMove(x, y, e);
          }
      };

      if (this.EnableScrollUpDown == true)
      {
        this.TouchTimer = setTimeout(function ()
        {
          _this8.MouseDrag = null;
          T_ShowCorssCursor();
        }, 800);
      }

      this.MouseDrag = drag;
      if (this.EnableScrollUpDown == false)
      T_ShowCorssCursor();
    }
  };

  this.ontouchmove = function (e)
  {var _this9 = this;
    if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

    var jsChart = this;
    var drag = jsChart.MouseDrag;
    var touches = this.GetToucheData(e, jsChart.IsForceLandscape);
    if (this.ChartCorssCursor.IsShow === true && this.IsPhoneDragging(e))
    {
      if (drag == null)
      {
        var x = touches[0].clientX;
        var y = touches[0].clientY;
        this.LastMovePoint = { X: x, Y: y };

        if (this.DrawMoveTimer) return;
        this.DrawMoveTimer = setTimeout(function ()
        {
          if (!_this9.LastMovePoint) return;
          _this9.OnMouseMove(_this9.LastMovePoint.X, _this9.LastMovePoint.Y, e);
          _this9.DrawMoveTimer = null;
        }, this.DrawMoveWaitTime);
      }
    }

    if (drag != null)
    {
      //TODO:上下滚动
      this.ClearTouchTimer();

      this.MouseDrag = null;
      var x = touches[0].clientX;
      var y = touches[0].clientY;
      this.OnMouseMove(x, y, e);
    }
  };

  //创建
  //windowCount 窗口个数
  this.Create = function (windowCount)
  {
    this.UIElement.JSChartContainer = this;

    //创建十字光标
    this.ChartCorssCursor = new _umychartChartpaintWechat.JSCommonChartPaint_ChartCorssCursor();
    this.ChartCorssCursor.Canvas = this.Canvas;
    this.ChartCorssCursor.StringFormatX = new HQMinuteTimeStringFormat();
    this.ChartCorssCursor.StringFormatY = new HQPriceStringFormat();
    this.ChartCorssCursor.StringFormatY.LanguageID = this.LanguageID;

    //创建等待提示
    this.ChartSplashPaint = new _umychartChartpaintWechat.JSCommonChartPaint_ChartSplashPaint();
    this.ChartSplashPaint.Canvas = this.Canvas;
    this.ChartSplashPaint.SplashTitle = this.LoadDataSplashTitle;
    this.ChartSplashPaint.HQChart = this;

    //创建框架容器
    this.Frame = new HQTradeFrame();
    this.Frame.ChartBorder = new ChartBorder();
    this.Frame.ChartBorder.UIElement = this.UIElement;
    this.Frame.ChartBorder.Top = 25;
    this.Frame.ChartBorder.Left = 50;
    this.Frame.ChartBorder.Bottom = 20;
    this.Frame.Canvas = this.Canvas;
    this.ChartCorssCursor.Frame = this.Frame; //十字光标绑定框架
    this.ChartSplashPaint.Frame = this.Frame;

    this.CreateChildWindow(windowCount);
    this.CreateMainKLine();

    //子窗口动态标题
    for (var i in this.Frame.SubFrame)
    {
      var titlePaint = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicChartTitlePainting();
      titlePaint.Frame = this.Frame.SubFrame[i].Frame;
      titlePaint.Canvas = this.Canvas;
      titlePaint.LanguageID = this.LanguageID;

      this.TitlePaint.push(titlePaint);
    }

    this.ChartCorssCursor.StringFormatX.Frame = this.Frame.SubFrame[0].Frame;
  };

  //创建子窗口
  this.CreateChildWindow = function (windowCount)
  {var _this10 = this;
    for (var i = 0; i < windowCount; ++i)
    {
      var border = new ChartBorder();
      border.UIElement = this.UIElement;

      var frame = new MinuteFrame();
      frame.Canvas = this.Canvas;
      frame.ChartBorder = border;
      frame.Identify = i;
      if (i < 2) frame.ChartBorder.TitleHeight = 0;
      frame.XPointCount = 243;

      var DEFAULT_HORIZONTAL = [9, 8, 7, 6, 5, 4, 3, 2, 1];
      frame.HorizontalMax = DEFAULT_HORIZONTAL[0];
      frame.HorizontalMin = DEFAULT_HORIZONTAL[DEFAULT_HORIZONTAL.length - 1];

      if (i == 0)
      {
        frame.YSplitOperator = new _umychartFramesplitWechat.JSCommonSplit_FrameSplitMinutePriceY();
        frame.YSplitOperator.FrameSplitData = this.FrameSplitData.get('price');
        frame.YSplitOperator.GetEventCallback = function (id) {return _this10.GetEventCallback(id);};
      } else

      {
        frame.YSplitOperator = new _umychartFramesplitWechat.JSCommonSplit_FrameSplitY();
        frame.YSplitOperator.FrameSplitData = this.FrameSplitData.get('double');
        frame.YSplitOperator.LanguageID = this.LanguageID;
        frame.YSplitOperator.GetEventCallback = function (id) {return _this10.GetEventCallback(id);};
      }

      frame.YSplitOperator.Frame = frame;
      frame.YSplitOperator.ChartBorder = border;
      frame.XSplitOperator = new _umychartFramesplitWechat.JSCommonSplit_FrameSplitMinuteX();
      frame.XSplitOperator.Frame = frame;
      frame.XSplitOperator.ChartBorder = border;
      if (i != windowCount - 1) frame.XSplitOperator.ShowText = false;
      frame.XSplitOperator.Operator();

      for (var j in DEFAULT_HORIZONTAL)
      {
        frame.HorizontalInfo[j] = new _umychartFramesplitWechat.JSCommonSplit_CoordinateInfo();
        frame.HorizontalInfo[j].Value = DEFAULT_HORIZONTAL[j];
        if (i == 0 && j == frame.HorizontalMin) continue;

        frame.HorizontalInfo[j].Message[1] = DEFAULT_HORIZONTAL[j].toString();
        frame.HorizontalInfo[j].Font = "14px 微软雅黑";
      }

      var subFrame = new SubFrameItem();
      subFrame.Frame = frame;
      if (i == 0) subFrame.Height = 20;else
      subFrame.Height = 10;

      this.Frame.SubFrame[i] = subFrame;
    }
  };

  this.CreateSubFrameItem = function (id)
  {var _this11 = this;
    var border = new ChartBorder();
    border.UIElement = this.UIElement;

    var frame = new MinuteFrame();
    frame.Canvas = this.Canvas;
    frame.ChartBorder = border;
    frame.Identify = id; //窗口序号
    frame.XPointCount = 243;

    if (id >= 2)
    {
      if (this.ModifyIndexDialog) frame.ModifyIndexEvent = this.ModifyIndexDialog.DoModal; //绑定菜单事件
      if (this.ChangeIndexDialog) frame.ChangeIndexEvent = this.ChangeIndexDialog.DoModal;
    }

    var DEFAULT_HORIZONTAL = [9, 8, 7, 6, 5, 4, 3, 2, 1];
    frame.HorizontalMax = DEFAULT_HORIZONTAL[0];
    frame.HorizontalMin = DEFAULT_HORIZONTAL[DEFAULT_HORIZONTAL.length - 1];

    frame.YSplitOperator = new _umychartFramesplitWechat.JSCommonSplit_FrameSplitY();
    frame.YSplitOperator.LanguageID = this.LanguageID;
    frame.YSplitOperator.FrameSplitData = this.FrameSplitData.get('double');
    frame.YSplitOperator.Frame = frame;
    frame.YSplitOperator.ChartBorder = border;
    frame.XSplitOperator = new _umychartFramesplitWechat.JSCommonSplit_FrameSplitMinuteX();
    frame.XSplitOperator.Frame = frame;
    frame.XSplitOperator.ChartBorder = border;
    frame.XSplitOperator.ShowText = false;
    frame.XSplitOperator.GetEventCallback = function (id) {return _this11.GetEventCallback(id);};
    frame.YSplitOperator.GetEventCallback = function (id) {return _this11.GetEventCallback(id);};

    //K线数据绑定
    var xPointCouont = this.Frame.SubFrame[0].Frame.XPointCount;
    frame.XPointCount = xPointCouont;
    frame.Data = this.ChartPaint[0].Data;

    for (var j in DEFAULT_HORIZONTAL)
    {
      frame.HorizontalInfo[j] = new _umychartFramesplitWechat.JSCommonSplit_CoordinateInfo();
      frame.HorizontalInfo[j].Value = DEFAULT_HORIZONTAL[j];
      frame.HorizontalInfo[j].Message[1] = DEFAULT_HORIZONTAL[j].toString();
      frame.HorizontalInfo[j].Font = "14px 微软雅黑";
    }

    var subFrame = new SubFrameItem();
    subFrame.Frame = frame;
    subFrame.Height = 10;

    return subFrame;
  };

  this.UpdateXShowText = function ()
  {
    var bLastFrame = true;
    for (var i = this.Frame.SubFrame.length - 1; i >= 0; --i)
    {
      var item = this.Frame.SubFrame[i].Frame;
      var subFrame = this.Frame.SubFrame[i];

      if (bLastFrame)
      {
        item.XSplitOperator.ShowText = true;
        if (subFrame.Height > 0) bLastFrame = false;
      } else

      {
        item.XSplitOperator.ShowText = false;
      }
    }
  };

  //删除某一个窗口的指标
  this.DeleteIndexPaint = function (windowIndex)
  {
    var paint = new Array();
    for (var i in this.ChartPaint) //踢出当前窗口的指标画法
    {
      var item = this.ChartPaint[i];
      if (i == 0 || item.ChartFrame != this.Frame.SubFrame[windowIndex].Frame)
      paint.push(item);
    }

    //清空指定最大最小值
    this.Frame.SubFrame[windowIndex].Frame.YSpecificMaxMin = null;
    this.Frame.SubFrame[windowIndex].Frame.IsLocked = false; //解除上锁

    this.ChartPaint = paint;

    //清空东条标题
    var titleIndex = windowIndex + 1;
    this.TitlePaint[titleIndex].Data = [];
    this.TitlePaint[titleIndex].Title = null;
  };

  this.CreateStockInfo = function () {
    this.ExtendChartPaint[0] = new StockInfoExtendChartPaint();
    this.ExtendChartPaint[0].Canvas = this.Canvas;
    this.ExtendChartPaint[0].ChartBorder = this.Frame.ChartBorder;
    this.ExtendChartPaint[0].ChartFrame = this.Frame;

    this.Frame.ChartBorder.Right = 300;
  };

  //创建主图K线画法
  this.CreateMainKLine = function ()
  {
    //分钟线
    var minuteLine = new _umychartChartpaintWechat.JSCommonChartPaint_ChartMinutePriceLine();
    minuteLine.Canvas = this.Canvas;
    minuteLine.ChartBorder = this.Frame.SubFrame[0].Frame.ChartBorder;
    minuteLine.ChartFrame = this.Frame.SubFrame[0].Frame;
    minuteLine.Name = "Minute-Line";
    minuteLine.Color = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Minute.PriceColor;
    minuteLine.AreaColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Minute.AreaPriceColor;
    this.ChartPaint[0] = minuteLine;

    //分钟线均线
    var averageLine = new _umychartChartpaintWechat.JSCommonChartPaint_ChartMinutePriceLine();
    averageLine.Canvas = this.Canvas;
    averageLine.ChartBorder = this.Frame.SubFrame[0].Frame.ChartBorder;
    averageLine.ChartFrame = this.Frame.SubFrame[0].Frame;
    averageLine.Name = "Minute-Average-Line";
    averageLine.Color = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Minute.AvPriceColor;
    averageLine.IsDrawArea = false;
    this.ChartPaint[1] = averageLine;

    //成交量柱子
    var chartVol = new _umychartChartpaintWechat.JSCommonChartPaint_ChartMinuteVolumBar();
    chartVol.Color = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Minute.VolBarColor;
    chartVol.Canvas = this.Canvas;
    chartVol.ChartBorder = this.Frame.SubFrame[1].Frame.ChartBorder;
    chartVol.ChartFrame = this.Frame.SubFrame[1].Frame;
    chartVol.Name = "Minute-Vol-Bar";
    this.ChartPaint[2] = chartVol;

    //持仓线
    var chartPosition = new _umychartChartpaintWechat.JSCommonChartPaint_ChartSubLine();
    chartPosition.Color = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Minute.PriceColor;
    chartPosition.Canvas = this.Canvas;
    chartPosition.ChartBorder = this.Frame.SubFrame[1].Frame.ChartBorder;
    chartPosition.ChartFrame = this.Frame.SubFrame[1].Frame;
    chartPosition.Name = "Minute-Position-Line";
    this.ChartPaint[3] = chartPosition;

    this.TitlePaint[0] = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicMinuteTitlePainting();
    this.TitlePaint[0].Frame = this.Frame.SubFrame[0].Frame;
    this.TitlePaint[0].Canvas = this.Canvas;
    this.TitlePaint[0].LanguageID = this.LanguageID;

    //主图叠加画法
    var paint = new ChartOverlayMinutePriceLine();
    paint.Canvas = this.Canvas;
    paint.ChartBorder = this.Frame.SubFrame[0].Frame.ChartBorder;
    paint.ChartFrame = this.Frame.SubFrame[0].Frame;
    paint.Name = "Overlay-Minute";
    this.OverlayChartPaint[0] = paint;
  };

  //切换成 脚本指标
  this.ChangeScriptIndex = function (windowIndex, indexData)
  {
    this.DeleteIndexPaint(windowIndex);
    this.WindowIndex[windowIndex] = new _umychartIndexWechat.JSCommonIndex_ScriptIndex(indexData.Name, indexData.Script, indexData.Args, indexData); //脚本执行

    var bindData = this.SourceData;
    this.BindIndexData(windowIndex, bindData); //执行脚本

    this.UpdataDataoffset(); //更新数据偏移
    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Draw();
  };

  this.ChangeIndex = function (windowIndex, indexName, option)
  {
    if (this.Frame.SubFrame.length < 3) return;

    //查找系统指标
    var scriptData = new _umychartIndexDataWechat.JSCommonIndexScript.JSIndexScript();
    var indexInfo = scriptData.Get(indexName);
    if (!indexInfo) return;
    if (windowIndex < 2) windowIndex = 2;
    if (windowIndex >= this.Frame.SubFrame.length) windowIndex = 2;

    var indexData =
    {
      Name: indexInfo.Name, Script: indexInfo.Script, Args: indexInfo.Args, ID: indexName,
      //扩展属性 可以是空
      KLineType: indexInfo.KLineType, YSpecificMaxMin: indexInfo.YSpecificMaxMin, YSplitScale: indexInfo.YSplitScale,
      FloatPrecision: indexInfo.FloatPrecision, Condition: indexInfo.Condition, StringFormat: indexInfo.StringFormat };


    if (option)
    {
      if (option.FloatPrecision >= 0) indexData.FloatPrecision = option.FloatPrecision;
      if (option.StringFormat > 0) indexData.StringFormat = option.StringFormat;
      if (option.Args) indexData.Args = option.Args;
    }

    return this.ChangeScriptIndex(windowIndex, indexData);
  };

  this.RemoveIndexWindow = function (id)
  {
    _umychartConsoleWechat.JSConsole.Chart.Log('[MinuteChartContainer::RemoveIndexWindow] remove id', id);

    if (id < 2) return;
    if (!this.Frame.SubFrame) return;
    if (id >= this.Frame.SubFrame.length) return;

    var delFrame = this.Frame.SubFrame[id].Frame;
    this.DeleteIndexPaint(id);
    this.Frame.SubFrame.splice(id, 1);
    this.WindowIndex.splice(id, 1);
    this.TitlePaint.splice(id + 1, 1); //删除对应的动态标题

    for (var i = 0; i < this.Frame.SubFrame.length; ++i)
    {
      var item = this.Frame.SubFrame[i].Frame;
      if (i == this.Frame.SubFrame.length - 1) item.XSplitOperator.ShowText = true;else
      item.XSplitOperator.ShowText = false;

      item.Identify = i;
    }

    this.Frame.SetSizeChage(true);
    this.UpdateFrameMaxMin();
    this.ResetFrameXYSplit();
    this.Draw();
  };

  //切换股票代码
  this.ChangeSymbol = function (symbol)
  {
    this.Symbol = symbol;
    this.CancelAutoUpdate(); //先停止定时器
    this.ChartSplashPaint.SetTitle(this.LoadDataSplashTitle);
    this.ChartSplashPaint.EnableSplash(true);
    this.RequestData();
  };

  this.ChangeDayCount = function (count)
  {
    if (count < 0 || count > 10) return;
    this.DayCount = count;
    this.CancelAutoUpdate(); //先停止定时器
    this.RequestData();
  };

  //叠加股票 只支持日线数据
  this.OverlaySymbol = function (symbol, option)
  {
    var paint = this.OverlayChartPaint[0];
    if (!paint.MainData) return false;

    paint.Symbol = symbol;
    if (option)
    {
      if (option.Color) paint.Color = option.Color;
    }

    if (this.DayCount <= 1) this.RequestOverlayMinuteData(); //请求数据
    else this.RequestOverlayHistoryMinuteData();

    return true;
  };

  this.TryClickLock = function (x, y) {
    for (var i in this.Frame.SubFrame) {
      var item = this.Frame.SubFrame[i];
      if (!item.Frame.IsLocked) continue;
      if (!item.Frame.LockPaint) continue;

      var tooltip = new TooltipData();
      if (!item.Frame.LockPaint.GetTooltipData(x, y, tooltip)) continue;

      tooltip.HQChart = this;
      if (tooltip.Data.Callback) tooltip.Data.Callback(tooltip);
      return true;
    }

    return false;
  };

  this.RequestData = function ()
  {
    if (this.DayCount <= 1) this.RequestMinuteData();else
    this.RequestHistoryMinuteData(); //请求数据
  };

  this.RecvMinuteDataEvent = function ()
  {
    if (!this.mapEvent.has(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.RECV_MINUTE_DATA)) return;

    var event = this.mapEvent.get(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.RECV_MINUTE_DATA);
    var data = { MinuteData: this.SourceData, Stock: { Symbol: this.Symbol, Name: this.Name } };
    event.Callback(event, data, this);
  };

  this.RequestHistoryMinuteData = function () //请求历史分钟数据
  {
    var self = this;
    this.ChartSplashPaint.SetTitle(this.LoadDataSplashTitle);
    this.ChartSplashPaint.EnableSplash(true);
    this.Draw();

    if (this.NetworkFilter)
    {
      var obj =
      {
        Name: 'MinuteChartContainer::RequestHistoryMinuteData', //类名::
        Explain: '多日分时数据',
        Request: { Url: self.HistoryMinuteApiUrl, Data: { daycount: self.DayCount, symbol: self.Symbol }, Type: 'POST' },
        Self: this,
        PreventDefault: false };

      this.NetworkFilter(obj, function (data) {
        self.ChartSplashPaint.EnableSplash(false);
        self.RecvHistoryMinuteData(data);
      });

      if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求
    }

    wx.request({
      url: self.HistoryMinuteApiUrl,
      data:
      {
        "symbol": self.Symbol,
        "daycount": self.DayCount },

      method: "post",
      dataType: "json",
      success: function success(data) {
        self.ChartSplashPaint.EnableSplash(false);
        self.RecvHistoryMinuteData(data);
      } });

  };

  this.RecvHistoryMinuteData = function (recvdata)
  {
    var data = recvdata.data;
    if (data.code != 0)
    {
      _umychartConsoleWechat.JSConsole.Chart.Log('[MinuteChartContainer::RecvHistoryMinuteData] failed.', data);
      return;
    }
    this.DayData = MinuteChartContainer.JsonDataToMinuteDataArray(data);;
    this.Symbol = data.symbol;
    this.Name = data.name;

    this.UpdateHistoryMinuteUI();
    this.RecvMinuteDataEvent();
    this.RequestOverlayHistoryMinuteData();

    if (typeof this.UpdateUICallback == 'function') this.UpdateUICallback('RecvHistoryMinuteData', this);

    this.AutoUpdate();
  };

  this.UpdateHistoryMinuteUI = function ()
  {
    var allMinuteData = this.HistoryMinuteDataToArray(this.DayData);

    //原始数据
    var sourceData = new _umychartDataWechat.JSCommon_ChartData();
    sourceData.Data = allMinuteData;

    this.SourceData = sourceData;
    this.TradeDate = this.DayData[0].Date;

    this.BindMainData(sourceData, this.DayData[0].YClose);
    //if (MARKET_SUFFIX_NAME.IsChinaFutures(this.Symbol)) this.ChartPaint[1].Data = null;   //期货均线暂时不用

    if (this.Frame.SubFrame.length > 2)
    {
      var bindData = new _umychartDataWechat.JSCommon_ChartData();
      bindData.Data = allMinuteData;
      for (var i = 2; i < this.Frame.SubFrame.length; ++i)
      {
        this.BindIndexData(i, bindData);
      }
    }

    for (var _i2 in this.Frame.SubFrame)
    {
      var item = this.Frame.SubFrame[_i2];
      item.Frame.XSplitOperator.Symbol = this.Symbol;
      item.Frame.XSplitOperator.DayCount = this.DayData.length;
      item.Frame.XSplitOperator.DayData = this.DayData;
      item.Frame.XSplitOperator.Operator(); //调整X轴个数
      item.Frame.YSplitOperator.Symbol = this.Symbol;
    }

    this.ChartCorssCursor.StringFormatY.Symbol = this.Symbol;
    this.ChartCorssCursor.StringFormatX.Symbol = this.Symbol;
    this.TitlePaint[0].IsShowDate = true;
    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Frame.SetSizeChage(true);
    this.Draw();
  };

  this.HistoryMinuteDataToArray = function (data) //把多日分钟数据转化为单数组
  {
    var result = [];
    for (var i = data.length - 1; i >= 0; --i) {
      var item = data[i];
      for (var j in item.Data) {
        result.push(item.Data[j]);
      }
    }
    return result;
  };

  this.UpdateLatestMinuteData = function (data, date) //更新最新交易日的分钟数据
  {
    for (var i in this.DayData) {
      var item = this.DayData[i];
      if (item.Date === date) {
        item.Data = data;
        break;
      }
    }
  };

  //请求分钟数据
  this.RequestMinuteData = function ()
  {
    var self = this;

    var fields =
    [
    "name", "symbol",
    "yclose", "open", "price", "high", "low",
    "vol", "amount",
    "date", "time",
    "minute", "minutecount"];


    var upperSymbol = this.Symbol.toUpperCase();
    if (_umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsChinaFutures(upperSymbol)) //期货的需要加上结算价
      {
        fields.push("clearing");
        fields.push("yclearing");
      }

    if (this.NetworkFilter)
    {
      var obj =
      {
        Name: 'MinuteChartContainer::RequestMinuteData', //类名::函数名
        Explain: '最新分时数据',
        Request: { Url: self.MinuteApiUrl, Data: { field: fields, symbol: [self.Symbol] }, Type: 'POST' },
        Self: this,
        PreventDefault: false };

      this.NetworkFilter(obj, function (data)
      {
        self.ChartSplashPaint.EnableSplash(false);
        self.RecvMinuteData(data);
      });

      if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求
    }

    wx.request({
      url: this.MinuteApiUrl,
      data:
      {
        "field": fields,
        "symbol": [this.Symbol],
        "start": -1 },

      method: "post",
      dataType: "json",
      success: function success(data) {
        self.ChartSplashPaint.EnableSplash(false);
        self.RecvMinuteData(data);
      } });

  };

  this.RecvMinuteData = function (data)
  {
    var aryMinuteData = MinuteChartContainer.JsonDataToMinuteData(data.data);

    if (this.DayCount > 1) //多日走势图
      {
        this.UpdateLatestMinuteData(aryMinuteData, data.data.stock[0].date);
        this.UpdateHistoryMinuteUI();
        this.RecvMinuteDataEvent();
        this.RequestOverlayMinuteData(); //更新最新叠加数据
        if (typeof this.UpdateUICallback == 'function') this.UpdateUICallback('RecvMinuteData', this);
        this.AutoUpdate();
        return;
      }

    //原始数据
    var sourceData = new _umychartDataWechat.JSCommon_ChartData();
    sourceData.Data = aryMinuteData;

    this.TradeDate = data.data.stock[0].date;

    this.SourceData = sourceData;
    this.Symbol = data.data.stock[0].symbol;
    this.Name = data.data.stock[0].name;
    var yClose = data.data.stock[0].yclose;
    var upperSymbol = this.Symbol.toUpperCase();
    var isFutures = _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsFutures(upperSymbol);
    if (data.data.stock[0].yclearing && isFutures) yClose = data.data.stock[0].yclearing; //期货使用前结算价
    var extendData = { High: data.data.stock[0].high, Low: data.data.stock[0].low };
    this.BindMainData(sourceData, yClose, extendData);

    for (var _i3 in this.Frame.SubFrame) //把股票代码设置到X轴刻度类里
    {
      var item = this.Frame.SubFrame[_i3];
      item.Frame.XSplitOperator.Symbol = this.Symbol;
      item.Frame.XSplitOperator.DayCount = 1;
      item.Frame.XSplitOperator.Operator(); //调整X轴个数
      item.Frame.YSplitOperator.Symbol = this.Symbol;
    }

    //计算指标
    if (this.Frame.SubFrame.length > 2)
    {
      var bindData = new _umychartDataWechat.JSCommon_ChartData();
      bindData.Data = aryMinuteData;
      for (var i = 2; i < this.Frame.SubFrame.length; ++i)
      {
        this.BindIndexData(i, bindData);
      }
    }

    this.ChartCorssCursor.StringFormatY.Symbol = this.Symbol;
    this.ChartCorssCursor.StringFormatX.Symbol = this.Symbol;

    var chartInfo = this.GetChartMinuteInfo();
    if (chartInfo) chartInfo.SourceData = this.SourceData; //数据绑定到信息地雷上
    this.RecvMinuteDataEvent();
    this.RequestMinuteInfoData();
    this.RequestOverlayMinuteData(); //请求叠加数据 (主数据下载完再下载)

    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Frame.SetSizeChage(true);
    this.Draw();

    if (typeof this.UpdateUICallback == 'function') this.UpdateUICallback('RecvMinuteData', this);

    this.AutoUpdate();
  };

  //请求叠加数据 (主数据下载完再下载))
  this.RequestOverlayMinuteData = function ()
  {
    if (!this.OverlayChartPaint.length) return;

    var symbol = this.OverlayChartPaint[0].Symbol;
    if (!symbol) return;

    var self = this;
    var date = this.TradeDate; //最后一个交易日期

    if (this.NetworkFilter)
    {
      var obj =
      {
        Name: 'MinuteChartContainer::RequestOverlayMinuteData', //类名::函数名
        Explain: '叠加股票最新分时数据',
        Request: { Url: self.HistoryMinuteApiUrl, Data: { days: [date], symbol: symbol }, Type: 'POST' },
        Self: this,
        PreventDefault: false };

      this.NetworkFilter(obj, function (data)
      {
        self.RecvOverlayMinuteData(data);
      });

      if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求
    }


    //请求数据
    wx.request({
      url: self.HistoryMinuteApiUrl,
      data:
      {
        "symbol": symbol,
        "days": [date] },

      method: "post",
      dataType: "json",
      success: function success(data) {
        self.RecvOverlayMinuteData(data);
      } });

  };

  this.RecvOverlayMinuteData = function (recvData) {
    var data = recvData.data;
    var aryMinuteData = MinuteChartContainer.JsonDataToMinuteDataArray(data);

    var sourceData = null;
    var yClose;
    if (this.DayCount > 1) //多日数据
      {
        if (aryMinuteData.length <= 0) return;

        var minuteData = aryMinuteData[0];
        for (var i in this.OverlaySourceData) {
          var item = this.OverlaySourceData[i];
          if (item.Date == minuteData.Date) {
            this.OverlaySourceData[i] = minuteData;
            var allMinuteData = this.HistoryMinuteDataToArray(this.OverlaySourceData);
            var sourceData = new _umychartDataWechat.JSCommon_ChartData();
            sourceData.Data = allMinuteData;
            yClose = minuteData.YClose;
            break;
          }
        }
        if (sourceData == null) return;
      } else
    {
      if (aryMinuteData.length > 0) sourceData = aryMinuteData[0];else
      sourceData = new _umychartDataWechat.JSCommon_ChartData();
      yClose = sourceData.YClose;
    }

    this.OverlayChartPaint[0].Data = sourceData;
    this.OverlayChartPaint[0].Title = data.name;
    this.OverlayChartPaint[0].Symbol = data.symbol;
    this.OverlayChartPaint[0].YClose = yClose;

    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Frame.SetSizeChage(true);
    this.Draw();

    if (typeof this.UpdateUICallback == 'function') this.UpdateUICallback('RecvOverlayMinuteData', this);
  };

  this.RequestOverlayHistoryMinuteData = function ()
  {
    if (!this.OverlayChartPaint.length) return;
    var symbol = this.OverlayChartPaint[0].Symbol;
    if (!symbol) return;

    var self = this;
    var days = [];
    for (var i in this.DayData)
    {
      var item = this.DayData[i];
      days.push(item.Date);
    }

    if (days.length <= 0) return;

    if (this.NetworkFilter)
    {
      var obj =
      {
        Name: 'MinuteChartContainer::RequestOverlayHistoryMinuteData', //类名::函数名
        Explain: '叠加股票多日分时数据',
        Request: { Url: self.HistoryMinuteApiUrl, Data: { days: days, symbol: symbol }, Type: 'POST' },
        Self: this,
        PreventDefault: false };

      this.NetworkFilter(obj, function (data)
      {
        self.RecvOverlayHistoryMinuteData(data);
      });

      if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求
    }

    wx.request({
      url: self.HistoryMinuteApiUrl,
      data:
      {
        "symbol": symbol,
        "days": days },

      method: "post",
      dataType: "json",
      async: true,
      success: function success(data) {
        self.RecvOverlayHistoryMinuteData(data);
      } });

  };

  this.RecvOverlayHistoryMinuteData = function (recvData) //叠加历史的分钟数据
  {
    var data = recvData.data;
    var dayData = MinuteChartContainer.JsonDataToMinuteDataArray(data);
    var overlayDayData = [];
    for (var i in this.DayData) {
      var item = this.DayData[i];
      var bFind = false;
      for (var j in dayData) {
        if (item.Date == dayData[j].Date) {
          overlayDayData.push(dayData[i]);
          bFind = true;
          break;
        }
      }
      if (!bFind) //当天不存在叠加数据, 存空
        {
          var empytData = new _umychartDataWechat.JSCommon_ChartData();
          empytData.Date = item.Date;
        }
    }

    this.OverlaySourceData = overlayDayData;
    var allMinuteData = this.HistoryMinuteDataToArray(overlayDayData);

    //原始数据
    var sourceData = new _umychartDataWechat.JSCommon_ChartData();
    sourceData.Data = allMinuteData;

    var yClose = overlayDayData[0].YClose;
    this.OverlayChartPaint[0].Data = sourceData;
    this.OverlayChartPaint[0].Title = data.name;
    this.OverlayChartPaint[0].Symbol = data.symbol;
    this.OverlayChartPaint[0].YClose = yClose;

    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Frame.SetSizeChage(true);
    this.Draw();

    if (typeof this.UpdateUICallback == 'function') this.UpdateUICallback('RecvOverlayHistoryMinuteData', this);
  };

  this.CancelAutoUpdate = function () //关闭停止更新
  {
    if (typeof this.AutoUpdateTimer == 'number')
    {
      clearTimeout(this.AutoUpdateTimer);
      this.AutoUpdateTimer = undefined;
    }
  };

  //数据自动更新
  this.AutoUpdate = function ()
  {
    this.CancelAutoUpdate();
    if (!this.IsAutoUpdate) return;
    if (!this.Symbol) return;
    if (this.IsDestroy) return;

    var self = this;
    var marketStatus = _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.GetMarketStatus(this.Symbol);
    if (marketStatus == 0 || marketStatus == 3) return; //闭市,盘后

    var frequency = this.AutoUpdateFrequency;
    if (marketStatus == 1) //盘前
      {
        this.AutoUpdateTimer = setTimeout(function () {self.AutoUpdate();}, frequency);
      } else
    if (marketStatus == 2) //盘中
      {
        this.AutoUpdateTimer = setTimeout(function ()
        {
          //self.ResetOverlaySymbolStatus(); 
          self.RequestMinuteData();
        }, frequency);
      }
  };

  this.StopAutoUpdate = function ()
  {
    this.CancelAutoUpdate();
    this.IsAutoUpdate = false;
  };

  this.BindIndexData = function (windowIndex, hisData)
  {
    if (!this.WindowIndex[windowIndex]) return;

    if (typeof this.WindowIndex[windowIndex].RequestData == "function") //数据需要另外下载的.
      {
        this.WindowIndex[windowIndex].RequestData(this, windowIndex, hisData);
        return;
      }

    if (typeof this.WindowIndex[windowIndex].ExecuteScript == 'function')
    {
      this.WindowIndex[windowIndex].ExecuteScript(this, windowIndex, hisData);
      return;
    }

    this.WindowIndex[windowIndex].BindData(this, windowIndex, hisData);
  };


  this.BindMainData = function (minuteData, yClose, extendData) //绑定分钟数据
  {
    //分钟数据
    var bindData = new _umychartDataWechat.JSCommon_ChartData();
    bindData.Data = minuteData.GetClose();
    this.ChartPaint[0].Data = bindData;
    this.ChartPaint[0].YClose = yClose;
    this.ChartPaint[0].NotSupportMessage = null;

    this.Frame.SubFrame[0].Frame.YSplitOperator.YClose = yClose;
    this.Frame.SubFrame[0].Frame.YSplitOperator.Data = bindData;

    //均线
    bindData = new _umychartDataWechat.JSCommon_ChartData();
    bindData.Data = minuteData.GetMinuteAvPrice();
    this.ChartPaint[1].Data = bindData;

    this.Frame.SubFrame[0].Frame.YSplitOperator.AverageData = bindData;
    this.Frame.SubFrame[0].Frame.YSplitOperator.OverlayChartPaint = this.OverlayChartPaint;
    if (extendData)
    {
      this.Frame.SubFrame[0].Frame.YSplitOperator.High = extendData.High;
      this.Frame.SubFrame[0].Frame.YSplitOperator.Low = extendData.Low;
    }

    //成交量
    this.ChartPaint[2].Data = minuteData;
    this.ChartPaint[2].YClose = yClose;

    var upperSymbol = this.Symbol.toUpperCase();
    var bFutures = _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsChinaFutures(upperSymbol);
    var bSHO = _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsSHO(upperSymbol);

    if (bFutures || bSHO)
    {
      this.ChartPaint[3].Data.Data = minuteData.GetPosition();
    } else

    {
      this.ChartPaint[3].Data.Data = null;
    }

    this.TitlePaint[0].Data = this.SourceData; //动态标题
    this.TitlePaint[0].Symbol = this.Symbol;
    this.TitlePaint[0].Name = this.Name;
    this.TitlePaint[0].YClose = yClose;

    if (this.ChartCorssCursor)
    {
      if (this.ChartCorssCursor.StringFormatY)
      {
        this.ChartCorssCursor.StringFormatY.YClose = yClose;
        this.ChartCorssCursor.StringFormatX.Data = this.ChartPaint[0].Data; //十字光标
      }
    }

    if (this.ExtendChartPaint[0])
    {
      this.ExtendChartPaint[0].Symbol = this.Symbol;
      this.ExtendChartPaint[0].Name = this.Name;
    }

    this.OverlayChartPaint[0].MainData = this.ChartPaint[0].Data; //叠加
    this.OverlayChartPaint[0].MainYClose = yClose;
  };

  //获取子窗口的所有画法
  this.GetChartPaint = function (windowIndex)
  {
    var paint = new Array();
    for (var i in this.ChartPaint)
    {
      if (i < 3) continue; //分钟 均线 成交量 3个线不能改
      var item = this.ChartPaint[i];
      if (item.ChartFrame == this.Frame.SubFrame[windowIndex].Frame)
      paint.push(item);
    }

    return paint;
  };

  //创建指定窗口指标
  this.CreateWindowIndex = function (windowIndex)
  {
    this.WindowIndex[windowIndex].Create(this, windowIndex);
  };

  this.CreateExtendChart = function (name, option) //创建扩展图形
  {
    var chart;
    switch (name) {

      case 'MinuteTooltip':
        chart = new _umychartExtendchartWechat.JSCommonExtendChartPaint_MinuteTooltipPaint();
        chart.Canvas = this.Canvas;
        chart.ChartBorder = this.Frame.ChartBorder;
        chart.ChartFrame = this.Frame;
        chart.HQChart = this;
        option.LanguageID = this.LanguageID;
        chart.SetOption(option);
        this.ExtendChartPaint.push(chart);
        return chart;
      default:
        return null;}

  };

  this.SetMinuteInfo = function (aryInfo, bUpdate)
  {
    this.ChartInfo = []; //先清空
    for (var i in aryInfo)
    {
      var infoItem = _umychartKlineinfoWechat.JSCommon_JSMinuteInfoMap.Get(aryInfo[i]);
      if (!infoItem) continue;
      var item = infoItem.Create();
      this.ChartInfo.push(item);
    }

    if (bUpdate == true) this.RequestMinuteInfoData();
  };

  this.GetChartMinuteInfo = function ()
  {
    return this.ChartInfoPaint;
  };

  this.CreateMinuteInfo = function (option) //在Create()以后 在调用
  {
    var chart = new _umychartChartpaintWechat.JSCommonChartPaint_ChartMinuteInfo();
    chart.Canvas = this.Canvas;
    chart.ChartBorder = this.Frame.SubFrame[0].Frame.ChartBorder;
    chart.ChartFrame = this.Frame.SubFrame[0].Frame;
    chart.ChartMinutePrice = this.ChartPaint[0];
    if (option && chart.SetOption) chart.SetOption(option);
    this.ChartInfoPaint = chart;
    return chart;
  };

  //信息地雷数据请求
  this.RequestMinuteInfoData = function ()
  {
    if (this.ChartInfo.length <= 0) return;

    var chart = this.GetChartMinuteInfo();
    if (!chart) chart = this.CreateMinuteInfo(null); //不存在就创建 

    chart.SourceData = this.SourceData;

    //信息地雷信息
    for (var i in this.ChartInfo) {
      this.ChartInfo[i].RequestData(this);
    }
  };

  //更新信息地雷
  this.UpdataChartInfo = function ()
  {
    var chart = this.GetChartMinuteInfo();
    if (!chart) return;

    var infoMap = new Map();
    for (var i in this.ChartInfo)
    {
      var infoData = this.ChartInfo[i].Data;
      for (var j in infoData)
      {
        var item = infoData[j];
        var dateTime = "".concat(item.Date, " ").concat(item.Time);
        if (infoMap.has(dateTime)) infoMap.get(dateTime).Data.push(item);else
        infoMap.set(dateTime, { Data: new Array(item) });
      }
    }

    chart.Data = infoMap;
  };
}

//API 返回数据 转化为array[]
MinuteChartContainer.JsonDataToMinuteData = function (data)
{
  var upperSymbol = data.stock[0].symbol.toUpperCase();
  var isSHSZ = _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol);
  var isFutures = _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsChinaFutures(upperSymbol) || _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsNYMEX(upperSymbol);
  var isSHO = _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsSHO(upperSymbol); //上海股票期权

  var preClose = data.stock[0].yclose; //前一个数据价格
  var preAvPrice = data.stock[0].yclose; //前一个均价
  var yClose = data.stock[0].yclose;
  if (isFutures && data.stock[0].yclearing) yClose = preClose = preAvPrice = data.stock[0].yclearing; //期货使用昨结算价

  var date = data.stock[0].date;
  var aryMinuteData = new Array();
  for (var i in data.stock[0].minute)
  {
    var jsData = data.stock[0].minute[i];
    var item = new _umychartDataWechat.JSCommon_MinuteData();

    if (jsData.price) preClose = jsData.price;
    if (jsData.avprice) preAvPrice = jsData.avprice;

    item.Close = jsData.price;
    item.Open = jsData.open;
    item.High = jsData.high;
    item.Low = jsData.low;
    if (isSHSZ) item.Vol = jsData.vol / 100; //原始单位股
    else item.Vol = jsData.vol;
    item.Amount = jsData.amount;
    item.Increase = jsData.increase;
    item.Risefall = jsData.risefall;
    item.AvPrice = jsData.avprice;

    if (!item.Close) //当前没有价格 使用上一个价格填充
      {
        item.Close = preClose;
        item.Open = item.High = item.Low = item.Close;
      }
    if (!item.AvPrice) item.AvPrice = preAvPrice;

    if (jsData.date > 0) date = jsData.date; //分钟数据中有日期 优先使用
    item.DateTime = date.toString() + " " + jsData.time.toString();
    item.Date = data.stock[0].date;
    item.Time = jsData.time;
    if (8 < jsData.length && jsData[8] > 0)
    {
      item.Date = jsData[8]; //日期
      item.DateTime = item.Date.toString() + " " + jsData[0].toString();
    }
    if (isFutures || isSHO) item.Position = jsData.position; //期货 期权有持仓

    if (i == 0) //第1个数据 写死9：25
      {
        item.IsFristData = true;
        //if (isSHSZ) item.DateTime = data.stock[0].date.toString() + " 0925";
        if (item.Close <= 0) //第1分钟 没数据就用开盘价
          {
            item.Close = data.stock[0].open;
            item.High = item.Low = data.stock[0].open;
            item.AvPrice = data.stock[0].open;
            _umychartConsoleWechat.JSConsole.Chart.Log('[MinuteChartContainer::JsonDataToMinuteData] first minute data is empty.', data.stock[0].symbol, jsData);
          }
      }

    //价格是0的 都用空
    if (item.Open <= 0) item.Open = null;
    if (item.Close <= 0) item.Close = null;
    if (item.AvPrice <= 0) item.AvPrice = null;
    if (item.High <= 0) item.High = null;
    if (item.Low <= 0) item.Low = null;

    if (yClose && item.Close) item.Increase = (item.Close - yClose) / yClose * 100; //涨幅 (最新价格-昨收)/昨收*10

    aryMinuteData[i] = item;
  }

  return aryMinuteData;
};

//多日日线数据API 转化成array[];
MinuteChartContainer.JsonDataToMinuteDataArray = function (data)
{
  var upperSymbol = data.symbol.toUpperCase();
  var isSHSZ = _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol);
  var isFutures = _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsChinaFutures(upperSymbol) || _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsNYMEX(upperSymbol);
  var isSHO = _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsSHO(upperSymbol); //上海股票期权
  var result = [];
  for (var i in data.data)
  {
    var minuteData = [];
    var dayData = data.data[i];
    var date = dayData.date;
    var yClose = dayData.yclose; //前收盘 计算涨幅
    var preClose = yClose; //前一个数据价格
    var preAvPrice = null; //前一个均价
    for (var j in dayData.minute)
    {
      var jsData = dayData.minute[j];
      if (jsData[2]) preClose = jsData[2]; //保存上一个收盘数据
      var item = new _umychartDataWechat.JSCommon_MinuteData();
      item.Close = jsData[2];
      item.Open = jsData[1];
      item.High = jsData[3];
      item.Low = jsData[4];
      if (isSHSZ) item.Vol = jsData[5] / 100; //原始单位股
      else item.Vol = jsData[5];
      item.Amount = jsData[6];

      if (7 < jsData.length && jsData[7] > 0)
      {
        item.AvPrice = jsData[7]; //均价
        preAvPrice = jsData[7];
      }

      if (!item.Close) //当前没有价格 使用上一个价格填充
        {
          item.Close = preClose;
          item.Open = item.High = item.Low = item.Close;
        }

      if (!item.AvPrice && preAvPrice) item.AvPrice = preAvPrice;

      if (item.Close && yClose) item.Increase = (item.Close - yClose) / yClose * 100;else
      item.Increase = null;

      item.DateTime = date.toString() + " " + jsData[0].toString();
      item.Date = date;
      item.Time = jsData[0];
      if (8 < jsData.length && jsData[8] > 0)
      {
        item.Date = jsData[8]; //日期
        item.DateTime = item.Date.toString() + " " + jsData[0].toString();
      }
      if ((isFutures || isSHO) && 9 < jsData.length) item.Position = jsData[9]; //持仓

      if (j == 0)
      {
        //if (isSHSZ) item.DateTime = date.toString() + " 0925";//第1个数据 写死9：25
        item.IsFristData = true;
      }

      //价格是0的 都用空
      if (item.Open <= 0) item.Open = null;
      if (item.Close <= 0) item.Close = null;
      if (item.AvPrice <= 0) item.AvPrice = null;
      if (item.High <= 0) item.High = null;
      if (item.Low <= 0) item.Low = null;
      if (item.AvPrice <= 0) item.AvPrice = null;

      minuteData[j] = item;
    }

    var newData = new _umychartDataWechat.JSCommon_ChartData();
    newData.Data = minuteData;
    newData.YClose = yClose;
    newData.Close = dayData.close;
    newData.Date = date;

    result.push(newData);
  }

  return result;
};

/*
       历史分钟走势图
   */
function HistoryMinuteChartContainer(uielement) {
  this.newMethod = MinuteChartContainer; //派生
  this.newMethod(uielement);
  delete this.newMethod;

  this.HistoryMinuteApiUrl = "https://opensourcecache.zealink.com/cache/minuteday/day/";


  //创建主图K线画法
  this.CreateMainKLine = function () {
    //分钟线
    var minuteLine = new _umychartChartpaintWechat.JSCommonChartPaint_ChartMinutePriceLine();
    minuteLine.Canvas = this.Canvas;
    minuteLine.ChartBorder = this.Frame.SubFrame[0].Frame.ChartBorder;
    minuteLine.ChartFrame = this.Frame.SubFrame[0].Frame;
    minuteLine.Name = "Minute-Line";
    minuteLine.Color = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Minute.PriceColor;

    this.ChartPaint[0] = minuteLine;

    //分钟线均线
    var averageLine = new _umychartChartpaintWechat.JSCommonChartPaint_ChartLine();
    averageLine.Canvas = this.Canvas;
    averageLine.ChartBorder = this.Frame.SubFrame[0].Frame.ChartBorder;
    averageLine.ChartFrame = this.Frame.SubFrame[0].Frame;
    averageLine.Name = "Minute-Average-Line";
    averageLine.Color = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Minute.AvPriceColor;
    this.ChartPaint[1] = averageLine;

    var averageLine = new _umychartChartpaintWechat.JSCommonChartPaint_ChartMinuteVolumBar();
    averageLine.Color = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Minute.VolBarColor;
    averageLine.Canvas = this.Canvas;
    averageLine.ChartBorder = this.Frame.SubFrame[1].Frame.ChartBorder;
    averageLine.ChartFrame = this.Frame.SubFrame[1].Frame;
    averageLine.Name = "Minute-Vol-Bar";
    this.ChartPaint[2] = averageLine;


    this.TitlePaint[0] = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicMinuteTitlePainting();
    this.TitlePaint[0].Frame = this.Frame.SubFrame[0].Frame;
    this.TitlePaint[0].Canvas = this.Canvas;
    this.TitlePaint[0].IsShowDate = true;

    /*
                                          //主图叠加画法
                                          var paint=new ChartOverlayKLine();
                                          paint.Canvas=this.Canvas;
                                          paint.ChartBorder=this.Frame.SubFrame[0].Frame.ChartBorder;
                                          paint.ChartFrame=this.Frame.SubFrame[0].Frame;
                                          paint.Name="Overlay-KLine";
                                          this.OverlayChartPaint[0]=paint;
                                          */

  };

  //设置交易日期
  this.ChangeTradeDate = function (trdateDate) {
    if (!trdateDate) return;

    this.TradeDate = trdateDate;
    this.RequestData(); //更新数据
  };

  this.RequestData = function () {
    var date = new Date();
    var nowDate = date.getFullYear() * 10000 + (date.getMonth() + 1) * 100 + date.getDate();
    if (nowDate == this.TradeDate) this.RequestMinuteData();else
    this.RequestHistoryMinuteData();
  };

  //请求分钟数据
  this.RequestHistoryMinuteData = function () {
    var self = this;
    var url = this.HistoryMinuteApiUrl + this.TradeDate.toString() + "/" + this.Symbol + ".json";

    wx.request({
      url: url,
      method: "get",
      dataType: "json",
      success: function success(data) {
        self.ChartSplashPaint.EnableSplash(false);
        self.RecvHistoryMinuteData(data);
      },
      error: function error(reqeust) {
        self.ChartSplashPaint.EnableSplash(false);
        self.RecvHistoryMinuteError(reqeust);
      } });

  };

  this.RecvHistoryMinuteError = function (reqeust) {
    if (reqeust.status != 404) return;

    var sourceData = new _umychartDataWechat.JSCommon_ChartData();
    this.SourceData = sourceData;

    for (var i in this.ChartPaint) {
      this.ChartPaint[i].Data = sourceData;
      if (i == 0) this.ChartPaint[i].NotSupportMessage = '没有权限访问!';
    }

    this.TitlePaint[0].Data = this.SourceData; //动态标题
    this.TitlePaint[0].Symbol = this.Symbol;
    this.TitlePaint[0].Name = null;

    this.Draw();
  };

  this.RecvHistoryMinuteData = function (recvData) {
    if (recvData.statusCode != 200) {
      var sourceData = new _umychartDataWechat.JSCommon_ChartData();
      this.SourceData = sourceData;

      for (var i in this.ChartPaint) {
        this.ChartPaint[i].Data = sourceData;
        if (i == 0) this.ChartPaint[i].NotSupportMessage = '没有权限访问!';
      }

      this.TitlePaint[0].Data = this.SourceData; //动态标题
      this.TitlePaint[0].Symbol = this.Symbol;
      this.TitlePaint[0].Name = null;

      this.Draw();
      return;
    }

    var data = recvData.data;
    var aryMinuteData = HistoryMinuteChartContainer.JsonDataToMinuteData(data);

    //原始数据
    var sourceData = new _umychartDataWechat.JSCommon_ChartData();
    sourceData.Data = aryMinuteData;

    this.TradeDate = data.date;

    this.SourceData = sourceData;
    this.Symbol = data.symbol;
    this.Name = data.name;

    this.BindMainData(sourceData, data.day.yclose);

    if (this.Frame.SubFrame.length > 2) {
      var bindData = new _umychartDataWechat.JSCommon_ChartData();
      bindData.Data = aryMinuteData;
      for (var i = 2; i < this.Frame.SubFrame.length; ++i) {
        this.BindIndexData(i, bindData);
      }
    }

    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Frame.SetSizeChage(true);
    this.Draw();

    //this.AutoUpdata();
  };

}

//API 返回数据 转化为array[]
HistoryMinuteChartContainer.JsonDataToMinuteData = function (data)
{
  var aryMinuteData = new Array();
  for (var i in data.minute.time)
  {
    var item = new _umychartDataWechat.JSCommon_MinuteData();
    if (data.minute.price[i] <= 0 && i > 0) //当前这一分钟价格为空,使用上一分钟的数据
      {
        item.Close = aryMinuteData[i - 1].Close;
        item.Open = aryMinuteData[i - 1].Close;
        item.High = item.Close;
        item.Low = item.Close;
        item.Vol = data.minute.vol[i] / 100; //原始单位股
        item.Amount = data.minute.amount[i];
        item.DateTime = data.date.toString() + " " + data.minute.time[i].toString();
        item.Date = data.date;
        item.Time = data.minute.time[i];
        //item.Increate=jsData.increate;
        //item.Risefall=jsData.risefall;
        item.AvPrice = aryMinuteData[i - 1].AvPrice;
      } else

    {
      item.Close = data.minute.price[i];
      item.Open = data.minute.open[i];
      item.High = data.minute.high[i];
      item.Low = data.minute.low[i];
      item.Vol = data.minute.vol[i] / 100; //原始单位股
      item.Amount = data.minute.amount[i];
      item.DateTime = data.date.toString() + " " + data.minute.time[i].toString();
      item.Date = data.date;
      item.Time = data.minute.time[i];
      //item.Increate=jsData.increate;
      //item.Risefall=jsData.risefall;
      item.AvPrice = data.minute.avprice[i];
    }

    //价格是0的 都用空
    if (item.Open <= 0) item.Open = null;
    if (item.Close <= 0) item.Close = null;
    if (item.AvPrice <= 0) item.AvPrice = null;
    if (item.High <= 0) item.High = null;
    if (item.Low <= 0) item.Low = null;

    aryMinuteData[i] = item;
  }

  return aryMinuteData;
};

/////////////////////////////////////////////////////////////////////////////
//  自定义指数
//
function CustomKLineChartContainer(uielement) {
  this.newMethod = KLineChartContainer; //派生
  this.newMethod(uielement);
  delete this.newMethod;

  this.ClassName = 'CustomKLineChartContainer';
  this.ChangeRight = null; //没有复权设置
  this.LoadDataSplashTitle = '计算指数数据';

  this.CustomKLineApiUrl = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Domain + "/API/IndexCalculate"; //自定义指数计算地址
  this.CustomStock; //成分
  this.QueryDate = { Start: 20180101, End: 20180627 }; //计算时间区间

  this.RequestHistoryData = function () {
    var self = this;
    this.ChartSplashPaint.SetTitle(this.LoadDataSplashTitle);
    this.ChartSplashPaint.EnableSplash(true);
    this.Draw();
    wx.request({
      url: this.CustomKLineApiUrl,
      data:
      {
        "stock": self.CustomStock,
        "Name": self.Symbol,
        "date": { "startdate": self.QueryDate.Start, "enddate": self.QueryDate.End } },

      method: 'POST',
      dataType: "json",
      async: true,
      success: function success(data) {
        self.ChartSplashPaint.EnableSplash(false);
        self.RecvHistoryData(data);
      } });

  };

  this.RecvHistoryData = function (recvData)
  {
    var data = recvData.data;
    var aryDayData = KLineChartContainer.JsonDataToHistoryData(data);

    //原始数据
    var sourceData = new _umychartDataWechat.JSCommon_ChartData();
    sourceData.Data = aryDayData;
    sourceData.DataType = 0; //0=日线数据 1=分钟数据
    sourceData.Symbol = data.symbol;

    //显示的数据
    var bindData = new _umychartDataWechat.JSCommon_ChartData();
    bindData.Data = aryDayData;
    bindData.Right = 0; //指数没有复权
    bindData.Period = this.Period;
    bindData.DataType = 0;
    bindData.Symbol = data.symbol;

    if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(this.Period, false)) //周期数据
      {
        var periodData = sourceData.GetPeriodData(bindData.Period);
        bindData.Data = periodData;
      }

    //绑定数据
    this.SourceData = sourceData;
    this.Name = data.name;
    this.BindMainData(bindData, this.PageSize);

    for (var i = 0; i < this.Frame.SubFrame.length; ++i)
    {
      this.BindIndexData(i, bindData);
    }
    //this.BindIndexData(0,hisData);
    //this.BindIndexData(1,hisData);
    //this.BindIndexData(2,hisData);

    //刷新画图
    this.UpdataDataoffset(); //更新数据偏移
    this.UpdatePointByCursorIndex(); //更新十字光标位子
    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Frame.SetSizeChage(true);
    this.Draw();

    if (typeof this.UpdateUICallback == 'function') this.UpdateUICallback('RecvHistoryData', this);
  };

}

////////////////////////////////////////////////////////////////////////////////
//  K线横屏显示
//
function KLineChartHScreenContainer(uielement)
{
  this.newMethod = KLineChartContainer; //派生
  this.newMethod(uielement);
  delete this.newMethod;

  this.ClassName = 'KLineChartHScreenContainer';

  this.OnMouseMove = function (x, y, e)
  {
    this.LastPoint.X = x;
    this.LastPoint.Y = y;
    this.CursorIndex = this.Frame.GetXData(y);

    this.DrawDynamicInfo();
  };

  //手机拖拽
  this.ontouchstart = function (e)
  {
    if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

    var jsChart = this;
    if (jsChart.DragMode == 0) return;

    jsChart.IsOnTouch = true;
    jsChart.PhonePinch = null;

    if (this.IsPhoneDragging(e))
    {
      if (jsChart.TryClickLock || this.TryClickIndexTitle)
      {
        var touches = this.GetToucheData(e);
        var x = touches[0].clientX;
        var y = touches[0].clientY;
        if (jsChart.TryClickLock && jsChart.TryClickLock(x, y)) return;
        if (jsChart.TryClickIndexTitle && jsChart.TryClickIndexTitle(x, y)) return;
      }

      //长按2秒,十字光标
      if (this.TouchTimer != null) clearTimeout(this.TouchTimer);
      if (this.ChartCorssCursor.IsShow == true)
      {
        this.TouchTimer = setTimeout(function () {
          if (drag.Click.X == drag.LastMove.X && drag.Click.Y == drag.LastMove.Y) //手指没有移动，出现十字光标
            {
              var mouseDrag = jsChart.MouseDrag;
              jsChart.MouseDrag = null;
              //移动十字光标
              var x = drag.Click.X;
              var y = drag.Click.Y;
              jsChart.OnMouseMove(x, y, e);
            }
        }, 800);
      }


      var drag = { "Click": {}, "LastMove": {} }; //最后移动的位置
      var touches = this.GetToucheData(e);

      drag.Click.X = touches[0].clientX;
      drag.Click.Y = touches[0].clientY;
      drag.LastMove.X = touches[0].clientX;
      drag.LastMove.Y = touches[0].clientY;

      jsChart.MouseDrag = drag;
    } else
    if (this.IsPhonePinching(e))
    {
      var phonePinch = { "Start": {}, "Last": {} };
      var touches = this.GetToucheData(e);

      phonePinch.Start = { "X": touches[0].pageX, "Y": touches[0].pageY, "X2": touches[1].pageX, "Y2": touches[1].pageY };
      phonePinch.Last = { "X": touches[0].pageX, "Y": touches[0].pageY, "X2": touches[1].pageX, "Y2": touches[1].pageY };

      jsChart.PhonePinch = phonePinch;
    }
  };


  this.ontouchmove = function (e)
  {
    if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

    var jsChart = this;
    var touches = this.GetToucheData(e);

    if (this.IsPhoneDragging(e))
    {
      var drag = jsChart.MouseDrag;
      if (drag == null)
      {
        var x = touches[0].clientX;
        var y = touches[0].clientY;
        jsChart.OnMouseMove(x, y, e);
      } else

      {
        var moveSetp = Math.abs(drag.LastMove.Y - touches[0].clientY);
        moveSetp = parseInt(moveSetp);
        if (jsChart.DragMode == 1) //数据左右拖拽
          {
            if (moveSetp < 5) return;

            var isLeft = true;
            if (drag.LastMove.Y < touches[0].clientY) isLeft = false; //右移数据

            if (jsChart.DataMove(moveSetp, isLeft))
            {
              jsChart.UpdataDataoffset();
              jsChart.UpdatePointByCursorIndex();
              jsChart.UpdateFrameMaxMin();
              jsChart.ResetFrameXYSplit();
              jsChart.Draw();
            }

            drag.LastMove.X = touches[0].clientX;
            drag.LastMove.Y = touches[0].clientY;
          }
      }
    } else
    if (this.IsPhonePinching(e))
    {
      var phonePinch = jsChart.PhonePinch;
      if (!phonePinch) return;

      if (this.EnableZoomUpDown && this.EnableZoomUpDown.Touch === false) return;

      var yHeight = Math.abs(touches[0].pageX - touches[1].pageX);
      var yLastHeight = Math.abs(phonePinch.Last.X - phonePinch.Last.X2);
      var yStep = yHeight - yLastHeight;
      if (Math.abs(yStep) < 5) return;

      if (yStep > 0) //放大
        {
          var cursorIndex = {};
          cursorIndex.Index = parseInt(Math.abs(jsChart.CursorIndex - 0.5).toFixed(0));
          if (!jsChart.Frame.ZoomUp(cursorIndex)) return;
          jsChart.CursorIndex = cursorIndex.Index;
          jsChart.UpdatePointByCursorIndex();
          jsChart.UpdataDataoffset();
          jsChart.UpdateFrameMaxMin();
          jsChart.ResetFrameXYSplit();
          jsChart.Draw();
        } else
        //缩小
        {
          var cursorIndex = {};
          cursorIndex.Index = parseInt(Math.abs(jsChart.CursorIndex - 0.5).toFixed(0));
          if (!jsChart.Frame.ZoomDown(cursorIndex)) return;
          jsChart.CursorIndex = cursorIndex.Index;
          jsChart.UpdataDataoffset();
          jsChart.UpdatePointByCursorIndex();
          jsChart.UpdateFrameMaxMin();
          jsChart.ResetFrameXYSplit();
          jsChart.Draw();
        }

      phonePinch.Last = { "X": touches[0].pageX, "Y": touches[0].pageY, "X2": touches[1].pageX, "Y2": touches[1].pageY };
    }
  };


  uielement.onmousedown = function (e) //鼠标拖拽
  {
    if (!this.JSChartContainer) return;
    if (this.JSChartContainer.DragMode == 0) return;

    if (this.JSChartContainer.TryClickLock) {
      var x = e.clientX - this.getBoundingClientRect().left;
      var y = e.clientY - this.getBoundingClientRect().top;
      if (this.JSChartContainer.TryClickLock(x, y)) return;
    }


    var drag =
    {
      "Click": {},
      "LastMove": {} //最后移动的位置
    };

    drag.Click.X = e.clientX;
    drag.Click.Y = e.clientY;
    drag.LastMove.X = e.clientX;
    drag.LastMove.Y = e.clientY;

    this.JSChartContainer.MouseDrag = drag;
    document.JSChartContainer = this.JSChartContainer;
    this.JSChartContainer.SelectChartDrawPicture = null;

    uielement.ondblclick = function (e) {
      var x = e.clientX - this.getBoundingClientRect().left;
      var y = e.clientY - this.getBoundingClientRect().top;

      if (this.JSChartContainer)
      this.JSChartContainer.OnDoubleClick(x, y, e);
    };

    document.onmousemove = function (e) {
      if (!this.JSChartContainer) return;
      //加载数据中,禁用鼠标事件
      if (this.JSChartContainer.ChartSplashPaint && this.JSChartContainer.ChartSplashPaint.IsEnableSplash == true) return;

      var drag = this.JSChartContainer.MouseDrag;
      if (!drag) return;

      var moveSetp = Math.abs(drag.LastMove.Y - e.clientY);

      if (this.JSChartContainer.DragMode == 1) //数据左右拖拽
        {
          if (moveSetp < 5) return;

          var isLeft = true;
          if (drag.LastMove.Y < e.clientY) isLeft = false; //右移数据

          if (this.JSChartContainer.DataMove(moveSetp, isLeft)) {
            this.JSChartContainer.UpdataDataoffset();
            this.JSChartContainer.UpdatePointByCursorIndex();
            this.JSChartContainer.UpdateFrameMaxMin();
            this.JSChartContainer.ResetFrameXYSplit();
            this.JSChartContainer.Draw();
          }

          drag.LastMove.X = e.clientX;
          drag.LastMove.Y = e.clientY;
        }
    };

    document.onmouseup = function (e) {
      //清空事件
      document.onmousemove = null;
      document.onmouseup = null;

      //清空数据
      this.JSChartContainer.MouseDrag = null;
      this.JSChartContainer.CurrentChartDrawPicture = null;
      this.JSChartContainer = null;
    };
  };

  //创建
  //windowCount 窗口个数
  this.Create = function (windowCount) {
    this.UIElement.JSChartContainer = this;

    //创建十字光标
    this.ChartCorssCursor = new _umychartChartpaintWechat.JSCommonChartPaint_ChartCorssCursor();
    this.ChartCorssCursor.Canvas = this.Canvas;
    this.ChartCorssCursor.StringFormatX = new HQDateStringFormat();
    this.ChartCorssCursor.StringFormatY = new HQPriceStringFormat();

    //创建等待提示
    this.ChartSplashPaint = new _umychartChartpaintWechat.JSCommonChartPaint_ChartSplashPaint();
    this.ChartSplashPaint.Canvas = this.Canvas;
    this.ChartSplashPaint.HQChart = this;

    //创建框架容器
    this.Frame = new HQTradeHScreenFrame();
    this.Frame.ChartBorder = new ChartBorder();
    this.Frame.ChartBorder.UIElement = this.UIElement;
    this.Frame.ChartBorder.Top = 30;
    this.Frame.ChartBorder.Left = 5;
    this.Frame.ChartBorder.Bottom = 20;
    this.Frame.Canvas = this.Canvas;
    this.ChartCorssCursor.Frame = this.Frame; //十字光标绑定框架
    this.ChartSplashPaint.Frame = this.Frame;

    this.CreateChildWindow(windowCount);
    this.CreateMainKLine();

    //子窗口动态标题
    for (var i in this.Frame.SubFrame) {
      var titlePaint = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicChartTitlePainting();
      titlePaint.Frame = this.Frame.SubFrame[i].Frame;
      titlePaint.Canvas = this.Canvas;

      this.TitlePaint.push(titlePaint);
    }
  };

  //创建子窗口
  this.CreateChildWindow = function (windowCount)
  {
    for (var i = 0; i < windowCount; ++i)
    {
      var border = new ChartBorder();
      border.UIElement = this.UIElement;

      var frame = new KLineHScreenFrame();
      frame.Canvas = this.Canvas;
      frame.ChartBorder = border;
      frame.Identify = i; //窗口序号
      frame.RightSpaceCount = this.RightSpaceCount; //右边

      if (this.ModifyIndexDialog) frame.ModifyIndexEvent = this.ModifyIndexDialog.DoModal; //绑定菜单事件
      if (this.ChangeIndexDialog) frame.ChangeIndexEvent = this.ChangeIndexDialog.DoModal;

      frame.HorizontalMax = 20;
      frame.HorizontalMin = 10;

      if (i == 0)
      {
        frame.YSplitOperator = new _umychartFramesplitWechat.JSCommonSplit_FrameSplitKLinePriceY();
        frame.YSplitOperator.FrameSplitData = this.FrameSplitData.get('price');
        //主图上下间距
        border.TopSpace = 12;
        border.BottomSpace = 12;
      } else

      {
        frame.YSplitOperator = new _umychartFramesplitWechat.JSCommonSplit_FrameSplitY();
        frame.YSplitOperator.FrameSplitData = this.FrameSplitData.get('double');
        //frame.IsLocked = true;
      }

      frame.YSplitOperator.Frame = frame;
      frame.YSplitOperator.ChartBorder = border;
      frame.XSplitOperator = new _umychartFramesplitWechat.JSCommonSplit_FrameSplitKLineX();
      frame.XSplitOperator.Frame = frame;
      frame.XSplitOperator.ChartBorder = border;

      if (i != windowCount - 1) frame.XSplitOperator.ShowText = false;

      for (var j = frame.HorizontalMin; j <= frame.HorizontalMax; j += 1)
      {
        frame.HorizontalInfo[j] = new _umychartFramesplitWechat.JSCommonSplit_CoordinateInfo();
        frame.HorizontalInfo[j].Value = j;
        if (i == 0 && j == frame.HorizontalMin) continue;

        frame.HorizontalInfo[j].Message[1] = j.toString();
        frame.HorizontalInfo[j].Font = "14px 微软雅黑";
      }

      var subFrame = new SubFrameItem();
      subFrame.Frame = frame;
      if (i == 0)
      subFrame.Height = 20;else

      subFrame.Height = 10;

      this.Frame.SubFrame[i] = subFrame;
    }
  };
}

////////////////////////////////////////////////////////////////////////////////
//  走势图横屏显示
//
function MinuteChartHScreenContainer(uielement) {
  this.newMethod = MinuteChartContainer; //派生
  this.newMethod(uielement);
  delete this.newMethod;

  this.ClassName = 'MinuteChartHScreenContainer';

  this.OnMouseMove = function (x, y, e) {
    this.LastPoint.X = x;
    this.LastPoint.Y = y;
    this.CursorIndex = this.Frame.GetXData(y);

    this.DrawDynamicInfo();
  };

  //创建
  //windowCount 窗口个数
  this.Create = function (windowCount) {
    this.UIElement.JSChartContainer = this;

    //创建十字光标
    this.ChartCorssCursor = new _umychartChartpaintWechat.JSCommonChartPaint_ChartCorssCursor();
    this.ChartCorssCursor.Canvas = this.Canvas;
    this.ChartCorssCursor.StringFormatX = new HQMinuteTimeStringFormat();
    this.ChartCorssCursor.StringFormatY = new HQPriceStringFormat();

    //创建等待提示
    this.ChartSplashPaint = new _umychartChartpaintWechat.JSCommonChartPaint_ChartSplashPaint();
    this.ChartSplashPaint.Canvas = this.Canvas;
    this.ChartSplashPaint.SplashTitle = this.LoadDataSplashTitle;

    //创建框架容器
    this.Frame = new HQTradeHScreenFrame();
    this.Frame.ChartBorder = new ChartBorder();
    this.Frame.ChartBorder.UIElement = this.UIElement;
    this.Frame.ChartBorder.Top = 25;
    this.Frame.ChartBorder.Left = 50;
    this.Frame.ChartBorder.Bottom = 20;
    this.Frame.Canvas = this.Canvas;
    this.ChartCorssCursor.Frame = this.Frame; //十字光标绑定框架
    this.ChartSplashPaint.Frame = this.Frame;

    this.CreateChildWindow(windowCount);
    this.CreateMainKLine();

    //子窗口动态标题
    for (var i in this.Frame.SubFrame) {
      var titlePaint = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicChartTitlePainting();
      titlePaint.Frame = this.Frame.SubFrame[i].Frame;
      titlePaint.Canvas = this.Canvas;

      this.TitlePaint.push(titlePaint);
    }

    this.ChartCorssCursor.StringFormatX.Frame = this.Frame.SubFrame[0].Frame;
  };

  //创建子窗口
  this.CreateChildWindow = function (windowCount) {
    for (var i = 0; i < windowCount; ++i) {
      var border = new ChartBorder();
      border.UIElement = this.UIElement;

      var frame = new MinuteHScreenFrame();
      frame.Canvas = this.Canvas;
      frame.ChartBorder = border;
      if (i < 2) frame.ChartBorder.TitleHeight = 0;
      frame.XPointCount = 243;

      var DEFAULT_HORIZONTAL = [9, 8, 7, 6, 5, 4, 3, 2, 1];
      frame.HorizontalMax = DEFAULT_HORIZONTAL[0];
      frame.HorizontalMin = DEFAULT_HORIZONTAL[DEFAULT_HORIZONTAL.length - 1];

      if (i == 0) {
        frame.YSplitOperator = new _umychartFramesplitWechat.JSCommonSplit_FrameSplitMinutePriceY();
        frame.YSplitOperator.FrameSplitData = this.FrameSplitData.get('price');
      } else
      {
        frame.YSplitOperator = new _umychartFramesplitWechat.JSCommonSplit_FrameSplitY();
        frame.YSplitOperator.FrameSplitData = this.FrameSplitData.get('double');
      }

      frame.YSplitOperator.Frame = frame;
      frame.YSplitOperator.ChartBorder = border;
      frame.XSplitOperator = new _umychartFramesplitWechat.JSCommonSplit_FrameSplitMinuteX();
      frame.XSplitOperator.Frame = frame;
      frame.XSplitOperator.ChartBorder = border;
      if (i != windowCount - 1) frame.XSplitOperator.ShowText = false;
      frame.XSplitOperator.Operator();

      for (var j in DEFAULT_HORIZONTAL) {
        frame.HorizontalInfo[j] = new _umychartFramesplitWechat.JSCommonSplit_CoordinateInfo();
        frame.HorizontalInfo[j].Value = DEFAULT_HORIZONTAL[j];
        if (i == 0 && j == frame.HorizontalMin) continue;

        frame.HorizontalInfo[j].Message[1] = DEFAULT_HORIZONTAL[j].toString();
        frame.HorizontalInfo[j].Font = "14px 微软雅黑";
      }

      var subFrame = new SubFrameItem();
      subFrame.Frame = frame;
      if (i == 0)
      subFrame.Height = 20;else

      subFrame.Height = 10;

      this.Frame.SubFrame[i] = subFrame;
    }
  };

}

////////////////////////////////////////////////////////////////////////////////
//  K线训练,包含横屏 
//
function KLineTrainChartContainer(uielement, bHScreen)
{
  if (bHScreen === true)
  {
    this.newMethod = KLineChartHScreenContainer; //派生
    this.newMethod(uielement);
    delete this.newMethod;
  } else

  {
    this.newMethod = KLineChartContainer; //派生
    this.newMethod(uielement);
    delete this.newMethod;
  }

  this.ClassName2 = 'KLineTrainChartContainer';
  this.BuySellPaint; //买卖点画法
  this.TrainDataCount = 300; //训练数据个数
  this.AutoRunTimer = null; //K线自动前进定时器
  this.BuySellData = []; //模拟买卖数据 {Buy:{Price:价格,Date:日期,Time:时间} , Sell:{Price:价格,Date:日期,Time:时间} 
  this.TrainDataIndex; //当前训练的数据索引
  this.TrainCallback; //训练回调 (K线每前进一次就调用一次)
  this.DragMode = 1;

  this.TrainStartEnd = {};
  this.KLineSourceData; //原始K线数据 对应 SourceData
  this.TrainInfo = { Start: {}, End: {} }; // Index:数据索引, Date:日期  Time:时间

  this.CreateBuySellPaint = function () //在主窗口建立以后 创建买卖点
  {
    var chart = new _umychartChartpaintWechat.JSCommonChartPaint_ChartBuySell();
    chart.Canvas = this.Canvas;
    chart.ChartBorder = this.Frame.SubFrame[0].Frame.ChartBorder;
    chart.ChartFrame = this.Frame.SubFrame[0].Frame;
    chart.Name = "KLine-Train-BuySell";
    this.ChartPaintEx[0] = chart;
  };

  this.GetKDataIndexByDateTime = function (kData, dateTime)
  {
    if (!dateTime || !kData) return -1;

    for (var i in kData)
    {
      var item = kData[i];
      if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(this.Period, true))
      {
        if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(this.TrainStartDate.Time))
        {
          if (item.Date >= this.TrainStartDate.Date && item.Time >= this.TrainStartDate.Time)
          return parseInt(i);
        } else

        {
          if (item.Date >= this.TrainStartDate.Date)
          return parseInt(i);
        }
      } else
      if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(this.Period, true) || _umychartDataWechat.JSCommon_ChartData.IsTickPeriod(this.Period))
      {
        if (item.Date >= this.TrainStartDate.Date)
        return parseInt(i);
      }
    }

    return -1;
  };

  this.AfterBindMainData = function (funcName)
  {
    if (!this.ChartPaintEx[0]) this.CreateBuySellPaint();

    var hisData = this.ChartPaint[0].Data;
    this.ChartPaintEx[0].Data = hisData;

    var showItem = hisData.Data[hisData.Data.length - 1];

    //最后一个显示数据
    this.TrainInfo.LastShowData = showItem;
    //最后一个原始数据
    this.TrainInfo.LastData = this.SourceData.Data[this.SourceData.Data.length - 1];

    if (funcName != 'Update')
    this.UpdateTrainUICallback("开始");
  };

  this.BeforeBindMainData = function (funcName)
  {
    if (funcName == "Update") return;

    //全量数据 需要过滤
    this.KLineSourceData = new _umychartDataWechat.JSCommon_ChartData();
    this.KLineSourceData.Data = this.SourceData.Data.slice(0);
    var count = this.SourceData.Data.length;
    var lEnd = count - this.TrainDataCount - 20;
    var findIndex = this.GetKDataIndexByDateTime(this.SourceData.Data, this.TrainStartDate);
    if (findIndex >= 0)
    {
      lEnd = findIndex + 1;
      if (count - lEnd < this.TrainDataCount) this.TrainDataCount = count - lEnd;
    }

    //训练起始日期
    var index = lEnd - 1;
    var kItem = this.SourceData.Data[index];
    this.TrainInfo.Start.Index = index;
    this.TrainInfo.Start.Date = kItem.Date;
    this.TrainInfo.Start.Time = kItem.Time;

    //训练结束日期
    this.TrainInfo.End.Index = index;
    this.TrainInfo.End.Date = kItem.Date;
    this.TrainInfo.End.Time = kItem.Time;

    //最后一个数据
    this.TrainInfo.LastData = kItem;

    //修改数据个数
    this.SourceData.Data.length = lEnd;
  };

  this.Run = function (option)
  {
    if (this.AutoRunTimer) return;
    if (this.TrainDataCount <= 0) return;

    var self = this;
    this.AutoRunTimer = setInterval(function () {
      if (!self.MoveNextKLineData(option)) clearInterval(self.AutoRunTimer);
    }, 1000);
  };

  this.MoveNextKLineData = function (option) //{PageSize:, Step:}
  {
    if (this.TrainDataCount <= 0) return false;

    var step = 1,moveStep = 0;
    if (option && option.Step > 1) step = option.Step;
    for (var i = 0; i < step; ++i)
    {
      var index = this.TrainInfo.End.Index + 1;
      if (index >= this.KLineSourceData.Data.length) break;

      var kItem = this.KLineSourceData.Data[index];
      this.SourceData.Data.push(kItem);

      this.TrainInfo.End.Index = index;
      this.TrainInfo.End.Date = kItem.Date;
      this.TrainInfo.End.Time = kItem.Time;
      --this.TrainDataCount;
      ++moveStep;



      if (this.TrainDataCount <= 0) break;
    }

    if (moveStep == 0) return false;

    //使用当前页数据个数移动K线
    var pageSize = this.Frame.GetCurrentPageSize();
    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(pageSize))
    this.PageSize = pageSize - this.RightSpaceCount;

    this.Update();

    if (this.TrainDataCount <= 0)
    {
      this.FinishTrainData();
      this.UpdateTrainUICallback("结束");
      return false;
    }

    this.UpdateTrainUICallback("训练中");
    return true;
  };

  this.UpdateTrainUICallback = function (description)
  {
    //新的监听事件
    if (!this.mapEvent.has(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.RECV_TRAIN_MOVE_STEP)) return;
    var item = this.mapEvent.get(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.RECV_TRAIN_MOVE_STEP);
    if (!item.Callback) return;

    var data =
    {
      TrainDataCount: this.TrainDataCount,
      BuySellData: this.BuySellData,
      KLine:
      {
        Start: { Index: this.TrainInfo.Start.Index, Date: this.TrainInfo.Start.Date },
        End: { Index: this.TrainInfo.End.Index, Date: this.TrainInfo.End.Date } },

      LastData: this.TrainInfo.LastData,
      LastShowData: this.TrainInfo.LastShowData };

    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(this.TrainInfo.Start.Time)) data.KLine.Start.Time = this.TrainInfo.Start.Time;
    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(this.TrainInfo.End.Time)) data.KLine.End.Time = this.TrainInfo.End.Time;
    if (description) data.Description = description;

    if (this.TrainDataCount <= 0)
    {
      data.Symbol = this.Symbol;
      data.Name = this.Name;
    }

    item.Callback(item, data, this);
  };

  this.FinishTrainData = function ()
  {

  };

  this.Stop = function ()
  {
    if (this.AutoRunTimer != null) clearInterval(this.AutoRunTimer);
    this.AutoRunTimer = null;
  };

  this.BuyOrSell = function (obj, bDraw) //{ Price:价格, Vol:数量, Op: 买/卖 0=buy 1=sell, ID:单号 } bDraw是否立即绘制图标
  {
    var kItem = this.TrainInfo.LastShowData;
    if (!kItem) return false;

    var buySellPaint = this.ChartPaintEx[0];
    if (!buySellPaint) return false;

    var hisData = this.ChartPaint[0].Data;
    if (!hisData || hisData.Data.length <= 0) return false;

    var index = hisData.Data.length - 1; //数据索引
    var buyItem = { Date: this.TrainInfo.End.Date, Time: this.TrainInfo.End.Time, Price: obj.Price, Vol: obj.Vol, Op: 0, ID: obj.ID };
    if (obj.Op == 1) buyItem.Op = 1;
    var key = index;
    buyItem.Key = key;

    this.BuySellData.push(buyItem);
    buySellPaint.AddTradeItem(buyItem);

    if (bDraw == true) this.Draw();
  };

  this.RestartTrain = function (option) // { Symbol:, Period:周期, Right:复权, Train:{ DataCount:, DateTime: } }
  {
    _umychartConsoleWechat.JSConsole.Chart.Log('[KLineTrainChartContainer::RestartTrain] option ', option);

    this.TrainInfo = { Start: {}, End: {} };
    this.BuySellData = [];
    this.KLineSourceData = null;

    var buySellPaint = this.ChartPaintEx[0];
    if (buySellPaint)
    {
      buySellPaint.Data = null;
      buySellPaint.ClearTradeData();
    }

    if (option.Symbol) this.Symbol = option.Symbol;
    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(option.Period)) this.Period = option.Period;
    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(option.Right)) this.Right = option.Right;
    if (option.Train)
    {
      if (option.Train.DataCount > 1) this.TrainDataCount = option.Train.DataCount;
      if (option.Train.DateTime) this.TrainStartDate = option.Train.DateTime;
    }

    var symbol = this.Symbol;
    this.ChangeSymbol(symbol);
  };
}

/////////////////////////////////////////////////////////////////////////////////
//  深度图
//
function DepthChartContainer(uielement)
{
  this.newMethod = JSChartContainer; //派生
  this.newMethod(uielement);
  delete this.newMethod;

  this.ClassName = "DepthChartContainer";
  this.Symbol;

  //数据
  this.MapAsk = new Map();
  this.MapBid = new Map();

  this.IsAutoUpdate = false; //是否自动更新行情数据
  this.AutoUpdateFrequency = 30000; //30秒更新一次数据
  this.AutoUpdateTimer;

  this.DefaultZoom = 0.8; //默认显示80%的盘口 (0 - 1)
  this.MaxVolRate = 1.1;

  this.Create = function (option)
  {
    this.UIElement.JSChartContainer = this;

    //创建十字光标
    this.ChartCorssCursor = new _umychartChartpaintWechat.JSCommonChartPaint_DepthChartCorssCursor();
    this.ChartCorssCursor.Canvas = this.Canvas;
    this.ChartCorssCursor.HQChart = this;
    //this.ChartCorssCursor.StringFormatX=g_DivTooltipDataForamt.Create("CorssCursor_XStringFormat");
    //this.ChartCorssCursor.StringFormatX.LanguageID=this.LanguageID;
    //this.ChartCorssCursor.StringFormatY=g_DivTooltipDataForamt.Create("CorssCursor_YStringFormat");
    //this.ChartCorssCursor.StringFormatY.LanguageID=this.LanguageID;


    //创建等待提示
    this.ChartSplashPaint = new _umychartChartpaintWechat.JSCommonChartPaint_ChartSplashPaint();
    this.ChartSplashPaint.Canvas = this.Canvas;

    //创建框架
    this.Frame = new DepthChartFrame();
    this.Frame.ChartBorder = new ChartBorder();
    this.Frame.ChartBorder.UIElement = this.UIElement;
    this.Frame.ChartBorder.Top = 30;
    this.Frame.ChartBorder.Left = 5;
    this.Frame.ChartBorder.Bottom = 20;
    this.Frame.ChartBorder.TitleHeight = 0;
    this.Frame.Canvas = this.Canvas;

    var ySplitOper = new _umychartFramesplitWechat.JSCommonSplit_FrameSplitY();
    ySplitOper.FrameSplitData = this.FrameSplitData.get('double');
    ySplitOper.LanguageID = this.LanguageID;
    ySplitOper.Frame = this.Frame;
    ySplitOper.SplitCount = 5;
    ySplitOper.IgnoreYValue = [0];
    ySplitOper.LineType = 3;
    ySplitOper.ChartBorder = this.Frame.ChartBorder;
    this.Frame.YSplitOperator = ySplitOper;

    var xSplitOper = new _umychartFramesplitWechat.JSCommonSplit_FrameSplitXDepth();
    xSplitOper.Frame = this.Frame;;
    xSplitOper.ChartBorder = this.Frame.ChartBorder;;
    xSplitOper.LanguageID = this.LanguageID;
    xSplitOper.LineType = 3;
    this.Frame.XSplitOperator = xSplitOper;

    if (this.ChartCorssCursor) this.ChartCorssCursor.Frame = this.Frame; //十字光标绑定框架
    this.ChartSplashPaint.Frame = this.Frame;

    var chartItem = new _umychartChartpaintWechat.JSCommonChartPaint_ChartOrderbookDepth();
    chartItem.Canvas = this.Canvas;
    chartItem.ChartBorder = this.Frame.ChartBorder;
    chartItem.ChartFrame = this.Frame;
    chartItem.Name = "深度图";
    this.ChartPaint.push(chartItem);
  };

  this.ontouchstart = function (e)
  {
    this.IsOnTouch = true;
    this.TouchDrawCount = 0;
    this.PhonePinch = null;

    var isSingleTouch = this.IsSingleTouch(e);
    if (this.EnableScrollUpDown == false || !isSingleTouch) //多点触屏 
      {

      }

    if (this.IsPhoneDragging(e))
    {
      var drag =
      {
        "Click": {},
        "LastMove": {} //最后移动的位置
      };

      var touches = this.GetToucheData(e, this.IsForceLandscape);

      drag.Click.X = touches[0].clientX;
      drag.Click.Y = touches[0].clientY;
      drag.LastMove.X = touches[0].clientX;
      drag.LastMove.Y = touches[0].clientY;

      this.MouseDrag = drag;

      var x = drag.Click.X;
      var y = drag.Click.Y;
      this.OnMouseMove(x, y, e);
    } else
    if (this.IsPhonePinching(e))
    {
      var phonePinch =
      {
        "Start": {},
        "Last": {} };


      var touches = this.GetToucheData(e, this.IsForceLandscape);

      phonePinch.Start = { "X": touches[0].pageX, "Y": touches[0].pageY, "X2": touches[1].pageX, "Y2": touches[1].pageY };
      phonePinch.Last = { "X": touches[0].pageX, "Y": touches[0].pageY, "X2": touches[1].pageX, "Y2": touches[1].pageY };

      this.PhonePinch = phonePinch;
    }
  };

  this.ontouchmove = function (e)
  {
    var touches = this.GetToucheData(e, false);
    if (this.IsPhoneDragging(e))
    {
      var drag = this.MouseDrag;
      if (drag == null)
      {
        var x = touches[0].clientX;
        var y = touches[0].clientY;
        this.OnMouseMove(x, y, e);
      } else

      {
        this.MouseDrag = null;
        var x = touches[0].clientX;
        var y = touches[0].clientY;
        this.OnMouseMove(x, y, e);
      }
    } else
    if (this.IsPhonePinching(e))
    {
      var phonePinch = this.PhonePinch;
      if (!phonePinch) return;

      if (this.EnableZoomUpDown && this.EnableZoomUpDown.Touch === false) return;

      var yHeight = Math.abs(touches[0].pageY - touches[1].pageY);
      var yLastHeight = Math.abs(phonePinch.Last.Y - phonePinch.Last.Y2);
      var yStep = yHeight - yLastHeight;
      var xHeight = Math.abs(touches[0].pageX - touches[1].pageX);
      var xLastHeight = Math.abs(phonePinch.Last.X - phonePinch.Last.X2);
      var xStep = xHeight - xLastHeight;
      var minStep = this.ZoomStepPixel;
      if (Math.abs(yStep) < minStep && Math.abs(xStep) < minStep) return;

      var step = yStep;
      if (Math.abs(yStep) < minStep) step = xStep;

      if (step > 0) //放大
        {
          if (!this.Frame.ZoomUp()) return;
          this.UpdateFrameMaxMin();
          this.Draw();
        } else
        //缩小
        {
          if (!this.Frame.ZoomDown()) return;
          this.UpdateFrameMaxMin();
          this.Draw();
        }

      phonePinch.Last = { "X": touches[0].pageX, "Y": touches[0].pageY, "X2": touches[1].pageX, "Y2": touches[1].pageY };
    }
  };

  this.ontouchend = function (e)
  {
    _umychartConsoleWechat.JSConsole.Chart.Log('[DepthChartContainer::OnTouchEnd]', e);
    this.IsOnTouch = false;
    this.Draw();
    this.TouchDrawCount = 0;
  };

  this.OnMouseMove = function (x, y, e, bFullDraw)
  {
    var lastY = this.LastPoint.Y;
    this.LastPoint.X = x;
    this.LastPoint.Y = y;
    this.FullDraw();
  };

  this.ChangeSymbol = function (symbol)
  {
    this.CancelAutoUpdate(); //先停止定时器
    this.Symbol = symbol;
    this.MapBid = new Map();
    this.MapAsk = new Map();
    this.Frame.VerticalRange.Differ = null;

    this.ChartSplashPaint.SetTitle(this.LoadDataSplashTitle);
    this.ChartSplashPaint.EnableSplash(true);
    this.Draw();

    this.RequestDepthData();
  };

  this.RequestDepthData = function () //全量历史数据
  {
    var self = this;
    if (this.NetworkFilter)
    {
      var obj =
      {
        Name: 'DepthChartContainer::RequestDepthData', //类名::
        Explain: '深度图数据',
        Request: { Data: { symbol: self.Symbol } },
        Self: this,
        PreventDefault: false };

      this.NetworkFilter(obj, function (data)
      {
        self.ChartSplashPaint.EnableSplash(false);
        self.RecvDepthData(data);
        self.AutoUpdate();
      });

      if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求
    }
  };

  this.RecvDepthData = function (data)
  {
    this.UpdateAskAndBid(data);

    var aryAsk = Array.from(this.MapAsk.values()); //卖    右边
    aryAsk.sort(function (a, b) {return a.Price - b.Price;});
    var sumVol = 0;
    for (var i in aryAsk)
    {
      var item = aryAsk[i];
      sumVol += item.Vol;

      aryAsk[i] = { Price: item.Price, Vol: sumVol };
    }

    var aryBid = Array.from(this.MapBid.values()); //买    左边
    aryBid.sort(function (a, b) {return b.Price - a.Price;});
    var sumVol = 0;
    for (var i in aryBid)
    {
      var item = aryBid[i];
      sumVol += item.Vol;

      aryBid[i] = { Price: item.Price, Vol: sumVol };
    }

    var drawData = { Asks: aryAsk, Bids: aryBid };
    var chart = this.ChartPaint[0];
    chart.Data = drawData;

    this.Frame.XSplitOperator.Symbol = this.Symbol;
    this.ChartCorssCursor.Data = drawData;
    this.ChartCorssCursor.Symbol = this.Symbol;

    this.UpdateFramePriceList();
    this.UpdateFrameMaxMin();

    this.Draw();
  };

  this.UpdateAskAndBid = function (data) //更新数据
  {
    if (data.datatype == "snapshot") //全量数据
      {
        this.MapBid = new Map();
        this.MapAsk = new Map();
      }

    for (var i in data.asks)
    {
      var item = data.asks[i];
      var price = parseFloat(item[0]);
      var vol = parseFloat(item[1]);

      if (this.MapAsk.has(price))
      {
        var value = this.MapAsk.get(price);
        if (vol <= 0) this.MapAsk.delete(price);else
        value.Vol = vol;
      } else

      {
        if (vol > 0) this.MapAsk.set(price, { Price: price, Vol: vol });
      }
    }

    for (var i in data.bids)
    {
      var item = data.bids[i];
      var price = parseFloat(item[0]);
      var vol = parseFloat(item[1]);

      if (this.MapBid.has(price))
      {
        var value = this.MapBid.get(price);
        if (vol <= 0) this.MapBid.delete(price);else
        value.Vol = vol;
      } else

      {
        if (vol > 0) this.MapBid.set(price, { Price: price, Vol: vol });
      }
    }
  };

  this.UpdateFramePriceList = function ()
  {
    var aryAskPrice = Array.from(this.MapAsk.keys());
    var aryBidPrice = Array.from(this.MapBid.keys());

    aryAskPrice.sort(function (a, b) {return a - b;});
    aryBidPrice.sort(function (a, b) {return a - b;});

    if (aryAskPrice.length > 1 && aryBidPrice.length > 1)
    {
      var askMin = aryAskPrice[0],askMax = aryAskPrice[aryAskPrice.length - 1];
      var bidMin = aryBidPrice[0],bidMax = aryBidPrice[aryBidPrice.length - 1];
      var askDifference = askMax - askMin; //卖差值
      var bidDifference = bidMax - bidMin; //买差值
      var difference = Math.max(askDifference, bidDifference); //取最大的差值,2边调整

      var ask = { Min: askMin, Max: askMin + difference };
      var bid = { Max: bidMax, Min: bidMax - difference };
      var range = { Max: ask.Max, Min: bid.Min };
    }

    this.Frame.SetPriceList(aryAskPrice, aryBidPrice);
    var xRange = this.Frame.VerticalRange;
    xRange.Max = range.Max;
    xRange.Center = range.Min + (range.Max - range.Min) / 2;
    xRange.Min = range.Min;
    xRange.MaxDiffer = difference; //差值
    xRange.Ask = ask;
    xRange.Bid = bid;
    if (!_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(xRange.Differ))
    xRange.Differ = difference * this.DefaultZoom;

    xRange.Min = xRange.Center - xRange.Differ;
    xRange.Max = xRange.Center + xRange.Differ;
  };

  this.UpdateFrameMaxMin = function ()
  {
    var range = this.ChartPaint[0].GetMaxMin();

    this.Frame.HorizontalMax = range.Max * this.MaxVolRate;
    this.Frame.HorizontalMin = 0;
    this.Frame.XYSplit = true;
  };

  this.CancelAutoUpdate = function () //关闭停止更新
  {
    if (typeof this.AutoUpdateTimer == 'number')
    {
      clearTimeout(this.AutoUpdateTimer);
      this.AutoUpdateTimer = undefined;
    }
  };

  this.StopAutoUpdate = function ()
  {
    this.CancelAutoUpdate();
    if (!this.IsAutoUpdate) return;
    this.IsAutoUpdate = false;
  };

  this.AutoUpdate = function () //数据自动更新
  {
    this.CancelAutoUpdate();
    if (!this.IsAutoUpdate) return;
    if (!this.Symbol) return;
    if (this.IsDestroy) return;

    var self = this;
    var marketStatus = _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.GetMarketStatus(this.Symbol);
    if (marketStatus == 0 || marketStatus == 3) return; //闭市,盘后

    var frequency = this.AutoUpdateFrequency;
    if (marketStatus == 1) //盘前
      {
        this.AutoUpdateTimer = setTimeout(function ()
        {
          self.AutoUpdate();
        }, frequency);
      } else
    if (marketStatus == 2) //盘中
      {
        this.AutoUpdateTimer = setTimeout(function ()
        {
          self.RequestDepthData();
        }, frequency);
      }
  };
}

////////////////////////////////////////////////////////////////////////////////
//  简单的图形框架
//
function SimlpleChartContainer(uielement) {
  this.newMethod = JSChartContainer; //派生
  this.newMethod(uielement);
  delete this.newMethod;

  this.WindowIndex = new Array();
  this.MainDataControl; //主数据类(对外的接口类)
  this.SubDataControl = new Array();
  this.FrameType = 0; //框架类型

  this.YSplitCount = 4;

  //创建
  this.Create = function () {
    this.UIElement.JSChartContainer = this;

    //创建十字光标
    //this.ChartCorssCursor=new ChartCorssCursor();
    //this.ChartCorssCursor.Canvas=this.Canvas;
    //this.ChartCorssCursor.StringFormatX=new HQDateStringFormat();
    //this.ChartCorssCursor.StringFormatY=new HQPriceStringFormat();

    //创建等待提示
    this.ChartSplashPaint = new _umychartChartpaintWechat.JSCommonChartPaint_ChartSplashPaint();
    this.ChartSplashPaint.Canvas = this.Canvas;

    //创建框架容器
    if (this.FrameType == 1) this.Frame = new Rotate90SimpleChartFrame();else
    this.Frame = new SimpleChartFrame();
    this.Frame.ChartBorder = new ChartBorder();
    this.Frame.ChartBorder.UIElement = this.UIElement;
    this.Frame.ChartBorder.Top = 30;
    this.Frame.ChartBorder.Left = 5;
    this.Frame.ChartBorder.Bottom = 20;
    this.Frame.Canvas = this.Canvas;
    if (this.ChartCorssCursor) this.ChartCorssCursor.Frame = this.Frame; //十字光标绑定框架
    this.ChartSplashPaint.Frame = this.Frame;

    this.CreateMainChart();

  };

  this.SetMainDataConotrl = function (dataControl) {
    if (!dataControl) return;

    this.MainDataControl = dataControl;
    this.ChartPaint = []; //图形
    this.Frame.BarCount = 0;

    var yStringFormat = this.Frame.YSplitOperator.StringFormat; //保存配置

    this.CreateMainChart();
    this.Frame.YSplitOperator.StringFormat = yStringFormat; //还原配置
    this.Draw();
    this.RequestData();
  };

  //创建主数据画法
  this.CreateMainChart = function ()
  {
    if (!this.MainDataControl) return;

    var barIndex = 0;
    for (var i in this.MainDataControl.DataType)
    {
      var item = this.MainDataControl.DataType[i];
      if (item.Type == "BAR")
      {
        var chartItem = void 0;
        if (this.FrameType == 1) chartItem = new ChartXYSubBar();else
        chartItem = new ChartSubBar();

        chartItem.BarID = barIndex;
        chartItem.Canvas = this.Canvas;
        chartItem.ChartBorder = this.Frame.ChartBorder;
        chartItem.ChartFrame = this.Frame;
        chartItem.Name = item.Name;
        if (item.Color) chartItem.UpBarColor = item.Color;
        if (item.Color2) chartItem.DownBarColor = item.Color2;

        this.ChartPaint.push(chartItem);
        ++this.Frame.BarCount;
        ++barIndex;
      } else
      if (item.Type == "LINE")
      {
        var _chartItem = new _umychartChartpaintWechat.JSCommonChartPaint_ChartLine();
        _chartItem.Canvas = this.Canvas;
        _chartItem.ChartBorder = this.Frame.ChartBorder;
        _chartItem.ChartFrame = this.Frame;
        _chartItem.Name = item.Name;
        if (item.Color) _chartItem.Color = item.Color;

        this.ChartPaint.push(_chartItem);
      }
    }

    var floatPrecision = 2; //设置纵坐标的小数位数 默认为2
    var ignoreYValue = null;
    if (this.Frame.YSplitOperator)
    {
      floatPrecision = this.Frame.YSplitOperator.FloatPrecision; //备份上次实例化的值
      if (this.Frame.YSplitOperator.IgnoreYValue) ignoreYValue = this.Frame.YSplitOperator.IgnoreYValue;
    }

    this.Frame.YSplitOperator = new _umychartFramesplitWechat.JSCommonSplit_FrameSplitY();
    this.Frame.YSplitOperator.FloatPrecision = floatPrecision; //实例化纵坐标分割后 赋给备份的值
    this.Frame.YSplitOperator.IgnoreYValue = ignoreYValue;

    this.Frame.YSplitOperator.SplitCount = this.YSplitCount;
    this.Frame.YSplitOperator.FrameSplitData = this.FrameSplitData.get('double');
    this.Frame.YSplitOperator.Frame = this.Frame;
    this.Frame.YSplitOperator.ChartBorder = this.Frame.ChartBorder;

    this.Frame.XSplitOperator = new _umychartFramesplitWechat.JSCommonSplit_FrameSplitXData();
    this.Frame.XSplitOperator.Frame = this.Frame;
    this.Frame.XSplitOperator.ChartBorder = this.Frame.ChartBorder;


    // this.TitlePaint[0]=new DynamicKLineTitlePainting();
    // this.TitlePaint[0].Frame=this.Frame.SubFrame[0].Frame;
    // this.TitlePaint[0].Canvas=this.Canvas;
  };

  this.RequestData = function () {
    if (!this.MainDataControl) return;

    this.MainDataControl.JSChartContainer = this;
    this.MainDataControl.RequestData();
  };

  this.UpdateMainData = function (dataControl) {
    var lCount = 0;
    for (var i in dataControl.Data) {
      var itemData = new _umychartDataWechat.JSCommon_ChartData();
      itemData.Data = dataControl.Data[i];
      this.ChartPaint[i].Data = itemData;
      if (lCount < itemData.Data.length) lCount = itemData.Data.length;
    }

    this.Frame.XPointCount = lCount;
    this.Frame.Data = this.ChartPaint[0].Data;
    this.Frame.XData = dataControl.XData;

    this.UpdateFrameMaxMin(); //调整坐标最大 最小值
    this.Frame.SetSizeChage(true);
    this.Draw();
  };

}

////////////////////////////////////////////////////////////////////////////////
//  饼图图形框架
//
function PieChartContainer(uielement) {
  this.Radius; //半径
  this.newMethod = JSChartContainer; //派生
  this.newMethod(uielement);
  delete this.newMethod;

  this.MainDataControl; //主数据类(对外的接口类)

  //鼠标移动
  this.OnMouseMove = function (x, y, e) {};

  //创建
  this.Create = function () {
    this.UIElement.JSChartContainer = this;

    //创建等待提示
    this.ChartSplashPaint = new _umychartChartpaintWechat.JSCommonChartPaint_ChartSplashPaint();
    this.ChartSplashPaint.Canvas = this.Canvas;

    //创建框架容器
    this.Frame = new NoneFrame();
    this.Frame.ChartBorder = new ChartBorder();
    this.Frame.ChartBorder.UIElement = this.UIElement;
    this.Frame.ChartBorder.Top = 30;
    this.Frame.ChartBorder.Left = 5;
    this.Frame.ChartBorder.Bottom = 20;
    this.Frame.Canvas = this.Canvas;

    this.ChartSplashPaint.Frame = this.Frame;
    this.CreateMainChart();
  };

  this.SetMainDataConotrl = function (dataControl) {
    if (!dataControl) return;

    this.MainDataControl = dataControl;
    this.ChartPaint = []; //图形

    this.CreateMainChart();
    this.Draw();
    this.RequestData();
  };

  //创建主数据画法
  this.CreateMainChart = function ()
  {
    if (!this.MainDataControl) return;

    for (var i in this.MainDataControl.DataType)
    {
      var item = this.MainDataControl.DataType[i];
      if (item.Type == "PIE")
      {
        var chartItem = new _umychartChartpaintWechat.JSCommonChartPaint_ChartPie();
        chartItem.Canvas = this.Canvas;
        chartItem.ChartBorder = this.Frame.ChartBorder;
        chartItem.ChartFrame = this.Frame;
        chartItem.Name = item.Name;

        this.ChartPaint.push(chartItem);
      } else
      if (item.Type == 'CIRCLE')
      {
        var chartItem = new _umychartChartpaintWechat.JSCommonChartPaint_ChartCircle();
        chartItem.Canvas = this.Canvas;
        chartItem.ChartBorder = this.Frame.ChartBorder;
        chartItem.ChartFrame = this.Frame;
        chartItem.Name = item.Name;

        this.ChartPaint.push(chartItem);
      } else
      if (item.Type == 'RADAR') //雷达图
        {
          var chartItem = new _umychartChartpaintWechat.JSCommonChartPaint_ChartRadar();
          chartItem.Canvas = this.Canvas;
          chartItem.ChartBorder = this.Frame.ChartBorder;
          chartItem.ChartFrame = this.Frame;
          chartItem.Name = item.Name;
          if (item.StartAngle) chartItem.StartAngle = item.StartAngle;
          if (item.TitleFont) chartItem.TitleFont = item.TitleFont;
          this.ChartPaint.push(chartItem);
        }
    }

    // this.TitlePaint[0]=new DynamicKLineTitlePainting();
    // this.TitlePaint[0].Frame=this.Frame.SubFrame[0].Frame;
    // this.TitlePaint[0].Canvas=this.Canvas;
  };

  this.RequestData = function () {
    if (!this.MainDataControl) return;

    this.MainDataControl.JSChartContainer = this;
    this.MainDataControl.RequestData();
  };

  this.UpdateMainData = function (dataControl) {
    for (var i in dataControl.Data) {
      var itemData = new _umychartDataWechat.JSCommon_ChartData();
      itemData.Data = dataControl.Data[i];
      this.ChartPaint[i].Data = itemData;
    }
    this.Frame.SetSizeChage(true);
    this.Draw();
  };

}

//地图
function MapChartContainer(uielement) {
  this.newMethod = JSChartContainer; //派生
  this.newMethod(uielement);
  delete this.newMethod;

  this.MainDataControl; //主数据类(对外的接口类)

  //鼠标移动
  this.OnMouseMove = function (x, y, e) {

  };

  //创建
  this.Create = function () {
    this.UIElement.JSChartContainer = this;

    //创建等待提示
    this.ChartSplashPaint = new _umychartChartpaintWechat.JSCommonChartPaint_ChartSplashPaint();
    this.ChartSplashPaint.Canvas = this.Canvas;

    //创建框架容器
    this.Frame = new NoneFrame();
    this.Frame.ChartBorder = new ChartBorder();
    this.Frame.ChartBorder.UIElement = this.UIElement;
    this.Frame.ChartBorder.Top = 30;
    this.Frame.ChartBorder.Left = 5;
    this.Frame.ChartBorder.Bottom = 20;
    this.Frame.Canvas = this.Canvas;

    this.ChartSplashPaint.Frame = this.Frame;
    this.CreateMainChart();
  };

  this.SetMainDataConotrl = function (dataControl) {
    if (!dataControl) return;

    this.MainDataControl = dataControl;
    this.ChartPaint = []; //图形

    this.CreateMainChart();
    this.Draw();
    this.RequestData();
  };

  //创建主数据画法
  this.CreateMainChart = function () {
    if (!this.MainDataControl) return;

    var chartItem = new _umychartChartpaintWechat.JSCommonChartPaint_ChartChinaMap();
    chartItem.Canvas = this.Canvas;
    chartItem.ChartBorder = this.Frame.ChartBorder;
    chartItem.ChartFrame = this.Frame;
    chartItem.Name = this.MainDataControl.DataType[0].Name;

    if (this.Radius) chartItem.Radius = this.Radius;

    this.ChartPaint.push(chartItem);

    // this.TitlePaint[0]=new DynamicKLineTitlePainting();
    // this.TitlePaint[0].Frame=this.Frame.SubFrame[0].Frame;
    // this.TitlePaint[0].Canvas=this.Canvas;
  };

  this.RequestData = function () {
    if (!this.MainDataControl) return;

    this.MainDataControl.JSChartContainer = this;
    this.MainDataControl.RequestData();
  };

  this.UpdateMainData = function (dataControl) {
    this.ChartPaint[0].Data = dataControl.Data[0];

    this.Frame.SetSizeChage(true);
    this.Draw();
  };
}

var HQ_DATA_TYPE =
{
  KLINE_ID: 0, //K线
  MINUTE_ID: 2, //当日走势图
  HISTORY_MINUTE_ID: 3, //历史分钟走势图
  MULTIDAY_MINUTE_ID: 4 //多日走势图
};




function APIScriptIndex(name, script, args, option) //后台执行指标
{
  this.newMethod = _umychartIndexWechat.JSCommonIndex_ScriptIndex; //派生
  this.newMethod(name, script, args, option);
  delete this.newMethod;

  this.ApiUrl; //指标执行api地址
  this.HQDataType;

  if (option.API)
  {
    if (option.API.Url) this.ApiUrl = option.API.Url;
    if (option.API.Name) this.Name = this.ID = option.API.Name;
    if (option.API.ID) this.ID = option.API.ID;
  }

  this.ExecuteScript = function (hqChart, windowIndex, hisData)
  {
    _umychartConsoleWechat.JSConsole.Chart.Log('[APIScriptIndex::ExecuteScript] name, Arguments ', this.Name, this.Arguments);

    //数据类型
    var hqDataType = HQ_DATA_TYPE.KLINE_ID; //默认K线
    if (hqChart.ClassName === 'MinuteChartContainer' || hqChart.ClassName === 'MinuteChartHScreenContainer')
    {
      if (hqChart.DayCount > 1) hqDataType = HQ_DATA_TYPE.MULTIDAY_MINUTE_ID; //多日分钟
      else hqDataType = HQ_DATA_TYPE.MINUTE_ID; //分钟数据
    } else
    if (hqChart.ClassName === 'HistoryMinuteChartContainer')
    {
      hqDataType = HQ_DATA_TYPE.HISTORY_MINUTE_ID; //历史分钟
    }

    var args = [];
    if (this.Arguments)
    {
      for (var i in this.Arguments)
      {
        var item = this.Arguments[i];
        args.push({ name: item.Name, value: item.Value });
      }
    }

    var requestCount = hqChart.GetRequestDataCount();
    var self = this;
    var postData =
    {
      indexname: this.ID, symbol: hqChart.Symbol, script: this.Script, args: args,
      period: hqChart.Period, right: hqChart.Right, maxdatacount: requestCount.MaxRequestDataCount, maxminutedaycount: requestCount.MaxRequestMinuteDayCount, hqdatatype: hqDataType };

    if (hqDataType == HQ_DATA_TYPE.MULTIDAY_MINUTE_ID || hqDataType == HQ_DATA_TYPE.MINUTE_ID) postData.daycount = hqChart.DayCount;
    this.HQDataType = hqDataType;

    if (hqChart.NetworkFilter)
    {
      var obj =
      {
        Name: 'APIScriptIndex::ExecuteScript', //类名::
        Explain: '指标计算',
        Request: { Url: self.ApiUrl, Type: 'POST', Data: postData },
        Self: this,
        HQChart: hqChart,
        PreventDefault: false };


      hqChart.NetworkFilter(obj, function (data)
      {
        self.RecvAPIData(data, hqChart, windowIndex, hisData);
      });

      if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求
    }

    wx.request({
      url: self.ApiUrl,
      data: postData,
      method: 'POST',
      dataType: "json",
      async: true,
      success: function success(recvData)
      {
        self.RecvAPIData(recvData, hqChart, windowIndex, hisData);
      },
      error: function error(request)
      {
        self.RecvError(request);
      } });

  };

  this.RecvAPIData = function (recvData, hqChart, windowIndex, hisData)
  {
    var data = recvData.data;
    _umychartConsoleWechat.JSConsole.Chart.Log('[APIScriptIndex::RecvAPIData] recv data ', this.Name, data);
    if (data.code != 0) return;

    if (data.outdata && data.outdata.name) this.Name = data.outdata.name;

    if (data.outdata.args) //外部修改显示参数
      {
        this.Arguments = [];
        for (var i in data.outdata.args)
        {
          var item = data.outdata.args[i];
          this.Arguments.push({ Name: item.name, Value: item.value });
        }
      }

    if (this.HQDataType == HQ_DATA_TYPE.KLINE_ID)
    {
      this.OutVar = this.FittingData(data.outdata, hqChart);
      _umychartConsoleWechat.JSConsole.Chart.Log('[APIScriptIndex::RecvAPIData] conver to OutVar ', this.OutVar);
    } else

    {
      this.OutVar = this.FittingMinuteData(data.outdata, hqChart); //走势图数据
    }
    this.BindData(hqChart, windowIndex, hisData);

    if (this.IsLocked == false) //不上锁
      {
        hqChart.Frame.SubFrame[windowIndex].Frame.SetLock(null);
      } else
      //上锁
      {
        var lockData =
        {
          IsLocked: true, Callback: this.LockCallback, IndexName: this.Name, ID: this.LockID,
          BG: this.LockBG, Text: this.LockText, TextColor: this.LockTextColor, Font: this.LockFont, Count: this.LockCount, MinWidth: this.LockMinWidth };

        hqChart.Frame.SubFrame[windowIndex].Frame.SetLock(lockData);
      }

    hqChart.UpdataDataoffset(); //更新数据偏移
    hqChart.UpdateFrameMaxMin(); //调整坐标最大 最小值
    hqChart.Draw();

    if (hqChart.GetIndexEvent)
    {
      var event = hqChart.GetIndexEvent(); //指标计算完成回调
      if (event)
      {
        var data =
        {
          OutVar: this.OutVar, WindowIndex: windowIndex, Name: this.Name, Arguments: this.Arguments, HistoryData: hisData,
          Stock: { Symbol: hqChart.Symbol, Name: hqChart.Name } };

        event.Callback(event, data, this);
      }
    }
  };

  this.FittingData = function (jsonData, hqChart)
  {
    var outVar = jsonData.outvar;
    var date = jsonData.date;
    var time = jsonData.time;
    var kdata = hqChart.ChartPaint[0].Data;

    //把数据拟合到kdata上
    var result = [];

    for (var i in outVar)
    {
      var item = outVar[i];
      var indexData = [];
      var outVarItem = { Name: item.name, Type: item.type };
      if (item.color) outVarItem.Color = item.color;
      if (item.data)
      {
        outVarItem.Data = this.FittingArray(item.data, date, time, hqChart);

        if (item.color) outVarItem.Color = item.color;
        if (item.linewidth >= 1) outVarItem.LineWidth = item.linewidth;
        if (item.isshow == false) outVarItem.IsShow = false;
        if (item.isexdata == true) outVarItem.IsExData = true;

        result.push(outVarItem);
      } else
      if (item.Draw)
      {
        var draw = item.Draw;
        var drawItem = {};
        if (draw.DrawType == 'DRAWICON') //图标
          {
            drawItem.Icon = draw.Icon;
            drawItem.Name = draw.Name;
            drawItem.DrawType = draw.DrawType;
            drawItem.DrawData = this.FittingArray(draw.DrawData, date, time, hqChart);
            outVarItem.Draw = drawItem;

            result.push(outVarItem);
          } else
        if (draw.DrawType == 'DRAWTEXT') //文本
          {
            drawItem.Text = draw.Text;
            drawItem.Name = draw.Name;
            drawItem.DrawType = draw.DrawType;
            drawItem.DrawData = this.FittingArray(draw.DrawData, date, time, hqChart);
            outVarItem.Draw = drawItem;

            result.push(outVarItem);
          } else
        if (draw.DrawType == 'STICKLINE') //柱子
          {
            drawItem.Name = draw.Name;
            drawItem.Type = draw.Type;
            drawItem.Width = draw.Width;
            drawItem.DrawType = draw.DrawType;
            drawItem.DrawData = this.FittingArray(draw.DrawData, date, time, hqChart, 1);
            outVarItem.Draw = drawItem;

            result.push(outVarItem);
          } else
        if (draw.DrawType == 'MULTI_LINE')
        {
          drawItem.Text = draw.Text;
          drawItem.Name = draw.Name;
          drawItem.DrawType = draw.DrawType;
          drawItem.DrawData = this.FittingMultiLine(draw.DrawData, date, time, hqChart);
          outVarItem.Draw = drawItem;

          result.push(outVarItem);
        } else
        if (draw.DrawType == 'MULTI_BAR')
        {
          drawItem.Text = draw.Text;
          drawItem.Name = draw.Name;
          drawItem.DrawType = draw.DrawType;
          drawItem.DrawData = this.FittingMultiLine(draw.DrawData, date, time, hqChart);
          outVarItem.Draw = drawItem;

          result.push(outVarItem);
        } else
        if (draw.DrawType == 'MULTI_TEXT')
        {
          drawItem.Text = draw.Text;
          drawItem.Name = draw.Name;
          drawItem.DrawType = draw.DrawType;
          drawItem.DrawData = this.FittingMultiText(draw.DrawData, date, time, hqChart);
          this.GetKLineData(drawItem.DrawData, hqChart);
          outVarItem.Draw = drawItem;
          result.push(outVarItem);
        } else
        if (draw.DrawType == "MULTI_HTMLDOM") //外部自己创建dom
          {
            drawItem.Text = draw.Text;
            drawItem.Name = draw.Name;
            drawItem.DrawType = draw.DrawType;
            drawItem.Callback = draw.Callback;
            drawItem.DrawData = this.FittingMultiText(draw.DrawData, date, time, hqChart);
            this.GetKLineData(drawItem.DrawData, hqChart);
            outVarItem.Draw = drawItem;
            result.push(outVarItem);
          } else
        if (draw.DrawType == "KLINE_BG")
        {
          drawItem.Name = draw.Name;
          drawItem.DrawType = draw.DrawType;
          drawItem.DrawData = { Color: draw.Color, Angle: draw.Angle };
          drawItem.DrawData.Data = this.FittingKLineBG(draw.DrawData, hqChart);

          outVarItem.Draw = drawItem;
          outVarItem.Name = draw.DrawType;
          result.push(outVarItem);
        }
      }
    }

    return result;
  };

  // h, high, low l.
  this.GetKLineData = function (data, hqChart)
  {
    if (!data) return;
    if (!Array.isArray(data)) return;
    var kData = hqChart.ChartPaint[0].Data; //K线

    for (var i in data)
    {
      var item = data[i];
      if (!_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsString(item.Value)) continue;
      if (!_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Index)) continue;
      if (item.Index < 0 || item.Index >= kData.Data.length) continue;
      var valueName = item.Value.toUpperCase();
      var kItem = kData.Data[item.Index];
      switch (valueName) {

        case "HIGH":
        case "H":
          item.Value = kItem.High;
          break;
        case "L":
        case "LOW":
          item.Value = kItem.Low;
          break;}

    }
  };

  this.FittingKLineBG = function (data, hqChart)
  {
    var kData = hqChart.ChartPaint[0].Data; //K线
    var result = [];
    if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(hqChart.Period, true)) //日线
      {
        var bFill = false;
        for (var i = 0, j = 0; i < kData.Data.length;)
        {
          result[i] = 0;
          var kItem = kData.Data[i];
          if (j >= data.length)
          {
            ++i;
            continue;
          }
          var dataItem = data[j];

          if (dataItem.Date < kItem.Date)
          {
            ++j;
          } else
          if (dataItem.Date > kItem.Date)
          {
            ++i;
          } else

          {
            bFill = true;
            result[i] = 1;
            ++j;
            ++i;
          }
        }

        if (bFill) return result;
      } else
    if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(hqChart.Period, true)) //分钟线
      {
        var bFill = false;
        for (var i = 0, j = 0; i < kData.Data.length;)
        {
          result[i] = 0;
          var kItem = kData.Data[i];
          if (j >= data.length)
          {
            ++i;
            continue;
          }
          var dataItem = data[j];

          if (dataItem.Date < kItem.Date || dataItem.Date == kItem.Date && dataItem.Time < kItem.Time)
          {
            ++j;
          } else
          if (dataItem.Date > kItem.Date || dataItem.Date == kItem.Date && dataItem.Time > kItem.Time)
          {
            ++i;
          } else

          {
            bFill = true;
            result[i] = 1;
            ++j;
            ++i;
          }
        }

        if (bFill) return result;
      }

    return null;
  };

  this.FittingArray = function (sourceData, date, time, hqChart, arrayType) //arrayType 0=单值数组 1=结构体
  {
    var kdata = hqChart.ChartPaint[0].Data; //K线

    var arySingleData = [];
    for (var i in sourceData)
    {
      var value = sourceData[i];
      var indexItem = new _umychartDataWechat.JSCommon_SingleData(); //单列指标数据
      indexItem.Date = date[i];
      if (time && i < time.length) indexItem.Time = time[i];
      indexItem.Value = value;
      arySingleData.push(indexItem);
    }

    var aryFittingData;
    if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(hqChart.Period, true))
    aryFittingData = kdata.GetFittingData(arySingleData); //数据和主图K线拟合
    else
      aryFittingData = kdata.GetMinuteFittingData(arySingleData); //数据和主图K线拟合

    var bindData = new _umychartDataWechat.JSCommon_ChartData();
    bindData.Data = aryFittingData;
    var result;
    if (arrayType == 1) result = bindData.GetObject();else
    result = bindData.GetValue();
    return result;
  };

  this.FittingMultiLine = function (sourceData, date, time, hqChart)
  {
    var kdata = hqChart.ChartPaint[0].Data; //K线

    if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(hqChart.Period, true)) //日线
      {
        var aryPoint = [];
        for (var i in sourceData)
        {
          var item = sourceData[i];
          for (var j in item.Point)
          {
            var point = item.Point[j];
            aryPoint.push(point);
          }
        }

        aryPoint.sort(function (a, b) {return a.Date - b.Date;});
        kdata.GetDateIndex(aryPoint);
        return sourceData;
      } else
    if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(hqChart.Period, true)) //分钟线
      {
        var aryPoint = [];
        for (var i in sourceData)
        {
          var item = sourceData[i];
          for (var j in item.Point)
          {
            var point = item.Point[j];
            aryPoint.push(point);
          }
        }

        aryPoint.sort(function (a, b) {
          if (a.Date == b.Date) return a.Time - b.Time;
          return a.Date - b.Date;
        });

        kdata.GetDateTimeIndex(aryPoint);
        return sourceData;
      }

    return null;
  };

  this.FittingMultiText = function (sourceData, date, time, hqChart)
  {
    var kdata = hqChart.ChartPaint[0].Data; //K线

    if (_umychartDataWechat.JSCommon_ChartData.IsDayPeriod(hqChart.Period, true)) //日线
      {
        sourceData.sort(function (a, b) {return a.Date - b.Date;});
        kdata.GetDateIndex(sourceData);
        return sourceData;
      } else
    if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(hqChart.Period, true)) //分钟线
      {
        sourceData.sort(function (a, b) {
          if (a.Date == b.Date) return a.Time - b.Time;
          return a.Date - b.Date;
        });


        kdata.GetDateTimeIndex(sourceData);
        return sourceData;
      }

    return null;
  };
}

//市场多空
function MarketLongShortIndex() {
  this.newMethod = _umychartIndexWechat.JSCommonIndex_BaseIndex; //派生
  this.newMethod('市场多空');
  delete this.newMethod;

  this.Index = new Array(
  new _umychartIndexWechat.JSCommonIndex_IndexInfo("多空指标", null),
  new _umychartIndexWechat.JSCommonIndex_IndexInfo("多头区域", null),
  new _umychartIndexWechat.JSCommonIndex_IndexInfo("空头区域", null));


  this.Index[0].LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.LineColor[0];
  this.Index[1].LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.UpBarColor;
  this.Index[2].LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DownBarColor;

  this.LongShortData; //多空数据

  this.Create = function (hqChart, windowIndex) {
    for (var i in this.Index) {
      var paint = null;
      if (i == 0)
      paint = new _umychartChartpaintWechat.JSCommonChartPaint_ChartLine();else

      paint = new ChartStraightLine();

      paint.Color = this.Index[i].LineColor;
      paint.Canvas = hqChart.Canvas;
      paint.Name = this.Name + "-" + i.toString();
      paint.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
      paint.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;

      hqChart.ChartPaint.push(paint);
    }
  };

  //请求数据
  this.RequestData = function (hqChart, windowIndex, hisData) {
    var self = this;
    var param =
    {
      HQChart: hqChart,
      WindowIndex: windowIndex,
      HistoryData: hisData };


    this.LongShortData = [];

    if (param.HQChart.Period > 0) //周期数据
      {
        this.NotSupport(param.HQChart, param.WindowIndex, "不支持周期切换");
        param.HQChart.Draw();
        return false;
      }

    //请求数据
    wx.request({
      url: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.MarketLongShortApiUrl,
      data:
      {},


      method: 'POST',
      dataType: "json",
      async: true,
      success: function success(recvData) {
        self.RecvData(recvData, param);
      } });


    return true;
  };

  this.RecvData = function (recvData, param) {
    if (recvData.data.data.length <= 0) return;

    var aryData = new Array();
    for (var i in recvData.data.data) {
      var item = recvData.data.data[i];
      var indexData = new _umychartDataWechat.JSCommon_SingleData();
      indexData.Date = item[0];
      indexData.Value = item[1];
      aryData.push(indexData);
    }

    var aryFittingData = param.HistoryData.GetFittingData(aryData);

    var bindData = new _umychartDataWechat.JSCommon_ChartData();
    bindData.Data = aryFittingData;
    bindData.Period = param.HQChart.Period; //周期
    bindData.Right = param.HQChart.Right; //复权

    this.LongShortData = bindData.GetValue();
    this.BindData(param.HQChart, param.WindowIndex, param.HistoryData);

    param.HQChart.UpdataDataoffset(); //更新数据偏移
    param.HQChart.UpdateFrameMaxMin(); //调整坐标最大 最小值
    param.HQChart.Draw();

  };


  this.BindData = function (hqChart, windowIndex, hisData) {
    var paint = hqChart.GetChartPaint(windowIndex);

    if (paint.length != this.Index.length) return false;

    //paint[0].Data.Data=SWLData;
    paint[0].Data.Data = this.LongShortData;
    paint[0].NotSupportMessage = null;
    paint[1].Data.Data[0] = 8;
    paint[2].Data.Data[0] = 1;

    //指定[0,9]
    hqChart.Frame.SubFrame[windowIndex].Frame.YSpecificMaxMin = { Max: 9, Min: 0, Count: 3 };

    var titleIndex = windowIndex + 1;

    for (var i in paint) {
      hqChart.TitlePaint[titleIndex].Data[i] = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicTitleData(paint[i].Data, this.Index[i].Name, this.Index[i].LineColor);
      if (i > 0) hqChart.TitlePaint[titleIndex].Data[i].DataType = "StraightLine";
    }

    hqChart.TitlePaint[titleIndex].Title = this.FormatIndexTitle();

    if (hqChart.UpdateUICallback) hqChart.UpdateUICallback('MarketLongShortIndex', paint, { WindowIndex: windowIndex, HistoryData: hisData }); //通知上层回调
    return true;
  };

}

//市场择时
function MarketTimingIndex() {
  this.newMethod = _umychartIndexWechat.JSCommonIndex_BaseIndex; //派生
  this.newMethod('市场择时');
  delete this.newMethod;

  this.Index = new Array(
  new _umychartIndexWechat.JSCommonIndex_IndexInfo("因子择时", null));


  this.TimingData; //择时数据
  this.TitleColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameSplitTextColor;

  this.Create = function (hqChart, windowIndex) {
    for (var i in this.Index) {
      var paint = new _umychartChartpaintWechat.JSCommonChartPaint_ChartMACD();
      paint.Canvas = hqChart.Canvas;
      paint.Name = this.Name + "-" + i.toString();
      paint.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
      paint.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;

      hqChart.ChartPaint.push(paint);
    }
  };

  //请求数据
  this.RequestData = function (hqChart, windowIndex, hisData) {
    var self = this;
    var param =
    {
      HQChart: hqChart,
      WindowIndex: windowIndex,
      HistoryData: hisData };


    this.LongShortData = [];

    if (param.HQChart.Period > 0) //周期数据
      {
        this.NotSupport(param.HQChart, param.WindowIndex, "不支持周期切换");
        param.HQChart.Draw();
        return false;
      }

    //请求数据
    wx.request({
      url: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.MarketLongShortApiUrl,
      data:
      {},


      method: 'POST',
      dataType: "json",
      async: true,
      success: function success(recvData) {
        self.RecvData(recvData, param);
      } });


    return true;
  };

  this.RecvData = function (recvData, param) {
    if (recvData.data.data.length <= 0) return;

    var aryData = new Array();
    for (var i in recvData.data.data) {
      var item = recvData.data.data[i];
      var indexData = new _umychartDataWechat.JSCommon_SingleData();
      indexData.Date = item[0];
      indexData.Value = item[2];
      aryData.push(indexData);
    }

    var aryFittingData = param.HistoryData.GetFittingData(aryData);

    var bindData = new _umychartDataWechat.JSCommon_ChartData();
    bindData.Data = aryFittingData;
    bindData.Period = param.HQChart.Period; //周期
    bindData.Right = param.HQChart.Right; //复权

    this.TimingData = bindData.GetValue();
    this.BindData(param.HQChart, param.WindowIndex, param.HistoryData);

    param.HQChart.UpdataDataoffset(); //更新数据偏移
    param.HQChart.UpdateFrameMaxMin(); //调整坐标最大 最小值
    param.HQChart.Draw();
  };


  this.BindData = function (hqChart, windowIndex, hisData) {
    var paint = hqChart.GetChartPaint(windowIndex);

    if (paint.length != this.Index.length) return false;

    //paint[0].Data.Data=SWLData;
    paint[0].Data.Data = this.TimingData;
    paint[0].NotSupportMessage = null;

    var titleIndex = windowIndex + 1;
    for (var i in paint) {
      hqChart.TitlePaint[titleIndex].Data[i] = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicTitleData(paint[i].Data, this.Index[i].Name, this.TitleColor);
      hqChart.TitlePaint[titleIndex].Data[i].StringFormat = _umychartCharttitleWechat.JSCommonChartTitle_STRING_FORMAT_TYPE.THOUSANDS;
      hqChart.TitlePaint[titleIndex].Data[i].FloatPrecision = 0;
    }

    hqChart.TitlePaint[titleIndex].Title = this.FormatIndexTitle();

    if (hqChart.UpdateUICallback) hqChart.UpdateUICallback('MarketTimingIndex', paint, { WindowIndex: windowIndex, HistoryData: hisData }); //通知上层回调
    return true;
  };
}

//市场关注度
function MarketAttentionIndex() {
  this.newMethod = _umychartIndexWechat.JSCommonIndex_BaseIndex; //派生
  this.newMethod('市场关注度');
  delete this.newMethod;

  this.Index = new Array(
  new _umychartIndexWechat.JSCommonIndex_IndexInfo("市场关注度指数", null));


  this.Data; //关注度数据
  this.TitleColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameSplitTextColor;
  this.ApiUrl = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.MarketAttentionApiUrl;

  this.Create = function (hqChart, windowIndex) {
    for (var i in this.Index) {
      var paint = new ChartBar(); //柱子
      paint.Canvas = hqChart.Canvas;
      paint.Name = this.Name + "-" + i.toString();
      paint.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
      paint.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;
      paint.UpBarColor = paint.DownBarColor = 'rgb(243,152,0)';

      hqChart.ChartPaint.push(paint);
    }
  };

  //调整框架
  this.SetFrame = function (hqChart, windowIndex, hisData) {
    hqChart.Frame.SubFrame[windowIndex].Frame.YSpecificMaxMin = { Max: 6, Min: 0, Count: 3 };
  };

  //请求数据
  this.RequestData = function (hqChart, windowIndex, hisData) {
    var self = this;
    var param =
    {
      HQChart: hqChart,
      WindowIndex: windowIndex,
      HistoryData: hisData };


    this.Data = [];

    if (param.HQChart.Period > 0) //周期数据
      {
        this.NotSupport(param.HQChart, param.WindowIndex, "不支持周期切换");
        param.HQChart.Draw();
        return false;
      }

    //请求数据
    wx.request({
      url: this.ApiUrl,
      data:
      {
        "symbol": param.HQChart.Symbol,
        "startdate": 20100101 },

      method: 'POST',
      dataType: "json",
      success: function success(recvData) {
        self.RecvData(recvData.data, param);
      } });


    return true;
  };

  this.RecvData = function (recvData, param) {
    if (recvData.date.length < 0) return;

    var aryData = new Array();
    for (var i in recvData.date) {
      var indexData = new _umychartDataWechat.JSCommon_SingleData();
      indexData.Date = recvData.date[i];
      indexData.Value = recvData.value[i];
      aryData.push(indexData);
    }

    var aryFittingData = param.HistoryData.GetFittingData(aryData);

    var bindData = new _umychartDataWechat.JSCommon_ChartData();
    bindData.Data = aryFittingData;
    bindData.Period = param.HQChart.Period; //周期
    bindData.Right = param.HQChart.Right; //复权

    this.Data = bindData.GetValue();
    this.BindData(param.HQChart, param.WindowIndex, param.HistoryData);
    this.SetFrame(param.HQChart, param.WindowIndex, param.HistoryData);

    param.HQChart.UpdataDataoffset(); //更新数据偏移
    param.HQChart.UpdateFrameMaxMin(); //调整坐标最大 最小值
    param.HQChart.Draw();

    // if (typeof (this.UpdateUICallback) == 'function') this.UpdateUICallback('RecvHistoryData', this);
  };


  this.BindData = function (hqChart, windowIndex, hisData) {
    var paint = hqChart.GetChartPaint(windowIndex);

    if (paint.length != this.Index.length) return false;

    //paint[0].Data.Data=SWLData;
    paint[0].Data.Data = this.Data;
    paint[0].NotSupportMessage = null;

    var titleIndex = windowIndex + 1;

    for (var i in paint) {
      hqChart.TitlePaint[titleIndex].Data[i] = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicTitleData(paint[i].Data, this.Index[i].Name, this.TitleColor);
      hqChart.TitlePaint[titleIndex].Data[i].StringFormat = _umychartCharttitleWechat.JSCommonChartTitle_STRING_FORMAT_TYPE.THOUSANDS;
      hqChart.TitlePaint[titleIndex].Data[i].FloatPrecision = 0;
    }

    hqChart.TitlePaint[titleIndex].Title = this.FormatIndexTitle();
    return true;
  };
}


/*
      行业,指数热度
  */
function MarketHeatIndex() {
  this.newMethod = _umychartIndexWechat.JSCommonIndex_BaseIndex; //派生
  this.newMethod('指数/行业热度');
  delete this.newMethod;

  this.Index = new Array(
  new _umychartIndexWechat.JSCommonIndex_IndexInfo("热度指数", 5),
  new _umychartIndexWechat.JSCommonIndex_IndexInfo('MA', 10),
  new _umychartIndexWechat.JSCommonIndex_IndexInfo('MA', null));


  this.Data; //关注度数据

  this.ApiUrl = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.MarketHeatApiUrl;

  this.Index[0].LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameSplitTextColor;
  this.Index[1].LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.LineColor[0];
  this.Index[2].LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.LineColor[1];

  this.Create = function (hqChart, windowIndex) {
    for (var i in this.Index) {
      var paint = null;
      if (i == 0) {
        paint = new _umychartChartpaintWechat.JSCommonChartPaint_ChartMACD(); //柱子
      } else
      {
        paint = new _umychartChartpaintWechat.JSCommonChartPaint_ChartLine();
        paint.Color = this.Index[i].LineColor;
      }

      paint.Canvas = hqChart.Canvas;
      paint.Name = this.Name + "-" + i.toString();
      paint.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
      paint.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;

      hqChart.ChartPaint.push(paint);
    }
  };

  //请求数据
  this.RequestData = function (hqChart, windowIndex, hisData) {
    var self = this;
    var param =
    {
      HQChart: hqChart,
      WindowIndex: windowIndex,
      HistoryData: hisData };


    this.Data = [];

    if (param.HQChart.Period > 0) //周期数据
      {
        this.NotSupport(param.HQChart, param.WindowIndex, "不支持周期切换");
        param.HQChart.Draw();
        return false;
      }

    //请求数据
    wx.request({
      url: this.ApiUrl,
      data:
      {
        "symbol": param.HQChart.Symbol,
        "startdate": 20100101 },

      method: 'POST',
      dataType: "json",
      success: function success(recvData) {
        self.RecvData(recvData.data, param);
      } });


    return true;
  };

  this.RecvData = function (recvData, param) {
    if (recvData.date.length < 0) return;

    var aryData = new Array();
    for (var i in recvData.date) {
      var indexData = new _umychartDataWechat.JSCommon_SingleData();
      indexData.Date = recvData.date[i];
      indexData.Value = recvData.value[i];
      aryData.push(indexData);
    }

    var aryFittingData = param.HistoryData.GetFittingData(aryData);

    var bindData = new _umychartDataWechat.JSCommon_ChartData();
    bindData.Data = aryFittingData;
    bindData.Period = param.HQChart.Period; //周期
    bindData.Right = param.HQChart.Right; //复权

    this.Data = bindData.GetValue();
    this.BindData(param.HQChart, param.WindowIndex, param.HistoryData);

    param.HQChart.UpdataDataoffset(); //更新数据偏移
    param.HQChart.UpdateFrameMaxMin(); //调整坐标最大 最小值
    param.HQChart.Draw();
  };


  this.BindData = function (hqChart, windowIndex, hisData) {
    var paint = hqChart.GetChartPaint(windowIndex);

    if (paint.length != this.Index.length) return false;

    paint[0].Data.Data = this.Data;
    paint[0].NotSupportMessage = null;

    var MA = _umychartHqIndexformulaWechat.JSCommon_HQIndexFormula.MA(this.Data, this.Index[0].Param);
    paint[1].Data.Data = MA;

    var MA2 = _umychartHqIndexformulaWechat.JSCommon_HQIndexFormula.MA(this.Data, this.Index[1].Param);
    paint[2].Data.Data = MA2;

    var titleIndex = windowIndex + 1;

    for (var i in paint) {
      var name = ""; //显示的名字特殊处理
      if (i == 0)
      name = hqChart.Name + this.Index[i].Name;else

      name = "MA" + this.Index[i - 1].Param;
      hqChart.TitlePaint[titleIndex].Data[i] = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicTitleData(paint[i].Data, name, this.Index[i].LineColor);
      hqChart.TitlePaint[titleIndex].Data[i].StringFormat = _umychartCharttitleWechat.JSCommonChartTitle_STRING_FORMAT_TYPE.DEFAULT;
      hqChart.TitlePaint[titleIndex].Data[i].FloatPrecision = 2;

    }

    hqChart.TitlePaint[titleIndex].Title = this.FormatIndexTitle();

    return true;
  };

}

//自定义指数热度
function CustonIndexHeatIndex() {
  this.newMethod = _umychartIndexWechat.JSCommonIndex_BaseIndex; //派生
  this.newMethod('Market-Heat');
  delete this.newMethod;

  this.Index = new Array(
  new _umychartIndexWechat.JSCommonIndex_IndexInfo('区域', 3),
  new _umychartIndexWechat.JSCommonIndex_IndexInfo("热度指数", 10),
  new _umychartIndexWechat.JSCommonIndex_IndexInfo('MA', 5),
  new _umychartIndexWechat.JSCommonIndex_IndexInfo('MA', 10));


  this.Data; //热度数据

  this.ApiUrl = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.CustomIndexHeatApiUrl;

  this.Index[1].LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.LineColor[1];
  this.Index[2].LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.LineColor[2];
  this.Index[3].LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.LineColor[3];

  this.Create = function (hqChart, windowIndex) {
    for (var i in this.Index) {
      var paint = null;
      if (i == 0) {
        paint = new _umychartChartpaintWechat.JSCommonChartPaint_ChartStraightArea();
      } else
      {
        paint = new _umychartChartpaintWechat.JSCommonChartPaint_ChartLine();
        paint.Color = this.Index[i].LineColor;
      }

      paint.Canvas = hqChart.Canvas;
      paint.Name = this.Name + "-" + i.toString();
      paint.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
      paint.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;

      hqChart.ChartPaint.push(paint);
    }
  };

  //请求数据
  this.RequestData = function (hqChart, windowIndex, hisData) {
    var self = this;
    var param =
    {
      HQChart: hqChart,
      WindowIndex: windowIndex,
      HistoryData: hisData };


    this.Data = [];

    if (param.HQChart.Period > 0) //周期数据
      {
        this.NotSupport(param.HQChart, param.WindowIndex, "不支持周期切换");
        param.HQChart.Draw();
        return false;
      }

    //请求数据
    wx.request({
      url: this.ApiUrl,
      data:
      {
        "stock": param.HQChart.CustomStock,
        "date": { "startdate": param.HQChart.QueryDate.Start, "enddate": param.HQChart.QueryDate.End },
        "day": [this.Index[0].Param, this.Index[1].Param] },

      method: 'POST',
      dataType: "json",
      success: function success(recvData) {
        self.RecvData(recvData, param);
      } });


    return true;
  };

  this.RecvData = function (recvData, param) {
    var data = recvData.data;
    if (data.data == null || data.data.length < 0) return;

    //JSConsole.Chart.Log(recvData.data);
    var aryData = new Array();
    for (var i in data.data) {
      var item = data.data[i];
      var indexData = new _umychartDataWechat.JSCommon_SingleData();
      indexData.Date = item[0];
      indexData.Value = item[1];
      aryData.push(indexData);
    }

    var aryFittingData = param.HistoryData.GetFittingData(aryData);

    var bindData = new _umychartDataWechat.JSCommon_ChartData();
    bindData.Data = aryFittingData;
    bindData.Period = param.HQChart.Period; //周期
    bindData.Right = param.HQChart.Right; //复权

    this.Data = bindData.GetValue();
    this.BindData(param.HQChart, param.WindowIndex, param.HistoryData);

    param.HQChart.UpdataDataoffset(); //更新数据偏移
    param.HQChart.UpdateFrameMaxMin(); //调整坐标最大 最小值
    param.HQChart.Draw();
  };


  this.BindData = function (hqChart, windowIndex, hisData) {
    var paint = hqChart.GetChartPaint(windowIndex);

    if (paint.length != this.Index.length) return false;

    paint[0].NotSupportMessage = null;

    paint[0].Data.Data =
    [
    { Value: 0, Value2: 0.2, Color: 'rgb(46,139,87)', Title: '较差区', TitleColor: 'rgb(245,255 ,250)' },
    { Value: 0.19, Value2: 0.4, Color: 'rgb(255,140,0)', Title: '变热区', TitleColor: 'rgb(245,255 ,250)' },
    { Value: 0.39, Value2: 0.8, Color: 'rgb(255,106,106)', Title: '较好区', TitleColor: 'rgb(245,255 ,250)' },
    { Value: 0.79, Value2: 1, Color: 'rgb(255,69,0)', Title: '过热区', TitleColor: 'rgb(245,255 ,250)' }];


    paint[1].Data.Data = this.Data;

    var MA = _umychartHqIndexformulaWechat.JSCommon_HQIndexFormula.MA(this.Data, this.Index[2].Param);
    paint[2].Data.Data = MA;

    var MA2 = _umychartHqIndexformulaWechat.JSCommon_HQIndexFormula.MA(this.Data, this.Index[3].Param);
    paint[3].Data.Data = MA2;

    //指定框架最大最小[0,1]
    hqChart.Frame.SubFrame[windowIndex].Frame.YSpecificMaxMin = { Max: 1, Min: 0, Count: 3 };

    var titleIndex = windowIndex + 1;

    for (var i = 1; i < paint.length; ++i) {
      var name = this.Index[i].Name; //显示的名字特殊处理
      if (name == 'MA') name = "MA" + this.Index[i].Param;
      hqChart.TitlePaint[titleIndex].Data[i] = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicTitleData(paint[i].Data, name, this.Index[i].LineColor);
      hqChart.TitlePaint[titleIndex].Data[i].StringFormat = _umychartCharttitleWechat.JSCommonChartTitle_STRING_FORMAT_TYPE.DEFAULT;
      hqChart.TitlePaint[titleIndex].Data[i].FloatPrecision = 2;
    }


    hqChart.TitlePaint[titleIndex].Title = '热度' + '(' + this.Index[0].Param + ',' + this.Index[1].Param + ',' + this.Index[2].Param + ',' + this.Index[3].Param + ')';

    return true;
  };

}

/*
      本福特系数(财务粉饰)
  */
function BenfordIndex() {
  this.newMethod = _umychartIndexWechat.JSCommonIndex_BaseIndex; //派生
  this.newMethod('财务风险');
  delete this.newMethod;

  this.Index = new Array(
  new _umychartIndexWechat.JSCommonIndex_IndexInfo('区域', null),
  new _umychartIndexWechat.JSCommonIndex_IndexInfo("系数", null));


  this.Data; //财务数据

  this.ApiUrl = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.StockHistoryDayApiUrl;

  this.Index[0].LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.LineColor[0];
  this.Index[1].LineColor = 'rgb(105,105,105)';

  this.Create = function (hqChart, windowIndex) {
    for (var i in this.Index) {
      var paint = null;
      if (i == 0)
      paint = new _umychartChartpaintWechat.JSCommonChartPaint_ChartStraightArea();else
      if (i == 1)
      paint = new ChartLineMultiData();

      if (paint) {
        paint.Color = this.Index[i].LineColor;
        paint.Canvas = hqChart.Canvas;
        paint.Name = this.Name + "-" + i.toString();
        paint.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
        paint.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;

        hqChart.ChartPaint.push(paint);
      }
    }
  };

  //请求数据
  this.RequestData = function (hqChart, windowIndex, hisData) {
    var self = this;
    var param =
    {
      HQChart: hqChart,
      WindowIndex: windowIndex,
      HistoryData: hisData };


    this.Data = [];

    if (param.HQChart.Period != 2) //周期数据
      {
        this.NotSupport(param.HQChart, param.WindowIndex, "只支持月线");
        param.HQChart.Draw();
        return false;
      }

    var aryField = ["finance.benford", "announcement2.quarter", "announcement1.quarter", "announcement3.quarter", "announcement4.quarter"];
    var aryCondition =
    [
    { item: ["date", "int32", "gte", "20130101"] },
    {
      item: ["announcement1.year", "int32", "gte", 0,
      "announcement2.year", "int32", "gte", 0,
      "announcement3.year", "int32", "gte", 0,
      "announcement4.year", "int32", "gte", 0,
      "or"] }];


    //请求数据
    wx.request({
      url: this.ApiUrl,
      data:
      {
        "symbol": [param.HQChart.Symbol],
        "field": aryField,
        "condition": aryCondition },

      method: 'POST',
      dataType: "json",
      success: function success(recvData) {
        self.RecvData(recvData, param);
      } });


    return true;
  };

  this.JsonDataToMapSingleData = function (recvData) {
    var stockData = recvData.stock[0].stockday;
    var mapData = new Map();
    for (var i in stockData) {
      var item = stockData[i];
      var indexData = new _umychartDataWechat.JSCommon_SingleData();
      indexData.Date = item.date;
      indexData.Value = new Array();
      if (item.finance1 != null && item.announcement1 != null) {
        var year = item.announcement1.year;
        var quarter = item.announcement1.quarter;
        var value = item.finance1.benford;
        indexData.Value.push({ Year: year, Quarter: quarter, Value: value });
      }
      if (item.finance2 != null && item.announcement2 != null) {
        var _year = item.announcement2.year;
        var _quarter = item.announcement2.quarter;
        var _value = item.finance2.benford;
        indexData.Value.push({ Year: _year, Quarter: _quarter, Value: _value });
      }
      if (item.finance3 != null && item.announcement3 != null) {
        var _year2 = item.announcement3.year;
        var _quarter2 = item.announcement3.quarter;
        var _value2 = item.finance3.benford;
        indexData.Value.push({ Year: _year2, Quarter: _quarter2, Value: _value2 });
      }
      if (item.finance4 != null && item.announcement4 != null) {
        var _year3 = item.announcement4.year;
        var _quarter3 = item.announcement4.quarter;
        var _value3 = item.finance4.benford;
        indexData.Value.push({ Year: _year3, Quarter: _quarter3, Value: _value3 });
      }

      mapData.set(indexData.Date, indexData);
    }

    var aryData = new Array();var _iterator = _createForOfIteratorHelper(
    mapData),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var item = _step.value;
        aryData.push(item[1]);
      }} catch (err) {_iterator.e(err);} finally {_iterator.f();}

    return aryData;
  };

  this.RecvData = function (recvData, param) {
    _umychartConsoleWechat.JSConsole.Chart.Log(recvData);
    if (recvData.data.stock == null || recvData.data.stock.length <= 0) return;

    var aryData = this.JsonDataToMapSingleData(recvData.data);
    var aryFittingData = param.HistoryData.GetFittingMonthData(aryData);

    var bindData = new _umychartDataWechat.JSCommon_ChartData();
    bindData.Data = aryFittingData;
    bindData.Period = param.HQChart.Period; //周期
    bindData.Right = param.HQChart.Right; //复权

    this.Data = bindData.GetValue();
    this.BindData(param.HQChart, param.WindowIndex, param.HistoryData);

    param.HQChart.UpdataDataoffset(); //更新数据偏移
    param.HQChart.UpdateFrameMaxMin(); //调整坐标最大 最小值
    param.HQChart.Draw();
  };


  this.BindData = function (hqChart, windowIndex, hisData) {
    var paint = hqChart.GetChartPaint(windowIndex);

    if (paint.length != this.Index.length) return false;

    paint[0].NotSupportMessage = null;

    paint[0].Data.Data =
    [
    // { Value: 0, Value2: 0.2, Color: 'rgb(50,205,50)', Title: '安全区', TitleColor: 'rgb(245,255 ,250)' },
    // { Value: 0.2, Value2: 0.4, Color: 'rgb(255,140,0)', Title: '预警区', TitleColor: 'rgb(245,255 ,250)' },
    // { Value: 0.4, Value2: 1, Color: 'rgb(255,106,106)', Title: '警示区', TitleColor: 'rgb(245,255 ,250)' }
    { Value: 0, Value2: 0.2, Color: 'rgb(219,255,193)', Title: '安全区', TitleColor: 'rgb(66,192,99)' },
    { Value: 0.2, Value2: 0.4, Color: 'rgb(255,228,170)', Title: '预警区', TitleColor: 'rgb(255,124,3)' },
    { Value: 0.4, Value2: 1, Color: 'rgb(254,219,212)', Title: '警示区', TitleColor: 'rgb(255,0,0)' }];


    paint[1].Data.Data = this.Data;

    //指定框架最大最小[0,1]
    hqChart.Frame.SubFrame[windowIndex].Frame.YSpecificMaxMin = { Max: 1, Min: 0, Count: 3 };
    hqChart.Frame.SubFrame[windowIndex].Frame.YSplitScale = [0.2, 0.4];

    var titleIndex = windowIndex + 1;

    hqChart.TitlePaint[titleIndex].Data[1] = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicTitleData(paint[1].Data, this.Index[1].Name, this.Index[1].LineColor);
    hqChart.TitlePaint[titleIndex].Data[1].DataType = "MultiReport";

    hqChart.TitlePaint[titleIndex].Title = this.FormatIndexTitle();

    return true;
  };
}

//是否是指数代码
function IsIndexSymbol(symbol) {
  var upperSymbol = symbol.toUpperCase();
  if (upperSymbol.indexOf('.SH') > 0) {
    upperSymbol = upperSymbol.replace('.SH', '');
    if (upperSymbol.charAt(0) == '0' && parseInt(upperSymbol) <= 3000) return true;

  } else
  if (upperSymbol.indexOf('.SZ') > 0) {
    upperSymbol = upperSymbol.replace('.SZ', '');
    if (upperSymbol.charAt(0) == '3' && upperSymbol.charAt(1) == '9') return true;
  } else
  if (upperSymbol.indexOf('.CI') > 0) //自定义指数
    {
      return true;
    }

  return false;
}

//导出统一使用JSCommon命名空间名
module.exports =
{
  JSCommon:
  {
    JSCanvasElement: JSCanvasElement,
    JSChart: JSChart,
    Guid: Guid,
    IFrameSplitOperator: _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator,
    ChartData: _umychartDataWechat.JSCommon_ChartData,
    DataPlus: _umychartDataWechat.JSCommon_DataPlus,
    KLineTooltipPaint: _umychartExtendchartWechat.JSCommonExtendChartPaint_KLineTooltipPaint,
    MARKET_SUFFIX_NAME: _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME,
    JSCommonCoordinateData: _umychartCoordinatedataWechat.JSCommonCoordinateData,
    FrameSplitKLineX: _umychartFramesplitWechat.JSCommonSplit_FrameSplitKLineX,
    FrameSplitKLinePriceY: _umychartFramesplitWechat.JSCommonSplit_FrameSplitKLinePriceY,
    JSCHART_EVENT_ID: _umychartDataWechat.JSCommon_JSCHART_EVENT_ID } };

/***/ }),
/* 102 */
/*!*******************************************************************!*\
  !*** I:/out-project/FCoinEx/static/js/umychart.console.wechat.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

//日志输出类
var JSConsole =
{
  Chart: { Log: console.log, Warn: console.warn }, //图形日志
  Complier: { Log: console.log, Warn: console.warn } //编译器日志
};

module.exports =
{
  JSConsole:
  {
    Chart: JSConsole.Chart,
    Complier: JSConsole.Complier } };

/***/ }),
/* 103 */
/*!****************************************************************!*\
  !*** I:/out-project/FCoinEx/static/js/umychart.data.wechat.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";












var _umychartCoordinatedataWechat = __webpack_require__(/*! ./umychart.coordinatedata.wechat.js */ 104); /*
                                                                                        copyright (c) 2018 jones
                                                                                    
                                                                                        http://www.apache.org/licenses/LICENSE-2.0
                                                                                    
                                                                                        开源项目 https://github.com/jones2000/HQChart
                                                                                    
                                                                                        jones_2000@163.com
                                                                                        
                                                                                        行情数据结构 及计算方法
                                                                                    */function Guid() {function S4() {return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);}

  return S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4();
}

//历史K线数据
function HistoryData()
{
  this.Date;
  this.YClose;
  this.Open;
  this.Close;
  this.High;
  this.Low;
  this.Vol;
  this.Amount;
  this.Time; //分钟 HHMM / 秒HHMMSS
  this.FlowCapital = 0; //流通股本
  this.Position = null; //持仓量

  //指数才有的数据
  this.Stop; //停牌家数
  this.Up; //上涨
  this.Down; //下跌
  this.Unchanged; //平盘
}

//数据复制
HistoryData.Copy = function (data)
{
  var newData = new HistoryData();
  newData.Date = data.Date;
  newData.YClose = data.YClose;
  newData.Open = data.Open;
  newData.Close = data.Close;
  newData.High = data.High;
  newData.Low = data.Low;
  newData.Vol = data.Vol;
  newData.Amount = data.Amount;
  newData.Time = data.Time;
  newData.FlowCapital = data.FlowCapital;
  newData.Position = data.Position;

  //指数才有的数据
  newData.Stop = data.Stop;
  newData.Up = data.Up;
  newData.Down = data.Down;
  newData.Unchanged = data.Unchanged;

  return newData;
};

//把数据 src 复制到 dest中
HistoryData.CopyTo = function (dest, src)
{
  dest.Date = src.Date;
  dest.YClose = src.YClose;
  dest.Open = src.Open;
  dest.Close = src.Close;
  dest.High = src.High;
  dest.Low = src.Low;
  dest.Vol = src.Vol;
  dest.Amount = src.Amount;
  dest.Time = src.Time;
  dest.FlowCapital = src.FlowCapital;

  dest.Stop = src.Stop;
  dest.Up = src.Up;
  dest.Down = src.Down;
  dest.Unchanged = src.Unchanged;
};

//数据复权拷贝
HistoryData.CopyRight = function (data, seed)
{
  var newData = new HistoryData();
  newData.Date = data.Date;
  newData.YClose = data.YClose * seed;
  newData.Open = data.Open * seed;
  newData.Close = data.Close * seed;
  newData.High = data.High * seed;
  newData.Low = data.Low * seed;

  newData.Vol = data.Vol;
  newData.Amount = data.Amount;

  newData.FlowCapital = data.FlowCapital;
  newData.Position = data.Position;

  return newData;
};

//分钟数据
function MinuteData()
{
  this.Close;
  this.Open;
  this.High;
  this.Low;
  this.Vol;
  this.Amount;
  this.DateTime;
  this.Increase;
  this.Risefall;
  this.AvPrice;
  this.Date;
  this.Time;
  this.Position = null; //持仓量
}

//单指标数据
function SingleData()
{
  this.Date; //日期
  this.Value; //数据
}


function DataPlus() {}; //外部数据计算方法接口
DataPlus.GetMinutePeriodData = null;
/*
                                     DataPlus.GetMinutePeriodData=function(period,data,self)
                                     {
                                     
                                     }
                                     */

//////////////////////////////////////////////////////////////////////
// 数据集合
function ChartData()
{
  this.Data = new Array();
  this.DataOffset = 0; //数据偏移
  this.Period = 0; //周期 0 日线 1 周线 2 月线 3年线
  this.Right = 0; //复权 0 不复权 1 前复权 2 后复权
  this.Symbol; //股票代码

  this.Data2 = new Array(); //第1组数据 走势图:历史分钟数据

  this.GetCloseMA = function (dayCount)
  {
    var result = new Array();
    for (var i = 0, len = this.Data.length; i < len; i++)
    {
      if (i < dayCount)
      {
        result[i] = null;
        continue;
      }

      var sum = 0;
      for (var j = 0; j < dayCount; j++)
      {
        sum += this.Data[i - j].Close;
      }
      result[i] = sum / dayCount;
    }
    return result;
  };

  this.GetVolMA = function (dayCount)
  {
    var result = new Array();
    for (var i = 0, len = this.Data.length; i < len; i++)
    {
      if (i < dayCount)
      {
        result[i] = null;
        continue;
      }

      var sum = 0;
      for (var j = 0; j < dayCount; j++)
      {
        sum += this.Data[i - j].Vol;
      }
      result[i] = sum / dayCount;
    }
    return result;
  };

  this.GetAmountMA = function (dayCount)
  {
    var result = new Array();
    for (var i = 0, len = this.Data.length; i < len; i++)
    {
      if (i < dayCount)
      {
        result[i] = null;
        continue;
      }

      var sum = 0;
      for (var j = 0; j < dayCount; j++)
      {
        sum += this.Data[i - j].Amount;
      }
      result[i] = sum / dayCount;
    }
    return result;
  };

  //获取收盘价
  this.GetClose = function ()
  {
    var result = new Array();
    for (var i in this.Data)
    {
      result[i] = this.Data[i].Close;
    }

    return result;
  };

  this.GetYClose = function ()
  {
    var result = new Array();
    for (var i in this.Data)
    {
      result[i] = this.Data[i].YClose;
    }

    return result;
  };

  this.GetHigh = function ()
  {
    var result = new Array();
    for (var i in this.Data)
    {
      result[i] = this.Data[i].High;
    }

    return result;
  };

  this.GetLow = function ()
  {
    var result = new Array();
    for (var i in this.Data)
    {
      result[i] = this.Data[i].Low;
    }

    return result;
  };

  this.GetOpen = function ()
  {
    var result = new Array();
    for (var i in this.Data)
    {
      result[i] = this.Data[i].Open;
    }

    return result;
  };

  this.GetVol = function ()
  {
    var result = new Array();
    for (var i in this.Data)
    {
      result[i] = this.Data[i].Vol;
    }

    return result;
  };

  this.GetAmount = function ()
  {
    var result = new Array();
    for (var i in this.Data)
    {
      result[i] = this.Data[i].Amount;
    }

    return result;
  };

  this.GetPosition = function ()
  {
    var result = new Array();
    for (var i in this.Data)
    {
      result[i] = this.Data[i].Position;
    }

    return result;
  };

  this.GetDate = function ()
  {
    var result = [];
    for (var i in this.Data)
    {
      result[i] = this.Data[i].Date;
    }

    return result;
  };

  this.GetTime = function ()
  {
    var result = [];
    for (var i in this.Data)
    {
      result[i] = this.Data[i].Time;
    }

    return result;
  };

  this.GetUp = function () //上涨家数
  {
    var result = [];
    for (var i in this.Data) {
      result[i] = this.Data[i].Up;
    }

    return result;
  };

  this.GetDown = function () //下跌家数
  {
    var result = [];
    for (var i in this.Data) {
      result[i] = this.Data[i].Down;
    }

    return result;
  };

  this.GetYear = function ()
  {
    var result = new Array();
    for (var i in this.Data)
    {
      result[i] = parseInt(this.Data[i].Date / 10000);
    }

    return result;
  };

  this.GetMonth = function ()
  {
    var result = new Array();
    for (var i in this.Data)
    {
      result[i] = parseInt(this.Data[i].Date % 10000 / 100);
    }

    return result;
  };

  //分时图均价
  this.GetAvPrice = function ()
  {
    var result = new Array();
    for (var i in this.Data)
    {
      var value = this.Data[i].AvPrice;
      if (ChartData.IsNumber(value))
      result[i] = value;else

      result[i] = 0;
    }

    return result;
  };

  //获取数据日期和时间范围
  this.GetDateRange = function ()
  {
    if (!this.Data || this.Data.length <= 0) return null;

    var start = this.Data[0];
    var end = this.Data[this.Data.length - 1];
    var range = { Start: { Date: start.Date }, End: { Date: end.Date } };
    if (ChartData.IsNumber(start.Time)) range.Start.Time = start.Time;
    if (ChartData.IsNumber(end.Time)) range.End.Time = end.Time;

    return range;
  };


  this.GetDateIndex = function (data) //日期转化 对应数据索引
  {
    for (var i = 0, j = 0; i < this.Data.length;)
    {
      var date = this.Data[i].Date;

      if (j >= data.length) break;

      var dateItem = data[j];

      if (dateItem.Date == date)
      {
        dateItem.Index = i;
        ++j;
      } else
      if (dateItem.Date < date)
      {
        ++j;
      } else

      {
        ++i;
      }
    }
  };


  this.GetDateTimeIndex = function (data) //日期 时间转化 对应数据索引
  {
    for (var i = 0, j = 0; i < this.Data.length;)
    {
      var date = this.Data[i].Date;
      var time = this.Data[i].Time;

      if (j >= data.length) break;

      var dateTimeItem = data[j];

      if (dateTimeItem.Date == date && dateTimeItem.Time == time)
      {
        dateTimeItem.Index = i;
        ++j;
      } else
      if (dateTimeItem.Date < date || dateTimeItem.Date == date && dateTimeItem.Time < time)
      {
        ++j;
      } else

      {
        ++i;
      }
    }
  };

  this.GetMinutePeriodData = function (period)
  {
    if (DataPlus.GetMinutePeriodData) return DataPlus.GetMinutePeriodData(period, this.Data, this);

    if (period > CUSTOM_MINUTE_PERIOD_START && period <= CUSTOM_MINUTE_PERIOD_END)
    return this.GetMinuteCustomPeriodData(period - CUSTOM_MINUTE_PERIOD_START);

    var result = [];
    var periodDataCount = 5;
    if (period == 5)
    periodDataCount = 5;else
    if (period == 6)
    periodDataCount = 15;else
    if (period == 7)
    periodDataCount = 30;else
    if (period == 8)
    periodDataCount = 60;else
    if (period == 11)
    periodDataCount = 120;else
    if (period == 12)
    periodDataCount = 240;else

    return this.Data;
    var bFirstPeriodData = false;
    var newData = null;
    var preTime = null; //上一次的计算时间
    for (var i = 0; i < this.Data.length;)
    {
      bFirstPeriodData = true;
      for (var j = 0; j < periodDataCount && i < this.Data.length; ++i)
      {
        if (bFirstPeriodData)
        {
          newData = new HistoryData();
          result.push(newData);
          bFirstPeriodData = false;
        }
        var minData = this.Data[i];
        if (minData == null)
        {
          ++j;
          continue;
        }
        if (minData.Time == 925 && (preTime == null || preTime != 924)) //9：25, 9:30 不连续就不算个数
          {
          } else
        if (minData.Time == 930 && (preTime == null || preTime != 929))
        {
        } else
        if (minData.Time == 1300 && (preTime == null || preTime != 1259)) //1点的数据 如果不是连续的 就不算个数
          {

          } else

        ++j;
        newData.Date = minData.Date;
        newData.Time = minData.Time;
        preTime = newData.Time;
        if (minData.Open == null || minData.Close == null)
        continue;
        if (newData.Open == null || newData.Close == null)
        {
          newData.Open = minData.Open;
          newData.High = minData.High;
          newData.Low = minData.Low;
          newData.YClose = minData.YClose;
          newData.Close = minData.Close;
          newData.Vol = minData.Vol;
          newData.Amount = minData.Amount;
          newData.Position = minData.Position;
          newData.FlowCapital = minData.FlowCapital;
        } else

        {
          if (newData.High < minData.High)
          newData.High = minData.High;
          if (newData.Low > minData.Low)
          newData.Low = minData.Low;
          newData.Close = minData.Close;
          newData.Vol += minData.Vol;
          newData.Amount += minData.Amount;
          newData.Position = minData.Position;
          newData.FlowCapital = minData.FlowCapital;
        }

        if (i + 1 < this.Data.length) //判断下一个数据是否是不同日期的
          {
            var nextItem = this.Data[i + 1];
            if (nextItem && nextItem.Date != minData.Date) //不同日期的, 周期结束
              {
                ++i;
                break;
              }
          }
      }
    }
    return result;
  };

  //自定义分钟
  this.GetMinuteCustomPeriodData = function (count)
  {
    var result = new Array();
    var periodDataCount = count;
    var bFirstPeriodData = false;
    var newData = null;
    for (var i = 0; i < this.Data.length;)
    {
      bFirstPeriodData = true;
      for (var j = 0; j < periodDataCount && i < this.Data.length; ++i, ++j)
      {
        if (bFirstPeriodData)
        {
          newData = new HistoryData();
          result.push(newData);
          bFirstPeriodData = false;
        }
        var minData = this.Data[i];
        if (minData == null) continue;

        newData.Date = minData.Date;
        newData.Time = minData.Time;
        if (minData.Open == null || minData.Close == null) continue;
        if (newData.Open == null || newData.Close == null)
        {
          newData.Open = minData.Open;
          newData.High = minData.High;
          newData.Low = minData.Low;
          newData.YClose = minData.YClose;
          newData.Close = minData.Close;
          newData.Vol = minData.Vol;
          newData.Amount = minData.Amount;
          newData.FlowCapital = minData.FlowCapital;
          newData.Position = minData.Position;
        } else

        {
          if (newData.High < minData.High) newData.High = minData.High;
          if (newData.Low > minData.Low) newData.Low = minData.Low;
          newData.Close = minData.Close;
          newData.Vol += minData.Vol;
          newData.Amount += minData.Amount;
          newData.FlowCapital = minData.FlowCapital;
          newData.Position = minData.Position;
        }
      }
    }
    return result;
  };

  this.GetDayPeriodData = function (period)
  {
    if (period > CUSTOM_DAY_PERIOD_START && period <= CUSTOM_DAY_PERIOD_END) //自定义周期
      return this.GetDayCustomPeriodData(period - CUSTOM_DAY_PERIOD_START);

    var isBit = _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsBIT(this.Symbol);
    var result = [];
    var index = 0;
    var startDate = 0;
    var weekCount = 2;
    var newData = null;
    for (var i in this.Data)
    {
      var isNewData = false;
      var dayData = this.Data[i];

      switch (period) {

        case 1: //周线
          if (isBit) var fridayDate = ChartData.GetSunday(dayData.Date);else
          var fridayDate = ChartData.GetFirday(dayData.Date);
          if (fridayDate != startDate)
          {
            isNewData = true;
            startDate = fridayDate;
          }
          break;
        case 21: //双周
          if (isBit) var fridayDate = ChartData.GetSunday(dayData.Date);else
          var fridayDate = ChartData.GetFirday(dayData.Date);
          if (fridayDate != startDate)
          {
            ++weekCount;
            if (weekCount >= 2)
            {
              isNewData = true;
              weekCount = 0;
            }
            startDate = fridayDate;
          }
          break;
        case 2: //月线
          if (parseInt(dayData.Date / 100) != parseInt(startDate / 100))
          {
            isNewData = true;
            startDate = dayData.Date;
          }
          break;
        case 3: //年线
          if (parseInt(dayData.Date / 10000) != parseInt(startDate / 10000))
          {
            isNewData = true;
            startDate = dayData.Date;
          }
          break;
        case 9: //季线
          var now = ChartData.GetQuarter(dayData.Date);
          now = parseInt(dayData.Date / 10000) * 10 + now;
          var last = ChartData.GetQuarter(startDate);
          last = parseInt(startDate / 10000) * 10 + last;
          if (now != last)
          {
            isNewData = true;
            startDate = dayData.Date;
          }
          break;}


      if (isNewData)
      {
        newData = new HistoryData();
        newData.Date = dayData.Date;
        result.push(newData);

        if (dayData.Open == null || dayData.Close == null) continue;

        newData.Open = dayData.Open;
        newData.High = dayData.High;
        newData.Low = dayData.Low;
        newData.YClose = dayData.YClose;
        newData.Close = dayData.Close;
        newData.Vol = dayData.Vol;
        newData.Amount = dayData.Amount;
        newData.FlowCapital = dayData.FlowCapital;
        newData.Position = dayData.Position;
      } else

      {
        if (newData == null) continue;
        if (dayData.Open == null || dayData.Close == null) continue;

        if (newData.Open == null || newData.Close == null)
        {
          newData.Open = dayData.Open;
          newData.High = dayData.High;
          newData.Low = dayData.Low;
          newData.YClose = dayData.YClose;
          newData.Close = dayData.Close;
          newData.Vol = dayData.Vol;
          newData.Amount = dayData.Amount;
          newData.FlowCapital = dayData.FlowCapital;
          newData.Position = dayData.Position;
        } else

        {
          if (newData.High < dayData.High) newData.High = dayData.High;
          if (newData.Low > dayData.Low) newData.Low = dayData.Low;

          newData.Close = dayData.Close;
          newData.Vol += dayData.Vol;
          newData.Amount += dayData.Amount;
          newData.Date = dayData.Date;
          newData.FlowCapital = dayData.FlowCapital;
          newData.Position = dayData.Position;
        }
      }
    }

    return result;
  };

  this.GetDayCustomPeriodData = function (count) //自定义日线周期
  {
    var result = [];
    var periodDataCount = count;
    var bFirstPeriodData = false;
    var newData = null;
    for (var i = 0; i < this.Data.length;)
    {
      bFirstPeriodData = true;
      for (var j = 0; j < periodDataCount && i < this.Data.length; ++i, ++j)
      {
        if (bFirstPeriodData)
        {
          newData = new HistoryData();
          result.push(newData);
          bFirstPeriodData = false;
        }
        var dayData = this.Data[i];
        if (dayData == null) continue;

        newData.Date = dayData.Date;

        if (dayData.Open == null || dayData.Close == null) continue;
        if (newData.Open == null || newData.Close == null)
        {
          newData.Open = dayData.Open;
          newData.High = dayData.High;
          newData.Low = dayData.Low;
          newData.YClose = dayData.YClose;
          newData.Close = dayData.Close;
          newData.Vol = dayData.Vol;
          newData.Amount = dayData.Amount;
          newData.FlowCapital = dayData.FlowCapital;
          newData.Position = dayData.Position;
        } else

        {
          if (newData.High < dayData.High) newData.High = dayData.High;
          if (newData.Low > dayData.Low) newData.Low = dayData.Low;
          newData.Close = dayData.Close;
          newData.Vol += dayData.Vol;
          newData.Amount += dayData.Amount;
          newData.Position = dayData.Position;
          newData.FlowCapital = dayData.FlowCapital;
        }
      }
    }
    return result;
  };

  //周期数据 1=周 2=月 3=年 9=季 
  this.GetPeriodData = function (period)
  {
    if (period == 1 || period == 2 || period == 3 || period == 9 || period == 21 || period > CUSTOM_DAY_PERIOD_START && period <= CUSTOM_DAY_PERIOD_END) return this.GetDayPeriodData(period);
    if (period == 5 || period == 6 || period == 7 || period == 8 || period == 11 || period == 12 || period > CUSTOM_MINUTE_PERIOD_START && period <= CUSTOM_MINUTE_PERIOD_END) return this.GetMinutePeriodData(period);
  };

  //复权  0 不复权 1 前复权 2 后复权
  this.GetRightDate = function (right)
  {
    var result = [];
    if (this.Data.length <= 0) return result;

    if (right == 1)
    {
      var index = this.Data.length - 1;
      var seed = 1; //复权系数
      var yClose = this.Data[index].YClose;

      result[index] = HistoryData.Copy(this.Data[index]);

      for (--index; index >= 0; --index)
      {
        if (yClose != this.Data[index].Close) break;
        result[index] = HistoryData.Copy(this.Data[index]);
        yClose = this.Data[index].YClose;
      }

      for (; index >= 0; --index)
      {
        if (yClose != this.Data[index].Close)
        seed *= yClose / this.Data[index].Close;

        result[index] = HistoryData.CopyRight(this.Data[index], seed);

        yClose = this.Data[index].YClose;
      }
    } else
    if (right == 2)
    {
      var index = 0;
      var seed = 1;
      var close = this.Data[index].Close;
      result[index] = HistoryData.Copy(this.Data[index]);

      for (++index; index < this.Data.length; ++index)
      {
        if (close != this.Data[index].YClose) break;
        result[index] = HistoryData.Copy(this.Data[index]);
        close = this.Data[index].Close;
      }

      for (; index < this.Data.length; ++index)
      {
        if (close != this.Data[index].YClose)
        seed *= close / this.Data[index].YClose;

        result[index] = HistoryData.CopyRight(this.Data[index], seed);

        close = this.Data[index].Close;
      }
    }

    return result;
  };

  //叠加数据和主数据拟合,去掉主数据没有日期的数据
  this.GetOverlayData = function (overlayData)
  {
    var result = [];

    for (var i = 0, j = 0; i < this.Data.length;)
    {
      var date = this.Data[i].Date;

      if (j >= overlayData.length)
      {
        result[i] = new HistoryData();
        result[i].Date = date;
        ++i;
        continue;;
      }

      var overlayDate = overlayData[j].Date;

      if (overlayDate == date)
      {
        result[i] = new HistoryData();
        result[i].Date = overlayData[j].Date;
        result[i].YClose = overlayData[j].YClose;
        result[i].Open = overlayData[j].Open;
        result[i].High = overlayData[j].High;
        result[i].Low = overlayData[j].Low;
        result[i].Close = overlayData[j].Close;
        result[i].Vol = overlayData[j].Vol;
        result[i].Amount = overlayData[j].Amount;

        //涨跌家数数据
        result[i].Stop = overlayData[j].Stop;
        result[i].Up = overlayData[j].Up;
        result[i].Down = overlayData[j].Down;
        result[i].Unchanged = overlayData[j].Unchanged;

        ++j;
        ++i;
      } else
      if (overlayDate < date)
      {
        ++j;
      } else

      {
        result[i] = new HistoryData();
        result[i].Date = date;
        ++i;
      }
    }

    return result;
  };


  /*
         技术指标数据方法
     */
  //以主图数据 拟合,返回 SingleData 数组
  this.GetFittingData = function (overlayData)
  {
    var result = new Array();

    for (var i = 0, j = 0; i < this.Data.length;)
    {
      var date = this.Data[i].Date;

      if (j >= overlayData.length)
      {
        result[i] = null;
        ++i;
        continue;;
      }

      var overlayDate = overlayData[j].Date;

      if (overlayDate == date)
      {
        var item = new SingleData();
        item.Date = overlayData[j].Date;
        item.Value = overlayData[j].Value;
        result[i] = item;
        ++j;
        ++i;
      } else
      if (overlayDate < date)
      {
        ++j;
      } else

      {
        result[i] = new SingleData();
        result[i].Date = date;
        ++i;
      }
    }

    return result;
  };

  // 缺省数据使用 emptyValue填充
  this.GetFittingData2 = function (overlayData, emptyValue)
  {
    var result = new Array();

    for (var i = 0, j = 0; i < this.Data.length;)
    {
      var date = this.Data[i].Date;

      if (j >= overlayData.length)
      {
        result[i] = new SingleData();
        result[i].Date = date;
        result[i].Value = emptyValue;
        ++i;
        continue;;
      }

      var overlayDate = overlayData[j].Date;

      if (overlayDate == date)
      {
        var item = new SingleData();
        item.Date = overlayData[j].Date;
        item.Value = overlayData[j].Value;
        result[i] = item;
        ++j;
        ++i;
      } else
      if (overlayDate < date)
      {
        ++j;
      } else

      {
        result[i] = new SingleData();
        result[i].Date = date;
        result[i].Value = emptyValue;
        ++i;
      }
    }

    return result;
  };


  this.GetMinuteFittingData = function (overlayData) //  分钟数据拟合
  {
    var result = [];
    for (var i = 0, j = 0; i < this.Data.length;)
    {
      var date = this.Data[i].Date;
      var time = this.Data[i].Time;

      if (j >= overlayData.length)
      {
        result[i] = null;
        ++i;
        continue;;
      }

      var overlayDate = overlayData[j].Date;
      var overlayTime = overlayData[j].Time;
      var overlayItem = overlayData[j];

      if (overlayDate == date && overlayTime == time)
      {
        var item = new SingleData();
        item.Date = overlayItem.Date;
        item.Time = overlayItem.Time;
        item.Value = overlayItem.Value;
        result[i] = item;
        ++j;
        ++i;
      } else
      if (overlayDate < date || overlayDate == date && overlayTime < time)
      {
        ++j;
      } else

      {
        var item = new SingleData();
        item.Date = date;
        item.Time = time;
        result[i] = item;
        ++i;
      }
    }

    return result;
  };

  //把财报数据拟合到主图数据,返回 SingleData 数组
  this.GetFittingFinanceData = function (financeData)
  {
    var result = [];

    for (var i = 0, j = 0; i < this.Data.length;)
    {
      var date = this.Data[i].Date;

      if (j < financeData.length)
      {
        var fDate = financeData[j].Date;
        if (date < fDate)
        {
          ++i;
          continue;
        }
      }

      if (j + 1 < financeData.length)
      {
        if (financeData[j].Date < date && financeData[j + 1].Date <= date)
        {
          ++j;
          continue;
        }
      }

      var item = new SingleData();
      item.Date = date;
      item.Value = financeData[j].Value;
      item.FinanceDate = financeData[j].Date; //财务日期 调试用
      result[i] = item;

      ++i;
    }

    return result;
  };

  //财务数据拟合到分钟数据上 返回 SingleData 数组
  this.GetMinuteFittingFinanceData = function (financeData)
  {
    var result = [];
    if (!Array.isArray(financeData) || financeData.length <= 0) return result;

    var i = 0;
    var firstItem = financeData[0];
    for (i = 0; i < this.Data.length; ++i)
    {
      var date = this.Data[i].Date;
      var time = this.Data[i].Time;
      if (date > firstItem.Date || date == firstItem.Date && time >= firstItem.Time)
      {
        break;
      }
    }

    for (var j = 0; i < this.Data.length;)
    {
      var date = this.Data[i].Date;
      var time = this.Data[i].Time;

      if (j + 1 < financeData.length)
      {
        if (financeData[j].Date < date && financeData[j + 1].Date <= date ||
        financeData[j].Date == date && financeData[j].Time < time && financeData[j + 1].Time <= time)
        {
          ++j;
          continue;
        }
      }

      var item = new SingleData();
      item.Date = date;
      item.Time = time;
      if (j < financeData.length)
      {
        item.Value = financeData[j].Value;
        item.FinanceDate = financeData[j].Date; //财务日期 调试用
        item.FinanceTime = financeData[j].Time; //财务日期 调试用
      } else

      {
        item.Value = null;
        item.FinanceDate = null;
        item.FinanceTime = null;
      }
      result[i] = item;

      ++i;
    }

    return result;
  };

  //市值计算 financeData.Value 是股数
  this.GetFittingMarketValueData = function (financeData)
  {
    var result = [];

    for (var i = 0, j = 0; i < this.Data.length;)
    {
      var date = this.Data[i].Date;
      var price = this.Data[i].Close;

      if (j + 1 < financeData.length)
      {
        if (financeData[j].Date < date && financeData[j + 1].Date <= date)
        {
          ++j;
          continue;
        }
      }

      var item = new SingleData();
      item.Date = date;
      item.Value = financeData[j].Value * price; //市值计算 收盘价*股数
      item.FinanceDate = financeData[j].Date; //财务日期 调试用
      result[i] = item;

      ++i;
    }

    return result;
  };

  //月线数据拟合
  this.GetFittingMonthData = function (overlayData) {
    var result = new Array();

    var preDate = null;
    for (var i = 0, j = 0; i < this.Data.length;) {
      var date = this.Data[i].Date;

      if (j >= overlayData.length) {
        result[i] = null;
        ++i;
        continue;;
      }

      var overlayDate = overlayData[j].Date;

      if (overlayDate == date) {
        var item = new SingleData();
        item.Date = overlayData[j].Date;
        item.Value = overlayData[j].Value;
        item.Text = overlayData[j].Text;
        result[i] = item;
        ++j;
        ++i;
      } else
      if (preDate != null && preDate < overlayDate && date > overlayDate) {
        var item = new SingleData();
        item.Date = date;
        item.OverlayDate = overlayData[j].Date;
        item.Value = overlayData[j].Value;
        item.Text = overlayData[j].Text;
        result[i] = item;
        ++j;
        ++i;
      } else
      if (overlayDate < date) {
        ++j;
      } else
      {
        result[i] = new SingleData();
        result[i].Date = date;
        ++i;
      }

      preDate = date;
    }

    return result;
  };


  this.GetValue = function ()
  {
    var result = new Array();
    for (var i in this.Data)
    {
      if (this.Data[i] == null || this.Data[i].Value == null)
      {
        result[i] = null;
      } else

      {
        // console.log(this.Data[i].Value);
        // console.log(i);
        if (!isNaN(this.Data[i].Value))
        result[i] = this.Data[i].Value;else
        if (this.Data[i].Value instanceof Array) //支持数组
          result[i] = this.Data[i].Value;else

        result[i] = null;
      }
    }

    return result;
  };

  this.GetPeriodSingleData = function (period)
  {
    var result = new Array();
    var index = 0;
    var startDate = 0;
    var newData = null;
    for (var i in this.Data)
    {
      var isNewData = false;
      var dayData = this.Data[i];
      if (dayData == null || dayData.Date == null) continue;

      switch (period) {

        case 1: //周线
          var fridayDate = ChartData.GetFirday(dayData.Date);
          if (fridayDate != startDate)
          {
            isNewData = true;
            startDate = fridayDate;
          }
          break;
        case 2: //月线
          if (parseInt(dayData.Date / 100) != parseInt(startDate / 100))
          {
            isNewData = true;
            startDate = dayData.Date;
          }
          break;
        case 3: //年线
          if (parseInt(dayData.Date / 10000) != parseInt(startDate / 10000))
          {
            isNewData = true;
            startDate = dayData.Date;
          }
          break;}


      if (isNewData)
      {
        newData = new SingleData();
        newData.Date = dayData.Date;
        newData.Value = dayData.Value;
        result.push(newData);
      } else

      {
        if (newData == null) continue;
        if (dayData.Value == null || isNaN(dayData.Value)) continue;
        if (newData.Value == null || isNaN(newData.Value)) newData.Value = dayData.Value;
      }
    }

    return result;
  };

  /*
         分钟数据方法
         this.GetClose()     每分钟价格
         this.GetVol()       每分钟成交量
     */

  //分钟均线
  this.GetMinuteAvPrice = function ()
  {
    var result = new Array();
    for (var i in this.Data)
    {
      result[i] = this.Data[i].AvPrice;
    }

    return result;
  };

  this.MergeMinuteData = function (data) //合并数据
  {
    var sourceFirstItem = this.Data[0];
    var firstItemID = 0;
    var firstItem = null;
    for (var i = 0; i < data.length; ++i) //查找比原始数据起始位置大的数据位置
    {
      var item = data[i];
      if (item.Date > sourceFirstItem.Date)
      {
        firstItemID = i;
        firstItem = item;
        break;
      }

      if (item.Date == sourceFirstItem.Date && item.Time >= sourceFirstItem.Time)
      {
        firstItemID = i;
        firstItem = item;
        break;
      }
    }
    if (firstItem == null) return false;

    var index = null;
    var bFind = false; //第1个数据是否完全匹配
    for (var i = this.Data.length - 1; i >= 0; --i)
    {
      var date = this.Data[i].Date;
      var time = this.Data[i].Time;

      if (firstItem.Date > date || firstItem.Date == date && firstItem.Time >= time)
      {
        index = i;
        if (firstItem.Date == date && firstItem.Time == time) bFind = true;
        break;
      }
    }

    if (index == null) return false;
    var j = index;
    var i = firstItemID;
    if (bFind == true) //第1个数据匹配,覆盖
      {
        var item = data[i];
        if (j - 1 > 0 && !item.YClose) item.YClose = this.Data[j - 1].Close; //前收盘如果没有就是上一记录的收盘
        var newItem = HistoryData.Copy(item);
        this.Data[j] = newItem;
        ++j;
        ++i;
      } else

    {
      ++j;
    }

    for (; i < data.length;)
    {
      var item = data[i];
      if (j >= this.Data.length - 1)
      {
        if (j - 1 > 0 && !item.YClose) item.YClose = this.Data[j - 1].YClose; //前收盘如果没有就是上一记录的收盘
        var newItem = HistoryData.Copy(item);
        this.Data[j] = newItem;
        ++j;
        ++i;
      } else

      {
        var oldItem = this.Data[j];
        if (oldItem.Date == item.Date && oldItem.Time == item.Time) //更新数据
          {
            HistoryData.CopyTo(oldItem, item);
            ++j;
            ++i;
          } else

        {
          ++j;
        }
      }
    }

    //console.log('[ChartData::MergeMinuteData] ', this.Data, data);
    return true;
  };

  //日线拟合交易数据, 不做平滑处理
  this.GetFittingTradeData = function (tradeData, nullValue, bExactMatch)
  {
    var result = [];
    var bMatch = false;
    for (var i = 0, j = 0; i < this.Data.length;)
    {
      var date = this.Data[i].Date;
      if (j < tradeData.length)
      {
        if (tradeData[j].Date > date)
        {
          var item = new SingleData();
          item.Date = date;
          item.Value = nullValue;
          result[i] = item;
          ++i;
          continue;
        }
      }

      if (j + 1 < tradeData.length)
      {
        if (tradeData[j].Date < date && tradeData[j + 1].Date <= date)
        {
          ++j;
          bMatch = false;
          continue;
        }
      }

      var item = new SingleData();
      item.Date = date;
      item.Value = nullValue;
      item.FinanceDate = null;
      if (j < tradeData.length)
      {
        var tradeItem = tradeData[j];
        if (this.Period == 0 && bExactMatch === true) //日线完全匹配
          {
            if (tradeItem.Date == item.Date)
            {
              item.Value = tradeItem.Value;
              item.FinanceDate = tradeItem.Date; //财务日期 调试用
              bMatch = true;
            }
          } else
          //其他日线周期
          {
            if (bMatch == false)
            {
              item.Value = tradeItem.Value;
              item.FinanceDate = tradeItem.Date; //财务日期 调试用
              bMatch = true;
            }
          }
      }

      result[i] = item;
      ++i;
    }

    return result;
  };

  this.GetMinuteFittingTradeData = function (tradeData, nullValue, bExactMatch)
  {
    var result = [];
    var bMatch = false;

    for (var i = 0, j = 0; i < this.Data.length;)
    {
      var date = this.Data[i].Date;
      var time = this.Data[i].Time;

      if (j < tradeData.length)
      {
        if (tradeData[j].Date > date || tradeData[j].Date == date && tradeData[j].Time > time)
        {
          var item = new SingleData();
          item.Date = date;
          item.Time = time;
          item.Value = nullValue;
          result[i] = item;
          ++i;
          continue;
        }
      }

      if (j + 1 < tradeData.length)
      {
        if (tradeData[j].Date < date && tradeData[j + 1].Date <= date ||
        tradeData[j].Date == date && tradeData[j].Time < time && tradeData[j + 1].Time <= time)
        {
          ++j;
          bMatch = false;
          continue;
        }
      }

      var item = new SingleData();
      item.Date = date;
      item.FinanceDate = null;
      item.Time = time;
      item.Value = nullValue;
      if (j < tradeData.length)
      {
        var tradeItem = tradeData[j];
        if (this.Period == 4 && bExactMatch === true) //1分钟线完全匹配
          {
            if (tradeItem.Date == item.Date && tradeItem.Time == item.Time) //完全匹配
              {
                item.Value = tradeItem.Value;
                item.FinanceDate = tradeItem.Date; //财务日期 调试用
                item.FinanceTime = tradeItem.Time;
                bMatch = true;
              }
          } else
          //其他日线周期
          {
            if (bMatch == false)
            {
              item.Value = tradeItem.Value;
              item.FinanceDate = tradeItem.Date; //财务日期 调试用
              item.FinanceTime = tradeItem.Time;
              bMatch = true;
            }
          }
      }

      result[i] = item;
      ++i;
    }

    return result;
  };

}

ChartData.IsNumber = function (value)
{
  if (value == null) return false;
  if (isNaN(value)) return false;

  return true;
};

ChartData.GetFirday = function (value)
{
  var date = new Date(parseInt(value / 10000), value / 100 % 100 - 1, value % 100);
  var day = date.getDay();
  if (day == 5) return value;

  var timestamp = date.getTime();
  if (day < 5)
  {
    var prevTimestamp = 24 * 60 * 60 * 1000 * (5 - day);
    timestamp += prevTimestamp;
  } else

  {
    var prevTimestamp = 24 * 60 * 60 * 1000 * (day - 5);
    timestamp -= prevTimestamp;
  }

  date.setTime(timestamp);
  var fridayDate = date.getFullYear() * 10000 + (date.getMonth() + 1) * 100 + date.getDate();
  var week = date.getDay();
  return fridayDate;
};

ChartData.GetSunday = function (value)
{
  var date = new Date(parseInt(value / 10000), value / 100 % 100 - 1, value % 100);
  var day = date.getDay();
  if (day == 0) return value;

  var timestamp = date.getTime();
  if (day > 0)
  {
    var prevTimestamp = 24 * 60 * 60 * 1000 * (7 - day);
    timestamp += prevTimestamp;
  }

  date.setTime(timestamp);
  var sundayDate = date.getFullYear() * 10000 + (date.getMonth() + 1) * 100 + date.getDate();
  var week = date.getDay();
  return sundayDate;
};

ChartData.GetQuarter = function (value)
{
  var month = parseInt(value % 10000 / 100);
  if (month == 1 || month == 2 || month == 3) return 1;else
  if (month == 4 || month == 5 || month == 6) return 2;else
  if (month == 7 || month == 8 || month == 9) return 3;else
  if (month == 10 || month == 11 || month == 12) return 4;else
  return 0;
};

//是否是日线周期  0=日线 1=周线 2=月线 3=年线 9=季线 21=双周 [40001-50000) 自定义日线 (isIncludeBase 是否包含基础日线周期)
var CUSTOM_DAY_PERIOD_START = 40000,CUSTOM_DAY_PERIOD_END = 49999;
ChartData.IsDayPeriod = function (period, isIncludeBase)
{
  if (period == 1 || period == 2 || period == 3 || period == 9 || period == 21) return true;
  if (period > CUSTOM_DAY_PERIOD_START && period <= CUSTOM_DAY_PERIOD_END) return true;
  if (period == 0 && isIncludeBase == true) return true;

  return false;
};

//是否是分钟周期 4=1分钟 5=5分钟 6=15分钟 7=30分钟 8=60分钟 11=2h 12=4h[20001-30000) 自定义分钟 (isIncludeBase 是否包含基础1分钟周期)
var CUSTOM_MINUTE_PERIOD_START = 20000,CUSTOM_MINUTE_PERIOD_END = 29999;
ChartData.IsMinutePeriod = function (period, isIncludeBase)
{
  if (period == 5 || period == 6 || period == 7 || period == 8 || period == 11 || period == 12) return true;
  if (period > CUSTOM_MINUTE_PERIOD_START && period <= CUSTOM_MINUTE_PERIOD_END) return true;
  if (period == 4 && isIncludeBase == true) return true;

  return false;
};

//是否是秒周期 [30001-32000)
var CUSTOM_SECOND_PERIOD_START = 30000,CUSTOM_SECOND_PERIOD_END = 32000;
ChartData.IsSecondPeriod = function (period)
{
  if (period > CUSTOM_SECOND_PERIOD_START && period <= CUSTOM_SECOND_PERIOD_END) return true;
  return false;
};


//是否是分笔图
ChartData.IsTickPeriod = function (period)
{
  return period == 10;
};

//获取周期名字
ChartData.GetPeriodName = function (period)
{
  var mapName = new Map(
  [
  [0, '日线'], [1, '周线'], [2, '月线'], [3, '年线'], [9, '季线'], [21, '双周'],
  [4, '1分'], [5, '5分'], [6, '15分'], [7, '30分'], [8, '60分'], [11, '2小时'], [12, '4小时'],
  [10, '分笔']]);


  if (mapName.has(period)) return mapName.get(period);

  return '';
};

function Rect(x, y, width, height)
{
  this.Left = x,
  this.Top = y;
  this.Right = x + width;
  this.Bottom = y + height;

  this.IsPointIn = function (x, y)
  {
    if (x >= this.Left && x <= this.Right && y >= this.Top && y <= this.Bottom) return true;
    return false;
  };
}

//修正线段有毛刺
function ToFixedPoint(value)
{
  //return value;
  return parseInt(value) + 0.5;
}

function ToFixedRect(value)
{
  var rounded;
  return rounded = 0.5 + value << 0;
}

var JSCHART_EVENT_ID =
{
  RECV_INDEX_DATA: 2, //接收指标数据
  RECV_HISTROY_DATA: 3, //接收到历史数据
  RECV_TRAIN_MOVE_STEP: 4, //接收K线训练,移动一次K线
  CHART_STATUS: 5, //每次Draw() 以后会调用
  BARRAGE_PLAY_END: 6, //单个弹幕播放完成
  RECV_START_AUTOUPDATE: 9, //开始自动更新
  RECV_STOP_AUTOUPDATE: 10, //停止自动更新
  ON_TITLE_DRAW: 12, //标题信息绘制事件
  RECV_MINUTE_DATA: 14, //分时图数据到达
  ON_CLICK_INDEXTITLE: 15, //点击指标标题事件
  RECV_KLINE_UPDATE_DATA: 16, //K线日,分钟更新数据到达 
  ON_INDEXTITLE_DRAW: 19, //指标标题重绘事件 
  ON_CUSTOM_VERTICAL_DRAW: 20, //自定义X轴绘制事件 
  ON_ENABLE_SPLASH_DRAW: 22, //开启/关闭过场动画事件

  ON_DRAW_DEPTH_TOOLTIP: 25, //绘制深度图tooltip事件
  ON_PHONE_TOUCH: 27, //手势点击事件 包含 TouchStart 和 TouchEnd

  ON_SPLIT_YCOORDINATE: 29 //分割Y轴及格式化刻度文字
};


//导出统一使用JSCommon命名空间名
module.exports =
{
  JSCommonData:
  {
    HistoryData: HistoryData,
    ChartData: ChartData,
    SingleData: SingleData,
    MinuteData: MinuteData,
    Rect: Rect,
    DataPlus: DataPlus,
    JSCHART_EVENT_ID: JSCHART_EVENT_ID },


  //单个类导出
  JSCommon_ChartData: ChartData,
  JSCommon_HistoryData: HistoryData,
  JSCommon_SingleData: SingleData,
  JSCommon_MinuteData: MinuteData,
  JSCommon_CUSTOM_DAY_PERIOD_START: CUSTOM_DAY_PERIOD_START,
  JSCommon_CUSTOM_DAY_PERIOD_END: CUSTOM_DAY_PERIOD_END,
  JSCommon_CUSTOM_MINUTE_PERIOD_START: CUSTOM_MINUTE_PERIOD_START,
  JSCommon_CUSTOM_MINUTE_PERIOD_END: CUSTOM_MINUTE_PERIOD_END,
  JSCommon_CUSTOM_SECOND_PERIOD_START: CUSTOM_SECOND_PERIOD_START,
  JSCommon_CUSTOM_SECOND_PERIOD_END: CUSTOM_SECOND_PERIOD_END,
  JSCommon_Rect: Rect,
  JSCommon_DataPlus: DataPlus,
  JSCommon_Guid: Guid,
  JSCommon_ToFixedPoint: ToFixedPoint,
  JSCommon_ToFixedRect: ToFixedRect,
  JSCommon_JSCHART_EVENT_ID: JSCHART_EVENT_ID };

/***/ }),
/* 104 */
/*!**************************************************************************!*\
  !*** I:/out-project/FCoinEx/static/js/umychart.coordinatedata.wechat.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
    copyright (c) 2018 jones

    http://www.apache.org/licenses/LICENSE-2.0

    开源项目 https://github.com/jones2000/HQChart

    jones_2000@163.com

    各个品种分钟走势图坐标信息
*/

function GetLocalTime(i) //得到标准时区的时间的函数
{
  if (typeof i !== 'number') return;
  var d = new Date();
  //得到1970年一月一日到现在的秒数
  var len = d.getTime();
  //本地时间与GMT时间的时间偏移差
  var offset = d.getTimezoneOffset() * 60000;
  //得到现在的格林尼治时间
  var utcTime = len + offset;
  return new Date(utcTime + 3600000 * i);
}

var MARKET_SUFFIX_NAME =
{
  SH: '.SH',
  SZ: '.SZ',
  SHSZ_C_Index: '.CI', //自定义指数
  SHO: '.SHO', //上海交易所 股票期权
  HK: '.HK',
  FHK: '.FHK', //港股期货 
  SHFE: '.SHF', //上期所 (Shanghai Futures Exchange)
  SHFE2: '.SHFE', //上期所 (Shanghai Futures Exchange)
  CFFEX: '.CFE', //中期所 (China Financial Futures Exchange)
  DCE: '.DCE', //大连商品交易所(Dalian Commodity Exchange)
  CZCE: '.CZC', //郑州期货交易所
  USA: '.USA', //美股
  FTSE: '.FTSE', //富时中国

  BIT: '.BIT', //数字货币 如比特币
  BIZ: '.BIZ', //数字货币

  NYMEX: '.NYMEX', //纽约商品期货交易所(New York Mercantile Exchange)
  COMEX: ".COMEX", //纽约商品期货交易所(New York Mercantile Exchange)
  NYBOT: ".NYBOT", //美國紐約商品交易所
  CBOT: ".CBOT", //芝商所

  LME: ".LME", //伦敦金属交易所

  ET: '.ET', //其他未知的品种

  IsET: function IsET(upperSymbol)
  {
    if (!upperSymbol) return false;
    return upperSymbol.indexOf(this.ET) > 0;
  },

  IsETShowAvPrice: function IsETShowAvPrice(upperSymbol) //是否显示均价
  {
    return false;
  },

  IsNYMEX: function IsNYMEX(upperSymbol)
  {
    if (!upperSymbol) return false;
    return upperSymbol.indexOf(this.NYMEX) > 0;
  },

  IsCOMEX: function IsCOMEX(upperSymbol)
  {
    if (!upperSymbol) return false;
    return upperSymbol.indexOf(this.COMEX) > 0;
  },

  IsNYBOT: function IsNYBOT(upperSymbol)
  {
    if (!upperSymbol) return false;
    return upperSymbol.indexOf(this.NYBOT) > 0;
  },

  IsCBOT: function IsCBOT(upperSymbol)
  {
    if (!upperSymbol) return false;
    return upperSymbol.indexOf(this.CBOT) > 0;
  },

  IsLME: function IsLME(upperSymbol)
  {
    if (!upperSymbol) return false;
    return upperSymbol.indexOf(this.LME) > 0;
  },

  IsFTSE: function IsFTSE(upperSymbol)
  {
    if (!upperSymbol) return false;
    return upperSymbol.indexOf(this.FTSE) > 0;
  },

  IsFHK: function IsFHK(upperSymbol)
  {
    if (!upperSymbol) return false;
    return upperSymbol.indexOf(this.FHK) > 0;
  },

  IsBIT: function IsBIT(upperSymbol)
  {
    if (!upperSymbol) return false;
    if (upperSymbol.indexOf(this.BIT) > 0) return true;
    if (upperSymbol.indexOf(this.BIZ) > 0) return true;
    return false;
  },

  IsUSA: function IsUSA(upperSymbol) //是否是美股
  {
    if (!upperSymbol) return false;
    return upperSymbol.indexOf(this.USA) > 0;
  },

  IsSH: function IsSH(upperSymbol)
  {
    //需要精确匹配最后3位
    var pos = upperSymbol.length - this.SH.length;
    var find = upperSymbol.indexOf(this.SH);
    return find == pos;
  },

  IsSZ: function IsSZ(upperSymbol)
  {
    var pos = upperSymbol.length - this.SZ.length;
    var find = upperSymbol.indexOf(this.SZ);
    return find == pos;
  },

  //自定义指数
  IsSHSZCustomIndex: function IsSHSZCustomIndex(upperSymbol)
  {
    var pos = upperSymbol.length - this.SHSZ_C_Index.length;
    var find = upperSymbol.indexOf(this.SHSZ_C_Index);
    return find == pos;
  },

  IsSHO: function IsSHO(upperSymbol)
  {
    var pos = upperSymbol.length - this.SHO.length;
    var find = upperSymbol.indexOf(this.SHO);
    return find == pos;
  },

  IsHK: function IsHK(upperSymbol)
  {
    var pos = upperSymbol.length - this.HK.length;
    var find = upperSymbol.indexOf(this.HK);
    return find == pos;
  },

  IsSHFE: function IsSHFE(upperSymbol)
  {
    if (!upperSymbol) return false;
    if (upperSymbol.indexOf(this.SHFE) > 0) return true;
    if (upperSymbol.indexOf(this.SHFE2) > 0) return true;
    return false;
  },

  IsCFFEX: function IsCFFEX(upperSymbol)
  {
    if (!upperSymbol) return false;
    return upperSymbol.indexOf(this.CFFEX) > 0;
  },

  IsDCE: function IsDCE(upperSymbol)
  {
    if (!upperSymbol) return false;
    return upperSymbol.indexOf(this.DCE) > 0;
  },

  IsCZCE: function IsCZCE(upperSymbol)
  {
    if (!upperSymbol) return false;
    return upperSymbol.indexOf(this.CZCE) > 0;
  },

  IsChinaFutures: function IsChinaFutures(upperSymbol) //是否是国内期货
  {
    return this.IsCFFEX(upperSymbol) || this.IsCZCE(upperSymbol) || this.IsDCE(upperSymbol) || this.IsSHFE(upperSymbol);
  },

  IsFutures: function IsFutures(upperSymbol) //是否是期货 包含国外的
  {
    return this.IsChinaFutures(upperSymbol) ||
    this.IsNYMEX(upperSymbol) || this.IsCOMEX(upperSymbol) || this.IsNYBOT(upperSymbol) || this.IsCBOT(upperSymbol) ||
    this.IsLME(upperSymbol);
  },

  IsSHSZ: function IsSHSZ(upperSymbol) //是否是沪深的股票
  {
    return this.IsSZ(upperSymbol) || this.IsSH(upperSymbol) || this.IsSHSZCustomIndex(upperSymbol);
  },

  IsSHSZFund: function IsSHSZFund(upperSymbol) //是否是交易所基金
  {
    if (!upperSymbol) return false;

    if (this.IsSH(upperSymbol)) //51XXXX.SH
      {
        if (upperSymbol.charAt(0) == '5' && upperSymbol.charAt(1) == '1') return true;
      } else
    if (this.IsSZ(upperSymbol)) //15XXXX.sz, 16XXXX.sz, 17XXXX.sz, 18XXXX.sz
      {
        if (upperSymbol.charAt(0) == '1' && (
        upperSymbol.charAt(1) == '5' || upperSymbol.charAt(1) == '6' || upperSymbol.charAt(1) == '7' || upperSymbol.charAt(1) == '8')) return true;
      }

    return false;
  },

  IsSHSZIndex: function IsSHSZIndex(symbol) //是否是沪深指数代码
  {
    if (!symbol) return false;

    var upperSymbol = symbol.toUpperCase();
    if (this.IsSH(upperSymbol))
    {
      var temp = upperSymbol.replace('.SH', '');
      if (upperSymbol.charAt(0) == '0' && parseInt(temp) <= 3000) return true;

    } else
    if (this.IsSZ(upperSymbol))
    {
      if (upperSymbol.charAt(0) == '3' && upperSymbol.charAt(1) == '9') return true;
    } else
    if (this.IsSHSZCustomIndex(upperSymbol)) //自定义指数
      {
        return true;
      }

    return false;
  },

  IsSHSZStockA: function IsSHSZStockA(symbol) //是否是沪深A股
  {
    if (!symbol) return false;
    var upperSymbol = symbol.toUpperCase();
    if (this.IsSH(upperSymbol))
    {
      var temp = upperSymbol.replace('.SH', '');
      if (upperSymbol.charAt(0) == '6') return true;
    } else
    if (this.IsSZ(upperSymbol))
    {
      if (upperSymbol.charAt(0) == '0')
      {
        if (upperSymbol.charAt(1) == '0' && upperSymbol.charAt(2) == '2') return true; //002 中小板
        if (upperSymbol.charAt(1) != '7' && upperSymbol.charAt(1) != '8') return true;
      }
    }

    return false;
  },

  IsSHStockSTAR: function IsSHStockSTAR(symbol) // 是否是科创板 Sci-Tech innovAtion boaRd (STAR Market)
  {
    if (!symbol) return false;
    var upperSymbol = symbol.toUpperCase();
    if (!this.IsSH(upperSymbol)) return false;
    if (upperSymbol.charAt(0) == '6' && upperSymbol.charAt(1) == '8' && upperSymbol.charAt(2) == '8')
    return true;

    return false;
  },

  GetMarketStatus: function GetMarketStatus(symbol) //获取市场状态 0=闭市 1=盘前 2=盘中 3=盘后
  {
    if (!symbol) return 0;
    var upperSymbol = symbol.toUpperCase();
    var nowDate = new Date();
    var day = nowDate.getDay();
    var time = nowDate.getHours() * 100 + nowDate.getMinutes();

    if (this.IsUSA(upperSymbol))
    {
      var usaDate = GetLocalTime(-4);
      var day = usaDate.getDay();
      var time = usaDate.getHours() * 100 + usaDate.getMinutes();
      if (day == 6 || day == 0) return 0; //周末

      //9:30 - 16:00 考虑夏令时间时间增加1小时 9:30 - 17:00
      if (time > 1730) return 3;
      if (time < 930) return 1;

      return 2;
    } else
    if (this.IsBIT(upperSymbol)) //数字货币24小时
      {
        return 2;
      } else
    if (this.IsFTSE(upperSymbol)) //富时中国 9:00-16:30 17:00-04:45
      {
        if (day == 6 || day == 0) return 0; //周末
        if (time >= 830 && time <= 2359) return 2;
        if (time >= 0 && time <= 500) return 2;
        return 0;
      } else
    if (this.IsFHK(upperSymbol)) //港股指数期货 9:15-12:00 13:00-16:30 17:15-01:00
      {
        if (day == 6 || day == 0) return 0; //周末
        if (time >= 900 && time <= 2359) return 2;
        if (time >= 0 && time <= 120) return 2;
        return 0;
      } else
    if (this.IsET(upperSymbol))
    {
      return this.GetETMarketStatus(symbol);
    } else
    if (this.IsHK(upperSymbol)) //港股
      {
        if (day == 6 || day == 0) return 0; //周末
        if (time > 1630) return 3;
        if (time < 925) return 1;
        return 2;
      } else
    if (this.IsNYMEX(upperSymbol))
    {
      return this.GetNYMEXMarketStatus(upperSymbol);
    } else
    if (this.IsCOMEX(upperSymbol))
    {
      return this.GetCOMEXMarketStatus(upperSymbol);
    } else
    if (this.IsNYBOT(upperSymbol))
    {
      return this.GetNYBOTMarketStatus(upperSymbol);
    } else
    if (this.IsCBOT(upperSymbol))
    {
      return this.GetCBOTMarketStatus(upperSymbol);
    } else
    if (this.IsChinaFutures(upperSymbol)) //国内期货
      {
        if (day == 6 || day == 0) return 0; //周末

        //21:00-2:30
        if (time >= 2100) return 2;
        if (time <= 240) return 2;

        //8:55-11:30, 13:00-15:00
        if (time >= 830 && time <= 1510) return 2;

        return 1;
      } else
      //9:30 - 15:40
      {
        if (day == 6 || day == 0) return 0; //周末
        if (time > 1540) return 3;
        if (time < 925) return 1;
        return 2;
      }

  },

  GetDefaultDecimal: function GetDefaultDecimal(symbol)
  {
    return 2;
  },

  GetFHKDecimal: function GetFHKDecimal(symbol) //港股指数期货 小数位数
  {
    return 0;
  },

  GetFTSEDecimal: function GetFTSEDecimal(symbol) //富时中国A50期货 小数位数
  {
    return 0;
  },

  GetBITDecimal: function GetBITDecimal(symbol)
  {
    return 2;
  },

  GetETDecimal: function GetETDecimal(symbol)
  {
    return 2;
  },

  GetSHODecimal: function GetSHODecimal(symbol)
  {
    return 4;
  },

  GetNYMEXDecimal: function GetNYMEXDecimal(symbol) //纽约期货交易所
  {
    return g_NYMEXTimeData.GetDecimal(symbol);
  },

  GetCOMEXDecimal: function GetCOMEXDecimal(symbol)
  {
    return g_COMEXTimeData.GetDecimal(symbol);
  },

  GetNYBOTDecimal: function GetNYBOTDecimal(symbol)
  {
    return g_NYBOTTimeData.GetDecimal(symbol);
  },

  GetCBOTDecimal: function GetCBOTDecimal(symbol)
  {
    return g_CBOTTimeData.GetDecimal(symbol);
  },

  GetLMEDecimal: function GetLMEDecimal(symbol)
  {
    return g_LMETimeData.GetDecimal(symbol);
  },

  GetETMarketStatus: function GetETMarketStatus(symbol)
  {
    // 0=闭市 1=盘前 2=盘中 3=盘后
    return 2;
  },

  GetCOMEXMarketStatus: function GetCOMEXMarketStatus(symbol)
  {
    return g_COMEXTimeData.GetMarketStatus(symbol);
  },

  GetNYBOTMarketStatus: function GetNYBOTMarketStatus(symbol)
  {
    return g_NYBOTTimeData.GetMarketStatus(symbol);
  },

  GetCBOTMarketStatus: function GetCBOTMarketStatus(symbol)
  {
    return g_CBOTTimeData.GetMarketStatus(symbol);
  },

  GetNYMEXMarketStatus: function GetNYMEXMarketStatus(symbol)
  {
    return g_NYMEXTimeData.GetMarketStatus(symbol);
  } };



//走势图分钟数据对应的时间
function MinuteTimeStringData()
{
  this.SHSZ = null; //上海深证交易所时间
  this.HK = null; //香港交易所时间
  this.Futures = new Map(); //期货交易时间 key=时间名称 Value=数据
  this.USA = null; //美股交易时间
  this.FTSE = null; //富时中国
  this.FHK = null; //港股指数期货
  this.BIT = null; //数字货币

  this.Initialize = function () //初始化 默认只初始化沪深的 其他市场动态生成
  {
    //this.SHSZ = this.CreateSHSZData();
    //this.HK = this.CreateHKData();
  };

  this.GetET = function (upperSymbol) //当天所有的分钟
  {
    throw { Name: 'MinuteTimeStringData::GetET', Error: 'not implement' };
  };

  this.GetSHSZ = function () //动态创建
  {
    if (!this.SHSZ) this.SHSZ = this.CreateSHSZData();
    return this.SHSZ;
  };

  this.GetSHO = function ()
  {
    if (!this.SHO) this.SHO = this.CreateSHOData();
    return this.SHO;
  };

  this.GetHK = function ()
  {
    if (!this.HK) this.HK = this.CreateHKData();
    return this.HK;
  };

  this.GetFutures = function (splitData)
  {
    if (!this.Futures.has(splitData.Name))
    {
      var data = this.CreateTimeData(splitData.Data);
      this.Futures.set(splitData.Name, data);
    }

    return this.Futures.get(splitData.Name);
  };

  this.GetUSA = function ()
  {
    if (!this.USA) this.USA = this.CreateUSAData();
    return this.USA;
  };

  this.GetFTSE = function ()
  {
    if (!this.FTSE) this.FTSE = this.CreateFTSEData();
    return this.FTSE;
  };

  this.GetFHK = function ()
  {
    if (!this.FHK) this.FHK = this.CreateFHKData();
    return this.FHK;
  };

  this.GetBIT = function (upperSymbol)
  {
    if (!this.BIT) this.BIT = this.CreateBITData();
    return this.BIT;
  };

  this.CreateSHSZData = function ()
  {
    var TIME_SPLIT =
    [
    { Start: 925, End: 925 },
    { Start: 930, End: 1130 },
    { Start: 1300, End: 1500 }];


    return this.CreateTimeData(TIME_SPLIT);
  };

  this.CreateSHOData = function ()
  {
    var TIME_SPLIT =
    [
    { Start: 930, End: 1129 },
    { Start: 1300, End: 1500 }];


    return this.CreateTimeData(TIME_SPLIT);
  };

  this.CreateHKData = function ()
  {
    var TIME_SPLIT =
    [
    { Start: 930, End: 1200 },
    { Start: 1300, End: 1600 }];


    return this.CreateTimeData(TIME_SPLIT);
  };

  this.CreateUSAData = function ()
  {
    //美国夏令时
    var TIME_SUMMER_SPLIT =
    [
    { Start: 2130, End: 2359 },
    { Start: 0, End: 400 }];


    //非夏令时
    var TIME_SPLIT =
    [
    { Start: 2230, End: 2359 },
    { Start: 0, End: 500 }];


    //使用美国本地时间
    var TIME_LOCAL_SPLIT =
    [
    { Start: 930, End: 1600 } //美国东部时间9:30到16:00
    ];

    return this.CreateTimeData(TIME_LOCAL_SPLIT);
  };

  this.CreateFTSEData = function ()
  {
    var TIME_SPLIT =
    [
    { Start: 1700, End: 2359 },
    { Start: 0, End: 445 },
    { Start: 900, End: 1630 }];


    return this.CreateTimeData(TIME_SPLIT);
  };

  this.CreateFHKData = function ()
  {
    //港股指数期货 9:15-12:00 13:00-16:30 17:15-01:00
    var TIME_SPLIT =
    [
    { Start: 1715, End: 2359 },
    { Start: 0, End: 100 },
    { Start: 915, End: 1200 },
    { Start: 1300, End: 1630 }];


    return this.CreateTimeData(TIME_SPLIT);
  };

  this.CreateBITData = function ()
  {
    //数字货币 7:00 - 6:59
    var TIME_SPLIT =
    [
    { Start: 600, End: 2359 },
    { Start: 0, End: 559 }];


    return this.CreateTimeData(TIME_SPLIT);
  };

  this.CreateTimeData = function (timeSplit)
  {
    var data = [];
    for (var i in timeSplit)
    {
      var item = timeSplit[i];
      for (var j = item.Start; j <= item.End; ++j)
      {
        if (j % 100 >= 60) continue; //大于60分钟的数据去掉
        data.push(j);
      }
    }
    return data;
  };

  this.GetTimeData = function (symbol)
  {
    if (!symbol) return this.SHSZ;

    var upperSymbol = symbol.toLocaleUpperCase(); //转成大写
    if (MARKET_SUFFIX_NAME.IsSH(upperSymbol) || MARKET_SUFFIX_NAME.IsSZ(upperSymbol) || MARKET_SUFFIX_NAME.IsSHSZIndex(upperSymbol)) return this.GetSHSZ();
    if (MARKET_SUFFIX_NAME.IsHK(upperSymbol)) return this.GetHK();
    if (MARKET_SUFFIX_NAME.IsCFFEX(upperSymbol) || MARKET_SUFFIX_NAME.IsCZCE(upperSymbol) || MARKET_SUFFIX_NAME.IsDCE(upperSymbol) || MARKET_SUFFIX_NAME.IsSHFE(upperSymbol))
    {
      var splitData = g_FuturesTimeData.GetSplitData(upperSymbol);
      if (!splitData) return null;
      return this.GetFutures(splitData);
    }
    if (MARKET_SUFFIX_NAME.IsFTSE(upperSymbol)) return this.GetFTSE();
    if (MARKET_SUFFIX_NAME.IsFHK(upperSymbol)) return this.GetFHK();
    if (MARKET_SUFFIX_NAME.IsET(upperSymbol)) return this.GetET(upperSymbol);
    if (MARKET_SUFFIX_NAME.IsBIT(upperSymbol)) return this.GetBIT(upperSymbol);

    if (MARKET_SUFFIX_NAME.IsNYMEX(upperSymbol)) //纽约期货交易所
      {
        var splitData = g_NYMEXTimeData.GetSplitData(upperSymbol);
        if (!splitData) return null;
        return this.GetFutures(splitData);
      }

    if (MARKET_SUFFIX_NAME.IsCOMEX(upperSymbol)) //纽约期货交易所
      {
        var splitData = g_COMEXTimeData.GetSplitData(upperSymbol);
        if (!splitData) return null;
        return this.GetFutures(splitData);
      }

    if (MARKET_SUFFIX_NAME.IsNYBOT(upperSymbol)) //纽约期货交易所
      {
        var splitData = g_NYBOTTimeData.GetSplitData(upperSymbol);
        if (!splitData) return null;
        return this.GetFutures(splitData);
      }

    if (MARKET_SUFFIX_NAME.IsCBOT(upperSymbol)) //芝商所
      {
        var splitData = g_CBOTTimeData.GetSplitData(upperSymbol);
        if (!splitData) return null;
        return this.GetFutures(splitData);
      }

    if (MARKET_SUFFIX_NAME.IsLME(upperSymbol)) //伦敦LME
      {
        var splitData = g_LMETimeData.GetSplitData(upperSymbol);
        if (!splitData) return null;
        return this.GetFutures(splitData);
      }
  };
}

//走势图刻度分钟线
function MinuteCoordinateData()
{
  //沪深走势图时间刻度
  var SHZE_MINUTE_X_COORDINATE =
  {
    Full: //完整模式
    [
    [0, 0, "rgb(200,200,200)", "09:30"],
    [31, 0, "RGB(200,200,200)", "10:00"],
    [61, 0, "RGB(200,200,200)", "10:30"],
    [91, 0, "RGB(200,200,200)", "11:00"],
    [122, 1, "RGB(200,200,200)", "13:00"],
    [152, 0, "RGB(200,200,200)", "13:30"],
    [182, 0, "RGB(200,200,200)", "14:00"],
    [212, 0, "RGB(200,200,200)", "14:30"],
    [242, 1, "RGB(200,200,200)", "15:00"] // 15:00
    ],
    Simple: //简洁模式
    [
    [0, 0, "rgb(200,200,200)", "09:30"],
    [61, 0, "RGB(200,200,200)", "10:30"],
    [122, 1, "RGB(200,200,200)", "13:00"],
    [182, 0, "RGB(200,200,200)", "14:00"],
    [242, 1, "RGB(200,200,200)", "15:00"]],

    Min: //最小模式     
    [
    [0, 0, "rgb(200,200,200)", "09:30"],
    [122, 1, "RGB(200,200,200)", "13:00"],
    [242, 1, "RGB(200,200,200)", "15:00"]],


    Count: 243,
    MiddleCount: 122,

    GetData: function GetData(width)
    {
      if (width < 200) return this.Min;else
      if (width < 400) return this.Simple;

      return this.Full;
    } };


  //上海股票期权时间刻度
  var SHO_MINUTE_X_COORDINATE =
  {
    Full: //完整模式
    [
    [0, 0, "rgb(200,200,200)", "09:30"],
    [30, 0, "RGB(200,200,200)", "10:00"],
    [60, 0, "RGB(200,200,200)", "10:30"],
    [90, 0, "RGB(200,200,200)", "11:00"],
    [120, 1, "RGB(200,200,200)", "13:00"],
    [150, 0, "RGB(200,200,200)", "13:30"],
    [180, 0, "RGB(200,200,200)", "14:00"],
    [210, 0, "RGB(200,200,200)", "14:30"],
    [240, 1, "RGB(200,200,200)", "15:00"] // 15:00
    ],
    Simple: //简洁模式
    [
    [0, 0, "rgb(200,200,200)", "09:30"],
    [60, 0, "RGB(200,200,200)", "10:30"],
    [120, 1, "RGB(200,200,200)", "13:00"],
    [180, 0, "RGB(200,200,200)", "14:00"],
    [240, 1, "RGB(200,200,200)", "15:00"]],

    Min: //最小模式     
    [
    [0, 0, "rgb(200,200,200)", "09:30"],
    [120, 1, "RGB(200,200,200)", "13:00"],
    [240, 1, "RGB(200,200,200)", "15:00"]],


    Count: 241,
    MiddleCount: 120,

    GetData: function GetData(width) {
      if (width < 200) return this.Min;else
      if (width < 400) return this.Simple;

      return this.Full;
    } };


  //港股走势图时间刻度
  var HK_MINUTE_X_COORDINATE =
  {
    Full: //完整模式
    [
    [0, 1, "RGB(200,200,200)", "09:30"],
    [30, 0, "RGB(200,200,200)", "10:00"],
    [60, 1, "RGB(200,200,200)", "10:30"],
    [90, 0, "RGB(200,200,200)", "11:00"],
    [120, 1, "RGB(200,200,200)", "11:30"],
    [151, 0, "RGB(200,200,200)", "13:00"],
    [181, 1, "RGB(200,200,200)", "13:30"],
    [211, 0, "RGB(200,200,200)", "14:00"],
    [241, 1, "RGB(200,200,200)", "14:30"],
    [271, 0, "RGB(200,200,200)", "15:00"],
    [301, 1, "RGB(200,200,200)", "15:30"],
    [331, 1, "RGB(200,200,200)", "16:00"]],

    Simple: //简洁模式
    [
    [0, 1, "RGB(200,200,200)", "09:30"],
    [60, 1, "RGB(200,200,200)", "10:30"],
    [120, 1, "RGB(200,200,200)", "11:30"],
    [211, 0, "RGB(200,200,200)", "14:00"],
    [271, 0, "RGB(200,200,200)", "15:00"],
    [331, 1, "RGB(200,200,200)", "16:00"]],

    Min: //最小模式     
    [
    [0, 1, "RGB(200,200,200)", "09:30"],
    [151, 0, "RGB(200,200,200)", "13:00"],
    [331, 1, "RGB(200,200,200)", "16:00"]],


    Count: 332,
    MiddleCount: 151,

    GetData: function GetData(width)
    {
      if (width < 200) return this.Min;else
      if (width < 450) return this.Simple;

      return this.Full;
    } };


  //富时中国
  var FTSE_MINUTE_X_COORDINATE =
  {
    Full: //完整模式
    [
    [0, 1, "RGB(200,200,200)", "17:00"],
    //[60, 0, "RGB(200,200,200)", "18:00"],
    [120, 1, "RGB(200,200,200)", "19:00"],
    //[180, 0, "RGB(200,200,200)", "20:00"],
    [240, 1, "RGB(200,200,200)", "21:00"],
    //[300, 0, "RGB(200,200,200)", "22:00"],
    [360, 1, "RGB(200,200,200)", "23:00"],
    //[420, 0, "RGB(200,200,200)", "00:00"],
    [480, 1, "RGB(200,200,200)", "01:00"],
    //[540, 0, "RGB(200,200,200)", "02:00"],
    [600, 1, "RGB(200,200,200)", "03:00"],
    //[660, 1, "RGB(200,200,200)", "04:00"],
    [706, 1, "RGB(200,200,200)", "09:00"],
    //[766, 1, "RGB(200,200,200)", "10:00"],
    [826, 1, "RGB(200,200,200)", "11:00"],
    //[886, 1, "RGB(200,200,200)", "12:00"],
    [946, 1, "RGB(200,200,200)", "13:00"],
    //[1006, 1, "RGB(200,200,200)", "14:00"],
    [1066, 1, "RGB(200,200,200)", "15:00"],
    [1156, 1, "RGB(200,200,200)", "16:30"]],

    Simple: //简洁模式
    [
    [0, 1, "RGB(200,200,200)", "17:00"],
    //[60, 0, "RGB(200,200,200)", "18:00"],
    //[120, 1, "RGB(200,200,200)", "19:00"],
    //[180, 0, "RGB(200,200,200)", "20:00"],
    [240, 1, "RGB(200,200,200)", "21:00"],
    //[300, 0, "RGB(200,200,200)", "22:00"],
    //[360, 1, "RGB(200,200,200)", "23:30"],
    //[420, 0, "RGB(200,200,200)", "00:00"],
    [480, 1, "RGB(200,200,200)", "01:00"],
    //[540, 0, "RGB(200,200,200)", "02:00"],
    //[600, 1, "RGB(200,200,200)", "03:00"],
    //[660, 1, "RGB(200,200,200)", "04:00"],
    [706, 1, "RGB(200,200,200)", "09:00"],
    //[766, 1, "RGB(200,200,200)", "10:00"],
    //[826, 1, "RGB(200,200,200)", "11:00"],
    //[886, 1, "RGB(200,200,200)", "12:00"],
    [946, 1, "RGB(200,200,200)", "13:00"],
    //[1006, 1, "RGB(200,200,200)", "14:00"],
    //[1066, 1, "RGB(200,200,200)", "15:00"],
    [1156, 1, "RGB(200,200,200)", "16:30"]],

    Min: //最小模式     
    [
    [0, 1, "RGB(200,200,200)", "17:00"],
    [706, 1, "RGB(200,200,200)", "09:00"],
    [1156, 1, "RGB(200,200,200)", "16:30"]],


    Count: 1157,
    MiddleCount: 707,

    GetData: function GetData(width) {
      if (width < 200) return this.Min;else
      if (width < 450) return this.Simple;

      return this.Full;
    } };


  //港股指数期货
  var FHK_MINUTE_X_COORDINATE =
  {
    Full: //完整模式
    [
    [0, 1, "RGB(200,200,200)", "17:15"],
    //[45, 0, "RGB(200,200,200)", "18:00"],
    [105, 1, "RGB(200,200,200)", "19:00"],
    //[165, 0, "RGB(200,200,200)", "20:00"],
    [225, 1, "RGB(200,200,200)", "21:00"],
    //[285, 0, "RGB(200,200,200)", "22:00"],
    [345, 1, "RGB(200,200,200)", "23:00"],
    //[405, 0, "RGB(200,200,200)", "00:00"],
    [466, 0, "RGB(200,200,200)", "09:15"],
    //[511, 1, "RGB(200,200,200)", "10:00"],
    [571, 1, "RGB(200,200,200)", "11:00"],
    //[632, 1, "RGB(200,200,200)", "13:00"],
    [692, 1, "RGB(200,200,200)", "14:00"],
    //[752, 1, "RGB(200,200,200)", "15:00"],
    [843, 1, "RGB(200,200,200)", "16:30"]],

    Simple: //简洁模式
    [
    [0, 1, "RGB(200,200,200)", "17:15"],
    //[45, 0, "RGB(200,200,200)", "18:00"],
    //[105, 1, "RGB(200,200,200)", "19:00"],
    //[165, 0, "RGB(200,200,200)", "20:00"],
    [225, 1, "RGB(200,200,200)", "21:00"],
    //[285, 0, "RGB(200,200,200)", "22:00"],
    //[345, 1, "RGB(200,200,200)", "23:00"],
    //[405, 0, "RGB(200,200,200)", "00:00"],
    [466, 0, "RGB(200,200,200)", "09:15"],
    //[511, 1, "RGB(200,200,200)", "10:00"],
    //[571, 1, "RGB(200,200,200)", "11:00"],
    [632, 1, "RGB(200,200,200)", "13:00"],
    //[692, 1, "RGB(200,200,200)", "14:00"],
    //[752, 1, "RGB(200,200,200)", "15:00"],
    [843, 1, "RGB(200,200,200)", "16:30"]],

    Min: //最小模式     
    [
    [0, 1, "RGB(200,200,200)", "17:15"],
    [466, 0, "RGB(200,200,200)", "09:15"],
    [843, 1, "RGB(200,200,200)", "16:30"]],


    Count: 843,
    MiddleCount: 466,

    GetData: function GetData(width) {
      if (width < 200) return this.Min;else
      if (width < 450) return this.Simple;

      return this.Full;
    } };


  this.GetCoordinateData = function (symbol, width)
  {
    var data = null;
    if (!symbol)
    {
      data = SHZE_MINUTE_X_COORDINATE; //默认沪深股票
    } else

    {
      var upperSymbol = symbol.toLocaleUpperCase(); //转成大写
      if (MARKET_SUFFIX_NAME.IsSH(upperSymbol) || MARKET_SUFFIX_NAME.IsSZ(upperSymbol))
      data = this.GetSHSZData(upperSymbol, width);else
      if (MARKET_SUFFIX_NAME.IsSHO(upperSymbol))
      data = this.GetSHOData(upperSymbol, width);else
      if (MARKET_SUFFIX_NAME.IsHK(upperSymbol))
      data = HK_MINUTE_X_COORDINATE;else
      if (MARKET_SUFFIX_NAME.IsCFFEX(upperSymbol) || MARKET_SUFFIX_NAME.IsCZCE(upperSymbol) || MARKET_SUFFIX_NAME.IsDCE(upperSymbol) || MARKET_SUFFIX_NAME.IsSHFE(upperSymbol))
      return this.GetChinatFuturesData(upperSymbol, width);else
      if (MARKET_SUFFIX_NAME.IsUSA(upperSymbol))
      data = this.GetUSAData(upperSymbol, width);else
      if (MARKET_SUFFIX_NAME.IsFTSE(upperSymbol, width))
      data = this.GetFTSEData(upperSymbol, width);else
      if (MARKET_SUFFIX_NAME.IsFHK(upperSymbol, width))
      data = this.GetFHKData(upperSymbol, width);else
      if (MARKET_SUFFIX_NAME.IsET(upperSymbol))
      data = this.GetETData(upperSymbol, width);else
      if (MARKET_SUFFIX_NAME.IsNYMEX(upperSymbol, width))
      return data = this.GetNYMEXData(upperSymbol, width);else
      if (MARKET_SUFFIX_NAME.IsCOMEX(upperSymbol, width))
      return data = this.GetCOMEXData(upperSymbol, width);else
      if (MARKET_SUFFIX_NAME.IsNYBOT(upperSymbol, width))
      return data = this.GetNYBOTData(upperSymbol, width);else
      if (MARKET_SUFFIX_NAME.IsCBOT(upperSymbol, width))
      return data = this.GetCBOTData(upperSymbol, width);else
      if (MARKET_SUFFIX_NAME.IsLME(upperSymbol, width))
      return data = this.GetLMEData(upperSymbol, width);else
      if (MARKET_SUFFIX_NAME.IsBIT(upperSymbol, width))
      data = this.GetBITData(upperSymbol, width);
    }

    //console.log('[MiuteCoordinateData]', width);
    var result = { Count: data.Count, MiddleCount: data.MiddleCount, Data: data.GetData(width) };
    return result;
  };

  this.GetSHSZData = function (upperSymbol, width)
  {
    var result = SHZE_MINUTE_X_COORDINATE;
    return result;
  };

  this.GetFuturesData = function (upperSymbol, width, timeData)
  {
    var splitData = timeData.GetSplitData(upperSymbol);
    if (!splitData) return null;
    var stringData = g_MinuteTimeStringData.GetFutures(splitData);
    if (!stringData) return null;
    var result = { Count: stringData.length };
    var coordinate = null;
    var minWidth = 200,simpleWidth = 480;
    /*
                                          if (splitData.Name =='21:00-1:00,9:00-10:15,10:30-11:30,13:30-15:00')
                                          {
                                              minWidth=250;
                                              simpleWidth=500;
                                          }
                                          */

    if (width < minWidth) coordinate = splitData.Coordinate.Min;else
    if (width < simpleWidth) coordinate = splitData.Coordinate.Simple;else
    coordinate = splitData.Coordinate.Full;

    var data = [];
    for (var i = 0; i < stringData.length; ++i)
    {
      var value = stringData[i];
      for (var j = 0; j < coordinate.length; ++j)
      {
        var coordinateItem = coordinate[j];
        if (value == coordinateItem.Value)
        {
          var item = [i, 0, 'RGB(200,200,200)', coordinateItem.Text];
          data.push(item);
          break;
        }
      }
    }

    result.Data = data;
    return result;
  };

  this.GetChinatFuturesData = function (upperSymbol, width)
  {
    return this.GetFuturesData(upperSymbol, width, g_FuturesTimeData);
  };

  this.GetNYMEXData = function (upperSymbol, width)
  {
    return this.GetFuturesData(upperSymbol, width, g_NYMEXTimeData);
  };

  this.GetCOMEXData = function (upperSymbol, width)
  {
    return this.GetFuturesData(upperSymbol, width, g_COMEXTimeData);
  };

  this.GetNYBOTData = function (upperSymbol, width)
  {
    return this.GetFuturesData(upperSymbol, width, g_NYBOTTimeData);
  };

  this.GetCBOTData = function (upperSymbol, width)
  {
    return this.GetFuturesData(upperSymbol, width, g_CBOTTimeData);
  };

  this.GetLMEData = function (upperSymbol, width)
  {
    return this.GetFuturesData(upperSymbol, width, g_LMETimeData);
  };

  this.GetFTSEData = function (upperSymbol, width)
  {
    var result = FTSE_MINUTE_X_COORDINATE;
    return result;
  };

  this.GetFHKData = function (upperSymbol, width)
  {
    var result = FHK_MINUTE_X_COORDINATE;
    return result;
  };

  this.GetETData = function (upperSymbol, width)
  {
    throw { Name: 'MinuteCoordinateData::GetETData', Error: 'not implement' };
  };

  this.GetBITData = function (upperSymbol, width)
  {
    throw { Name: 'MinuteCoordinateData::GetBITData', Error: 'not implement' };
  };

  this.GetUSAData = function (upperSymbol, width)
  {
    var result = USA_MINUTE_X_COORDINATE;
    return result;
  };

  this.GetSHOData = function (upperSymbol, width)
  {
    var result = SHO_MINUTE_X_COORDINATE;
    return result;
  };
}


//期货不同品种 交易时间数据 
function FuturesTimeData()
{
  this.TIME_SPLIT =
  [
  {
    Name: '9:00-10:15,10:30-11:30,13:30-15:00',
    Data:
    [
    //9:00-10:15,10:30-11:30,13:30-15:00
    { Start: 900, End: 1015 },
    { Start: 1031, End: 1130 },
    { Start: 1331, End: 1500 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 900, Text: '9:00' },
      { Value: 930, Text: '9:30' },
      { Value: 1000, Text: '10:00' },
      { Value: 1031, Text: '10:30' },
      { Value: 1100, Text: '11:00' },
      { Value: 1331, Text: '13:30' },
      { Value: 1400, Text: '14:00' },
      { Value: 1430, Text: '14:30' },
      { Value: 1500, Text: '15:00' }],

      Simple: //简洁模式
      [
      { Value: 900, Text: '9:00' },
      { Value: 1000, Text: '10:00' },
      { Value: 1331, Text: '13:30' },
      { Value: 1430, Text: '14:30' },
      { Value: 1500, Text: '15:00' }],

      Min: //最小模式  
      [
      { Value: 900, Text: '9:00' },
      { Value: 1331, Text: '13:30' },
      { Value: 1500, Text: '15:00' }] } },



  {

    Name: '9:15-11:30,13:00-15:15',
    Data:
    [
    { Start: 915, End: 1130 },
    { Start: 1301, End: 1515 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 930, Text: '9:30' },
      { Value: 1000, Text: '10:00' },
      { Value: 1030, Text: '10:30' },
      { Value: 1100, Text: '11:00' },
      { Value: 1301, Text: '13:00' },
      { Value: 1330, Text: '13:30' },
      { Value: 1400, Text: '14:00' },
      { Value: 1430, Text: '14:30' },
      { Value: 1515, Text: '15:15' }],

      Simple: //简洁模式
      [
      { Value: 930, Text: '9:30' },
      { Value: 1030, Text: '10:30' },
      { Value: 1301, Text: '13:00' },
      { Value: 1400, Text: '14:00' },
      { Value: 1515, Text: '15:15' }],

      Min: //最小模式  
      [
      { Value: 930, Text: '9:30' },
      { Value: 1301, Text: '13:00' },
      { Value: 1515, Text: '15:15' }] } },



  {
    Name: '9:30-11:30,13:00-15:00',
    Data:
    [
    { Start: 930, End: 1130 },
    { Start: 1301, End: 1500 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 930, Text: '9:30' },
      { Value: 1000, Text: '10:00' },
      { Value: 1030, Text: '10:30' },
      { Value: 1100, Text: '11:00' },
      { Value: 1301, Text: '13:00' },
      { Value: 1330, Text: '13:30' },
      { Value: 1400, Text: '14:00' },
      { Value: 1430, Text: '14:30' },
      { Value: 1500, Text: '15:00' }],

      Simple: //简洁模式
      [
      { Value: 930, Text: '9:30' },
      { Value: 1030, Text: '10:30' },
      { Value: 1301, Text: '13:00' },
      { Value: 1400, Text: '14:00' },
      { Value: 1500, Text: '15:00' }],

      Min: //最小模式  
      [
      { Value: 930, Text: '9:30' },
      { Value: 1301, Text: '13:00' },
      { Value: 1500, Text: '15:00' }] } },



  {
    Name: '21:00-23:30,9:00-10:15,10:30-11:30,13:30-15:00',
    Data:
    [
    { Start: 2100, End: 2330 },
    { Start: 901, End: 1015 },
    { Start: 1031, End: 1130 },
    { Start: 1331, End: 1500 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 2100, Text: '21:00' },
      { Value: 2200, Text: '22:00' },
      { Value: 2300, Text: '23:00' },
      { Value: 901, Text: '9:00' },
      { Value: 1031, Text: '10:30' },
      { Value: 1331, Text: '13:30' },
      { Value: 1430, Text: '14:30' },
      { Value: 1500, Text: '15:00' }],

      Simple: //简洁模式
      [
      { Value: 2100, Text: '21:00' },
      { Value: 901, Text: '9:00' },
      { Value: 1331, Text: '13:30' },
      { Value: 1500, Text: '15:00' }],

      Min: //最小模式  
      [
      { Value: 2100, Text: '21:00' },
      { Value: 901, Text: '9:00' },
      { Value: 1500, Text: '15:00' }] } },



  {
    Name: '21:00-1:00,9:00-10:15,10:30-11:30,13:30-15:00',
    Data:
    [
    { Start: 2100, End: 2359 },
    { Start: 0, End: 100 },
    { Start: 901, End: 1015 },
    { Start: 1031, End: 1130 },
    { Start: 1301, End: 1500 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 2100, Text: '21:00' },
      { Value: 2200, Text: '22:00' },
      { Value: 2300, Text: '23:00' },
      { Value: 901, Text: '9:00' },
      { Value: 1030, Text: '10:30' },
      { Value: 1331, Text: '13:30' },
      { Value: 1500, Text: '15:00' }],

      Simple: //简洁模式
      [
      { Value: 2100, Text: '21:00' },
      { Value: 2300, Text: '23:00' },
      { Value: 901, Text: '9:00' },
      { Value: 1031, Text: '10:30' },
      { Value: 1500, Text: '15:00' }],

      Min: //最小模式  
      [
      { Value: 2100, Text: '21:00' },
      { Value: 901, Text: '9:00' },
      { Value: 1500, Text: '15:00' }] } },



  {
    Name: '21:00-2:30,9:00-10:15,10:30-11:30,13:30-15:00',
    Data:
    [
    { Start: 2100, End: 2359 },
    { Start: 0, End: 230 },
    { Start: 901, End: 1015 },
    { Start: 1031, End: 1130 },
    { Start: 1331, End: 1500 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 2100, Text: '21:00' },
      { Value: 2300, Text: '23:00' },
      { Value: 100, Text: '1:00' },
      { Value: 901, Text: '9:00' },
      { Value: 1031, Text: '10:30' },
      { Value: 1331, Text: '13:30' },
      { Value: 1500, Text: '15:00' }],

      Simple: //简洁模式
      [
      { Value: 2100, Text: '21:00' },
      { Value: 2300, Text: '23:00' },
      { Value: 901, Text: '9:00' },
      { Value: 1100, Text: '11:00' },
      { Value: 1500, Text: '15:00' }],

      Min: //最小模式  
      [
      { Value: 2100, Text: '21:00' },
      { Value: 901, Text: '9:00' },
      { Value: 1500, Text: '15:00' }] } },



  {
    Name: '21:00-23:00,9:00-10:15,10:30-11:30,13:30-15:00',
    Data:
    [
    { Start: 2100, End: 2300 },
    { Start: 901, End: 1015 },
    { Start: 1031, End: 1130 },
    { Start: 1331, End: 1500 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 2100, Text: '21:00' },
      { Value: 2200, Text: '22:00' },
      { Value: 2300, Text: '23:00' },
      { Value: 1031, Text: '10:30' },
      { Value: 1331, Text: '13:30' },
      { Value: 1430, Text: '14:30' },
      { Value: 1500, Text: '15:00' }],

      Simple: //简洁模式
      [
      { Value: 2100, Text: '21:00' },
      { Value: 2300, Text: '23:00' },
      { Value: 1331, Text: '13:30' },
      { Value: 1500, Text: '15:00' }],

      Min: //最小模式  
      [
      { Value: 2100, Text: '21:00' },
      { Value: 2300, Text: '23:00' },
      { Value: 1500, Text: '15:00' }] } }];





  this.MAP_TWOWORDS = new Map([
  //大连商品交易所
  [MARKET_SUFFIX_NAME.DCE + '-JD', { Time: 0, Decimal: 0, Name: "鸡蛋" }],
  [MARKET_SUFFIX_NAME.DCE + '-FB', { Time: 0, Decimal: 2, Name: "纤板" }],
  [MARKET_SUFFIX_NAME.DCE + '-BB', { Time: 0, Decimal: 2, Name: "胶板" }],
  [MARKET_SUFFIX_NAME.DCE + '-PP', { Time: 6, Decimal: 0, Name: "丙烯" }],
  [MARKET_SUFFIX_NAME.DCE + '-JM', { Time: 6, Decimal: 1, Name: '焦煤' }],
  [MARKET_SUFFIX_NAME.DCE + '-EG', { Time: 6, Decimal: 0, Name: '乙二醇' }],
  [MARKET_SUFFIX_NAME.DCE + '-EB', { Time: 6, Decimal: 0, Name: '苯乙烯' }],
  [MARKET_SUFFIX_NAME.DCE + '-CS', { Time: 6, Decimal: 0, Name: '淀粉' }],
  [MARKET_SUFFIX_NAME.DCE + '-PG', { Time: 6, Decimal: 0, Name: '液化气' }],
  [MARKET_SUFFIX_NAME.DCE + '-RR', { Time: 6, Decimal: 0, Name: '梗米' }],
  //上期所
  [MARKET_SUFFIX_NAME.SHFE + '-CU', { Time: 4, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.SHFE + '-AL', { Time: 4, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.SHFE + '-NI', { Time: 4, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.SHFE + '-SN', { Time: 4, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.SHFE + '-ZN', { Time: 4, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.SHFE + '-PB', { Time: 4, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.SHFE + '-RU', { Time: 6, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.SHFE + '-FU', { Time: 6, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.SHFE + '-RB', { Time: 6, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.SHFE + '-BU', { Time: 6, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.SHFE + '-HC', { Time: 6, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.SHFE + '-WR', { Time: 0, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.SHFE + '-AG', { Time: 5, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.SHFE + '-AU', { Time: 5, Decimal: 2 }],
  //上期能源
  [MARKET_SUFFIX_NAME.SHFE + '-NR', { Time: 6, Decimal: 1, Name: '20号胶' }],
  [MARKET_SUFFIX_NAME.SHFE + '-SC', { Time: 6, Decimal: 1, Name: '中质含硫原油' }],
  [MARKET_SUFFIX_NAME.SHFE + '-LU', { Time: 6, Decimal: 0, Name: '低硫燃料油' }],

  //郑州期货交易所
  [MARKET_SUFFIX_NAME.CZCE + '-CF', { Time: 3, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-SR', { Time: 3, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-MA', { Time: 3, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-ZC', { Time: 3, Decimal: 1 }],
  [MARKET_SUFFIX_NAME.CZCE + '-TA', { Time: 3, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-RM', { Time: 3, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-OI', { Time: 3, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-ME', { Time: 3, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-FG', { Time: 3, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-WS', { Time: 0, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-WT', { Time: 0, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-GN', { Time: 0, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-RO', { Time: 0, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-RS', { Time: 0, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-ER', { Time: 0, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-RI', { Time: 0, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-WH', { Time: 0, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-AP', { Time: 0, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-PM', { Time: 0, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-QM', { Time: 0, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-TC', { Time: 0, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-JR', { Time: 0, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-LR', { Time: 0, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-SF', { Time: 0, Decimal: 0 }],
  [MARKET_SUFFIX_NAME.CZCE + '-SM', { Time: 0, Decimal: 0 }],

  //中期所
  [MARKET_SUFFIX_NAME.CFFEX + '-TF', { Time: 1, Decimal: 3, Name: "二债" }],
  [MARKET_SUFFIX_NAME.CFFEX + '-TS', { Time: 1, Decimal: 3, Name: "五债" }],
  [MARKET_SUFFIX_NAME.CFFEX + '-IH', { Time: 2, Decimal: 1, Name: '上证股指期货' }],
  [MARKET_SUFFIX_NAME.CFFEX + '-IC', { Time: 2, Decimal: 1, Name: '中证股指期货' }],
  [MARKET_SUFFIX_NAME.CFFEX + '-IF', { Time: 2, Decimal: 1, Name: '沪深股指期货' }]]);


  this.MAP_ONEWORD = new Map([
  //大连商品交易所
  [MARKET_SUFFIX_NAME.DCE + '-C', { Time: 6, Decimal: 0, Name: "玉米" }],
  [MARKET_SUFFIX_NAME.DCE + '-L', { Time: 6, Decimal: 0, Name: "乙烯" }],
  [MARKET_SUFFIX_NAME.DCE + '-V', { Time: 6, Decimal: 0, Name: "PVC" }],
  [MARKET_SUFFIX_NAME.DCE + '-A', { Time: 6, Decimal: 0, Name: "豆一" }],
  [MARKET_SUFFIX_NAME.DCE + '-B', { Time: 6, Decimal: 0, Name: "豆二" }],
  [MARKET_SUFFIX_NAME.DCE + '-M', { Time: 6, Decimal: 0, Name: "豆粕" }],
  [MARKET_SUFFIX_NAME.DCE + '-Y', { Time: 6, Decimal: 0, Name: "豆油" }],
  [MARKET_SUFFIX_NAME.DCE + '-P', { Time: 6, Decimal: 0, Name: "棕榈" }],
  [MARKET_SUFFIX_NAME.DCE + '-J', { Time: 6, Decimal: 1, Name: '焦炭' }],
  [MARKET_SUFFIX_NAME.DCE + '-I', { Time: 6, Decimal: 1, Name: "铁矿" }],
  //中期所 
  [MARKET_SUFFIX_NAME.CFFEX + '-T', { Time: 1, Decimal: 3, Name: "十债" }]]);


  this.GetData = function (upperSymbol)
  {
    var oneWord = upperSymbol.charAt(0);
    var twoWords = upperSymbol.substr(0, 2);
    var oneWordName = null,twoWordsName = null;

    if (MARKET_SUFFIX_NAME.IsDCE(upperSymbol)) //大连商品交易所
      {
        oneWordName = MARKET_SUFFIX_NAME.DCE + '-' + oneWord;
        twoWordsName = MARKET_SUFFIX_NAME.DCE + '-' + twoWords;
      } else
    if (MARKET_SUFFIX_NAME.IsSHFE(upperSymbol)) //上期所
      {
        oneWordName = MARKET_SUFFIX_NAME.SHFE + '-' + oneWord;
        twoWordsName = MARKET_SUFFIX_NAME.SHFE + '-' + twoWords;
      } else
    if (MARKET_SUFFIX_NAME.IsCFFEX(upperSymbol)) //中期所 
      {
        oneWordName = MARKET_SUFFIX_NAME.CFFEX + '-' + oneWord;
        twoWordsName = MARKET_SUFFIX_NAME.CFFEX + '-' + twoWords;
      } else
    if (MARKET_SUFFIX_NAME.IsCZCE(upperSymbol)) //郑州期货交易所
      {
        oneWordName = MARKET_SUFFIX_NAME.CZCE + '-' + oneWord;
        twoWordsName = MARKET_SUFFIX_NAME.CZCE + '-' + twoWords;
      }

    if (this.MAP_TWOWORDS.has(twoWordsName))
    {
      return this.MAP_TWOWORDS.get(twoWordsName);
    }

    if (this.MAP_ONEWORD.has(oneWordName))
    {
      return this.MAP_ONEWORD.get(oneWordName);
    }

    return null;
  };

  this.GetSplitData = function (upperSymbol)
  {
    var data = this.GetData(upperSymbol);
    if (!data) return null;

    return this.TIME_SPLIT[data.Time];
  };

  this.GetDecimal = function (upperSymbol) //期货价格小数位数
  {
    var data = this.GetData(upperSymbol);
    if (!data) return 2;

    return data.Decimal;
  };

  //添加新品种
  this.AddNewFutures = function (obj) //{ Suffix:后缀, Symbol:品种代码, Time:交易时间段, Decimal:小数位数, Name:名字 }
  {
    if (!obj) return;

    var key = obj.Suffix + '-' + obj.Symbol;
    var item = { Time: obj.Time, Decimal: obj.Decimal, Name: obj.Name };
    if (obj.Symbol.length == 1)
    {
      this.MAP_ONEWORD.set(key, item);
    } else
    if (obj.Symbol.length == 2)
    {
      this.MAP_TWOWORDS.set(key, item);
    }
  };
}

//纽约商品期货交易所 交易时间数据 
function NYMEXTimeData()
{
  this.MarketSuffix = ".NYMEX";
  this.TimeType = 0; // 0=标准时间 1=夏令时间
  //美国标准时间
  this.TIME_SPLIT =
  [
  {
    Name: '6:00-5:00',
    Data:
    [
    //6:00 - 5:00
    { Start: 600, End: 2359 },
    { Start: 0, End: 500 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 600, Text: '6:00' },
      { Value: 800, Text: '8:00' },
      { Value: 1000, Text: '10:00' },
      { Value: 1200, Text: '12:00' },
      { Value: 1400, Text: '14:00' },
      { Value: 1600, Text: '16:00' },
      { Value: 1800, Text: '18:00' },
      { Value: 2000, Text: '20:00' },
      { Value: 2200, Text: '22:00' },
      { Value: 0, Text: '0:00' },
      { Value: 200, Text: '2:00' },
      { Value: 400, Text: '4:00' }],

      Simple: //简洁模式
      [
      { Value: 600, Text: '6:00' },
      //{ Value: 800, Text: '8:00' },
      { Value: 1000, Text: '10:00' },
      //{ Value: 1200, Text: '12:00' },
      { Value: 1400, Text: '14:00' },
      //{ Value: 1600, Text: '16:00' },
      { Value: 1800, Text: '18:00' },
      //{ Value: 2000, Text: '20:00' },
      { Value: 2200, Text: '22:00' },
      //{ Value: 0, Text: '0:00' },
      { Value: 200, Text: '2:00' }
      //{ Value: 400, Text: '4:00' },
      ],
      Min: //最小模式  
      [
      { Value: 600, Text: '6:00' },
      { Value: 1800, Text: '18:00' },
      { Value: 500, Text: '5:00' }] } }];





  //美国夏时令
  this.TIME_SPLIT2 =
  [
  {
    Name: '7:00-6:00',
    Data:
    [
    //6:00 - 5:00
    { Start: 700, End: 2359 },
    { Start: 0, End: 600 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 700, Text: '7:00' },
      { Value: 900, Text: '9:00' },
      { Value: 1100, Text: '11:00' },
      { Value: 1300, Text: '13:00' },
      { Value: 1500, Text: '15:00' },
      { Value: 1700, Text: '17:00' },
      { Value: 1900, Text: '19:00' },
      { Value: 2100, Text: '21:00' },
      { Value: 2300, Text: '23:00' },
      { Value: 1, Text: '1:00' },
      { Value: 300, Text: '3:00' },
      { Value: 500, Text: '5:00' }],

      Simple: //简洁模式
      [
      { Value: 700, Text: '7:00' },
      //{ Value: 900, Text: '9:00' },
      { Value: 1100, Text: '11:00' },
      //{ Value: 1300, Text: '13:00' },
      { Value: 1500, Text: '15:00' },
      //{ Value: 1700, Text: '17:00' },
      { Value: 1900, Text: '19:00' },
      //{ Value: 2100, Text: '21:00' },
      { Value: 2300, Text: '23:00' },
      //{ Value: 1, Text: '1:00' },
      { Value: 300, Text: '3:00' }
      //{ Value: 500, Text: '5:00' }
      ],
      Min: //最小模式  
      [
      { Value: 700, Text: '7:00' },
      { Value: 1900, Text: '19:00' },
      { Value: 500, Text: '5:00' }] } }];





  this.FUTURES_LIST =
  [
  { Symbol: "CL", Decimal: 2, Time: 0 }, //原油
  { Symbol: "NG", Decimal: 3, Time: 0 }, //天然气
  { Symbol: "RB", Decimal: 4, Time: 0 }, //汽油
  { Symbol: "PL", Decimal: 1, Time: 0 }, //铂金
  { Symbol: "PA", Decimal: 2, Time: 0 }, //钯金
  { Symbol: "HR", Decimal: 0, Time: 0 }, //热轧钢卷
  { Symbol: "QM", Decimal: 3, Time: 0 }, //迷你原油
  { Symbol: "HO", Decimal: 4, Time: 0 } //燃油
  ];

  this.GetFuturesInfo = function (upperSymbol)
  {
    if (upperSymbol.indexOf(this.MarketSuffix) <= 0) return null;

    for (var i in this.FUTURES_LIST)
    {
      var item = this.FUTURES_LIST[i];
      if (upperSymbol.indexOf(item.Symbol) == 0)
      {
        return item;
      }
    }

    return null;
  };

  this.GetSplitData = function (upperSymbol)
  {
    //夏令和标准时间切换
    var timeSplit = this.TimeType == 0 ? this.TIME_SPLIT : this.TIME_SPLIT2;
    var find = this.GetFuturesInfo(upperSymbol);
    if (find) return timeSplit[find.Time];

    return timeSplit[0];
  };

  this.GetDecimal = function (upperSymbol)
  {
    var find = this.GetFuturesInfo(upperSymbol);
    if (find) return find.Decimal;

    return 3;
  };

  this.GetMarketStatus = function (upperSymbol) // 0=闭市 1=盘前 2=盘中 3=盘后
  {
    var usaDate = GetLocalTime(-4); //需要转成美国时间的 周6 周日
    var nowDate = new Date();
    var day = usaDate.getDay();
    var time = nowDate.getHours() * 100 + nowDate.getMinutes();
    if (day == 6 || day == 0) return 0; //周末
    if (time > 430 && time < 730) return 1;

    return 2;
  };
}

function COMEXTimeData()
{
  this.newMethod = NYMEXTimeData; //派生
  this.newMethod();
  delete this.newMethod;

  this.FUTURES_LIST =
  [
  { Symbol: "GC", Decimal: 1, Time: 0 }, //COMEX黄金
  { Symbol: "QO", Decimal: 2, Time: 0 }, //迷你黄金
  { Symbol: "MG", Decimal: 1, Time: 0 }, //微型黄金
  { Symbol: "QI", Decimal: 4, Time: 0 }, //迷你白银
  { Symbol: "SI", Decimal: 3, Time: 0 }, //COMEX白银
  { Symbol: "QI", Decimal: 4, Time: 0 }, //迷你白银
  { Symbol: "HG", Decimal: 4, Time: 0 } //COMEX铜
  ];

  this.MarketSuffix = ".COMEX";
}

function NYBOTTimeData()
{
  this.newMethod = NYMEXTimeData; //派生
  this.newMethod();
  delete this.newMethod;

  //美国标准时间
  this.TIME_SPLIT =
  [
  {
    Name: '9:00-2:20',
    Data:
    [
    //9:00-2:20
    { Start: 900, End: 2359 },
    { Start: 0, End: 220 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 900, Text: '9:00' },
      { Value: 1100, Text: '11:00' },
      { Value: 1300, Text: '13:00' },
      { Value: 1500, Text: '15:00' },
      { Value: 1700, Text: '17:00' },
      { Value: 1900, Text: '19:00' },
      { Value: 2100, Text: '21:00' },
      { Value: 2300, Text: '23:00' },
      { Value: 100, Text: '1:00' }],

      Simple: //简洁模式
      [
      { Value: 900, Text: '9:00' },
      //{ Value: 1100, Text: '11:00' },
      { Value: 1300, Text: '13:00' },
      //{ Value: 1500, Text: '15:00' },
      { Value: 1700, Text: '17:00' },
      //{ Value: 1900, Text: '19:00' },
      { Value: 2100, Text: '21:00' },
      //{ Value: 2300, Text: '23:00' },
      { Value: 100, Text: '1:00' }],

      Min: //最小模式  
      [
      { Value: 900, Text: '9:00' },
      { Value: 1700, Text: '17:00' },
      { Value: 100, Text: '1:00' }] } },



  {
    Name: '15:30-1:00',
    Data:
    [
    //9:00-2:20
    { Start: 1530, End: 2359 },
    { Start: 0, End: 100 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 1600, Text: '16:00' },
      { Value: 1700, Text: '17:00' },
      { Value: 1800, Text: '18:00' },
      { Value: 1900, Text: '19:00' },
      { Value: 2000, Text: '20:00' },
      { Value: 2100, Text: '21:00' },
      { Value: 2200, Text: '22:00' },
      { Value: 2300, Text: '23:00' },
      { Value: 0, Text: '0:00' },
      { Value: 100, Text: '1:00' }],

      Simple: //简洁模式
      [
      { Value: 1600, Text: '16:00' },
      //{ Value: 1600, Text: '17:00' },
      { Value: 1800, Text: '18:00' },
      //{ Value: 1900, Text: '19:00' },
      { Value: 2000, Text: '20:00' },
      //{ Value: 2100, Text: '21:00' },
      { Value: 2200, Text: '22:00' },
      //{ Value: 2300, Text: '23:00' },
      { Value: 0, Text: '0:00' }
      //{ Value: 100, Text: '1:00' }
      ],
      Min: //最小模式  
      [
      { Value: 1600, Text: '16:00' },
      { Value: 2100, Text: '21:00' },
      { Value: 100, Text: '1:00' }] } }];





  //美国夏时令
  this.TIME_SPLIT2 =
  [
  {
    Name: '10:00-3:20',
    Data:
    [
    //9:00-2:20
    { Start: 1000, End: 2359 },
    { Start: 0, End: 320 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 1000, Text: '10:00' },
      { Value: 1200, Text: '12:00' },
      { Value: 1400, Text: '14:00' },
      { Value: 1600, Text: '16:00' },
      { Value: 1800, Text: '18:00' },
      { Value: 2000, Text: '20:00' },
      { Value: 2200, Text: '22:00' },
      { Value: 0, Text: '0:00' },
      { Value: 200, Text: '2:00' }],

      Simple: //简洁模式
      [
      { Value: 1000, Text: '10:00' },
      //{ Value: 1200, Text: '12:00' },
      { Value: 1400, Text: '14:00' },
      //{ Value: 1600, Text: '16:00' },
      { Value: 1800, Text: '18:00' },
      //{ Value: 2000, Text: '20:00' },
      { Value: 2200, Text: '22:00' },
      //{ Value: 0, Text: '0:00' },
      { Value: 200, Text: '2:00' }],

      Min: //最小模式  
      [
      { Value: 1000, Text: '10:00' },
      { Value: 1800, Text: '18:00' },
      { Value: 200, Text: '2:00' }] } },



  {
    Name: '16:30-2:00',
    Data:
    [
    { Start: 1630, End: 2359 },
    { Start: 0, End: 200 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 1700, Text: '17:00' },
      { Value: 1800, Text: '18:00' },
      { Value: 1900, Text: '19:00' },
      { Value: 2000, Text: '20:00' },
      { Value: 2100, Text: '21:00' },
      { Value: 2200, Text: '22:00' },
      { Value: 2300, Text: '23:00' },
      { Value: 0, Text: '0:00' },
      { Value: 100, Text: '1:00' },
      { Value: 200, Text: '2:00' }],

      Simple: //简洁模式
      [
      { Value: 1700, Text: '17:00' },
      //{ Value: 1800, Text: '18:00' },
      { Value: 1900, Text: '19:00' },
      //{ Value: 2000, Text: '20:00' },
      { Value: 2100, Text: '21:00' },
      //{ Value: 2200, Text: '22:00' },
      { Value: 2300, Text: '23:00' },
      //{ Value: 0, Text: '0:00' },
      { Value: 100, Text: '1:00' }
      //{ Value: 200, Text: '2:00' }
      ],
      Min: //最小模式  
      [
      { Value: 1700, Text: '17:00' },
      { Value: 2100, Text: '21:00' },
      { Value: 200, Text: '2:00' }] } }];





  this.FUTURES_LIST =
  [
  { Symbol: "SB", Decimal: 2, Time: 1 }, //11号白糖
  { Symbol: "CT", Decimal: 2, Time: 0 } //棉花
  //{ Symbol:"KC", Decimal:2, Time:0 }, //咖啡
  //{ Symbol:"DX", Decimal:2, Time:0 }, //美元指数
  //{ Symbol:"CC", Decimal:2, Time:0 }  //可可
  ];

  this.MarketSuffix = ".NYBOT";

  this.GetMarketStatus = function (upperSymbol) // 0=闭市 1=盘前 2=盘中 3=盘后
  {
    var usaDate = GetLocalTime(-4); //需要转成美国时间的 周6 周日
    var day = usaDate.getDay();
    var time = usaDate.getHours() * 100 + usaDate.getMinutes();
    if (day == 6 || day == 0) return 0; //周末

    var find = this.GetFuturesInfo(upperSymbol);
    if (!find) return 2;

    if (find.Symbol == "SB") //Sugar No. 11 Futures 03:30 - 13:00
      {
        if (time > 300 && time < 1400) return 2;
      } else
    if (find.Symbol == "CT") //美棉 21:00-14:20 
      {
        if (time >= 0 && time <= 1500 || time >= 2000 && time <= 2359) return 2;
        return 1;
      }

    return 0;
  };
}

//芝商所
function CBOTTimeData()
{
  this.newMethod = NYMEXTimeData; //派生
  this.newMethod();
  delete this.newMethod;

  //夏令时间
  this.TIME_SPLIT =
  [
  {
    Name: '8:00-2:20',
    Data:
    [
    //6:00 - 5:00
    { Start: 800, End: 2359 },
    { Start: 0, End: 220 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 800, Text: '8:00' },
      { Value: 1000, Text: '10:00' },
      { Value: 1200, Text: '12:00' },
      { Value: 1400, Text: '14:00' },
      { Value: 1600, Text: '16:00' },
      { Value: 1800, Text: '18:00' },
      { Value: 2000, Text: '20:00' },
      { Value: 2200, Text: '22:00' },
      { Value: 0, Text: '0:00' },
      { Value: 200, Text: '2:00' }],

      Simple: //简洁模式
      [
      { Value: 800, Text: '8:00' },
      //{ Value: 1000, Text: '10:00' },
      { Value: 1200, Text: '12:00' },
      //{ Value: 1400, Text: '14:00' },
      { Value: 1600, Text: '16:00' },
      //{ Value: 1800, Text: '18:00' },
      { Value: 2000, Text: '20:00' },
      //{ Value: 2200, Text: '22:00' },
      { Value: 0, Text: '0:00' }
      //{ Value: 200, Text: '2:00' }
      ],
      Min: //最小模式  
      [
      { Value: 800, Text: '8:00' },
      { Value: 1800, Text: '18:00' },
      { Value: 200, Text: '2:00' }] } },



  {
    Name: '8:00-2:45',
    Data:
    [
    //6:00 - 5:00
    { Start: 800, End: 2359 },
    { Start: 0, End: 245 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 800, Text: '8:00' },
      { Value: 1000, Text: '10:00' },
      { Value: 1200, Text: '12:00' },
      { Value: 1400, Text: '14:00' },
      { Value: 1600, Text: '16:00' },
      { Value: 1800, Text: '18:00' },
      { Value: 2000, Text: '20:00' },
      { Value: 2200, Text: '22:00' },
      { Value: 0, Text: '0:00' },
      { Value: 200, Text: '2:00' }],

      Simple: //简洁模式
      [
      { Value: 800, Text: '8:00' },
      //{ Value: 1000, Text: '10:00' },
      { Value: 1200, Text: '12:00' },
      //{ Value: 1400, Text: '14:00' },
      { Value: 1600, Text: '16:00' },
      //{ Value: 1800, Text: '18:00' },
      { Value: 2000, Text: '20:00' },
      //{ Value: 2200, Text: '22:00' },
      { Value: 0, Text: '0:00' }
      //{ Value: 200, Text: '2:00' }
      ],
      Min: //最小模式  
      [
      { Value: 800, Text: '8:00' },
      { Value: 1800, Text: '18:00' },
      { Value: 200, Text: '2:00' }] } },



  {
    Name: '6:00-5:00',
    Data:
    [
    //6:00 - 5:00
    { Start: 600, End: 2359 },
    { Start: 0, End: 500 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 600, Text: '6:00' },
      { Value: 800, Text: '8:00' },
      { Value: 1000, Text: '10:00' },
      { Value: 1200, Text: '12:00' },
      { Value: 1400, Text: '14:00' },
      { Value: 1600, Text: '16:00' },
      { Value: 1800, Text: '18:00' },
      { Value: 2000, Text: '20:00' },
      { Value: 2200, Text: '22:00' },
      { Value: 0, Text: '0:00' },
      { Value: 200, Text: '2:00' },
      { Value: 400, Text: '4:00' }],

      Simple: //简洁模式
      [
      { Value: 600, Text: '6:00' },
      //{ Value: 800, Text: '8:00' },
      { Value: 1000, Text: '10:00' },
      //{ Value: 1200, Text: '12:00' },
      { Value: 1400, Text: '14:00' },
      //{ Value: 1600, Text: '16:00' },
      { Value: 1800, Text: '18:00' },
      //{ Value: 2000, Text: '20:00' },
      { Value: 2200, Text: '22:00' },
      //{ Value: 0, Text: '0:00' },
      { Value: 200, Text: '2:00' }
      //{ Value: 400, Text: '4:00' },
      ],
      Min: //最小模式  
      [
      { Value: 600, Text: '6:00' },
      { Value: 1800, Text: '18:00' },
      { Value: 500, Text: '5:00' }] } }];





  //标准时间
  this.TIME_SPLIT2 =
  [
  {
    Name: '9:00-3:20',
    Data:
    [
    { Start: 900, End: 2359 },
    { Start: 0, End: 320 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 900, Text: '9:00' },
      { Value: 1100, Text: '11:00' },
      { Value: 1300, Text: '13:00' },
      { Value: 1500, Text: '15:00' },
      { Value: 1700, Text: '17:00' },
      { Value: 1900, Text: '19:00' },
      { Value: 2100, Text: '21:00' },
      { Value: 2300, Text: '23:00' },
      { Value: 1, Text: '1:00' },
      { Value: 300, Text: '3:00' }],

      Simple: //简洁模式
      [
      { Value: 900, Text: '9:00' },
      //{ Value: 1100, Text: '11:00' },
      { Value: 1300, Text: '13:00' },
      //{ Value: 1500, Text: '15:00' },
      { Value: 1700, Text: '17:00' },
      //{ Value: 1900, Text: '19:00' },
      { Value: 2100, Text: '21:00' },
      //{ Value: 2300, Text: '23:00' },
      { Value: 1, Text: '1:00' }
      //{ Value: 300, Text: '3:00' }
      ],
      Min: //最小模式  
      [
      { Value: 900, Text: '9:00' },
      { Value: 1900, Text: '19:00' },
      { Value: 300, Text: '3:00' }] } },



  {
    Name: '9:00-3:45',
    Data:
    [
    { Start: 900, End: 2359 },
    { Start: 0, End: 345 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 900, Text: '9:00' },
      { Value: 1100, Text: '11:00' },
      { Value: 1300, Text: '13:00' },
      { Value: 1500, Text: '15:00' },
      { Value: 1700, Text: '17:00' },
      { Value: 1900, Text: '19:00' },
      { Value: 2100, Text: '21:00' },
      { Value: 2300, Text: '23:00' },
      { Value: 1, Text: '1:00' },
      { Value: 300, Text: '3:00' }],

      Simple: //简洁模式
      [
      { Value: 900, Text: '9:00' },
      //{ Value: 1100, Text: '11:00' },
      { Value: 1300, Text: '13:00' },
      //{ Value: 1500, Text: '15:00' },
      { Value: 1700, Text: '17:00' },
      //{ Value: 1900, Text: '19:00' },
      { Value: 2100, Text: '21:00' },
      //{ Value: 2300, Text: '23:00' },
      { Value: 1, Text: '1:00' }
      //{ Value: 300, Text: '3:00' }
      ],
      Min: //最小模式  
      [
      { Value: 900, Text: '9:00' },
      { Value: 1900, Text: '19:00' },
      { Value: 300, Text: '3:00' }] } },



  {
    Name: '7:00-6:00',
    Data:
    [
    { Start: 700, End: 2359 },
    { Start: 0, End: 600 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 700, Text: '7:00' },
      { Value: 900, Text: '9:00' },
      { Value: 1100, Text: '11:00' },
      { Value: 1300, Text: '13:00' },
      { Value: 1500, Text: '15:00' },
      { Value: 1700, Text: '17:00' },
      { Value: 1900, Text: '19:00' },
      { Value: 2100, Text: '21:00' },
      { Value: 2300, Text: '23:00' },
      { Value: 1, Text: '1:00' },
      { Value: 300, Text: '3:00' },
      { Value: 500, Text: '5:00' }],

      Simple: //简洁模式
      [
      { Value: 700, Text: '7:00' },
      //{ Value: 900, Text: '9:00' },
      { Value: 1100, Text: '11:00' },
      //{ Value: 1300, Text: '13:00' },
      { Value: 1500, Text: '15:00' },
      //{ Value: 1700, Text: '17:00' },
      { Value: 1900, Text: '19:00' },
      //{ Value: 2100, Text: '21:00' },
      { Value: 2300, Text: '23:00' },
      //{ Value: 1, Text: '1:00' },
      { Value: 300, Text: '3:00' }
      //{ Value: 500, Text: '5:00' }
      ],
      Min: //最小模式  
      [
      { Value: 700, Text: '7:00' },
      { Value: 1800, Text: '18:00' },
      { Value: 500, Text: '5:00' }] } }];





  this.FUTURES_LIST =
  [
  { Symbol: "ZC", Decimal: 2, Time: 0 }, //玉米
  { Symbol: "XC", Decimal: 2, Time: 1 }, //迷你玉米
  { Symbol: "ZS", Decimal: 2, Time: 0 }, //大豆
  { Symbol: "XK", Decimal: 2, Time: 1 }, //迷你大豆
  { Symbol: "ZL", Decimal: 2, Time: 0 }, //豆油
  { Symbol: "ZR", Decimal: 2, Time: 0 }, //稻谷
  { Symbol: "ZO", Decimal: 2, Time: 0 }, //燕麦
  { Symbol: "ZW", Decimal: 2, Time: 0 }, //小麦
  { Symbol: "XW", Decimal: 2, Time: 1 }, //迷你小麦
  { Symbol: "ZM", Decimal: 1, Time: 0 }, //豆粕

  { Symbol: "EH", Decimal: 3, Time: 2 }, //乙醇

  { Symbol: "YM", Decimal: 0, Time: 2 }, //小型道指
  { Symbol: "ES", Decimal: 2, Time: 2 }, //小型标普
  { Symbol: "NQ", Decimal: 2, Time: 2 }, //小型纳指

  { Symbol: "TY", Decimal: 4, Time: 2 }, //10年美国债
  { Symbol: "TU", Decimal: 4, Time: 2 }, //2年美国债
  { Symbol: "FV", Decimal: 4, Time: 2 }, //5年美国债
  { Symbol: "US", Decimal: 4, Time: 2 }, //30年美国债
  { Symbol: "UL", Decimal: 4, Time: 2 } //超国债
  ];

  this.MarketSuffix = ".CBOT";
}

function LMETimeData()
{
  this.newMethod = NYMEXTimeData; //派生
  this.newMethod();
  delete this.newMethod;

  //标准时间
  this.TIME_SPLIT =
  [
  {
    Name: 'LME 9:00-3:00',
    Data:
    [
    { Start: 900, End: 2359 },
    { Start: 0, End: 300 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 900, Text: '9:00' },
      { Value: 1100, Text: '11:00' },
      { Value: 1300, Text: '13:00' },
      { Value: 1500, Text: '15:00' },
      { Value: 1700, Text: '17:00' },
      { Value: 1900, Text: '19:00' },
      { Value: 2100, Text: '21:00' },
      { Value: 2300, Text: '23:00' },
      { Value: 100, Text: '1:00' },
      { Value: 300, Text: '3:00' }],

      Simple: //简洁模式
      [
      { Value: 900, Text: '9:00' },
      //{ Value: 1100, Text: '11:00' },
      { Value: 1300, Text: '13:00' },
      //{ Value: 1500, Text: '15:00' },
      { Value: 1700, Text: '17:00' },
      //{ Value: 1900, Text: '19:00' },
      { Value: 2100, Text: '21:00' },
      //{ Value: 2300, Text: '23:00' },
      { Value: 100, Text: '1:00' }
      // { Value: 300, Text: '3:00' }
      ],
      Min: //最小模式  
      [
      { Value: 900, Text: '9:00' },
      { Value: 1800, Text: '18:00' },
      { Value: 300, Text: '3:00' }] } }];





  //夏令
  this.TIME_SPLIT =
  [
  {
    Name: 'LME 8:00-2:00',
    Data:
    [
    { Start: 800, End: 2359 },
    { Start: 0, End: 200 }],

    Coordinate:
    {
      Full: //完整模式
      [
      { Value: 800, Text: '8:00' },
      { Value: 1000, Text: '10:00' },
      { Value: 1200, Text: '12:00' },
      { Value: 1400, Text: '14:00' },
      { Value: 1600, Text: '16:00' },
      { Value: 1800, Text: '18:00' },
      { Value: 2000, Text: '20:00' },
      { Value: 2200, Text: '22:00' },
      { Value: 0, Text: '0:00' },
      { Value: 200, Text: '2:00' }],

      Simple: //简洁模式
      [
      { Value: 800, Text: '8:00' },
      //{ Value: 1000, Text: '10:00' },
      { Value: 1200, Text: '12:00' },
      //{ Value: 1400, Text: '14:00' },
      { Value: 1600, Text: '16:00' },
      //{ Value: 1800, Text: '18:00' },
      { Value: 2000, Text: '20:00' },
      //{ Value: 2200, Text: '22:00' },
      { Value: 0, Text: '0:00' }
      //{ Value: 200, Text: '2:00' }
      ],
      Min: //最小模式  
      [
      { Value: 800, Text: '8:00' },
      { Value: 1800, Text: '18:00' },
      { Value: 200, Text: '2:00' }] } }];





  this.FUTURES_LIST =
  [
  { Symbol: "SND", Decimal: 0, Time: 0 }, //综合锡03
  { Symbol: "AHD", Decimal: 2, Time: 0 }, //综合铝03
  { Symbol: "PBD", Decimal: 2, Time: 0 }, //综合铅03
  { Symbol: "ZSD", Decimal: 2, Time: 0 }, //综合锌03
  { Symbol: "CAD", Decimal: 2, Time: 0 }, //综合铜03
  { Symbol: "NID", Decimal: 0, Time: 0 } //综合镍03
  ];

  this.MarketSuffix = ".LME";
}

var g_MinuteTimeStringData = new MinuteTimeStringData();
var g_MinuteCoordinateData = new MinuteCoordinateData();
var g_FuturesTimeData = new FuturesTimeData();
var g_NYMEXTimeData = new NYMEXTimeData();
var g_COMEXTimeData = new COMEXTimeData();
var g_NYBOTTimeData = new NYBOTTimeData();
var g_CBOTTimeData = new CBOTTimeData();
var g_LMETimeData = new LMETimeData();


function GetfloatPrecision(symbol) //获取小数位数
{
  var defaultfloatPrecision = 2; //默认2位
  if (!symbol) return defaultfloatPrecision;
  var upperSymbol = symbol.toUpperCase();

  //全部由外部控制
  if (typeof MARKET_SUFFIX_NAME.GetCustomDecimal == 'function') return MARKET_SUFFIX_NAME.GetCustomDecimal(upperSymbol);

  if (MARKET_SUFFIX_NAME.IsSHSZFund(upperSymbol)) defaultfloatPrecision = 3; //基金3位小数
  else if (MARKET_SUFFIX_NAME.IsSHO(upperSymbol)) defaultfloatPrecision = MARKET_SUFFIX_NAME.GetSHODecimal(upperSymbol);else
    if (MARKET_SUFFIX_NAME.IsChinaFutures(upperSymbol)) defaultfloatPrecision = g_FuturesTimeData.GetDecimal(upperSymbol); //期货小数位数读配置
    else if (MARKET_SUFFIX_NAME.IsFHK(upperSymbol)) defaultfloatPrecision = MARKET_SUFFIX_NAME.GetFHKDecimal(upperSymbol);else
      if (MARKET_SUFFIX_NAME.IsFTSE(upperSymbol)) defaultfloatPrecision = MARKET_SUFFIX_NAME.GetFTSEDecimal(upperSymbol);else
      if (MARKET_SUFFIX_NAME.IsBIT(upperSymbol)) defaultfloatPrecision = MARKET_SUFFIX_NAME.GetBITDecimal(upperSymbol);else
      if (MARKET_SUFFIX_NAME.IsET(upperSymbol)) defaultfloatPrecision = MARKET_SUFFIX_NAME.GetETDecimal(upperSymbol);else
      if (MARKET_SUFFIX_NAME.IsNYMEX(upperSymbol)) defaultfloatPrecision = g_NYMEXTimeData.GetDecimal(upperSymbol);else
      if (MARKET_SUFFIX_NAME.IsCOMEX(upperSymbol)) defaultfloatPrecision = g_COMEXTimeData.GetDecimal(upperSymbol);else
      if (MARKET_SUFFIX_NAME.IsNYBOT(upperSymbol)) defaultfloatPrecision = g_NYBOTTimeData.GetDecimal(upperSymbol);else
      if (MARKET_SUFFIX_NAME.IsCBOT(upperSymbol)) defaultfloatPrecision = g_CBOTTimeData.GetDecimal(upperSymbol);else
      defaultfloatPrecision = MARKET_SUFFIX_NAME.GetDefaultDecimal(upperSymbol);

  return defaultfloatPrecision;
}

//导出统一使用JSCommon命名空间名
module.exports =
{
  JSCommonCoordinateData:
  {
    MinuteCoordinateData: g_MinuteCoordinateData,
    MinuteTimeStringData: g_MinuteTimeStringData,
    MARKET_SUFFIX_NAME: MARKET_SUFFIX_NAME,
    GetfloatPrecision: GetfloatPrecision },


  JSCommonCoordinateData_MARKET_SUFFIX_NAME: MARKET_SUFFIX_NAME,
  JSCommonCoordinateData_Global_FuturesTimeData: g_FuturesTimeData,
  JSCommonCoordinateData_Global_NYMEXTimeData: g_NYMEXTimeData,
  JSCommonCoordinateData_Global_COMEXTimeData: g_COMEXTimeData,
  JSCommonCoordinateData_Global_NYBOTTimeData: g_NYBOTTimeData,
  JSCommonCoordinateData_Global_LMETimeData: g_LMETimeData,
  JSCommonCoordinateData_Global_CBOTTimeData: g_CBOTTimeData };

/***/ }),
/* 105 */
/*!*********************************************************************!*\
  !*** I:/out-project/FCoinEx/static/js/umychart.klineinfo.wechat.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";












var _umychartResourceWechat = __webpack_require__(/*! ./umychart.resource.wechat.js */ 106); /*
                                                                            copyright (c) 2018 jones
                                                                        
                                                                            http://www.apache.org/licenses/LICENSE-2.0
                                                                        
                                                                            开源项目 https://github.com/jones2000/HQChart
                                                                        
                                                                            jones_2000@163.com
                                                                        
                                                                            小程序信息地雷数据
                                                                        */var KLINE_INFO_TYPE = { INVESTOR: 1, //互动易
  ANNOUNCEMENT: 2, //公告
  PFORECAST: 3, //业绩预告
  ANNOUNCEMENT_QUARTER_1: 4, //一季度报
  ANNOUNCEMENT_QUARTER_2: 5, //半年报
  ANNOUNCEMENT_QUARTER_3: 6, //2季度报
  ANNOUNCEMENT_QUARTER_4: 7, //年报
  RESEARCH: 8, //调研
  BLOCKTRADING: 9, //大宗交易
  TRADEDETAIL: 10, //龙虎榜
  POLICY: 11 //策略信息
};
function KLineInfoData()
{
  this.ID;
  this.Date;
  this.Title;
  this.InfoType;
  this.ExtendData; //扩展数据
}

/*
      信息地雷
      信息地雷列表
  */
function JSKLineInfoMap()
{
}

JSKLineInfoMap.Get = function (id)
{
  var infoMap = new Map(
  [
  ["互动易", { Create: function Create() {return new InvestorInfo();} }],
  ["公告", { Create: function Create() {return new AnnouncementInfo();} }],
  ["业绩预告", { Create: function Create() {return new PforecastInfo();} }],
  ["调研", { Create: function Create() {return new ResearchInfo();} }],
  ["大宗交易", { Create: function Create() {return new BlockTrading();} }],
  ["龙虎榜", { Create: function Create() {return new TradeDetail();} }],
  ["策略选股", { Create: function Create() {return new PolicyInfo();} }]]);



  return infoMap.get(id);
};

function IKLineInfo()
{
  this.MaxReqeustDataCount = 1000;
  this.StartDate = 20160101;
  this.Data;

  this.GetToday = function ()
  {
    var date = new Date();
    var today = date.getFullYear() * 10000 + (date.getMonth() + 1) * 100 + date.getDate();
    return today;
  };
}

/*
      互动易
  */
function InvestorInfo()
{
  this.newMethod = IKLineInfo; //派生
  this.newMethod();
  delete this.newMethod;

  this.RequestData = function (hqChart)
  {
    var self = this;
    var param = { HQChart: hqChart };
    this.Data = [];

    //请求数据
    wx.request({
      url: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Domain + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.KLine.Info.Investor.ApiUrl,
      data:
      {
        "filed": ["question", "answerdate", "symbol", "id"],
        "symbol": [param.HQChart.Symbol],
        "querydate": { "StartDate": this.StartDate, "EndDate": this.GetToday() },
        "start": 0,
        "end": this.MaxReqeustDataCount },

      method: "post",
      dataType: "json",
      success: function success(recvData)
      {
        self.RecvData(recvData, param);
      } });


    return true;
  };

  this.RecvData = function (recvData, param)
  {
    var data = recvData.data;
    if (!data || !data.list || data.list.length <= 0) return;

    for (var i in data.list)
    {
      var item = data.list[i];
      var infoData = new KLineInfoData();
      infoData.Date = item.answerdate;
      infoData.Title = item.question;
      infoData.InfoType = KLINE_INFO_TYPE.INVESTOR;
      this.Data.push(infoData);
    }

    param.HQChart.UpdataChartInfo();
    param.HQChart.Draw();
  };
}

/*
      公告
  */
function AnnouncementInfo()
{
  this.newMethod = IKLineInfo; //派生
  this.newMethod();
  delete this.newMethod;

  this.RequestData = function (hqChart)
  {
    var self = this;
    var param = { HQChart: hqChart };
    this.Data = [];

    //请求数据
    wx.request({
      url: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Domain + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.KLine.Info.Announcement.ApiUrl,
      data:
      {
        "filed": ["title", "releasedate", "symbol", "id"],
        "symbol": [param.HQChart.Symbol],
        "querydate": { "StartDate": this.StartDate, "EndDate": this.GetToday() },
        "start": 0,
        "end": this.MaxReqeustDataCount },

      method: "post",
      dataType: "json",
      success: function success(recvData)
      {
        self.RecvData(recvData, param);
      } });


    return true;
  };

  this.RecvData = function (recvData, param)
  {
    var data = recvData.data;
    if (!data) return;
    if (!data.report || data.report.length <= 0) return;

    for (var i in data.report)
    {
      var item = data.report[i];
      var infoData = new KLineInfoData();
      infoData.Date = item.releasedate;
      infoData.Title = item.title;
      infoData.InfoType = KLINE_INFO_TYPE.ANNOUNCEMENT;
      for (var j in item.type)
      {
        var typeItem = item.type[j];
        switch (typeItem) {

          case "一季度报告":
            infoData.InfoType = KLINE_INFO_TYPE.ANNOUNCEMENT_QUARTER_1;
            break;
          case "半年度报告":
            infoData.InfoType = KLINE_INFO_TYPE.ANNOUNCEMENT_QUARTER_2;
            break;
          case "三季度报告":
            infoData.InfoType = KLINE_INFO_TYPE.ANNOUNCEMENT_QUARTER_3;
            break;
          case "年度报告":
            infoData.InfoType = KLINE_INFO_TYPE.ANNOUNCEMENT_QUARTER_4;
            break;}

      }
      this.Data.push(infoData);
    }

    param.HQChart.UpdataChartInfo();
    param.HQChart.Draw();
  };
}


/*
      业绩预告
  */
function PforecastInfo()
{
  this.newMethod = IKLineInfo; //派生
  this.newMethod();
  delete this.newMethod;

  this.RequestData = function (hqChart)
  {
    var self = this;
    this.Data = [];
    var param = { HQChart: hqChart };

    //请求数据
    wx.request({
      url: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Domain + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.KLine.Info.Pforecast.ApiUrl,
      data:
      {
        "field": ["pforecast.type", "pforecast.reportdate", "fweek"],
        "condition":
        [
        { "item": ["pforecast.reportdate", "int32", "gte", this.StartDate] }],

        "symbol": [param.HQChart.Symbol],
        "start": 0,
        "end": this.MaxReqeustDataCount },

      method: "post",
      dataType: "json",
      success: function success(recvData)
      {
        self.RecvData(recvData, param);
      } });

    return true;
  };

  this.RecvData = function (recvData, param)
  {
    var data = recvData.data;
    if (!data.stock || data.stock.length != 1) return;
    if (!data.stock[0].stockday || data.stock[0].stockday.length <= 0) return;

    for (var i in data.stock[0].stockday)
    {
      var item = data.stock[0].stockday[i];
      if (item.pforecast.length > 0)
      {
        var dataItem = item.pforecast[0];
        var infoData = new KLineInfoData();
        infoData.Date = item.date;
        infoData.Title = dataItem.type;
        infoData.InfoType = KLINE_INFO_TYPE.PFORECAST;
        infoData.ExtendData = { Type: dataItem.type, ReportDate: dataItem.reportdate };
        if (item.fweek) //未来周涨幅
          {
            infoData.ExtendData.FWeek = {};
            if (item.fweek.week1 != null) infoData.ExtendData.FWeek.Week1 = item.fweek.week1;
            if (item.fweek.week4 != null) infoData.ExtendData.FWeek.Week4 = item.fweek.week4;
          }
        this.Data.push(infoData);
      }
    }

    param.HQChart.UpdataChartInfo();
    param.HQChart.Draw();
  };
}

/*
     投资者关系 (调研)
  */
function ResearchInfo()
{
  this.newMethod = IKLineInfo; //派生
  this.newMethod();
  delete this.newMethod;

  this.RequestData = function (hqChart)
  {
    var self = this;
    var param = { HQChart: hqChart };

    this.Data = [];

    //请求数据
    wx.request({
      url: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Domain + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.KLine.Info.Research.ApiUrl,
      data:
      {
        "filed": ["releasedate", "researchdate", "level", "symbol", "id"],
        "querydate": { "StartDate": this.StartDate, "EndDate": this.GetToday() },
        "symbol": [param.HQChart.Symbol],
        "start": 0,
        "end": this.MaxReqeustDataCount },

      method: "post",
      dataType: "json",
      success: function success(recvData)
      {
        self.RecvData(recvData, param);
      } });


    return true;
  };

  this.RecvData = function (recvData, param)
  {
    var data = recvData.data;
    if (!data) return;
    if (!data.list || data.list.length <= 0) return;

    for (var i in data.list)
    {
      var item = data.list[i];
      var infoData = new KLineInfoData();
      infoData.ID = item.id;
      infoData.Date = item.researchdate;
      infoData.InfoType = KLINE_INFO_TYPE.RESEARCH;
      infoData.ExtendData = { Level: item.level };
      this.Data.push(infoData);

    }

    param.HQChart.UpdataChartInfo();
    param.HQChart.Draw();
  };
}

/*
      大宗交易
  */
function BlockTrading()
{
  this.newMethod = IKLineInfo; //派生
  this.newMethod();
  delete this.newMethod;

  this.RequestData = function (hqChart)
  {
    var self = this;
    var param = { HQChart: hqChart };
    this.Data = [];

    //请求数据
    wx.request({
      url: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Domain + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.KLine.Info.BlockTrading.ApiUrl,
      data:
      {
        "field": ["blocktrading.price", "blocktrading.vol", "blocktrading.premium", "fweek", "price"],
        "condition":
        [
        { "item": ["date", "int32", "gte", this.StartDate] },
        { "item": ["blocktrading.vol", "int32", "gte", "0"] }],

        "symbol": [param.HQChart.Symbol],
        "start": 0,
        "end": this.MaxReqeustDataCount },

      method: "post",
      dataType: "json",
      success: function success(recvData)
      {
        self.RecvData(recvData, param);
      } });


    return true;
  };

  this.RecvData = function (recvData, param)
  {
    var data = recvData.data;
    if (!data || !data.stock || data.stock.length != 1) return;
    if (!data.stock[0].stockday || data.stock[0].stockday.length <= 0) return;

    for (var i in data.stock[0].stockday)
    {
      var item = data.stock[0].stockday[i];
      var infoData = new KLineInfoData();
      infoData.Date = item.date;
      infoData.InfoType = KLINE_INFO_TYPE.BLOCKTRADING;
      infoData.ExtendData =
      {
        Price: item.blocktrading.price, //交易价格
        Premium: item.blocktrading.premium, //溢价 （百分比%)
        Vol: item.blocktrading.vol, //交易金额单位（万元)
        ClosePrice: item.price //收盘价
      };

      if (item.fweek) //未来周涨幅
        {
          infoData.ExtendData.FWeek = {};
          if (item.fweek.week1 != null) infoData.ExtendData.FWeek.Week1 = item.fweek.week1;
          if (item.fweek.week4 != null) infoData.ExtendData.FWeek.Week4 = item.fweek.week4;
        }

      this.Data.push(infoData);
    }

    param.HQChart.UpdataChartInfo();
    param.HQChart.Draw();
  };
}


/*
      龙虎榜
  */
function TradeDetail()
{
  this.newMethod = IKLineInfo; //派生
  this.newMethod();
  delete this.newMethod;

  this.RequestData = function (hqChart)
  {
    var self = this;
    var param = { HQChart: hqChart };

    this.Data = [];

    //请求数据
    wx.request({
      url: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Domain + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.KLine.Info.TradeDetail.ApiUrl,
      data:
      {
        "field": ["tradedetail.typeexplain", "tradedetail.type", "fweek"],
        "condition":
        [
        { "item": ["date", "int32", "gte", this.StartDate] },
        { "item": ["tradedetail.type", "int32", "gte", "0"] }],

        "symbol": [param.HQChart.Symbol],
        "start": 0,
        "end": this.MaxReqeustDataCount },

      method: "post",
      dataType: "json",
      success: function success(recvData)
      {
        self.RecvData(recvData, param);
      } });


    return true;
  };

  this.RecvData = function (recvData, param)
  {
    var data = recvData.data;
    if (!data || !data.stock || data.stock.length != 1) return;
    if (!data.stock[0].stockday || data.stock[0].stockday.length <= 0) return;

    for (var i in data.stock[0].stockday)
    {
      var item = data.stock[0].stockday[i];

      var infoData = new KLineInfoData();
      infoData.Date = item.date;
      infoData.InfoType = KLINE_INFO_TYPE.TRADEDETAIL;
      infoData.ExtendData = { Detail: new Array() };

      for (var j in item.tradedetail)
      {
        var tradeItem = item.tradedetail[j];
        infoData.ExtendData.Detail.push({ "Type": tradeItem.type, "TypeExplain": tradeItem.typeexplain });
      }

      if (item.fweek) //未来周涨幅
        {
          infoData.ExtendData.FWeek = {};
          if (item.fweek.week1 != null) infoData.ExtendData.FWeek.Week1 = item.fweek.week1;
          if (item.fweek.week4 != null) infoData.ExtendData.FWeek.Week4 = item.fweek.week4;
        }

      this.Data.push(infoData);
    }

    param.HQChart.UpdataChartInfo();
    param.HQChart.Draw();
  };
}

//策略信息
function PolicyInfo()
{
  this.newMethod = IKLineInfo; //派生
  this.newMethod();
  delete this.newMethod;

  this.PolicyList = []; //筛选的策略名字 {Name:策略名, Guid:策略的GUID}

  this.SetPolicyList = function (aryPolicy)
  {
    for (var i in aryPolicy)
    {
      this.PolicyList.push({ Name: aryPolicy[i] });
    }
  };

  this.RequestData = function (hqChart)
  {
    var self = this;
    this.Data = [];
    var param = { HQChart: hqChart };

    // setTimeout(function () { self.RecvData(null, param); }, 2000); //模拟数据到达

    //请求数据
    wx.request({
      url: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Domain + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.KLine.Info.Policy.ApiUrl,
      data: {
        "symbol": [param.HQChart.Symbol],
        field: ["policy"],
        "condition": [
        { "item": ["date", "int32", "gte", this.StartDate, "lte", this.GetToday()] }],
        "start": 0,
        "end": this.MaxReqeustDataCount },

      method: "post",
      dataType: "json",
      success: function success(recvData) {
        self.RecvData(recvData, param);
      } });



    return true;
  };

  this.RecvData = function (recvData, param)
  {
    var data = recvData.data;
    if (!data.stock || data.stock.length != 1) return;
    if (!data.stock[0].stockday || data.stock[0].stockday.length <= 0) return;

    var setName = new Set();
    for (var i in this.PolicyList) //把需要过滤的策略名字放set里, 方便后面过滤
    {
      setName.add(this.PolicyList[i].Name);
    }

    for (var i in data.stock[0].stockday)
    {
      var item = data.stock[0].stockday[i];
      var infoData = new KLineInfoData();
      infoData.Date = item.date;
      infoData.InfoType = KLINE_INFO_TYPE.POLICY;
      infoData.ExtendData = [];
      for (var j in item.policy)
      {
        var name = item.policy[j].name;
        if (setName.has(name)) infoData.ExtendData.push({ Name: name });
      }

      if (infoData.ExtendData.length > 0) this.Data.push(infoData);
    }

    param.HQChart.UpdataChartInfo();
    param.HQChart.Draw();

    if (param.HQChart.UpdateUICallback) param.HQChart.UpdateUICallback('RecvPolicyInfoData', this);
  };
}

////////////////////////////////////////////////////////////////////////////////////////////
//  走势图信息地雷
//
//
////////////////////////////////////////////////////////////////////////////////////////////
function JSMinuteInfoMap() {}

JSMinuteInfoMap.InfoMap = new Map(
[
["大盘异动", { Create: function Create() {return new MarketEventInfo();} }]]);


JSMinuteInfoMap.Get = function (id)
{
  return JSMinuteInfoMap.InfoMap.get(id);
};

function IMinuteInfo()
{
  this.Data;
  this.ClassName = 'IMinuteInfo';
}

//////////////////////////////////////////////////////////////////////
//  大盘异动
// 结构 {Date:日期 Time:时间, Title:标题, Type:0 }
////////////////////////////////////////////////////////////////////
function MarketEventInfo()
{
  this.newMethod = IMinuteInfo; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = 'MarketEventInfo';

  this.RequestData = function (hqChart)
  {
    var self = this;
    this.Data = [];
    var param =
    {
      HQChart: hqChart };


    var url = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.CacheDomain + '/cache/analyze/shszevent/marketevent/concept/' + hqChart.TradeDate + '.json';

    if (hqChart.NetworkFilter) {
      var obj =
      {
        Name: 'MarketEventInfo::RequestData', //类名::
        Explain: '大盘异动',
        Request: { Url: url, Type: 'Get', Data: { Date: hqChart.TradeDate, Symbol: hqChart.Symbol } },
        Self: this,
        PreventDefault: false };

      hqChart.NetworkFilter(obj, function (data)
      {
        self.RecvData(data, param);
        param.HQChart.UpdataChartInfo();
        param.HQChart.Draw();
      });

      if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求
    }

    //请求数据
    wx.request({
      url: url,
      method: "get",
      dataType: "json",
      success: function success(recvData) {
        self.RecvData(recvData, param);
      },
      error: function error(http, e) {
        console.warn("[MarketEventInfo::RequestData] error, http ", e, http);
      } });


    return true;
  };

  this.RecvData = function (recvData, param)
  {
    var data = recvData.data;
    for (var i in data.event)
    {
      var event = data.event[i];
      for (var j in event.data)
      {
        var item = event.data[j];
        if (item.length < 2) continue;
        var info = { Date: event.date, Time: item[0], Title: item[1], Type: 0 };
        this.Data.push(info);
      }
    }

    param.HQChart.UpdataChartInfo();
    param.HQChart.Draw();
  };
}

//导出统一使用JSCommon命名空间名
module.exports =
{
  JSCommonKLineInfo:
  {
    JSKLineInfoMap: JSKLineInfoMap,
    KLINE_INFO_TYPE: KLINE_INFO_TYPE,
    JSMinuteInfoMap: JSMinuteInfoMap },


  //单个类导出
  JSCommon_JSKLineInfoMap: JSKLineInfoMap,
  JSCommon_KLINE_INFO_TYPE: KLINE_INFO_TYPE,
  JSCommon_JSMinuteInfoMap: JSMinuteInfoMap };

/***/ }),
/* 106 */
/*!********************************************************************!*\
  !*** I:/out-project/FCoinEx/static/js/umychart.resource.wechat.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
    copyright (c) 2018 jones

    http://www.apache.org/licenses/LICENSE-2.0

    开源项目 https://github.com/jones2000/HQChart

    jones_2000@163.com

    全局配置颜色
*/


function JSChartResource()
{
  this.TooltipBGColor = "rgb(255, 255, 255)"; //背景色
  this.TooltipAlpha = 0.92; //透明度

  this.SelectRectBGColor = "rgba(1,130,212,0.06)"; //背景色
  //   this.SelectRectAlpha=0.06;                  //透明度
  this.BGColor = 'rgb(255,255,255)'; //背景色

  this.UpBarColor = "rgb(238,21,21)";
  this.DownBarColor = "rgb(25,158,0)";
  this.UnchagneBarColor = "rgb(0,0,0)";
  this.MinKLineBarWidth = 4; //最小的柱子宽度 比这个还小就画直线 

  this.Minute = {};
  this.Minute.VolBarColor = null;
  this.Minute.PriceColor = "rgb(50,171,205)";
  this.Minute.AreaPriceColor = 'rgba(50,171,205,0.1)';
  this.Minute.AvPriceColor = "rgb(238,127,9)";

  this.DefaultTextColor = "rgb(43,54,69)";
  this.DefaultTextFont = '14px 微软雅黑';
  this.IndexTitleBGColor = 'rgb(217,219,220)'; //指标名字背景色
  this.DynamicTitleFont = '12px 微软雅黑'; //指标动态标题字体

  this.UpTextColor = "rgb(238,21,21)";
  this.DownTextColor = "rgb(25,158,0)";
  this.UnchagneTextColor = "rgb(0,0,0)";
  this.CloseLineColor = 'rgb(0,191,255)';
  this.CloseLineAreaColor = ['rgba(0,191,255,0.8)', 'rgba(0,191,255,0.2)'];

  this.Title = {
    TradeIndexColor: 'rgb(105,105,105)', //交易指标颜色
    ColorIndexColor: 'rgb(112,128,144)', //五彩K线颜色

    VolColor: "rgb(43,54,69)", //标题成交量
    AmountColor: "rgb(43,54,69)", //成交金额 
    DateTimeColor: "rgb(43,54,69)", //时间,日期  
    SettingColor: "rgb(43,54,69)", //周期,复权
    NameColor: "rgb(43,54,69)", //股票名称
    TurnoverRateColor: 'rgb(43,54,69)', //换手率
    PositionColor: "rgb(43,54,69)" //持仓
  };

  this.FrameBorderPen = "rgb(225,236,242)";
  this.FrameSplitPen = "rgb(225,236,242)"; //分割线
  this.FrameSplitTextColor = "rgb(51,51,51)"; //刻度文字颜色
  this.FrameSplitTextFont = "12px 微软雅黑"; //坐标刻度文字字体
  this.FrameYLineDash = [2, 2]; //Y轴线段虚线点间距,填null 就是实线
  this.FrameXLineDash = null; //X轴线段虚线点间距,填null 就是实线
  //this.FrameSplitTextFont = "14px PingFang-SC-Bold";//坐标刻度文字字体
  this.FrameTitleBGColor = "rgb(246,251,253)"; //标题栏背景色
  this.Frame = {
    XBottomOffset: 0, //X轴文字向下偏移
    YTopOffset: 2 //Y轴顶部文字向下偏移
  };

  this.FrameLatestPrice =
  {
    TextColor: 'rgb(255,255,255)', //最新价格文字颜色
    UpBarColor: "rgb(238,21,21)", //上涨
    DownBarColor: "rgb(25,158,0)", //下跌
    UnchagneBarColor: "rgb(0,0,0)", //平盘
    BGAlpha: 0.6 };


  this.FrameMargin = 4; //左右一共的边距
  this.FrameLeftMargin = 2;
  this.FrameRightMargin = 2;

  this.CorssCursorBGColor = "rgb(43,54,69)"; //十字光标背景
  this.CorssCursorTextColor = "rgb(255,255,255)";
  this.CorssCursorTextFont = "12px 微软雅黑";
  this.CorssCursorHPenColor = "rgb(130,130,130)"; //十字光标线段颜色(水平)
  this.CorssCursorVPenColor = "rgb(130,130,130)"; //十字光标线段颜色(垂直)

  this.Domain = "https://opensource.zealink.com"; //API域名
  this.CacheDomain = "https://opensourcecache.zealink.com"; //缓存域名

  this.KLine =
  {
    MaxMin: { Font: '12px 微软雅黑', Color: 'rgb(111,111,111)' }, //K线最大最小值显示
    Info: //信息地雷
    {
      Color: 'rgb(205,149,12)',
      Color2: 'rgb(255,133,3)', //三角图形颜色
      TextColor: '#197de9',
      TextBGColor: 'rgba(220,220,220,0.5)',
      Investor:
      {
        ApiUrl: '/API/NewsInteract' //互动易
      },
      Announcement: //公告
      {
        ApiUrl: '/API/ReportList' },

      Pforecast: //业绩预告
      {
        ApiUrl: '/API/StockHistoryDay' },

      Research: //调研
      {
        ApiUrl: '/API/InvestorRelationsList' },

      BlockTrading: //大宗交易
      {
        ApiUrl: '/API/StockHistoryDay' },

      TradeDetail: //龙虎榜
      {
        ApiUrl: '/API/StockHistoryDay' },

      Policy: //策略
      {
        ApiUrl: '/API/StockHistoryDay' } } };




  this.Index = {};
  //指标线段颜色
  this.Index.LineColor =
  [
  "rgb(255,189,09)",
  "rgb(22,198,255)",
  "rgb(174,35,161)",
  "rgb(236,105,65)",
  "rgb(68,114,196)",
  "rgb(229,0,79)",
  "rgb(0,128,255)",
  "rgb(252,96,154)",
  "rgb(42,230,215)",
  "rgb(24,71,178)"];



  this.ColorArray = //自定义指标默认颜色
  [
  "rgb(255,174,0)",
  "rgb(25,199,255)",
  "rgb(175,95,162)",
  "rgb(236,105,65)",
  "rgb(68,114,196)",
  "rgb(229,0,79)",
  "rgb(0,128,255)",
  "rgb(252,96,154)",
  "rgb(42,230,215)",
  "rgb(24,71,178)"];


  //历史数据api
  this.Index.StockHistoryDayApiUrl = "https://opensource.zealink.com/API/StockHistoryDay";
  //市场多空
  this.Index.MarketLongShortApiUrl = "https://opensource.zealink.com/API/FactorTiming";
  //市场关注度
  this.Index.MarketAttentionApiUrl = "https://opensource.zealink.com/API/MarketAttention";
  //行业,指数热度
  this.Index.MarketHeatApiUrl = "https://opensource.zealink.com/API/MarketHeat";
  //自定义指数热度
  this.Index.CustomIndexHeatApiUrl = "https://opensource.zealink.com/API/QuadrantCalculate";

  //指标不支持信息
  this.Index.NotSupport = { Font: "14px 微软雅黑", TextColor: "rgb(52,52,52)" };

  //画图工具
  this.DrawPicture = {};
  this.DrawPicture.LineColor =
  [
  "rgb(30,144,255)"];


  this.DrawPicture.PointColor =
  [
  "rgb(105,105,105)"];


  this.KLineTrain =
  {
    Font: 'bold 14px 宋体',
    LastDataIcon: { Color: 'rgb(0,0,205)', Text: '⬇' },
    BuyIcon: { Color: 'rgb(255,185, 15)', Text: '买' },
    SellIcon: { Color: 'rgb(70,130,180)', Text: '卖' } };


  //K线tooltip
  this.TooltipPaint =
  {
    BGColor: 'rgba(250,250,250,0.8)', //背景色
    BorderColor: 'rgb(120,120,120)', //边框颜色
    TitleColor: 'rgb(120,120,120)', //标题颜色
    TitleFont: '13px 微软雅黑' //字体
  },

  //弹幕
  this.Barrage =
  {
    Font: '16px 微软雅黑', //字体
    Height: 20,
    Color: 'RGB(109,109,109)' };


  //走势图 信息地雷
  this.MinuteInfo = {
    TextColor: 'rgb(84,143,255)',
    Font: '14px 微软雅黑',
    PointColor: 'rgb(38,113,254)',
    LineColor: 'rgb(120,167,255)',
    TextBGColor: 'rgba(255,255,255,0.8)' };


  //单图标指标ChartSingleText -> DRAWICON
  this.DRAWICON =
  {
    Text:
    {
      MaxSize: 50, //字体最大
      MinSize: 20, //字体最小

      Zoom:
      {
        Type: 2, //0=放大(K线宽度*Value) 1=放大(K线+间距)*Value 2=(K线+间距)+2*Value;
        Value: 1 },


      FontName: 'Arial' //字体
    } };


  this.DRAWTEXT =
  {
    MaxSize: 18, //字体最大
    MinSize: 18, //字体最小

    Zoom:
    {
      Type: 1, //0=放大(K线宽度*Value) 1=放大(K线+间距)*Value 2=(K线+间距)+2*Value;
      Value: 1 },


    FontName: '微软雅黑' //字体
  };

  this.DRAWNUMBER =
  {
    MaxSize: 18, //字体最大
    MinSize: 18, //字体最小

    Zoom:
    {
      Type: 1, //0=放大(K线宽度*Value) 1=放大(K线+间距)*Value 2=(K线+间距)+2*Value;
      Value: 1 },


    FontName: '微软雅黑' //字体
  };

  this.DRAWABOVE =
  {
    YOffset: 0 //y坐标向上偏移
  };

  this.CIRCLEDOT =
  {
    Radius: 1.3 };


  this.POINTDOT =
  {
    Radius: 2 };


  //深度图
  this.DepthChart =
  {
    BidColor: { Line: "rgb(82,176,123)", Area: "rgba(82,176,123,0.8)" }, //卖
    AskColor: { Line: "rgb(207,76,89)", Area: "rgba(207,76,89, 0.8)" }, //买
    LineWidth: 4 };


  this.DepthCorss =
  {
    BidColor: { Line: "rgb(82,176,123)" }, //卖
    AskColor: { Line: "rgb(207,76,89)" }, //买
    LineWidth: 2, //线段宽度
    LineDash: [3, 3],
    Tooltip:
    {
      BGColor: 'rgba(236,240,245, 0.8)', TextColor: "rgb(130,140,151)",
      Border: { Top: 5, Left: 20, Bottom: 5, Center: 5 },
      Font: "14px 微软雅黑",
      LineHeight: 16 //单行高度
    } };


  // //自定义风格
  this.SetStyle = function (style)
  {
    if (style.TooltipBGColor) this.TooltipBGColor = style.TooltipBGColor;
    if (style.TooltipAlpha) this.TooltipAlpha = style.TooltipAlpha;
    if (style.BGColor) this.BGColor = style.BGColor;
    if (style.SelectRectBGColor) this.SelectRectBGColor = style.SelectRectBGColor;
    if (style.UpBarColor) this.UpBarColor = style.UpBarColor;
    if (style.DownBarColor) this.DownBarColor = style.DownBarColor;
    if (style.UnchagneBarColor) this.UnchagneBarColor = style.UnchagneBarColor;
    if (style.Minute)
    {
      if (style.Minute.VolBarColor) this.Minute.VolBarColor = style.Minute.VolBarColor;
      if (style.Minute.PriceColor) this.Minute.PriceColor = style.Minute.PriceColor;
      if (style.Minute.AvPriceColor) this.Minute.AvPriceColor = style.Minute.AvPriceColor;
      if (style.Minute.AreaPriceColor) this.Minute.AreaPriceColor = style.Minute.AreaPriceColor;
    }
    if (style.DefaultTextColor) this.DefaultTextColor = style.DefaultTextColor;
    if (style.DefaultTextFont) this.DefaultTextFont = style.DefaultTextFont;
    if (style.DynamicTitleFont) this.DynamicTitleFont = style.DynamicTitleFont;
    if (style.IndexTitleBGColor) this.IndexTitleBGColor = style.IndexTitleBGColor;
    if (style.UpTextColor) this.UpTextColor = style.UpTextColor;
    if (style.DownTextColor) this.DownTextColor = style.DownTextColor;
    if (style.UnchagneTextColor) this.UnchagneTextColor = style.UnchagneTextColor;
    if (style.CloseLineColor) this.CloseLineColor = style.CloseLineColor;
    if (style.CloseLineAreaColor) this.CloseLineAreaColor = style.CloseLineAreaColor;
    if (style.FrameBorderPen) this.FrameBorderPen = style.FrameBorderPen;
    if (style.FrameSplitPen) this.FrameSplitPen = style.FrameSplitPen;
    if (style.FrameSplitTextColor) this.FrameSplitTextColor = style.FrameSplitTextColor;
    if (style.FrameSplitTextFont) this.FrameSplitTextFont = style.FrameSplitTextFont;
    if (style.FrameTitleBGColor) this.FrameTitleBGColor = style.FrameTitleBGColor;

    if (style.Frame)
    {
      if (style.Frame.XBottomOffset) this.Frame.XBottomOffset = style.Frame.XBottomOffset;
      if (style.Frame.YTopOffset) this.Frame.YTopOffset = style.Frame.YTopOffset;
    }

    if (style.FrameLatestPrice)
    {
      if (style.FrameLatestPrice.TextColor) this.FrameLatestPrice.TextColor = style.FrameLatestPrice.TextColor;
      if (style.FrameLatestPrice.UpBarColor) this.FrameLatestPrice.UpBarColor = style.FrameLatestPrice.UpBarColor;
      if (style.FrameLatestPrice.DownBarColor) this.FrameLatestPrice.DownBarColor = style.FrameLatestPrice.DownBarColor;
      if (style.FrameLatestPrice.UnchagneBarColor) this.FrameLatestPrice.UnchagneBarColor = style.FrameLatestPrice.UnchagneBarColor;
      if (style.FrameLatestPrice.BGAlpha) this.FrameLatestPrice.BGAlpha = style.FrameLatestPrice.BGAlpha;
    }

    if (style.CorssCursorBGColor) this.CorssCursorBGColor = style.CorssCursorBGColor;
    if (style.CorssCursorTextColor) this.CorssCursorTextColor = style.CorssCursorTextColor;
    if (style.CorssCursorTextFont) this.CorssCursorTextFont = style.CorssCursorTextFont;
    if (style.CorssCursorHPenColor) this.CorssCursorHPenColor = style.CorssCursorHPenColor;
    if (style.CorssCursorVPenColor) this.CorssCursorVPenColor = style.CorssCursorVPenColor;
    if (style.KLine) this.KLine = style.KLine;
    if (style.Index)
    {
      if (style.Index.LineColor) this.Index.LineColor = style.Index.LineColor;
      if (style.Index.NotSupport) this.Index.NotSupport = style.Index.NotSupport;
    }

    if (style.ColorArray) this.ColorArray = style.ColorArray;

    if (style.DrawPicture)
    {
      this.DrawPicture.LineColor = style.DrawPicture.LineColor;
      this.DrawPicture.PointColor = style.DrawPicture.PointColor;
    }

    if (style.TooltipPaint)
    {
      if (style.TooltipPaint.BGColor) this.TooltipPaint.BGColor = style.TooltipPaint.BGColor;
      if (style.TooltipPaint.BorderColor) this.TooltipPaint.BorderColor = style.TooltipPaint.BorderColor;
      if (style.TooltipPaint.TitleColor) this.TooltipPaint.TitleColor = style.TooltipPaint.TitleColor;
      if (style.TooltipPaint.TitleFont) this.TooltipPaint.TitleFont = style.TooltipPaint.TitleFont;
    }

    if (style.Title)
    {
      if (style.Title.TradeIndexColor) this.Title.TradeIndexColor = style.Title.TradeIndexColor;
      if (style.Title.ColorIndexColor) this.Title.ColorIndexColor = style.Title.ColorIndexColor;

      if (style.Title.VolColor) this.Title.VolColor = style.Title.VolColor;
      if (style.Title.AmountColor) this.Title.AmountColor = style.Title.AmountColor;
      if (style.Title.DateTimeColor) this.Title.DateTimeColor = style.Title.DateTimeColor;
      if (style.Title.NameColor) this.Title.NameColor = style.Title.NameColor;
      if (style.Title.SettingColor) this.Title.SettingColor = style.Title.SettingColor;
      if (style.Title.TurnoverRateColor) this.Title.TurnoverRateColor = style.Title.TurnoverRateColor;
      if (style.Title.PositionColor) this.Title.PositionColor = style.Title.PositionColor;
    }

    if (style.DRAWICON)
    {
      if (style.DRAWICON.Text)
      {
        var item = style.DRAWICON.Text;
        if (IFrameSplitOperator.IsPlusNumber(item.MaxSize)) this.DRAWICON.Text.MaxSize = item.MaxSize;
        if (IFrameSplitOperator.IsPlusNumber(item.MinSize)) this.DRAWICON.Text.MinSize = item.MinSize;
        if (item.Zoom) this.DRAWICON.Text.Zoom = item.Zoom;
        if (item.FontName) this.DRAWICON.Text.FontName = item.FontName;
      }
    }

    if (style.DRAWTEXT)
    {
      var item = style.DRAWTEXT;
      if (IFrameSplitOperator.IsPlusNumber(item.MaxSize)) this.DRAWICON.MaxSize = item.MaxSize;
      if (IFrameSplitOperator.IsPlusNumber(item.MinSize)) this.DRAWICON.MinSize = item.MinSize;
      if (item.Zoom) this.DRAWICON.Zoom = item.Zoom;
      if (item.FontName) this.DRAWICON.FontName = item.FontName;
    }

    if (style.DRAWNUMBER)
    {
      var item = style.DRAWNUMBER;
      if (this.IsPlusNumber(item.MaxSize)) this.DRAWNUMBER.Text.MaxSize = item.MaxSize;
      if (this.IsPlusNumber(item.MinSize)) this.DRAWNUMBER.Text.MinSize = item.MinSize;
      if (item.Zoom) this.DRAWNUMBER.Text.Zoom = item.Zoom;
      if (item.FontName) this.DRAWNUMBER.Text.FontName = item.FontName;
    }

    if (style.DRAWABOVE)
    {
      var item = style.DRAWABOVE;
      if (this.IsNumber(item.YOffset)) this.DRAWABOVE.YOffset = item.YOffset;
    }

    if (style.DepthChart)
    {
      var item = style.DepthChart;
      if (item.BidColor)
      {
        if (item.BidColor.Line) this.DepthChart.BidColor.Line = item.BidColor.Line;
        if (item.BidColor.Area) this.DepthChart.BidColor.Area = item.BidColor.Area;
      }
      if (item.AskColor)
      {
        if (item.AskColor.Line) this.DepthChart.AskColor.Line = item.AskColor.Line;
        if (item.AskColor.Area) this.DepthChart.AskColor.Area = item.AskColor.Area;
      }

      if (item.LineWidth) this.DepthChart.LineWidth = item.LineWidth;
    }

    if (style.DepthCorss)
    {
      var item = style.DepthCorss;
      if (item.BidColor)
      {
        if (item.BidColor.Line) this.DepthCorss.BidColor.Line = item.BidColor.Line;
      }

      if (item.AskColor)
      {
        if (item.AskColor.Line) this.DepthCorss.AskColor.Line = item.AskColor.Line;
      }

      if (item.LineWidth) this.DepthCorss.LineWidth = item.LineWidth;
      if (item.LineDash) this.DepthCorss.LineDash = item.LineDash;

      if (item.Tooltip)
      {
        var tooltip = item.Tooltip;
        if (tooltip.BGColor) this.DepthCorss.Tooltip.BGColor = tooltip.BGColor;
        if (tooltip.TextColor) this.DepthCorss.Tooltip.TextColor = tooltip.TextColor;
        if (tooltip.Font) this.DepthCorss.Tooltip.Font = tooltip.Font;
        if (tooltip.LineHeight) this.DepthCorss.Tooltip.LineHeight = tooltip.LineHeight;

        var border = tooltip.Border;
        if (this.IsNumber(border.Top)) this.DepthCorss.Tooltip.Border.Top = border.Top;
        if (this.IsNumber(border.Left)) this.DepthCorss.Tooltip.Border.Left = border.Left;
        if (this.IsNumber(border.Bottom)) this.DepthCorss.Tooltip.Border.Bottom = border.Bottom;
        if (this.IsNumber(border.Center)) this.DepthCorss.Tooltip.Border.Center = border.Center;
      }
    }

    if (style.CIRCLEDOT)
    {
      var item = style.CIRCLEDOT;
      if (this.IsNumber(item.Radius)) this.CIRCLEDOT.Radius = item.Radius;
    }

    if (style.POINTDOT)
    {
      var item = style.POINTDOT;
      if (this.IsNumber(item.Radius)) this.POINTDOT.Radius = item.Radius;
    }
  };


  this.IsNumber = function (value)
  {
    if (value == null) return false;
    if (isNaN(value)) return false;

    return true;
  };

  //判断是否是正数
  this.IsPlusNumber = function (value)
  {
    if (value == null) return false;
    if (isNaN(value)) return false;

    return value > 0;
  };
}

var g_JSChartResource = new JSChartResource();

var JSCHART_LANGUAGE_ID =
{
  LANGUAGE_CHINESE_ID: 0,
  LANGUAGE_ENGLISH_ID: 1 };


function JSChartLocalization()
{
  this.TextResource = new Map([
  //内部tooltip
  ['Tooltip-Open', { CN: '开:', EN: 'O:' }],
  ['Tooltip-High', { CN: '高:', EN: 'H:' }],
  ['Tooltip-Low', { CN: '低:', EN: 'L:' }],
  ['Tooltip-Close', { CN: '收:', EN: 'C:' }],
  ['Tooltip-Increase', { CN: '幅:', EN: 'I:' }],
  ['Tooltip-Vol', { CN: '量:', EN: 'V:' }],
  ['Tooltip-Amount', { CN: '额:', EN: 'A:' }],
  ['Tooltip-AvPrice', { CN: '均:', EN: 'AP:' }],
  ['Tooltip-Price', { CN: '价:', EN: 'P:' }],
  ['Tooltip-Exchange', { CN: '换:', EN: 'E:' }],
  ['Tooltip-Position', { CN: '持:', EN: 'P:' }],

  //K线动态标题
  ['KTitle-Open', { CN: '开:', EN: 'O:' }],
  ['KTitle-High', { CN: '高:', EN: 'H:' }],
  ['KTitle-Low', { CN: '低:', EN: 'L:' }],
  ['KTitle-Close', { CN: '收:', EN: 'C:' }],
  ['KTitle-Increase', { CN: '幅:', EN: 'I:' }],
  ['KTitle-Vol', { CN: '量:', EN: 'V:' }],
  ['KTitle-Amount', { CN: '额:', EN: 'A:' }],
  ['KTitle-Exchange', { CN: '换:', EN: 'E:' }],
  ['KTitle-Position', { CN: '持:', EN: 'P:' }],

  //走势图动态标题
  ['MTitle-Close', { CN: '价:', EN: 'C:' }],
  ['MTitle-AvPrice', { CN: '均:', EN: 'AC:' }],
  ['MTitle-Increase', { CN: '幅:', EN: 'I:' }],
  ['MTitle-Vol', { CN: '量:', EN: 'V:' }],
  ['MTitle-Amount', { CN: '额:', EN: 'A:' }],
  ['MTitle-Position', { CN: '持:', EN: 'P:' }],

  //周期
  ['日线', { CN: '日线', EN: '1D' }],
  ['周线', { CN: '周线', EN: '1W' }],
  ['双周', { CN: '双周', EN: "2W" }],
  ['月线', { CN: '月线', EN: '1M' }],
  ['年线', { CN: '年线', EN: '1Y' }],
  ['1分', { CN: '1分', EN: '1Min' }],
  ['5分', { CN: '5分', EN: '5Min' }],
  ['15分', { CN: '15分', EN: '15Min' }],
  ['30分', { CN: '30分', EN: '30Min' }],
  ['60分', { CN: '60分', EN: '60Min' }],
  ['季线', { CN: '季线', EN: '1Q' }],
  ['分笔', { CN: '分笔', EN: 'Tick' }],
  ['2小时', { CN: '2小时', EN: '2H' }],
  ['4小时', { CN: '4小时', EN: '4H' }],

  //复权
  ['不复权', { CN: '不复权', EN: 'No Right' }],
  ['前复权', { CN: '前复权', EN: 'Pro Right' }],
  ['后复权', { CN: '后复权', EN: 'Post Right' }],

  //week
  ['日', { CN: '日', EN: 'Sun.' }],
  ['一', { CN: '一', EN: 'Mon.' }],
  ['二', { CN: '二', EN: 'Tues.' }],
  ['三', { CN: '三', EN: 'Wed.' }],
  ['四', { CN: '四', EN: 'Thur.' }],
  ['五', { CN: '五', EN: 'Fri.' }],
  ['六', { CN: '六', EN: 'Sat.' }],

  ['1月', { CN: '1月', EN: 'Jan' }],
  ['2月', { CN: '2月', EN: 'Feb' }],
  ['3月', { CN: '3月', EN: 'Mar' }],
  ['4月', { CN: '4月', EN: 'Apr' }],
  ['5月', { CN: '5月', EN: 'May' }],
  ['6月', { CN: '6月', EN: 'Jun' }],
  ['7月', { CN: '7月', EN: 'Jul' }],
  ['8月', { CN: '8月', EN: 'Aug' }],
  ['9月', { CN: '9月', EN: 'Sept' }],
  ['10月', { CN: '10月', EN: 'Oct' }],
  ['11月', { CN: '11月', EN: 'Nov' }],
  ['12月', { CN: '12月', EN: 'Dec' }],

  ['自定义分钟', { CN: '分', EN: 'Min' }],
  ['自定义日线', { CN: '日', EN: 'D' }],
  ['自定义秒', { CN: '秒', EN: 'S' }]]);



  this.GetText = function (key, language)
  {
    var item = this.TextResource.get(key);
    if (!item) return '';

    switch (language) {

      case JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID:
        return item.CN;
      case JSCHART_LANGUAGE_ID.LANGUAGE_ENGLISH_ID:
        return item.EN;
      default:
        return item.CN;}

  };

  this.SetTextResource = function (key, value)
  {
    this.TextResource.set(key, value);
  };
};

var g_JSChartLocalization = new JSChartLocalization();

//导出统一使用JSCommon命名空间名
module.exports =
{
  JSCommonResource:
  {
    JSChartResource: JSChartResource,
    Global_JSChartResource: g_JSChartResource,
    Global_JSChartLocalization: g_JSChartLocalization,
    JSCHART_LANGUAGE_ID: JSCHART_LANGUAGE_ID },


  //单个类导出
  JSCommonResource_JSChartResource: JSChartResource,
  JSCommonResource_Global_JSChartResource: g_JSChartResource,
  JSCommonResource_Global_JSChartLocalization: g_JSChartLocalization,
  JSCommonResource_JSCHART_LANGUAGE_ID: JSCHART_LANGUAGE_ID };

/***/ }),
/* 107 */
/*!********************************************************************!*\
  !*** I:/out-project/FCoinEx/static/js/umychart.complier.wechat.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";













var _umychartConsoleWechat = __webpack_require__(/*! ./umychart.console.wechat.js */ 102);
var _umychartDataWechat = __webpack_require__(/*! ./umychart.data.wechat.js */ 103);

var _umychartResourceWechat = __webpack_require__(/*! ./umychart.resource.wechat.js */ 106);var _JS_EXECUTE_JOB_ID;function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}function _createForOfIteratorHelper(o, allowArrayLike) {var it;if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = o[Symbol.iterator]();}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}






var g_JSComplierResource =
{
  Domain: "https://opensource.zealink.com", //API域名
  CacheDomain: "https://opensourcecache.zealink.com", //缓存域名

  CustomFunction: //定制函数
  {
    Data: new Map() //自定义函数 key=函数名, Value:{ID:函数名, Callback: }
  },

  CustomVariant: //自定义变量
  {
    Data: new Map() //自定义函数 key=变量名, Value:{ Name:变量名, Description:描述信息 }
  },

  IsCustomFunction: function IsCustomFunction(name)
  {
    if (g_JSComplierResource.CustomFunction.Data.has(name)) return true;
    return false;
  },

  IsCustomVariant: function IsCustomVariant(name)
  {
    if (g_JSComplierResource.CustomVariant.Data.has(name)) return true;
    return false;
  } };


var Messages = {
  BadGetterArity: 'Getter must not have any formal parameters',
  BadSetterArity: 'Setter must have exactly one formal parameter',
  BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
  ConstructorIsAsync: 'Class constructor may not be an async method',
  ConstructorSpecialMethod: 'Class constructor may not be an accessor',
  DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
  DefaultRestParameter: 'Unexpected token =',
  DuplicateBinding: 'Duplicate binding %0',
  DuplicateConstructor: 'A class may only have one constructor',
  DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
  ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
  GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
  IllegalBreak: 'Illegal break statement',
  IllegalContinue: 'Illegal continue statement',
  IllegalExportDeclaration: 'Unexpected token',
  IllegalImportDeclaration: 'Unexpected token',
  IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
  IllegalReturn: 'Illegal return statement',
  InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
  InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
  InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
  InvalidLHSInForIn: 'Invalid left-hand side in for-in',
  InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
  InvalidModuleSpecifier: 'Unexpected token',
  InvalidRegExp: 'Invalid regular expression',
  LetInLexicalBinding: 'let is disallowed as a lexically bound name',
  MissingFromClause: 'Unexpected token',
  MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
  NewlineAfterThrow: 'Illegal newline after throw',
  NoAsAfterImportNamespace: 'Unexpected token',
  NoCatchOrFinally: 'Missing catch or finally after try',
  ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
  Redeclaration: '%0 \'%1\' has already been declared',
  StaticPrototype: 'Classes may not have static property named prototype',
  StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
  StrictDelete: 'Delete of an unqualified identifier in strict mode.',
  StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
  StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
  StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
  StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
  StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
  StrictModeWith: 'Strict mode code may not include a with statement',
  StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
  StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
  StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
  StrictReservedWord: 'Use of future reserved word in strict mode',
  StrictVarName: 'Variable name may not be eval or arguments in strict mode',
  TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
  UnexpectedEOS: 'Unexpected end of input',
  UnexpectedIdentifier: 'Unexpected identifier',
  UnexpectedNumber: 'Unexpected number',
  UnexpectedReserved: 'Unexpected reserved word',
  UnexpectedString: 'Unexpected string',
  UnexpectedTemplate: 'Unexpected quasi %0',
  UnexpectedToken: 'Unexpected token %0',
  UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
  UnknownLabel: 'Undefined label \'%0\'',
  UnterminatedRegExp: 'Invalid regular expression: missing /' };


var Regex = {
  // Unicode v8.0.0 NonAsciiIdentifierStart:
  NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
  // Unicode v8.0.0 NonAsciiIdentifierPart:
  NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };


var Character =
{
  FromCodePoint: function FromCodePoint(cp) {
    return cp < 0x10000 ? String.fromCharCode(cp) :
    String.fromCharCode(0xD800 + (cp - 0x10000 >> 10)) +
    String.fromCharCode(0xDC00 + (cp - 0x10000 & 1023));
  },

  //是否是空格 https://tc39.github.io/ecma262/#sec-white-space
  IsWhiteSpace: function IsWhiteSpace(cp)
  {
    return cp === 0x20 || cp === 0x09 || cp === 0x0B || cp === 0x0C || cp === 0xA0 ||
    cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0;
  },

  //是否换行 https://tc39.github.io/ecma262/#sec-line-terminators
  IsLineTerminator: function IsLineTerminator(cp)
  {
    return cp === 0x0A || cp === 0x0D || cp === 0x2028 || cp === 0x2029;
  },

  // https://tc39.github.io/ecma262/#sec-names-and-keywords
  IsIdentifierStart: function IsIdentifierStart(cp)
  {
    return cp === 0x24 || cp === 0x5F ||
    cp >= 0x41 && cp <= 0x5A ||
    cp >= 0x61 && cp <= 0x7A ||
    cp === 0x5C ||
    //【】
    cp === 0x3010 || cp === 0x3011 ||
    cp >= 0x80 && Regex.NonAsciiIdentifierStart.test(Character.FromCodePoint(cp));
  },

  IsIdentifierPart: function IsIdentifierPart(cp)
  {
    return cp === 0x24 || cp === 0x5F ||
    cp >= 0x41 && cp <= 0x5A ||
    cp >= 0x61 && cp <= 0x7A ||
    cp >= 0x30 && cp <= 0x39 ||
    cp === 0x5C ||
    //【】
    cp === 0x3010 || cp === 0x3011 ||
    cp >= 0x80 && Regex.NonAsciiIdentifierPart.test(Character.FromCodePoint(cp));
  },

  // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
  IsDecimalDigit: function IsDecimalDigit(cp)
  {
    return cp >= 0x30 && cp <= 0x39; // 0..9
  },

  IsHexDigit: function IsHexDigit(cp)
  {
    return cp >= 0x30 && cp <= 0x39 || cp >= 0x41 && cp <= 0x46 || cp >= 0x61 && cp <= 0x66; // a..f
  },

  isOctalDigit: function isOctalDigit(cp)
  {
    return cp >= 0x30 && cp <= 0x37; // 0..7
  } };


var TOKEN_NAME = {};
TOKEN_NAME[1 /* BooleanLiteral */] = 'Boolean';
TOKEN_NAME[2 /* EOF */] = '<end>';
TOKEN_NAME[3 /* Identifier */] = 'Identifier';
TOKEN_NAME[4 /* Keyword */] = 'Keyword';
TOKEN_NAME[5 /* NullLiteral */] = 'Null';
TOKEN_NAME[6 /* NumericLiteral */] = 'Numeric';
TOKEN_NAME[7 /* Punctuator */] = 'Punctuator';
TOKEN_NAME[8 /* StringLiteral */] = 'String';
TOKEN_NAME[9 /* RegularExpression */] = 'RegularExpression';
TOKEN_NAME[10 /* Template */] = 'Template';

//编译异常, 错误类
function ErrorHandler()
{
  this.Error = [];

  this.RecordError = function (error)
  {
    this.Error.push(error);
  };

  this.ConstructError = function (msg, column)
  {
    var error = new Error(msg);
    //通过自己抛异常并自己截获 来获取调用堆栈信息
    try
    {
      throw error;
    }
    catch (base)
    {
      if (Object.create && Object.defineProperties)
      {
        error = Object.create(base);
        error.Column = column;
      }
    }

    return error;
  };

  this.CreateError = function (index, line, col, description)
  {
    var msg = 'Line ' + line + ': ' + description;
    var error = this.ConstructError(msg, col);
    error.Index = index;
    error.LineNumber = line;
    error.Description = description;
    return error;
  };

  this.ThrowError = function (index, line, col, description)
  {
    var error = this.CreateError(index, line, col, description);
    throw error;
  };
}

//扫描类
function Scanner(code, ErrorHandler)
{
  this.Source = code;
  this.ErrorHandler = ErrorHandler;
  this.Length = code.length;
  this.Index = 0;
  this.LineNumber = code.length > 0 ? 1 : 0;
  this.LineStart = 0;
  this.CurlyStack = [];

  this.SaveState = function () //保存当前扫描状态
  {
    return { Index: this.Index, LineNumber: this.LineNumber, LineStart: this.LineStart };
  };

  this.RestoreState = function (state) //还原扫描状态
  {
    this.Index = state.Index;
    this.LineNumber = state.LineNumber;
    this.LineStart = state.LineStart;
  };

  this.IsEOF = function () //否是已经结束
  {
    return this.Index >= this.Length;
  };

  this.IsKeyword = function (id)
  {
    return false;
  };

  this.CodePointAt = function (i)
  {
    var cp = this.Source.charCodeAt(i);
    if (cp >= 0xD800 && cp <= 0xDBFF)
    {
      var second = this.Source.charCodeAt(i + 1);
      if (second >= 0xDC00 && second <= 0xDFFF) {
        var first = cp;
        cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
      }
    }
    return cp;
  };

  this.Lex = function ()
  {
    if (this.IsEOF()) return { Type: 2 /*EOF*/, Value: '', LineNumber: this.LineNumber, LineStart: this.LineStart, Start: this.Index, End: this.Index };
    var cp = this.Source.charCodeAt(this.Index);

    //变量名 或 关键字
    if (Character.IsIdentifierStart(cp)) return this.ScanIdentifier();

    //( ) ; 开头 操作符扫描
    if (cp === 0x28 || cp === 0x29 || cp === 0x3B) return this.ScanPunctuator();

    //' " 开头 字符串扫描
    if (cp === 0x27 || cp === 0x22) return this.ScanStringLiteral();

    //. 开头 浮点型
    if (cp == 0x2E)
    {
      if (Character.IsDecimalDigit(this.Source.charCodeAt(this.Index + 1)))
      return this.ScanNumericLiteral();

      return this.ScanPunctuator();
    }

    //数字
    if (Character.IsDecimalDigit(cp)) return this.ScanNumericLiteral();

    if (cp >= 0xD800 && cp < 0xDFFF)
    {
      if (Character.IsIdentifierStart(this.CodePointAt(this.Index))) return this.ScanIdentifier();
    }

    return this.ScanPunctuator();

  };

  //关键字 变量名 https://tc39.github.io/ecma262/#sec-names-and-keywords
  this.ScanIdentifier = function ()
  {
    var type;
    var start = this.Index;
    //0x5C 反斜杠
    var id = this.Source.charCodeAt(start) === 0x5C ? this.GetComplexIdentifier() : this.GetIdentifier();

    if (id.length) type = 3; //Identifier
    else if (this.IsKeyword(id)) type = 4; //Keyword
      else if (id == null) type = 5; //NullLiteral
        else if (id == 'true' || id == 'false') type = 1; //BooleanLiteral
          else type = 3; //Identifier

    if (type != 3 && start + id.length != this.Index)
    {
      var restore = this.Index;
      this.Index = start;
      throw Messages.InvalidEscapedReservedWord;
      this.Index = restore;
    }

    if (id == 'AND' || id == 'OR') type = 7 /*Punctuator*/;

    return { Type: type, Value: id, LineNumber: this.LineNumber, LineStart: this.LineStart, Start: start, End: this.Index };
  };

  this.GetIdentifier = function ()
  {
    var start = this.Index++; //start 保存进来的位置
    while (!this.IsEOF())
    {
      var ch = this.Source.charCodeAt(this.Index);
      if (ch == 0x5C)
      {
        this.Index = start;
        return this.GetComplexIdentifier();
      } else
      if (ch >= 0xD800 && ch < 0xDFFF)
      {
        this.Index = start;
        return this.GetComplexIdentifier();
      }

      if (Character.IsIdentifierPart(ch)) ++this.Index;else
      break;
    }

    return this.Source.slice(start, this.Index);
  };

  //操作符 https://tc39.github.io/ecma262/#sec-punctuators
  this.ScanPunctuator = function ()
  {
    var start = this.Index;
    var str = this.Source[this.Index];
    switch (str) {

      case '(':
        ++this.Index;
        break;
      case ')':
      case ';':
      case ',':
        ++this.Index;
        break;
      case '.':
        ++this.Index;
        /*if (this.Source[this.Index] === '.' && this.Source[this.Index + 1] === '.') 
                      {
                          //Spread operator: ...
                          this.Index += 2;
                          str = '...';
                      }
                      */
        break;
      default:
        str = this.Source.substr(this.Index, 3);
        if (str == 'AND')
        {
          this.Index += 3;
        } else

        {
          str = this.Source.substr(this.Index, 2);
          if (str === '&&' || str === '||' || str === '==' || str === '!=' || str === '<>' || str === '<=' || str === '>=' || str === '=>' || str == ':=' || str == 'OR')
          {
            this.Index += 2;
          } else

          {
            str = this.Source[this.Index];
            if ('<>=!+-*%&|^/:'.indexOf(str) >= 0) ++this.Index;
          }
        }}


    if (this.Index == start)
    this.ThrowUnecpectedToken();

    return { Type: 7 /*Punctuator*/, Value: str, LineNumber: this.LineNumber, LineStart: this.LineStart, Start: start, End: this.Index };
  };

  //字符串 https://tc39.github.io/ecma262/#sec-literals-string-literals
  this.ScanStringLiteral = function ()
  {
    var start = this.Index;
    var quote = this.Source[this.Index];

    ++this.Index;
    var octal = false;
    var str = '';
    while (!this.IsEOF())
    {
      var ch = this.Source[this.Index++];
      if (ch == quote)
      {
        quote = '';
        break;
      } else
      if (ch == '\\') //字符串转义
        {
          throw "not complete";
        } else
      if (Character.IsLineTerminator(ch.charCodeAt(0)))
      {
        break;
      } else

      {
        str += ch;
      }
    }

    if (quote != '')
    {
      this.Index = start;
      this.ThrowUnecpectedToken();
    }

    return { Type: 8 /*StringLiteral*/, Value: str, LineNumber: this.LineNumber, LineStart: this.LineStart, Start: start, End: this.Index };
  };

  this.ScanNumericLiteral = function ()
  {
    var start = this.Index;
    var ch = this.Source[this.Index];
    var num = '';
    if (ch != '.')
    {
      num = this.Source[this.Index++];
      ch = this.Source[this.Index];
      // Hex number starts with '0x'. 16进制
      if (num == '0')
      {
        if (ch == 'x' || ch == 'X')
        {
          ++this.Index;
          return this.ScanHexLiteral(start);
        }
      }

      while (Character.IsDecimalDigit(this.Source.charCodeAt(this.Index)))
      {
        num += this.Source[this.Index++];
      }

      ch = this.Source[this.Index];
    }

    if (ch == '.')
    {
      num += this.Source[this.Index++];
      while (Character.IsDecimalDigit(this.Source.charCodeAt(this.Index)))
      {
        num += this.Source[this.Index++];
      }
      ch = this.Source[this.Index];
    }

    //科学计数法
    if (ch == 'e' || ch == 'E')
    {
      num += this.Source[this.Index++];
      ch = this.Source[this.Index];
      if (ch == '+' || ch == '-') num += this.Source[this.Index];
      if (Character.IsDecimalDigit(this.Source.charCodeAt(this.Index)))
      {
        while (Character.IsDecimalDigit(this.Source.charCodeAt(this.Index)))
        {
          num += this.Source[this.Index++];
        }
      } else

      {
        this.ThrowUnecpectedToken();
      }
    }

    if (Character.IsIdentifierStart(this.Source.charCodeAt(this.Index)))
    {
      this.ThrowUnecpectedToken();
    }

    return { Type: 6 /*NumericLiteral*/, Value: parseFloat(num), LineNumber: this.LineNumber, LineStart: this.LineStart, Start: start, End: this.Index };
  };

  //空格 或 注释
  this.ScanComments = function ()
  {
    var comments;
    var start = this.Index == 0;
    while (!this.IsEOF())
    {
      var ch = this.Source.charCodeAt(this.Index);
      if (Character.IsWhiteSpace(ch)) //过滤掉空格
        {
          ++this.Index;
        } else
      if (Character.IsLineTerminator(ch))
      {
        ++this.Index;
        if (ch == 0x0D && this.Source.charCodeAt(this.Index) == 0x0A) ++this.Index; //回车+换行
        ++this.LineNumber;
        this.LineStart = this.Index;
        start = true;
      } else
      if (ch == 0x2F) // //注释
        {
          ch = this.Source.charCodeAt(this.Index + 1);
          if (ch == 0x2F)
          {
            this.Index += 2;
            var comment = this.SkipSingleLineComment(2);
            start = true;
          } else

          {
            break;
          }
        } else
      if (ch == 0x7B) //{ }  注释
        {
          this.Index += 1;
          var _comment = this.SkipMultiLineComment();
        } else

      {
        break;
      }
    }

    return comments;
  };

  this.SkipMultiLineComment = function ()
  {
    var comments = [];
    while (!this.IsEOF())
    {
      var ch = this.Source.charCodeAt(this.Index);
      if (Character.IsLineTerminator(ch))
      {
        ++this.LineNumber;
        ++this.Index;
        this.LineStart = this.Index;
      } else
      if (ch == 0x7D)
      {
        this.Index += 1;
        return comments;
      } else

      {
        ++this.Index;
      }
    }

    return comments;
  };

  //单行注释 https://tc39.github.io/ecma262/#sec-comments
  this.SkipSingleLineComment = function (offset)
  {
    var comments = [];
    while (!this.IsEOF())
    {
      var ch = this.Source.charCodeAt(this.Index);
      ++this.Index;
      if (Character.IsLineTerminator(ch))
      {
        if (ch === 13 && this.Source.charCodeAt(this.Index) === 10)
        ++this.Index;

        ++this.LineNumber;
        this.LineStart = this.Index;
        return comments;
      }
    }

    return comments;
  };

  this.ThrowUnecpectedToken = function (message)
  {
    if (!message) message = Messages.UnexpectedTokenIllegal;
    return this.ErrorHandler.ThrowError(this.Index, this.LineNumber, this.Index - this.LineStart + 1, message);
  };

}

function Tokenizer(code)
{
  this.ErrorHandler = new ErrorHandler(); //错误信息处理类
  this.Scanner = new Scanner(code, this.ErrorHandler);
  this.Buffer = [];

  this.GetNextToken = function ()
  {
    if (this.Buffer.length == 0)
    {
      var comments = this.Scanner.ScanComments();
      if (!this.Scanner.IsEOF())
      {
        var token = this.Scanner.Lex();

        var entry = { Type: TOKEN_NAME[token.Type], Value: this.Scanner.Source.slice(token.Start, token.End) };

        this.Buffer.push(entry);
      }
    }

    return this.Buffer.shift();
  };
}

var Syntax = {
  AssignmentExpression: 'AssignmentExpression',
  AssignmentPattern: 'AssignmentPattern',
  ArrayExpression: 'ArrayExpression',
  ArrayPattern: 'ArrayPattern',
  ArrowFunctionExpression: 'ArrowFunctionExpression',
  AwaitExpression: 'AwaitExpression',
  BlockStatement: 'BlockStatement',
  BinaryExpression: 'BinaryExpression',
  BreakStatement: 'BreakStatement',
  CallExpression: 'CallExpression',
  CatchClause: 'CatchClause',
  ClassBody: 'ClassBody',
  ClassDeclaration: 'ClassDeclaration',
  ClassExpression: 'ClassExpression',
  ConditionalExpression: 'ConditionalExpression',
  ContinueStatement: 'ContinueStatement',
  DoWhileStatement: 'DoWhileStatement',
  DebuggerStatement: 'DebuggerStatement',
  EmptyStatement: 'EmptyStatement',
  ExportAllDeclaration: 'ExportAllDeclaration',
  ExportDefaultDeclaration: 'ExportDefaultDeclaration',
  ExportNamedDeclaration: 'ExportNamedDeclaration',
  ExportSpecifier: 'ExportSpecifier',
  ExpressionStatement: 'ExpressionStatement',
  ForStatement: 'ForStatement',
  ForOfStatement: 'ForOfStatement',
  ForInStatement: 'ForInStatement',
  FunctionDeclaration: 'FunctionDeclaration',
  FunctionExpression: 'FunctionExpression',
  Identifier: 'Identifier',
  IfStatement: 'IfStatement',
  ImportDeclaration: 'ImportDeclaration',
  ImportDefaultSpecifier: 'ImportDefaultSpecifier',
  ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
  ImportSpecifier: 'ImportSpecifier',
  Literal: 'Literal',
  LabeledStatement: 'LabeledStatement',
  LogicalExpression: 'LogicalExpression',
  MemberExpression: 'MemberExpression',
  MetaProperty: 'MetaProperty',
  MethodDefinition: 'MethodDefinition',
  NewExpression: 'NewExpression',
  ObjectExpression: 'ObjectExpression',
  ObjectPattern: 'ObjectPattern',
  Program: 'Program',
  Property: 'Property',
  RestElement: 'RestElement',
  ReturnStatement: 'ReturnStatement',
  SequenceExpression: 'SequenceExpression',
  SpreadElement: 'SpreadElement',
  Super: 'Super',
  SwitchCase: 'SwitchCase',
  SwitchStatement: 'SwitchStatement',
  TaggedTemplateExpression: 'TaggedTemplateExpression',
  TemplateElement: 'TemplateElement',
  TemplateLiteral: 'TemplateLiteral',
  ThisExpression: 'ThisExpression',
  ThrowStatement: 'ThrowStatement',
  TryStatement: 'TryStatement',
  UnaryExpression: 'UnaryExpression',
  UpdateExpression: 'UpdateExpression',
  VariableDeclaration: 'VariableDeclaration',
  VariableDeclarator: 'VariableDeclarator',
  WhileStatement: 'WhileStatement',
  WithStatement: 'WithStatement',
  YieldExpression: 'YieldExpression' };



function Node()
{
  this.IsNeedIndexData = false; //是否需要大盘数据
  this.IsNeedLatestData = false; //是否需要最新的个股行情数据
  this.IsNeedSymbolData = false; //是否需要下载股票数据
  this.IsNeedMarginData = new Set();
  this.IsNeedNewsAnalysisData = new Set(); //新闻统计数据
  this.IsNeedBlockIncreaseData = new Set(); //是否需要市场涨跌股票数据统计
  this.IsNeedSymbolExData = new Set(); //下载股票行情的其他数据

  this.FunctionData = []; //{ID:,  Args:,  FunctionName: }
  //FINVALUE(ID),FINONE(ID,Y,MMDD), FINANCE(ID)

  this.IsAPIData = []; //加载API数据

  this.GetDataJobList = function () //下载数据任务列表
  {
    var jobs = [];
    if (this.IsNeedSymbolData) jobs.push({ ID: JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_SYMBOL_DATA });
    if (this.IsNeedIndexData) jobs.push({ ID: JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_INDEX_DATA });
    if (this.IsNeedLatestData) jobs.push({ ID: JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_SYMBOL_LATEST_DATA });

    //涨跌停家数统计
    var _iterator = _createForOfIteratorHelper(this.IsNeedBlockIncreaseData),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;)
      {var blockSymbol = _step.value;
        jobs.push({ ID: JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_INDEX_INCREASE_DATA, Symbol: blockSymbol });
      }

      //加载融资融券
    } catch (err) {_iterator.e(err);} finally {_iterator.f();}var _iterator2 = _createForOfIteratorHelper(this.IsNeedMarginData),_step2;try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;)
      {var jobID = _step2.value;
        jobs.push({ ID: jobID });
      }

      //加载新闻统计
    } catch (err) {_iterator2.e(err);} finally {_iterator2.f();}var _iterator3 = _createForOfIteratorHelper(this.IsNeedNewsAnalysisData),_step3;try {for (_iterator3.s(); !(_step3 = _iterator3.n()).done;)
      {var jobID = _step3.value;
        jobs.push({ ID: jobID });
      }} catch (err) {_iterator3.e(err);} finally {_iterator3.f();}

    for (var i in this.IsAPIData)
    {
      var item = this.IsAPIData[i];
      jobs.push(item);
    }

    //行情其他数据
    var _iterator4 = _createForOfIteratorHelper(this.IsNeedSymbolExData),_step4;try {for (_iterator4.s(); !(_step4 = _iterator4.n()).done;)
      {var jobID = _step4.value;
        jobs.push({ ID: jobID });
      }} catch (err) {_iterator4.e(err);} finally {_iterator4.f();}

    for (var i in this.FunctionData)
    {
      var item = this.FunctionData[i];
      jobs.push(item);
    }

    return jobs;
  };

  this.VerifySymbolVariable = function (varName, token)
  {
    var setIndexName = new Set(['INDEXA', 'INDEXC', 'INDEXH', 'INDEXL', "INDEXO", "INDEXV", 'INDEXDEC', 'INDEXADV']);
    if (setIndexName.has(varName))
    {
      this.IsNeedIndexData = true;
      return;
    }

    var setSymbolDataName = new Set(['CLOSE', 'C', 'VOL', 'V', 'OPEN', 'O', 'HIGH', 'H', 'LOW', 'L', 'AMOUNT']);
    if (setSymbolDataName.has(varName))
    {
      this.IsNeedSymbolData = true;
      return;
    }

    if (varName === 'VOLR')
    {
      if (!this.IsNeedSymbolExData.has(JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_VOLR_DATA))
      this.IsNeedSymbolExData.add(JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_VOLR_DATA);
      return;
    }

    if (varName == 'HYBLOCK' || varName == 'DYBLOCK' || varName == 'GNBLOCK')
    {
      if (!this.IsNeedSymbolExData.has(JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_GROUP_DATA))
      this.IsNeedSymbolExData.add(JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_GROUP_DATA);
      return;
    }

    //CAPITAL流通股本(手), EXCHANGE 换手率, TOTALCAPITAL 总股本(手)
    var setVariantName = new Set(["CAPITAL", "TOTALCAPITAL", "EXCHANGE"]);
    if (setVariantName.has(varName))
    {
      var item = { ID: JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_VARIANT, VariantName: varName };
      if (token) item.Token = { Index: token.Start, Line: token.LineNumber };
      this.FunctionData.push(item);
      return;
    }

    if (g_JSComplierResource.IsCustomVariant(varName)) //自定义函数
      {
        var item = { VariantName: varName, ID: JS_EXECUTE_JOB_ID.JOB_CUSTOM_VARIANT_DATA };
        if (token) item.Token = { Index: token.Start, Line: token.LineNumber };
        this.FunctionData.push(item);
        return;
      }
  };

  this.VerifySymbolFunction = function (callee, args, token)
  {
    //自定义函数 可以覆盖系统内置函数
    if (g_JSComplierResource.IsCustomFunction(callee.Name))
    {
      var item = { FunctionName: callee.Name, ID: JS_EXECUTE_JOB_ID.JOB_CUSTOM_FUNCTION_DATA, Args: args };
      if (token) item.Token = { Index: token.Start, Line: token.LineNumber };
      this.FunctionData.push(item);
      return;
    }

    if (callee.Name == 'DYNAINFO')
    {
      this.IsNeedLatestData = true;
      return;
    }

    //财务函数
    if (callee.Name == 'FINANCE')
    {
      var item = { ID: JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_FINANCE, Args: args, FunctionName: callee.Name };
      if (token) item.Token = { Index: token.Start, Line: token.LineNumber };
      this.FunctionData.push(item);
      return;
    }

    if (callee.Name == "FINVALUE")
    {
      var item = { ID: JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_FINVALUE, Args: args, FunctionName: callee.Name };
      if (token) item.Token = { Index: token.Start, Line: token.LineNumber };
      this.FunctionData.push(item);
      return;
    }

    if (callee.Name == "FINONE")
    {
      var item = { ID: JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_FINONE, Args: args, FunctionName: callee.Name };
      if (token) item.Token = { Index: token.Start, Line: token.LineNumber };
      this.FunctionData.push(item);
      return;
    }

    if (callee.Name == 'GPJYVALUE')
    {
      var item = { ID: JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_GPJYVALUE, Args: args, FunctionName: callee.Name };
      if (token) item.Token = { Index: token.Start, Line: token.LineNumber };
      this.FunctionData.push(item);
      return;
    }

    if (callee.Name === 'MARGIN')
    {
      var jobID = JS_EXECUTE_JOB_ID.GetMarginJobID(args[0].Value);
      if (jobID && !this.IsNeedMarginData.has(jobID)) this.IsNeedMarginData.add(jobID);
      return;
    }

    if (callee.Name === 'NEWS')
    {
      var _jobID = JS_EXECUTE_JOB_ID.GetNewsAnalysisID(args[0].Value);
      if (_jobID && !this.IsNeedNewsAnalysisData.has(_jobID)) this.IsNeedNewsAnalysisData.add(_jobID);
      return;
    }

    if (callee.Name == 'COST' || callee.Name == 'WINNER') //筹码都需要换手率
      {
        //下载流通股
        var item = { ID: JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_FINANCE, Args: [7], FunctionName: "FINANCE", FunctionName2: callee.Name };
        if (token) item.Token = { Index: token.Start, Line: token.LineNumber };
        this.FunctionData.push(item);
        return;
      }

    if (callee.Name === 'BETA') //beta需要下载上证指数
      {
        this.IsNeedIndexData = true;
        return;
      }

    if (callee.Name == 'UPCOUNT' || callee.Name == 'DOWNCOUNT') //上涨下跌个数
      {
        var blockSymbol = args[0].Value;
        if (!this.IsNeedBlockIncreaseData.has(blockSymbol)) this.IsNeedBlockIncreaseData.add(blockSymbol);
        return;
      }

    if (callee.Name == "LOADAPIDATA") //加载API数据
      {
        var item = { Name: callee.Name, ID: JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_CUSTOM_API_DATA, Args: args };
        if (token) item.Token = { Index: token.Start, Line: token.LineNumber };

        this.IsAPIData.push(item);
        return;
      }
  };

  this.ExpressionStatement = function (expression)
  {
    return { Type: Syntax.ExpressionStatement, Expression: expression };
  };

  this.Script = function (body)
  {
    return { Type: Syntax.Program, Body: body, SourceType: '通达信脚本' };
  };

  this.SequenceExpression = function (expression)
  {
    return { Type: Syntax.SequenceExpression, Expression: expression };
  };

  this.BinaryExpression = function (operator, left, right)
  {
    var logical = operator === '||' || operator === '&&' || operator == 'AND' || operator == 'OR';
    var type = logical ? Syntax.LogicalExpression : Syntax.BinaryExpression;

    return { Type: type, Operator: operator, Left: left, Right: right };
  };

  this.Literal = function (value, raw)
  {
    return { Type: Syntax.Literal, Value: value, Raw: raw };
  };

  this.Identifier = function (name, token)
  {
    this.VerifySymbolVariable(name, token);

    return { Type: Syntax.Identifier, Name: name };
  };

  this.AssignmentExpression = function (operator, left, right)
  {
    return { Type: Syntax.AssignmentExpression, Operator: operator, Left: left, Right: right };
  };

  this.UnaryExpression = function (operator, argument)
  {
    return { Type: Syntax.UnaryExpression, Operator: operator, Argument: argument, Prefix: true };
  };

  this.EmptyStatement = function ()
  {
    return { Type: Syntax.EmptyStatement };
  };

  this.CallExpression = function (callee, args, token)
  {
    this.VerifySymbolFunction(callee, args, token);

    return { Type: Syntax.CallExpression, Callee: callee, Arguments: args };
  };

  this.StaticMemberExpression = function (object, property)
  {
    return { Type: Syntax.MemberExpression, Computed: false, Object: object, Property: property };
  };
}



function JSParser(code)
{
  this.ErrorHandler = new ErrorHandler();
  this.Scanner = new Scanner(code, this.ErrorHandler);
  this.Node = new Node(); //节点创建

  this.LookAhead = { Type: 2, Value: '', LineNumber: this.Scanner.LineNumber, LineStart: 0, Start: 0, End: 0 };
  this.HasLineTerminator = false;
  this.Context = {
    IsModule: false,
    await: false,
    allowIn: true,
    allowStrictDirective: true,
    allowYield: true,
    FirstCoverInitializedNameError: null,
    IsAssignmentTarget: false,
    IsBindingElement: false,
    InFunctionBody: false,
    inIteration: false,
    inSwitch: false,
    labelSet: {},
    Strict: false };


  this.PeratorPrecedence =
  {
    ')': 0,
    ';': 0,
    ',': 0,
    ']': 0,
    '||': 1,
    'OR': 1,
    '&&': 2,
    'AND': 2,
    '|': 3,
    '^': 4,
    '&': 5,
    '=': 6,
    '==': 6,
    '!=': 6,
    '<>': 6,
    '===': 6,
    '!==': 6,
    '<': 7,
    '>': 7,
    '<=': 7,
    '>=': 7,
    '<<': 8,
    '>>': 8,
    '>>>': 8,
    '+': 9,
    '-': 9,
    '*': 11,
    '/': 11,
    '%': 11 };


  this.StartMarker = { Index: 0, Line: this.Scanner.LineNumber, Column: 0 };
  this.LastMarker = { Index: 0, Line: this.Scanner.LineNumber, Column: 0 };

  this.Initialize = function ()
  {
    this.NextToken();
    this.LastMarker = { Index: this.Scanner.Index, Line: this.Scanner.LineNumber, Column: this.Scanner.Index - this.Scanner.LineStart };
  };


  this.CreateNode = function ()
  {
    return { Index: this.StartMarker.Index, Line: this.StartMarker.Line, Column: this.StartMarker.Column };
  };

  this.StartNode = function (token, lastLineStart)
  {
    if (lastLineStart == void 0) {lastLineStart = 0;}

    var column = token.Start - token.LineStart;
    var line = token.LineNumber;
    if (column < 0)
    {
      column += lastLineStart;
      line--;
    }

    return { Index: token.Start, Line: line, Column: column };
  };

  this.Match = function (value)
  {
    return this.LookAhead.Type == 7 /*Punctuator*/ && this.LookAhead.Value == value;
  };

  this.Expect = function (value)
  {
    var token = this.NextToken();
    if (token.Type != 7 /*Punctuator*/ || token.Value != value)
    this.ThrowUnexpectedToken(token);
  };

  //是否是赋值操作符
  this.MatchAssign = function ()
  {
    if (this.LookAhead.Type != 7 /*Punctuator*/) return false;
    var op = this.LookAhead.Value;

    return op == ':' || op == ':=';
  };

  this.GetTokenRaw = function (token)
  {
    return this.Scanner.Source.slice(token.Start, token.End);
  };

  this.NextToken = function ()
  {
    var token = this.LookAhead;
    this.LastMarker.Index = this.Scanner.Index;
    this.LastMarker.Line = this.Scanner.LineNumber;
    this.LastMarker.Column = this.Scanner.Index - this.Scanner.LineStart;
    this.CollectComments(); //过滤注释 空格

    if (this.Scanner.Index !== this.StartMarker.Index)
    {
      this.StartMarker.Index = this.Scanner.Index;
      this.StartMarker.Line = this.Scanner.LineNumber;
      this.StartMarker.Column = this.Scanner.Index - this.Scanner.LineStart;
    }

    var next = this.Scanner.Lex();
    this.HasLineTerminator = token.LineNumber != next.LineNumber;
    if (next && this.Context.Strict && next.Type == 3 /*Identifier */)
      {
        //TODO:
      }

    this.LookAhead = next;

    return token;
  };

  this.CollectComments = function ()
  {
    this.Scanner.ScanComments();
  };

  this.ParseScript = function ()
  {
    var node = this.CreateNode();
    var body = this.ParseDirectivePrologues();

    while (this.LookAhead.Type != 2 /*EOF*/)
    {
      body.push(this.ParseStatementListItem());
    }

    return this.Finalize(node, this.Node.Script(body));
  };

  //https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
  this.ParseDirective = function ()
  {
    var token = this.LookAhead;
    var node = this.CreateNode();
    var expr = this.ParseExpression();
  };

  this.ParseDirectivePrologues = function ()
  {
    var firstRestricted = null;
    var body = [];
    while (true)
    {
      var token = this.LookAhead;
      if (token.Type != 8 /*StringLiteral*/) break;

      var statement = this.ParseDirective();
      body.push(statement);
    }

    return body;
  };

  // https://tc39.github.io/ecma262/#sec-block
  this.ParseStatementListItem = function ()
  {
    var statement;
    this.Context.IsAssignmentTarget = true;
    this.Context.IsBindingElement = true;
    if (this.LookAhead.Type == 4 /*Keyword*/)
      {

      } else

    {
      statement = this.ParseStatement();
    }

    return statement;
  };

  // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
  this.ParseStatement = function ()
  {
    var statement;
    switch (this.LookAhead.Type) {

      case 1 /* BooleanLiteral */:
      case 5 /* NullLiteral */:
      case 6 /* NumericLiteral */:
      case 8 /* StringLiteral */:
      case 10 /* Template */:
      case 9 /* RegularExpression */:
        statement = this.ParseExpressionStatement();
        break;
      case 7 /* Punctuator */:
        var value = this.LookAhead.Value;
        if (value === '(') statement = this.ParseExpressionStatement();else
        if (value === ';') statement = this.ParseEmptyStatement();else
        statement = this.ParseExpressionStatement();
        break;
      case 3 /* Identifier */:
        statement = this.ParseLabelledStatement();
        break;
      case 4 /* Keyword */:
        break;
      default:
        statement = "error";}


    return statement;
  };

  // https://tc39.github.io/ecma262/#sec-empty-statement
  this.ParseEmptyStatement = function ()
  {
    var node = this.CreateNode();
    this.Expect(';');
    return this.Finalize(node, this.Node.EmptyStatement());
  };

  //https://tc39.github.io/ecma262/#sec-labelled-statements
  this.ParseLabelledStatement = function ()
  {
    var node = this.CreateNode();
    var expr = this.ParseExpression();
    this.ConsumeSemicolon();
    var statement = new this.Node.ExpressionStatement(expr);

    return this.Finalize(node, statement);
  };

  // https://tc39.github.io/ecma262/#sec-comma-operator
  this.ParseExpression = function ()
  {
    var startToken = this.LookAhead;
    var expr = this.IsolateCoverGrammar(this.ParseAssignmentExpression);
    if (this.Match(','))
    {
      var expressions = [];
      expressions.push(expr);
      while (this.LookAhead.Type != 2 /*EOF*/)
      {
        if (!this.Match(',')) break;
        this.NextToken();
        expressions.push(this.IsolateCoverGrammar(this.ParseAssignmentExpression));
      }

      expr = this.Finalize(this.StartNode(startToken), this.Node.SequenceExpression(expressions));
    }

    return expr;
  };

  this.ParseAssignmentExpression = function ()
  {
    var expr;

    var startToken = this.LookAhead;
    var token = startToken;
    expr = this.ParseConditionalExpression();

    if (this.MatchAssign())
    {
      if (!this.Context.IsAssignmentTarget)
      {
        var marker = expr.Marker;
        this.ThrowUnexpectedError(marker.Index, marker.Line, marker.Column, Messages.InvalidLHSInAssignment);
      }

      if (!this.Match('=') && !this.Match(':'))
      {
        this.Context.IsAssignmentTarget = false;
        this.Context.IsBindingElement = false;
      } else

      {
        this.ReinterpretExpressionAsPattern(expr);
      }

      token = this.NextToken();
      var operator = token.Value;
      var right = this.IsolateCoverGrammar(this.ParseAssignmentExpression);
      expr = this.Finalize(this.StartNode(startToken), this.Node.AssignmentExpression(operator, expr, right));
      this.Context.FirstCoverInitializedNameError = null;
    }

    return expr;
  };

  this.ParseConditionalExpression = function ()
  {
    var startToken = this.LookAhead;
    var expr = this.InheritCoverGrammar(this.ParseBinaryExpression);

    return expr;
  };

  this.ParseBinaryExpression = function ()
  {
    var startToken = this.LookAhead;
    var expr = this.InheritCoverGrammar(this.ParseExponentiationExpression);
    var token = this.LookAhead;
    var prec = this.BinaryPrecedence(token);
    if (prec > 0)
    {
      this.NextToken();
      this.Context.IsAssignmentTarget = false;
      this.Context.IsBindingElement = false;
      var markers = [startToken, this.LookAhead];
      var left = expr;
      var right = this.IsolateCoverGrammar(this.ParseExponentiationExpression);
      var stack = [left, token.Value, right];
      var precedences = [prec];
      while (true)
      {
        prec = this.BinaryPrecedence(this.LookAhead);
        if (prec <= 0) break;

        while (stack.length > 2 && prec <= precedences[precedences.length - 1])
        {
          right = stack.pop();
          var operator = stack.pop();
          precedences.pop();
          left = stack.pop();
          markers.pop();
          var node = this.StartNode(markers[markers.length - 1]);
          stack.push(this.Finalize(node, this.Node.BinaryExpression(operator, left, right)));
        }

        //Shift
        stack.push(this.NextToken().Value);
        precedences.push(prec);
        markers.push(this.LookAhead);
        stack.push(this.IsolateCoverGrammar(this.ParseExponentiationExpression));
      }

      var i = stack.length - 1;
      expr = stack[i];
      var lastMarker = markers.pop();
      while (i > 1)
      {
        var marker = markers.pop();
        var lastLineStart = lastMarker && lastMarker.LineStart;
        var _node = this.StartNode(marker, lastLineStart);
        var _operator = stack[i - 1];
        expr = this.Finalize(_node, this.Node.BinaryExpression(_operator, stack[i - 2], expr));
        i -= 2;
        lastMarker = marker;
      }
    }

    return expr;
  };

  this.ParseExponentiationExpression = function ()
  {
    var startToken = this.LookAhead;
    var expr = this.InheritCoverGrammar(this.ParseUnaryExpression);

    return expr;
  };

  this.ParseUnaryExpression = function ()
  {
    var expr;
    if (this.Match('+') || this.Match('-'))
    {
      var node = this.StartNode(this.LookAhead);
      var token = this.NextToken();
      expr = this.InheritCoverGrammar(this.ParseUnaryExpression);
      expr = this.Finalize(node, this.Node.UnaryExpression(token.Value, expr));
      this.Context.IsAssignmentTarget = false;
      this.Context.IsBindingElement = false;
    } else

    {
      expr = this.ParseUpdateExpression();
    }

    return expr;
  };

  // https://tc39.github.io/ecma262/#sec-update-expressions
  this.ParseUpdateExpression = function ()
  {
    var expr;
    var startToken = this.LookAhead;
    expr = this.InheritCoverGrammar(this.ParseLeftHandSideExpressionAllowCall);

    return expr;
  };

  this.ParseLeftHandSideExpressionAllowCall = function ()
  {
    var startToken = this.LookAhead;
    var expr;
    expr = this.InheritCoverGrammar(this.ParsePrimaryExpression);

    while (true)
    {
      if (this.Match('.'))
      {
        this.Context.IsBindingElement = false;
        this.Context.IsAssignmentTarget = true;
        this.Expect('.');
        var property = this.ParseIdentifierName();
        expr = this.Finalize(this.StartNode(startToken), this.Node.StaticMemberExpression(expr, property));
      } else
      if (this.Match('('))
      {
        this.Context.IsBindingElement = false;
        this.Context.IsAssignmentTarget = false;
        var args = this.ParseArguments(); //解析 调用参数
        expr = this.Finalize(this.StartNode(startToken), this.Node.CallExpression(expr, args, startToken));
      } else

      {
        break;
      }
    }

    return expr;
  };

  /*
     BooleanLiteral = 1,
     EOF=2,
     Identifier=3,
     Keyword=4,
     NullLiteral=5,
     NumericLiteral=6,
     Punctuator=7,
     StringLiteral=9,
     RegularExpression=9,
     Template=10
     */
  this.IsIdentifierName = function (token)
  {
    return token.Type === 3 //Identifier 
    || token.Type === 4 //Keyword 
    || token.Type === 1 //BooleanLiteral 
    || token.Type === 5; //NullLiteral;
  };

  this.ParseIdentifierName = function ()
  {
    var node = this.CreateNode();
    var token = this.NextToken();
    if (!this.IsIdentifierName(token))
    {
      this.ThrowUnexpectedToken(token);
    }

    return this.Finalize(node, this.Node.Identifier(token.Value, token));
  };

  // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
  this.ParseArguments = function ()
  {
    this.Expect('(');
    var args = [];
    if (!this.Match(')'))
    {
      while (true)
      {
        var expr = this.IsolateCoverGrammar(this.ParseAssignmentExpression);
        args.push(expr);

        if (this.Match(')')) break;

        this.ExpectCommaSeparator();

        if (this.Match(')')) break;
      }
    }

    this.Expect(')');
    return args;
  };

  // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
  this.ExpectCommaSeparator = function ()
  {
    this.Expect(',');
  };

  // https://tc39.github.io/ecma262/#sec-primary-expression
  this.ParsePrimaryExpression = function ()
  {
    var node = this.CreateNode();
    var expr;
    var token, raw;
    switch (this.LookAhead.Type) {

      case 3: /* Identifier */
        token = this.NextToken();
        expr = this.Finalize(node, this.Node.Identifier(token.Value, token));
        break;
      case 6: /* NumericLiteral */
      case 8: /* StringLiteral */
        this.Context.IsAssignmentTarget = false;
        this.Context.IsBindingElement = false;
        token = this.NextToken();
        raw = this.GetTokenRaw(token);
        expr = this.Finalize(node, this.Node.Literal(token.Value, raw));
        break;
      case 7: /* Punctuator */
        switch (this.LookAhead.Value) {

          case '(':
            this.Context.IsBindingElement = false;
            expr = this.InheritCoverGrammar(this.ParseGroupExpression);
            break;
          default:
            expr = this.ThrowUnexpectedToken(this.NextToken());}

        break;
      default:
        expr = this.ThrowUnexpectedToken(this.NextToken());}


    return expr;
  };

  this.ParseGroupExpression = function ()
  {
    var expr;
    this.Expect('(');
    if (this.Match(')'))
    {
      this.NextToken();
    } else

    {
      var startToken = this.LookAhead;
      var params = [];
      var arrow = false;
      this.Context.IsBindingElement = true;
      expr = this.InheritCoverGrammar(this.ParseAssignmentExpression);
      if (this.Match(','))
      {
        var expressions = [];
        this.Context.IsAssignmentTarget = false;
        expressions.push(expr);
        while (this.LookAhead.Type != 2 /* EOF */)
        {
          if (!this.Match(',')) break;

          this.NextToken();
          if (this.Match(')'))
          {

          }
        }
      }

      if (!arrow)
      {
        this.Expect(')');
        this.Context.IsBindingElement = false;
      }
    }

    return expr;
  };

  // https://tc39.github.io/ecma262/#sec-expression-statement
  this.ParseExpressionStatement = function ()
  {
    var node = this.CreateNode();
    var expr = this.ParseExpression();
    this.ConsumeSemicolon();

    return this.Finalize(node, this.Node.ExpressionStatement(expr));
  };

  this.ConsumeSemicolon = function ()
  {
    if (this.Match(';'))
    {
      this.NextToken();
    } else
    if (!this.HasLineTerminator)
    {
      //if (this.LookAhead.Type!=2/*EOF*/ && !this.Match('}'))

      this.LastMarker.Index = this.StartMarker.Index;
      this.LastMarker.Line = this.StartMarker.Line;
      this.LastMarker.Column = this.StartMarker.Column;
    }
  };

  this.ReinterpretExpressionAsPattern = function (expr)
  {
    switch (expr.Type) {

      case Syntax.Identifier:
      case Syntax.MemberExpression:
      case Syntax.AssignmentExpression:
        break;
      default:
        break;}

  };

  this.Finalize = function (marker, node)
  {
    node.Marker = { Line: marker.Line, Column: marker.Column, Index: marker.Index };
    return node;
  };

  this.BinaryPrecedence = function (token)
  {
    var op = token.Value;
    var precedence;

    if (token.Type === 7 /* Punctuator */) precedence = this.PeratorPrecedence[op] || 0;else
    precedence = 0;

    return precedence;
  };

  this.IsolateCoverGrammar = function (parseFunction)
  {
    var previousIsBindingElement = this.Context.IsBindingElement;
    var previousIsAssignmentTarget = this.Context.IsAssignmentTarget;
    var previousFirstCoverInitializedNameError = this.Context.FirstCoverInitializedNameError;

    this.Context.IsBindingElement = true;
    this.Context.IsAssignmentTarget = true;
    this.Context.FirstCoverInitializedNameError = null;
    var result = parseFunction.call(this);

    if (this.Context.FirstCoverInitializedNameError != null)
    {
      //错误 this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
    }

    this.Context.IsBindingElement = previousIsBindingElement;
    this.Context.IsAssignmentTarget = previousIsAssignmentTarget;
    this.Context.FirstCoverInitializedNameError = previousFirstCoverInitializedNameError;

    return result;
  };

  this.InheritCoverGrammar = function (parseFunction)
  {
    var previousIsBindingElement = this.Context.IsBindingElement;
    var previousIsAssignmentTarget = this.Context.IsAssignmentTarget;
    var previousFirstCoverInitializedNameError = this.Context.FirstCoverInitializedNameError;
    this.Context.IsBindingElement = true;
    this.Context.IsAssignmentTarget = true;
    this.Context.FirstCoverInitializedNameError = null;

    var result = parseFunction.call(this);

    this.Context.IsBindingElement = this.Context.IsBindingElement && previousIsBindingElement;
    this.Context.IsAssignmentTarget = this.Context.IsAssignmentTarget && previousIsAssignmentTarget;
    this.Context.FirstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.Context.FirstCoverInitializedNameError;

    return result;
  };

  this.ThrowUnexpectedToken = function (token, message)
  {
    throw this.UnexpectedTokenError(token, message);
  };

  this.ThrowUnexpectedError = function (index, line, column, message)
  {
    var msg = message || "执行异常";

    return this.ErrorHandler.ThrowError(index, line, column, msg);
  };

  this.UnexpectedTokenError = function (token, message)
  {
    var msg = message || Messages.UnexpectedToken;
    var value = 'ILLEGAL';
    if (token)
    {
      if (!message)
      {

      }
      value = token.Value;
    }

    msg = msg.replace("%0", value);
    if (token && typeof token.LineNumber == 'number')
    {
      var index = token.Start;
      var line = token.LineNumber;
      var lastMarkerLineStart = this.LastMarker.Index - this.LastMarker.Column;
      var column = token.Start - lastMarkerLineStart + 1;
      return this.ErrorHandler.CreateError(index, line, column, msg);
    } else

    {
      var _index = this.LastMarker.Index;
      var _line = this.LastMarker.Line;
      var _column = this.LastMarker.Column + 1;
      return this.ErrorHandler.CreateError(_index, _line, _column, msg);
    }
  };
}


/*
      算法类
  */
function JSAlgorithm(errorHandler, symbolData)
{
  this.ErrorHandler = errorHandler;
  this.SymbolData = symbolData; //股票数据

  //相加
  this.Add = function (data, data2)
  {
    var isNumber = typeof data == 'number';
    var isNumber2 = typeof data2 == 'number';

    //单数值相加
    if (isNumber && isNumber2) return data + data2;

    //都是数组相加
    var result = [];
    if (!isNumber && !isNumber2)
    {
      var count = Math.max(data.length, data2.length);
      for (var i = 0; i < count; ++i)
      {
        result[i] = null; //初始化

        if (i < data.length && i < data2.length)
        {
          if (!isNaN(data[i]) && !isNaN(data2[i])) result[i] = data[i] + data2[i];
        }
      }

      return result;
    }

    //单数据和数组相加
    var value;
    var aryData;
    if (isNumber)
    {
      value = data;
      aryData = data2;
    } else

    {
      value = data2;
      aryData = data;
    }

    for (var _i in aryData)
    {
      result[_i] = null;
      if (!isNaN(aryData[_i]) && !isNaN(value)) result[_i] = value + aryData[_i];
    }

    return result;
  };

  //相减
  this.Subtract = function (data, data2)
  {
    var isNumber = typeof data == 'number';
    var isNumber2 = typeof data2 == 'number';

    //单数值相减
    if (isNumber && isNumber2) return data - data2;

    //都是数组相减
    var result = [];
    if (!isNumber && !isNumber2)
    {
      var count = Math.max(data.length, data2.length);
      for (var i = 0; i < count; ++i)
      {
        result[i] = null; //初始化

        if (i < data.length && i < data2.length)
        {
          if (!isNaN(data[i]) && !isNaN(data2[i])) result[i] = data[i] - data2[i];
        }
      }

      return result;
    }

    if (isNumber) //单数据-数组
      {
        for (var _i2 in data2)
        {
          result[_i2] = null;
          if (!isNaN(data) && !isNaN(data2[_i2])) result[_i2] = data - data2[_i2];
        }
      } else
      //数组-单数据
      {
        for (var _i3 in data)
        {
          result[_i3] = null;
          if (!isNaN(data[_i3]) && !isNaN(data2)) result[_i3] = data[_i3] - data2;
        }
      }

    return result;
  };

  //相乘
  this.Multiply = function (data, data2)
  {
    var isNumber = typeof data == 'number';
    var isNumber2 = typeof data2 == 'number';

    //单数值相乘
    if (isNumber && isNumber2) return data * data2;

    //都是数组相乘
    var result = [];
    if (!isNumber && !isNumber2)
    {
      var count = Math.max(data.length, data2.length);
      for (var i = 0; i < count; ++i)
      {
        result[i] = null; //初始化

        if (i < data.length && i < data2.length)
        {
          if (!isNaN(data[i]) && !isNaN(data2[i])) result[i] = data[i] * data2[i];
        }
      }

      return result;
    }

    //单数据和数组相乘
    var value;
    var aryData;
    if (isNumber)
    {
      value = data;
      aryData = data2;
    } else

    {
      value = data2;
      aryData = data;
    }

    for (var _i4 in aryData)
    {
      result[_i4] = null;
      if (!isNaN(aryData[_i4]) && !isNaN(value)) result[_i4] = value * aryData[_i4];
    }

    return result;
  };

  //相除
  this.Divide = function (data, data2)
  {
    var isNumber = typeof data == 'number';
    var isNumber2 = typeof data2 == 'number';

    //单数值相除
    if (isNumber && isNumber2)
    {
      if (data2 == 0) return null; //除0判断
      return data / data2;
    }

    //都是数组相除
    var result = [];
    if (!isNumber && !isNumber2)
    {
      var count = Math.max(data.length, data2.length);
      for (var i = 0; i < count; ++i)
      {
        result[i] = null; //初始化

        if (i < data.length && i < data2.length)
        {
          if (this.IsNumber(data[i]) && this.IsDivideNumber(data2[i])) result[i] = data[i] / data2[i];
        }
      }

      return result;
    }

    if (isNumber) //单数据-数组
      {
        for (var _i5 in data2)
        {
          result[_i5] = null;
          if (this.IsNumber(data) && this.IsDivideNumber(data2[_i5])) result[_i5] = data / data2[_i5];
        }
      } else
      //数组-单数据
      {
        for (var _i6 in data)
        {
          result[_i6] = null;
          if (this.IsNumber(data[_i6]) && this.IsDivideNumber(data2)) result[_i6] = data[_i6] / data2;
        }
      }

    return result;

  };

  //大于
  this.GT = function (data, data2)
  {
    var isNumber = typeof data == 'number';
    var isNumber2 = typeof data2 == 'number';

    //单数值比较
    if (isNumber && isNumber2) return data > data2 ? 1 : 0;

    //都是数组比较
    var result = [];
    if (!isNumber && !isNumber2)
    {
      var count = Math.max(data.length, data2.length);
      for (var i = 0; i < count; ++i)
      {
        result[i] = null; //初始化

        if (i < data.length && i < data2.length)
        {
          if (!isNaN(data[i]) && !isNaN(data2[i])) result[i] = data[i] > data2[i] ? 1 : 0;
        }
      }

      return result;
    }

    if (isNumber) //单数据-数组
      {
        for (var _i7 in data2)
        {
          result[_i7] = null;
          if (!isNaN(data) && !isNaN(data2[_i7])) result[_i7] = data > data2[_i7] ? 1 : 0;
        }
      } else
      //数组-单数据
      {
        for (var _i8 in data)
        {
          result[_i8] = null;
          if (!isNaN(data[_i8]) && !isNaN(data2)) result[_i8] = data[_i8] > data2 ? 1 : 0;
        }
      }

    return result;
  };

  //大于等于
  this.GTE = function (data, data2)
  {
    var isNumber = typeof data == 'number';
    var isNumber2 = typeof data2 == 'number';

    //单数值比较
    if (isNumber && isNumber2) return data >= data2 ? 1 : 0;

    //都是数组比较
    var result = [];
    if (!isNumber && !isNumber2)
    {
      var count = Math.max(data.length, data2.length);
      for (var i = 0; i < count; ++i)
      {
        result[i] = null; //初始化

        if (i < data.length && i < data2.length)
        {
          if (!isNaN(data[i]) && !isNaN(data2[i])) result[i] = data[i] >= data2[i] ? 1 : 0;
        }
      }

      return result;
    }

    if (isNumber) //单数据-数组
      {
        for (var _i9 in data2)
        {
          result[_i9] = null;
          if (!isNaN(data) && !isNaN(data2[_i9])) result[_i9] = data >= data2[_i9] ? 1 : 0;
        }
      } else
      //数组-单数据
      {
        for (var _i10 in data)
        {
          result[_i10] = null;
          if (!isNaN(data[_i10]) && !isNaN(data2)) result[_i10] = data[_i10] >= data2 ? 1 : 0;
        }
      }

    return result;
  };

  //小于
  this.LT = function (data, data2)
  {
    var isNumber = typeof data == 'number';
    var isNumber2 = typeof data2 == 'number';

    //单数值比较
    if (isNumber && isNumber2) return data < data2 ? 1 : 0;

    //都是数组比较
    var result = [];
    if (!isNumber && !isNumber2)
    {
      var count = Math.max(data.length, data2.length);
      for (var i = 0; i < count; ++i)
      {
        result[i] = null; //初始化

        if (i < data.length && i < data2.length)
        {
          if (!isNaN(data[i]) && !isNaN(data2[i])) result[i] = data[i] < data2[i] ? 1 : 0;
        }
      }

      return result;
    }

    if (isNumber) //单数据-数组
      {
        for (var _i11 in data2)
        {
          result[_i11] = null;
          if (!isNaN(data) && !isNaN(data2[_i11])) result[_i11] = data < data2[_i11] ? 1 : 0;
        }
      } else
      //数组-单数据
      {
        for (var _i12 in data)
        {
          result[_i12] = null;
          if (!isNaN(data[_i12]) && !isNaN(data2)) result[_i12] = data[_i12] < data2 ? 1 : 0;
        }
      }

    return result;
  };

  //小于等于
  this.LTE = function (data, data2)
  {
    var isNumber = typeof data == 'number';
    var isNumber2 = typeof data2 == 'number';

    //单数值比较
    if (isNumber && isNumber2) return data >= data2 ? 1 : 0;

    //都是数组比较
    var result = [];
    if (!isNumber && !isNumber2)
    {
      var count = Math.max(data.length, data2.length);
      for (var i = 0; i < count; ++i)
      {
        result[i] = null; //初始化

        if (i < data.length && i < data2.length)
        {
          if (!isNaN(data[i]) && !isNaN(data2[i])) result[i] = data[i] <= data2[i] ? 1 : 0;
        }
      }

      return result;
    }

    if (isNumber) //单数据-数组
      {
        for (var _i13 in data2)
        {
          result[_i13] = null;
          if (!isNaN(data) && !isNaN(data2[_i13])) result[_i13] = data <= data2[_i13] ? 1 : 0;
        }
      } else
      //数组-单数据
      {
        for (var _i14 in data)
        {
          result[_i14] = null;
          if (!isNaN(data[_i14]) && !isNaN(data2)) result[_i14] = data[_i14] <= data2 ? 1 : 0;
        }
      }

    return result;
  };

  //等于
  this.EQ = function (data, data2)
  {
    var isNumber = typeof data == 'number';
    var isNumber2 = typeof data2 == 'number';

    //单数值比较
    if (isNumber && isNumber2) return data == data2 ? 1 : 0;

    //都是数组比较
    var result = [];
    if (!isNumber && !isNumber2)
    {
      var count = Math.max(data.length, data2.length);
      for (var i = 0; i < count; ++i)
      {
        result[i] = null; //初始化

        if (i < data.length && i < data2.length)
        {
          if (!isNaN(data[i]) && !isNaN(data2[i])) result[i] = data[i] == data2[i] ? 1 : 0;
        }
      }

      return result;
    }

    if (isNumber) //单数据-数组
      {
        for (var _i15 in data2)
        {
          result[_i15] = null;
          if (!isNaN(data) && !isNaN(data2[_i15])) result[_i15] = data == data2[_i15] ? 1 : 0;
        }
      } else
      //数组-单数据
      {
        for (var _i16 in data)
        {
          result[_i16] = null;
          if (!isNaN(data[_i16]) && !isNaN(data2)) result[_i16] = data[_i16] == data2 ? 1 : 0;
        }
      }

    return result;
  };

  //不等于
  this.NEQ = function (data, data2)
  {
    var isNumber = typeof data == 'number';
    var isNumber2 = typeof data2 == 'number';

    //单数值比较
    if (isNumber && isNumber2) return data != data2 ? 1 : 0;

    //都是数组比较
    var result = [];
    if (!isNumber && !isNumber2)
    {
      var count = Math.max(data.length, data2.length);
      for (var i = 0; i < count; ++i)
      {
        result[i] = null; //初始化

        if (i < data.length && i < data2.length)
        {
          if (!isNaN(data[i]) && !isNaN(data2[i])) result[i] = data[i] != data2[i] ? 1 : 0;
        }
      }

      return result;
    }

    if (isNumber) //单数据-数组
      {
        for (var _i17 in data2)
        {
          result[_i17] = null;
          if (!isNaN(data) && !isNaN(data2[_i17])) result[_i17] = data != data2[_i17] ? 1 : 0;
        }
      } else
      //数组-单数据
      {
        for (var _i18 in data)
        {
          result[_i18] = null;
          if (!isNaN(data[_i18]) && !isNaN(data2)) result[_i18] = data[_i18] != data2 ? 1 : 0;
        }
      }

    return result;
  };


  //AND  &&
  this.And = function (data, data2)
  {
    var isNumber = typeof data == 'number';
    var isNumber2 = typeof data2 == 'number';

    //单数值 &&
    if (isNumber && isNumber2) return data && data2 ? 1 : 0;

    //都是数组 &&
    var result = [];
    if (!isNumber && !isNumber2)
    {
      var count = Math.max(data.length, data2.length);
      for (var i = 0; i < count; ++i)
      {
        result[i] = null; //初始化

        if (i < data.length && i < data2.length)
        {
          if (!isNaN(data[i]) && !isNaN(data2[i])) result[i] = data[i] && data2[i] ? 1 : 0;
        }
      }

      return result;
    }

    if (isNumber) //单数据-数组
      {
        for (var _i19 in data2)
        {
          result[_i19] = null;
          if (!isNaN(data) && !isNaN(data2[_i19])) result[_i19] = data && data2[_i19] ? 1 : 0;
        }
      } else
      //数组-单数据
      {
        for (var _i20 in data)
        {
          result[_i20] = null;
          if (!isNaN(data[_i20]) && !isNaN(data2)) result[_i20] = data[_i20] && data2 ? 1 : 0;
        }
      }

    return result;
  };

  //OR  ||
  this.Or = function (data, data2)
  {
    var isNumber = typeof data == 'number';
    var isNumber2 = typeof data2 == 'number';

    //单数值 &&
    if (isNumber && isNumber2) return data || data2 ? 1 : 0;

    //都是数组 &&
    var result = [];
    if (!isNumber && !isNumber2)
    {
      var count = Math.max(data.length, data2.length);
      for (var i = 0; i < count; ++i)
      {
        result[i] = null; //初始化

        if (i < data.length && i < data2.length)
        {
          if (!isNaN(data[i]) && !isNaN(data2[i])) result[i] = data[i] || data2[i] ? 1 : 0;
        }
      }

      return result;
    }

    if (isNumber) //单数据-数组
      {
        for (var _i21 in data2)
        {
          result[_i21] = null;
          if (!isNaN(data) && !isNaN(data2[_i21])) result[_i21] = data || data2[_i21] ? 1 : 0;
        }
      } else
      //数组-单数据
      {
        for (var _i22 in data)
        {
          result[_i22] = null;
          if (!isNaN(data[_i22]) && !isNaN(data2)) result[_i22] = data[_i22] || data2 ? 1 : 0;
        }
      }

    return result;
  };

  this.IF = function (data, trueData, falseData)
  {
    var isNumber = this.IsNumber(data);
    var isNumber2 = this.IsNumber(trueData);
    var isNumber3 = this.IsNumber(falseData);

    var isArray2 = Array.isArray(trueData);
    var isArray3 = Array.isArray(falseData);

    //单数值
    if (isNumber)
    {
      if (isNumber2 && isNumber3) return data ? trueData : falseData;

      return data ? trueData : falseData;
    }

    //都是数组
    var result = [];
    for (var i in data)
    {
      if (data[i])
      {
        if (isNumber2) result[i] = trueData;else
        if (isArray2) result[i] = trueData[i];else
        result[i] = null;
      } else

      {
        if (isNumber3) result[i] = falseData;else
        if (isArray3) result[i] = falseData[i];else
        result[i] = null;
      }
    }

    return result;
  };

  /*
     根据条件求不同的值,同IF判断相反.
     用法: IFN(X,A,B)若X不为0则返回B,否则返回A
     例如: IFN(CLOSE>OPEN,HIGH,LOW)表示该周期收阴则返回最高值,否则返回最低值
     */
  this.IFN = function (data, trueData, falseData)
  {
    return this.IF(data, falseData, trueData);
  };

  //指标函数 函数名全部大写
  this.REF = function (data, n)
  {
    var result = [];
    if (typeof n == 'number')
    {
      if (data.length <= 0) return result;
      if (n >= data.length) return result;

      result = data.slice(0, data.length - n);

      for (var i = 0; i < n; ++i) {
        result.unshift(null);}
    } else
      //n 为数组的情况
      {
        for (var _i23 = 0; _i23 < data.length; ++_i23)
        {
          result[_i23] = null;
          if (_i23 >= n.length) continue;
          var value = n[_i23];
          if (value > 0 && value <= _i23) result[_i23] = data[_i23 - value];else
          if (_i23) result[_i23] = result[_i23 - 1];else
          result[_i23] = data[_i23];
        }
      }

    return result;
  };

  //引用若干周期前的数据(未作平滑处理).
  //用法: REFV(X,A),引用A周期前的X值.A可以是变量.
  //平滑处理:当引用不到数据时进行的操作.
  //例如: REFV(CLOSE,BARSCOUNT(C)-1)表示第二根K线的收盘价.
  this.REFV = function (data, n)
  {
    var result = [];
    if (typeof n == 'number')
    {
      if (data.length <= 0) return result;
      if (n >= data.length) return result;

      result = data.slice(0, data.length - n);

      for (var i = 0; i < n; ++i) {//不作平滑处理
        result.unshift(null);}
    } else
      //n 为数组的情况
      {
        for (var _i24 = 0; _i24 < data.length; ++_i24)
        {
          result[_i24] = null;
          if (_i24 >= n.length) continue;
          var value = n[_i24];
          if (value >= 0 && value <= _i24) result[_i24] = data[_i24 - value];
        }
      }

    return result;
  };

  //属于未来函数,引用若干周期后的数据(平滑处理).
  //用法: REFX(X,A),引用A周期后的X值.A可以是变量.
  //平滑处理:当引用不到数据时进行的操作.此函数中,平滑时使用上一个周期的引用值.
  //例如: TT:=IF(C>O,1,2);
  //      REFX(CLOSE,TT);表示阳线引用下一周期的收盘价,阴线引用日后第二周期的收盘价.
  this.REFX = function (data, n)
  {
    var result = [];
    if (typeof n == 'number')
    {
      if (data.length <= 0) return result;
      if (n >= data.length) return result;

      result = data.slice(n, data.length);

      //平滑处理
      var lastData = data[data.length - 1];
      for (var i = 0; i < n; ++i) {
        result.push(lastData);}
    } else
      //n 为数组的情况
      {
        var dataCount = data.length;
        for (var _i25 = 0; _i25 < data.length; ++_i25)
        {
          result[_i25] = null;
          if (_i25 >= n.length) continue;
          var value = n[_i25];
          if (value >= 0 && value + _i25 < dataCount) result[_i25] = data[_i25 + value];else
          if (_i25) result[_i25] = result[_i25 - 1];else
          result[_i25] = data[_i25];
        }
      }

    return result;
  };

  //属于未来函数,引用若干周期后的数据(未作平滑处理).
  //用法:REFXV(X,A),引用A周期后的X值.A可以是变量.
  //平滑处理:当引用不到数据时进行的操作.
  //例如: REFXV(CLOSE,1)表示下一周期的收盘价,在日线上就是明天收盘价
  this.REFXV = function (data, n)
  {
    var result = [];
    if (typeof n == 'number')
    {
      if (data.length <= 0) return result;
      if (n >= data.length) return result;

      result = data.slice(n, data.length);

      //平滑处理
      for (var i = 0; i < n; ++i) {
        result.push(null);}
    } else
      //n 为数组的情况
      {
        var dataCount = data.length;
        for (var _i26 = 0; _i26 < data.length; ++_i26)
        {
          result[_i26] = null;
          if (_i26 >= n.length) continue;
          var value = n[_i26];
          if (value >= 0 && value + _i26 < dataCount) result[_i26] = data[_i26 + value];
        }
      }

    return result;
  };

  this.MAX = function (data, data2)
  {
    var isNumber = typeof data == 'number';
    var isNumber2 = typeof data2 == 'number';

    //单数值
    if (isNumber && isNumber2) return Math.max(data, data2);

    //都是数组
    var result = [];
    if (!isNumber && !isNumber2)
    {
      var count = Math.max(data.length, data2.length);
      for (var i = 0; i < count; ++i)
      {
        result[i] = null; //初始化

        if (i < data.length && i < data2.length)
        {
          if (!isNaN(data[i]) && !isNaN(data2[i])) result[i] = Math.max(data[i], data2[i]);
        }
      }

      return result;
    }

    if (isNumber) //单数据-数组
      {
        for (var _i27 in data2)
        {
          result[_i27] = null;
          if (!isNaN(data) && !isNaN(data2[_i27])) result[_i27] = Math.max(data, data2[_i27]);
        }
      } else
      //数组-单数据
      {
        for (var _i28 in data)
        {
          result[_i28] = null;
          if (!isNaN(data[_i28]) && !isNaN(data2)) result[_i28] = Math.max(data[_i28], data2);
        }
      }

    return result;
  };

  this.MIN = function (data, data2)
  {
    var isNumber = typeof data == 'number';
    var isNumber2 = typeof data2 == 'number';

    //单数值
    if (isNumber && isNumber2) return Math.min(data, data2);

    //都是数组
    var result = [];
    if (!isNumber && !isNumber2)
    {
      var count = Math.max(data.length, data2.length);
      for (var i = 0; i < count; ++i)
      {
        result[i] = null; //初始化

        if (i < data.length && i < data2.length)
        {
          if (!isNaN(data[i]) && !isNaN(data2[i])) result[i] = Math.min(data[i], data2[i]);
        }
      }

      return result;
    }

    if (isNumber) //单数据-数组
      {
        for (var _i29 in data2)
        {
          result[_i29] = null;
          if (!isNaN(data) && !isNaN(data2[_i29])) result[_i29] = Math.min(data, data2[_i29]);
        }
      } else
      //数组-单数据
      {
        for (var _i30 in data)
        {
          result[_i30] = null;
          if (!isNaN(data[_i30]) && !isNaN(data2)) result[_i30] = Math.min(data[_i30], data2);
        }
      }

    return result;
  };

  //取正数
  this.ABS = function (data)
  {
    var result = [];

    for (var i in data)
    {
      result[i] = null;
      if (!isNaN(data[i])) result[i] = Math.abs(data[i]);
    }

    return result;
  };

  this.MA = function (data, dayCount)
  {
    if (dayCount <= 0) return [];

    var result = [];

    if (!data || !data.length) return result;

    for (var i = 0; i < data.length; ++i)
    {
      result[i] = null;
      if (this.IsNumber(data[i])) break;
    }

    var data = data.slice(0); //复制一份数据出来 需要把data数据里的null数据用前一个数据覆盖
    for (var days = 0; i < data.length; ++i, ++days)
    {
      if (days < dayCount - 1)
      {
        result[i] = null;
        continue;
      }

      var preValue = data[i - (dayCount - 1)];
      var sum = 0;
      for (var j = dayCount - 1; j >= 0; --j)
      {
        var value = data[i - j];
        if (!this.IsNumber(value))
        {
          value = preValue; //空数据就取上一个数据
          data[i - j] = value;
        } else

        {
          preValue = value;
        }
        sum += value;
      }

      result[i] = sum / dayCount;
    }
    //console.log("222222this.MA:", result, dayCount)
    return result;
  };

  //指数平均数指标 EMA(close,10)
  this.EMA = function (data, dayCount)
  {
    var result = [];

    var offset = 0;
    if (offset >= data.length) return result;

    //取首个有效数据
    for (; offset < data.length; ++offset)
    {
      if (data[offset] != null && !isNaN(data[offset]))
      break;
    }

    var p1Index = offset;
    var p2Index = offset + 1;

    result[p1Index] = data[p1Index];
    for (var i = offset + 1; i < data.length; ++i, ++p1Index, ++p2Index)
    {
      result[p2Index] = (2 * data[p2Index] + (dayCount - 1) * result[p1Index]) / (dayCount + 1);
    }

    return result;
  };

  this.XMA = function (data, n)
  {
    var result = [];
    var offset = 0;
    for (; offset < data.length; ++offset)
    {
      if (this.IsNumber(data[offset])) break;
    }

    var p = parseInt((n - 2) / 2);
    var sum = 0;
    var count = 0,start = 0,end = 0;

    for (var i = offset, j = 0; i < data.length; ++i)
    {
      start = i - p - 1;
      end = i + (n - p) - 1;
      for (j = start; j < end; ++j)
      {
        if (j >= 0 && j < data.length)
        {
          if (this.IsNumber(data[j]))
          {
            sum += data[j];
            ++count;
          }
        }
      }

      if (count != 0) result[i] = sum / count;else
      result[i] = null;

      sum = 0;
      count = 0;
    }

    return result;
  };

  /* 
         SMA 移动平均
         返回移动平均。
         用法：　SMA(X，N，M)　X的M日移动平均，M为权重，如Y=(X*M+Y'*(N-M))/N 
     */
  this.SMA = function (data, n, m)
  {
    var result = [];

    var i = 0;
    var lastData = null;
    for (; i < data.length; ++i)
    {
      if (data[i] == null || isNaN(data[i])) continue;
      lastData = data[i];
      result[i] = lastData; //第一天的数据
      break;
    }

    for (++i; i < data.length; ++i)
    {
      result[i] = (m * data[i] + (n - m) * lastData) / n;
      lastData = result[i];
    }

    return result;
  };

  /*
     求动态移动平均.
     用法: DMA(X,A),求X的动态移动平均.
     算法: 若Y=DMA(X,A)则 Y=A*X+(1-A)*Y',其中Y'表示上一周期Y值,A必须小于1.
     例如:DMA(CLOSE,VOL/CAPITAL)表示求以换手率作平滑因子的平均价
     */
  this.DMA = function (data, data2)
  {
    var result = [];
    if (data.length < 0 || data.length != data2.length) return result;

    var index = 0;
    for (; index < data.length; ++index)
    {
      if (data[index] != null && !isNaN(data[index]) && data2[index] != null && !isNaN(data2[index]))
      {
        result[index] = data[index];
        break;
      }
    }

    for (index = index + 1; index < data.length; ++index)
    {
      if (data[index] == null || data2[index] == null)
      result[index] = null;else

      {
        if (data[index] < 1)
        result[index] = data2[index] * data[index] + (1 - data2[index]) * result[index - 1];else

        result[index] = data[index];
      }
    }

    return result;
  };

  /*
     返回加权移动平均
     用法:WMA(X,N):X的N日加权移动平均.
     算法:Yn=(1*X1+2*X2+...+n*Xn)/(1+2+...+n)
      */
  this.WMA = function (data, dayCount)
  {
    var result = [];
    if (!data || !data.length) return result;
    if (dayCount < 1) dayCount = 1;
    var i = 0;
    for (i = 0; i < data.length && !this.IsNumber(data[i]); ++i)
    {
      result[i] = null;
    }
    var data = data.slice(0);
    for (var days = 0; i < data.length; ++i, ++days)
    {
      if (days < dayCount - 1)
      {
        result[i] = null;
        continue;
      }
      var preValue = data[i - (dayCount - 1)];
      var sum = 0;
      var count = 0;
      for (var j = dayCount - 1; j >= 0; --j)
      {
        var value = data[i - j];
        if (!this.IsNumber(value))
        {
          value = preValue;
          data[i - j] = value;
        } else

        preValue = value;

        count += dayCount - j;
        sum += value * (dayCount - j);
      }
      result[i] = sum / count;
    }
    return result;
  };

  /*
     返回平滑移动平均
     用法:MEMA(X,N):X的N日平滑移动平均,如Y=(X+Y'*(N-1))/N
     MEMA(X,N)相当于SMA(X,N,1)
     */
  this.MEMA = function (data, dayCount)
  {
    var result = [];
    if (!data || !data.length) return result;
    var i = 0,j = 0;
    for (j = 0; j < data.length && !this.IsNumber(data[j]); ++j)
    {
      result[j] = null;
    }
    i = j;
    if (dayCount < 1 || i + dayCount >= data.length) return result;
    var sum = 0;
    var data = data.slice(0);
    for (; i < j + dayCount; ++i)
    {
      result[i] = null;
      if (!this.IsNumber(data[i]) && i - 1 >= 0)
      data[i] = data[i - 1];
      sum += data[i];
    }
    result[i - 1] = sum / dayCount;
    for (; i < data.length; ++i)
    {
      if (this.IsNumber(result[i - 1]) && this.IsNumber(data[i]))
      result[i] = (data[i] + result[i - 1] * (dayCount - 1)) / dayCount;else
      if (i - 1 > -1 && this.IsNumber(result[i - 1]))
      result[i] = result[i - 1];else

      result[i] = null;
    }
    return result;
  };

  /*
     加权移动平均
     返回加权移动平均
     用法:EXPMA(X,M):X的M日加权移动平均
     EXPMA[i]=buffer[i]*para+(1-para)*EXPMA[i-1] para=2/(1+__para)
     */
  this.EXPMA = function (data, dayCount)
  {
    var result = [];
    if (dayCount >= data.length) return result;

    var i = dayCount;
    for (; i < data.length; ++i) //获取第1个有效数据
    {
      if (data[i] != null)
      {
        result[i] = data[i];
        break;
      }
    }

    for (i = i + 1; i < data.length; ++i)
    {
      if (result[i - 1] != null && data[i] != null)
      result[i] = (2 * data[i] + (dayCount - 1) * result[i - 1]) / (dayCount + 1);else
      if (result[i - 1] != null)
      result[i] = result[i - 1];
    }

    return result;
  };

  //加权平滑平均,MEMA[i]=SMA[i]*para+(1-para)*SMA[i-1] para=2/(1+__para)
  this.EXPMEMA = function (data, dayCount)
  {
    var result = [];
    if (dayCount >= data.length) return result;

    var index = 0;
    for (; index < data.length; ++index)
    {
      if (data[index] && !isNaN(data[index])) break;
    }

    var sum = 0;
    for (var i = 0; index < data.length && i < dayCount; ++i, ++index)
    {
      if (data[index] && !isNaN(data[index]))
      sum += data[index];else

      sum += data[index - 1];
    }

    result[index - 1] = sum / dayCount;
    for (; index < data.length; ++index)
    {
      if (result[index - 1] != null && data[index] != null)
      result[index] = (2 * data[index] + (dayCount - 1) * result[index - 1]) / (dayCount + 1);else
      if (result[index - 1] != null)
      result[index] = result[index - 1];
    }

    return result;
  };

  /*
     向前累加到指定值到现在的周期数.
     用法:SUMBARS(X,A):将X向前累加直到大于等于A,返回这个区间的周期数
     例如:SUMBARS(VOL,CAPITAL)求完全换手到现在的周期数
      */
  this.SUMBARS = function (data, data2)
  {
    var result = [];
    if (!data || !data.length || !data2 || !data2.length) return result;
    var start = 0,i = 0,j = 0;
    for (; start < data.length && !this.IsNumber(data[start]); ++start)
    {
      result[start] = null;
    }
    var total = 0;
    for (i = data.length - 1; i >= start; --i)
    {
      for (j = i, total = 0; j >= start && total < data2[i]; --j) {
        total += data[j];}
      if (j < start) result[i] = null;else
      result[i] = i - j;
    }
    for (i = start + 1; i < data.length; ++i)
    {
      if (result[i] == null)
      result[i] = result[i - 1];
    }
    return result;
  };

  /*
     求相反数.
     用法:REVERSE(X)返回-X.
     例如:REVERSE(CLOSE)返回-CLOSE
      */
  this.REVERSE = function (data)
  {
    var result = [];
    var i = 0;
    for (; i < data.length && !this.isNumber(data[i]); ++i)
    {
      result[i] = null;
    }
    for (; i < data.length; ++i)
    {
      if (!this.isNumber(data[i]))
      result[i] = null;else

      result[i] = 0 - data[i];
    }
    return result;
  };

  this.COUNT = function (data, n)
  {
    if (Array.isArray(n))
    {
      var start = null;
      var dataCount = data.length;
      for (var i = 0; i < dataCount; ++i)
      {
        if (this.IsNumber(data[i]))
        {
          start = i;
          break;
        }
      }
      if (start == null) return [];

      var result = [];
      var count = 0;
      for (var i = 0; i < n.length; ++i)
      {
        var period = n[i];
        if (!this.IsNumber(period)) continue;

        if (period < 1) period = i + 1;
        count = 0;
        for (var j = i, k = 0; j >= 0 && k < period; --j, ++k) //当前往前period天 统计
        {
          if (data[j]) ++count;
        }

        result[i] = count;
      }

      return result;
    } else

    {
      var period = n;
      var dataCount = data.length;
      var period = period < 1 ? dataCount : period;

      var i = 0,j = 0;
      for (; i < dataCount; ++i) // 取第1个有效数据
      {
        if (this.IsNumber(data[i])) break;
      }

      var result = [];
      var days = 0;
      for (; i < dataCount && j < period; ++i, ++j)
      {
        days = data[i] ? days + 1 : days;
        result[i] = days;
      }

      for (; i < dataCount; ++i)
      {
        if (data[i - period] && days) days--;

        days = data[i] ? days + 1 : days;
        result[i] = days;
      }

      return result;
    }
  };

  /*
     HHV 最高值
     求最高值。
     用法：　HHV(X，N)　求N周期内X最高值，N=0则从第一个有效值开始。
     例如：　HHV(HIGH,30)　表示求30日最高价。
     */
  this.HHV = function (data, n)
  {
    var result = [];
    if (Array.isArray(n))
    {
      var max = null;
      for (var i = 0, j = 0; i < data.length; ++i)
      {
        result[i] = null;
        if (i >= n.length) continue;

        max = null;
        var count = n[i];
        if (count > 0 && count <= i)
        {
          for (j = i - count; j <= i; ++j)
          {
            if (max == null || max < data[j]) max = data[j];
          }
        } else

        {
          count = i;
          for (j = 0; j <= i; ++j)
          {
            if (max == null || max < data[j]) max = data[j];
          }
        }

        result[i] = max;
      }
    } else

    {
      if (n > data.length) return result;
      if (n <= 0) n = data.length - 1;

      var nMax = 0;
      for (nMax = 0; nMax < data.length; ++nMax)
      {
        if (this.IsNumber(data[nMax])) break;
      }

      if (nMax < data.length) result[nMax] = data[nMax];
      for (var i = nMax + 1, j = 2; i < data.length && j < n; ++i, ++j)
      {
        if (data[i] >= data[nMax]) nMax = i;
        result[i] = data[nMax];
      }

      for (; i < data.length; ++i)
      {
        if (i - nMax < n)
        {
          nMax = data[i] < data[nMax] ? nMax : i;
        } else

        {
          for (j = nMax = i - n + 1; j <= i; ++j)
          {
            nMax = data[j] < data[nMax] ? nMax : j;
          }
        }

        result[i] = data[nMax];
      }
    }

    return result;
  };

  /*
     LLV 最低值
     求最低值。
     用法：　LLV(X，N)　求N周期内X最低值，N=0则从第一个有效值开始。
     例如：　LLV(LOW，0)　表示求历史最低价。
     */
  this.LLV = function (data, n)
  {
    var result = [];
    if (Array.isArray(n))
    {
      for (var i = 0; i < data.length; ++i)
      {
        result[i] = null;
        if (i >= n.length) continue;

        var min = null;
        var count = n[i];
        if (count > 0 && count <= i)
        {
          for (var j = i - count; j <= i; ++j)
          {
            if (min == null || min > data[j]) min = data[j];
          }
        } else

        {
          count = i;
          for (var j = 0; j <= i; ++j)
          {
            if (min == null || min > data[j]) min = data[j];
          }
        }

        result[i] = min;
      }
    } else

    {
      if (n > data.length) return result;
      if (n <= 0) n = data.length - 1;

      var nMin = 0;
      for (nMin = 0; nMin < data.length; ++nMin)
      {
        if (this.IsNumber(data[nMin])) break;
      }

      if (nMin < data.length) result[nMin] = data[nMin];
      for (var i = nMin + 1, j = 2; i < data.length && j < n; ++i, ++j)
      {
        if (data[i] <= data[nMin]) nMin = i;
        result[i] = data[nMin];
      }

      for (; i < data.length; ++i)
      {
        if (i - nMin < n)
        {
          nMin = data[i] > data[nMin] ? nMin : i;
        } else

        {
          for (j = nMin = i - n + 1; j <= i; ++j)
          {
            nMin = data[j] > data[nMin] ? nMin : j;
          }
        }

        result[i] = data[nMin];
      }
    }

    return result;
  };

  this.STD = function (data, n)
  {
    var result = [];

    var total = 0;
    var averageData = []; //平均值
    for (var i = n - 1; i < data.length; ++i)
    {
      total = 0;
      for (var j = 0; j < n; ++j)
      {
        total += data[i - j];
      }

      averageData[i] = total / n;
    }

    for (var i = n - 1; i < data.length; ++i)
    {
      total = 0;
      for (var j = 0; j < n; ++j)
      {
        total += Math.pow(data[i - j] - averageData[i], 2);
      }

      result[i] = Math.sqrt(total / n);
    }


    return result;
  };

  //平均绝对方差
  this.AVEDEV = function (data, n)
  {
    var result = [];

    var total = 0;
    var averageData = []; //平均值
    for (var i = n - 1; i < data.length; ++i)
    {
      total = 0;
      for (var j = 0; j < n; ++j)
      {
        total += data[i - j];
      }

      averageData[i] = total / n;
    }

    for (var i = n - 1; i < data.length; ++i)
    {
      total = 0;
      for (var j = 0; j < n; ++j)
      {
        total += Math.abs(data[i - j] - averageData[i]);
      }

      result[i] = total / n;
    }


    return result;
  };

  //上穿
  this.CROSS = function (data, data2)
  {
    var result = [];
    if (Array.isArray(data) && Array.isArray(data2))
    {
      if (data.length != data2.length) return result = [];

      var index = 0;
      for (; index < data.length; ++index)
      {
        if (this.IsNumber(data[index]) && this.IsNumber(data2[index]))
        break;
      }

      for (++index; index < data.length; ++index)
      {
        result[index] = data[index] > data2[index] && data[index - 1] < data2[index - 1] ? 1 : 0;
      }
    } else
    if (Array.isArray(data) && typeof data2 == 'number')
    {
      var index = 0;
      for (; index < data.length; ++index)
      {
        if (this.IsNumber(data[index])) break;
      }

      for (++index; index < data.length; ++index)
      {
        result[index] = data[index] > data2 && data[index - 1] < data2 ? 1 : 0;
      }
    } else
    if (typeof data == 'number' && Array.isArray(data2))
    {
      var index = 0;
      for (; index < data2.length; ++index)
      {
        if (this.IsNumber(data2[index])) break;
      }

      for (++index; index < data2.length; ++index)
      {
        result[index] = data2[index] < data && data2[index - 1] > data ? 1 : 0;
      }
    }

    return result;
  };

  //累乘
  this.MULAR = function (data, n)
  {
    var result = [];
    if (data.length < n) return result;

    var index = n;
    for (; index < data.length; ++index)
    {
      if (data[index] != null && !isNaN(data[index]))
      {
        result[index] = data[index];
        break;
      }
    }

    for (++index; index < data.length; ++index)
    {
      result[index] = result[index - 1] * data[index];
    }

    return result;
  };

  this.SUM = function (data, n)
  {
    var result = [];

    if (n == 0)
    {
      result[0] = data[0];

      for (var i = 1; i < data.length; ++i)
      {
        result[i] = result[i - 1] + data[i];
      }
    } else

    {
      for (var i = n - 1, j = 0; i < data.length; ++i, ++j)
      {
        for (var k = 0; k < n; ++k)
        {
          if (k == 0) result[i] = data[k + j];else
          result[i] += data[k + j];
        }
      }
    }

    return result;
  };

  /*
         BARSCOUNT 有效数据周期数
         求总的周期数。
         用法：　BARSCOUNT(X)　第一个有效数据到当前的天数。
         例如：　BARSCOUNT(CLOSE)　对于日线数据取得上市以来总交易日数，对于分笔成交取得当日成交笔数，对于1分钟线取得当日交易分钟数。
     */
  this.BARSCOUNT = function (data)
  {
    var result = [];
    var days = null;
    for (var i in data)
    {
      result[i] = 0;
      if (days == null)
      {
        if (!this.IsNumber(data[i])) contnue;

        days = 0;
      }

      result[i] = days;
      ++days;
    }

    return result;
  };

  //DEVSQ 数据偏差平方和
  //DEVSQ(X，N) 　返回数据偏差平方和。
  this.DEVSQ = function (data, n)
  {
    var result = [];
    if (typeof n != 'number') n = parseInt(n); //字符串的转成数值型
    var num = n;
    var datanum = data.length;
    var i = 0,j = 0,k = 0;
    var E = 0,DEV = 0;
    for (i = 0; i < datanum && !this.isNumber(data[i]); ++i)
    {
      result[i] = null;
    }
    if (num < 1 || i + num > datanum) return result;
    for (E = 0; i < datanum && j < num; ++i, ++j) {
      E += data[i] / num;}
    if (j == num)
    {
      DEV = 0;
      for (i--; k < num; k++) {
        DEV += (data[i - k] - E) * (data[i - k] - E);}
      result[i] = DEV;
      i++;
    }
    for (; i < datanum; ++i)
    {
      E += (data[i] - data[i - num]) / num;
      for (DEV = 0, k = 0; k < num; ++k) {
        DEV += (data[i - k] - E) * (data[i - k] - E);}
      result[i] = DEV;
    }
    return result;
  };

  //NOT 取反
  //求逻辑非。
  //用法：　NOT(X)　返回非X，即当X=0时返回1，否则返回0。
  //例如：　NOT(ISUP)　表示平盘或收阴。
  this.NOT = function (data)
  {
    var isNumber = typeof data == 'number';
    if (isNumber) return data ? 0 : 1;

    var result = [];
    for (var i in data)
    {
      result[i] = null;
      if (this.IsNumber(data[i])) result[i] = data[i] ? 0 : 1;
    }

    return result;
  };

  //FORCAST 线性回归预测值
  //FORCAST(X，N)　 返回线性回归预测值。
  this.FORCAST = function (data, n)
  {
    var result = [];
    if (typeof n != 'number') n = parseInt(n); //字符串的转成数值型
    var num = n;
    var datanum = data.length;
    if (num < 1 || num >= datanum)
    return result;
    var Ex = 0,Ey = 0,Sxy = 0,Sxx = 0,Const,Slope;
    var i, j, x;
    for (j = 0; j < datanum && !this.IsNumber(data[j]); ++j)
    {
      result[j] = null;
    }
    for (i = j + num - 1; i < datanum; ++i)
    {
      Ex = Ey = Sxy = Sxx = 0;
      for (j = 0, x = num; j < num && j <= i; ++j, --x)
      {
        Ex += x;
        Ey += data[i - j];
      }
      Ex /= num;
      Ey /= num;
      for (j = 0, x = num; j < num && j <= i; ++j, --x)
      {
        Sxy += (x - Ex) * (data[i - j] - Ey);
        Sxx += (x - Ex) * (x - Ex);
      }
      Slope = Sxy / Sxx;
      Const = Ey - Ex * Slope;
      result[i] = Slope * num + Const;
    }

    return result;
  };

  //SLOPE 线性回归斜率
  //SLOPE(X，N)　 返回线性回归斜率。
  this.SLOPE = function (data, n)
  {
    var result = [];
    if (typeof n != 'number') n = parseInt(n); //字符串的转成数值型
    if (n < 1 || !data.length) return result;
    if (n >= data.length) return result;

    var start = 0;
    for (var i = 0; i < data.length; ++i, ++start)
    {
      result[i] = null;
      if (this.IsNumber(data[i])) break;
    }

    var x, y, xy, xx;
    for (var _i31 = start + n - 1; _i31 < data.length; ++_i31)
    {
      result[_i31] = null;
      x = y = xy = xx = 0;
      for (var j = 0; j < n && j <= _i31; ++j)
      {
        x += _i31 - j; //数据索引相加
        y += data[_i31 - j]; //数据相加
      }

      x = x / n;y = y / n;
      for (j = 0; j < n && j <= _i31; ++j)
      {
        xy += (_i31 - j - x) * (data[_i31 - j] - y);
        xx += (_i31 - j - x) * (_i31 - j - x);
      }

      if (xx) result[_i31] = xy / xx;else
      if (_i31) result[_i31] = result[_i31 - 1];
    }

    return result;
  };

  //STDP 总体标准差
  //STDP(X，N)　 返回总体标准差。
  this.STDP = function (data, n)
  {
    var result = [];
    if (typeof n != 'number') n = parseInt(n); //字符串的转成数值型
    var num = n;
    var datanum = data.length;
    if (num < 1 || num >= datanum)
    return result;
    var i = 0,j = 0;
    for (i = 0; i < datanum && !this.isNumber(data[i]); ++i)
    {
      result[i] = null;
    }
    var SigmaPowerX = 0,SigmaX = 0,MidResult;
    for (; i < datanum && j < num; ++i, ++j)
    {
      SigmaPowerX += data[i] * data[i];
      SigmaX += data[i];
    }
    if (j == num)
    {
      MidResult = num * SigmaPowerX - SigmaX * SigmaX;
      result[i - 1] = Math.sqrt(MidResult) / num;
    }
    for (; i < datanum; ++i)
    {
      SigmaPowerX += data[i] * data[i] - data[i - num] * data[i - num];
      SigmaX += data[i] - data[i - num];
      MidResult = num * SigmaPowerX - SigmaX * SigmaX;
      result[i] = Math.sqrt(MidResult) / num;
    }
  };

  //VAR 估算样本方差
  //VAR(X，N)　 返回估算样本方差。
  this.VAR = function (data, n)
  {
    var result = [];
    if (typeof n != 'number') n = parseInt(n); //字符串的转成数值型
    var num = n;
    var datanum = data.length;
    if (num <= 1 || num >= datanum)
    return result;
    var i, j;
    for (i = 0; i < datanum && !this.IsNumber(data[i]); ++i)
    {
      result[i] = null;
    }
    var SigmaPowerX, SigmaX;
    for (j = 0, i = i + num - 1; i < datanum; ++i)
    {
      SigmaPowerX = SigmaX = 0;
      for (j = 0; j < num && j <= i; ++j)
      {
        SigmaPowerX += data[i - j] * data[i - j];
        SigmaX += data[i - j];
      }
      result[i] = (num * SigmaPowerX - SigmaX * SigmaX) / num * (num - 1);
    }

    return result;
  };

  //VARP 总体样本方差
  //VARP(X，N)　 返回总体样本方差 。
  this.VARP = function (data, n)
  {
    var result = [];
    if (typeof n != 'number') n = parseInt(n); //字符串的转成数值型
    var num = n;
    var datanum = data.length;
    if (num < 1 || num >= datanum)
    return result;
    var i = 0,j = 0;
    for (i = 0; i < datanum && !this.IsNumber(data[i]); ++i)
    {
      result[i] = null;
    }
    var SigmaPowerX = 0,SigmaX = 0;
    for (; i < datanum && j < num; ++i, ++j)
    {
      SigmaPowerX += data[i] * data[i];
      SigmaX += data[i];
    }
    if (j == num)
    result[i - 1] = (num * SigmaPowerX - SigmaX * SigmaX) / (num * num);
    for (; i < datanum; ++i)
    {
      SigmaPowerX += data[i] * data[i] - data[i - num] * data[i - num];
      SigmaX += data[i] - data[i - num];
      result[i] = (num * SigmaPowerX - SigmaX * SigmaX) / (num * num);
    }

    return result;
  };

  //RANGE(A,B,C)表示A>B AND A<C;
  this.RANGE = function (data, range, range2)
  {
    var isNumber = typeof data == 'number';
    var isNumber2 = typeof range == 'number';
    var isNumber3 = typeof range2 == 'number';

    if (isNumber && isNumber2 && isNumber3)
    {
      if (data > Math.min(range, range2) && data < Math.max(range, range2)) return 1;else
      return 0;
    }

    var result = [];
    var value, rangeValue, rangValue2;
    for (var i = 0; i < data.length; ++i)
    {
      result[i] = null;
      value = data[i];
      if (!this.IsNumber(value)) continue;

      if (!isNumber2)
      {
        if (i >= range.length) continue;

        rangeValue = range[i];
      } else

      {
        rangeValue = range;
      }
      if (!this.IsNumber(rangeValue)) continue;

      if (!isNumber3)
      {
        if (i >= range2.length) continue;

        rangeValue2 = range2[i];
      } else

      {
        rangeValue2 = range2;
      }
      if (!this.IsNumber(rangeValue2)) continue;


      result[i] = value > Math.min(rangeValue, rangeValue2) && value < Math.max(rangeValue, rangeValue2) ? 1 : 0;
    }

    return result;
  };

  this.EXIST = function (data, n)
  {
    n = parseInt(n);

    if (typeof data == 'number') return 0;

    var latestID; //最新满足条件的数据索引
    var result = [];
    var value;
    for (var i = 0; i < data.length; ++i)
    {
      result[i] = null;
      value = data[i];
      if (this.IsNumber(value) && value > 0) latestID == i;

      if (i - latestID < n) result[i] = 1;else
      result[i] = 0;
    }

    return result;
  };

  this.TFILTER = function (data, data2, n)
  {
    n = parseInt(n);

    var result = [];

    var isNumber = typeof data == 'number';
    var isNumber2 = typeof range == 'number';

    var count = Math.max(data.length, data2.length);
    for (var i = 0; i < count; ++i)
    {

    }


    return result;
  };

  /*
     过滤连续出现的信号.
     用法:FILTER(X,N):X满足条件后,将其后N周期内的数据置为0,N为常量.
     例如:
     FILTER(CLOSE>OPEN,5)查找阳线,5天内再次出现的阳线不被记录在内
     */
  this.FILTER = function (data, n)
  {
    var result = [];
    for (var i = 0, j = 0; i < data.length; ++i)
    {
      if (data[i])
      {
        result[i] = 1;
        for (j = 0; j < n && j + i + 1 < data.length; ++j)
        {
          result[j + i + 1] = 0;
        }
        i += n;
      } else

      {
        result[i] = 0;
      }
    }

    return result;
  };

  this.BARSLAST = function (data)
  {
    var result = [];
    if (!data) return result;

    var day = null;
    for (var i = 0; i < data.length; ++i)
    {
      result[i] = null;

      if (data[i] > 0) day = 0;else
      if (day != null) ++day;

      if (day != null) result[i] = day;
    }

    return result;
  };

  /*
     N周期内第一个条件成立到当前的周期数.
     用法:
     BARSSINCEN(X,N):N周期内第一次X不为0到现在的天数,N为常量
     例如:
     BARSSINCEN(HIGH>10,10)表示10个周期内股价超过10元时到当前的周期数
     */
  this.BARSSINCEN = function (data, n)
  {
    var result = [];
    if (this.IsNumber(n) && Array.isArray(data))
    {
      var nPeriod = n;
      if (nPeriod < 1) nPeriod = data.length;
      var i = this.GetFirstVaildIndex(data);
      if (i >= data.length) return result;
      var j = 0;
      if (i <= nPeriod - 1) j = nPeriod - 1;else
      j = i;

      result[j] = j - i;

      for (; j < data.length; ++j)
      {
        if (this.IsNumber(result[j - 1]))
        {
          if (result[j - 1] + 1 < nPeriod)
          {
            result[j] = result[j - 1] + 1;
          } else

          {
            for (var k = j - nPeriod + 1; k <= j; ++k)
            {
              if (!(Math.abs(data[k]) < 0.000001))
              {
                result[j] = j - k;
                break;
              }
            }
          }
        } else

        {
          if (!(Math.abs(data[j]) < 0.000001))
          result[j] = 0;
        }
      }
    }

    return result;
  };

  /*
     第一个条件成立到当前的周期数.
     用法:
     BARSSINCE(X):第一次X不为0到现在的天数
     例如:
     BARSSINCE(HIGH>10)表示股价超过10元时到当前的周期数
     */
  this.BARSSINCE = function (data)
  {
    var result = [];
    var day = null;

    for (var i = 0; i < data.length; ++i)
    {
      result[i] = null;
      if (day == null)
      {
        if (data[i]) day = 0;
      } else

      {
        ++day;
      }

      if (day) result[i] = day;
    }

    return result;
  };

  /*三角函数调用 func 三角函数 
     反正切值. 用法: ATAN(X)返回X的反正切值
     余弦值.  用法: COS(X)返回X的余弦值
     正弦值.  用法: SIN(X)返回X的正弦值
     正切值.  用法: TAN(X)返回X的正切值
       求自然对数. 用法: LN(X)以e为底的对数 例如: LN(CLOSE)求收盘价的对数
     求10为底的对数. 用法: LOG(X)取得X的对数 例如: LOG(100)等于2
     指数. 用法: EXP(X)为e的X次幂 例如: EXP(CLOSE)返回e的CLOSE次幂
     开平方. 用法: SQRT(X)为X的平方根 例如: SQRT(CLOSE)收盘价的平方根
     */

  this.Trigonometric = function (data, func)
  {
    if (!Array.isArray(data))
    {
      if (this.IsNumber(data)) return func(data);

      return null;
    } else

    {
      var result = [];
      for (var i in data)
      {
        var item = data[i];
        if (this.IsNumber(item)) result[i] = func(item);else
        result[i] = null;
      }

      return result;
    }
  };

  //反正弦值. 用法: ASIN(X)返回X的反正弦值
  this.ASIN = function (data)
  {
    if (!Array.isArray(data))
    {
      if (this.IsNumber(data)) return Math.acos(data);
      return null;
    } else

    {
      var result = [];
      for (var i in data)
      {
        var item = data[i];
        result[i] = null;
        if (this.IsNumber(item))
        {
          if (item >= -1 && item <= 1)
          {
            result[i] = Math.asin(item);
          } else
          if (i - 1 >= 0)
          {
            var preItem = result[i - 1];
            if (this.IsNumber(preItem)) result[i] = preItem;
          }
        }
      }

      return result;
    }
  };


  //反余弦值. 用法: ACOS(X)返回X的反余弦值
  this.ACOS = function (data)
  {
    if (!Array.isArray(data))
    {
      if (this.IsNumber(data)) return Math.acos(data);

      return null;
    } else

    {
      var result = [];
      for (var i in data)
      {
        var item = data[i];
        result[i] = null;
        if (this.IsNumber(item))
        {
          if (item >= -1 && item <= 1)
          {
            result[i] = Math.acos(item);
          } else
          if (i - 1 >= 0) //超出范围使用上一个数值
            {
              var preItem = result[i - 1];
              if (this.IsNumber(preItem)) result[i] = preItem;
            }
        }
      }

      return result;
    }
  };

  /*
     LAST(X,A,B):持续存在.
     用法:
     LAST(CLOSE>OPEN,10,5) 
     表示从前10日到前5日内一直阳线
     若A为0,表示从第一天开始,B为0,表示到最后日止
     */
  this.LAST = function (data, n, n2)
  {
    var result = [];
    if (n2 <= 0) n2 = data.length - 1;
    if (n2 > n) return result;

    var day = 0;

    for (var i = 0, j = 0; i < data.length; ++i) {
      result[i] = 0;
      day = 0;
      var start = i - n;
      var end = i - n2;
      if (start < 0 || end < 0) continue;

      for (j = start; j < data.length && j <= end; ++j, ++day) {
        if (!data[j]) break;
      }

      if (day == end - start + 1) //[start,end]
        result[i] = 1;
    }

    return result;
  };

  /*
     属于未来函数,之字转向.
     用法: ZIG(K,N),当价格变化量超过N%时转向,K表示0:开盘价,1:最高价,2:最低价,3:收盘价,其余:数组信息
     例如: ZIG(3,5)表示收盘价的5%的ZIG转向
     */
  this.ZIG = function (data, n)
  {
    var hisData = this.SymbolData.Data;
    var result = [];
    if (typeof data == 'number')
    {
      switch (data) {

        case 0:
          data = hisData.GetOpen();
          break;
        case 1:
          data = hisData.GetHigh();
          break;
        case 2:
          data = hisData.GetLow();
          break;
        case 3:
          data = hisData.GetClose();
          break;
        default:
          return result;}

    }

    return this.ZIG_Calculate(data, n);
  };

  this.ZIG_Calculate = function (data, dRate)
  {
    var dest = [];
    var nDataCount = data.length;
    var m = this.GetFirstVaildIndex(data);
    var i = 0,lLastPos = 0,lState = 0,j = 0;
    var dif = 0;
    for (i = m + 1, lLastPos = lState = m; i < nDataCount - 1 && lState == m; ++i)
    {
      lState = Math.abs(data[i] - data[m]) * 100 >= dRate * data[m] ? data[i] > data[m] ? i : -i : m;
    }

    for (; i < nDataCount - 1; ++i)
    {
      if (data[i] >= data[i - 1] && data[i] >= data[i + 1])
      {
        if (lState < 0)
        {
          if ((data[i] - data[-lState]) * 100 < dRate * data[-lState]) continue;else

          {
            dif = (data[lLastPos] - data[j = -lState]) / (-lState - lLastPos);
            dest[j--] = data[-lState];
            for (; j >= lLastPos; j--) {
              dest[j] = data[-lState] + (-lState - j) * dif;}
            lLastPos = -lState;
            lState = i;
          }
        } else
        if (data[i] > data[lState]) lState = i;
      } else
      if (data[i] <= data[i - 1] && data[i] <= data[i + 1])
      {
        if (lState > 0)
        {
          if ((data[lState] - data[i]) * 100 < dRate * data[lState]) continue;else

          {
            dif = (data[lState] - data[j = lLastPos]) / (lState - lLastPos);
            dest[j++] = data[lLastPos];
            for (; j <= lState; ++j) {
              dest[j] = data[lLastPos] + (j - lLastPos) * dif;}
            lLastPos = lState;
            lState = -i;
          }
        } else
        if (data[i] < data[-lState]) lState = -i;
      }
    }

    if (Math.abs(lState) >= nDataCount - 2)
    {
      if (lState > 0 && data[nDataCount - 1] >= data[lState]) lState = nDataCount - 1;
      if (lState < 0 && data[nDataCount - 1] <= data[-lState]) lState = 1 - nDataCount;
    }

    if (lState > 0)
    {
      dif = (data[lState] - data[j = lLastPos]) / (lState - lLastPos);
      dest[j++] = data[lLastPos];
      for (; j <= lState; ++j) {
        dest[j] = data[lLastPos] + (j - lLastPos) * dif;}
    } else

    {
      dif = (data[lLastPos] - data[j = -lState]) / (-lState - lLastPos);
      dest[j--] = data[-lState];
      for (; j >= lLastPos; j--) {
        dest[j] = data[-lState] + (-lState - j) * dif;}
    }
    if ((lState = Math.abs(lState)) < nDataCount - 1)
    {
      if (data[nDataCount - 1] >= data[lState])
      {
        dif = (data[nDataCount - 1] - data[j = lState]) / (nDataCount - lState);
        dest[j++] = data[lState];
        for (; j < nDataCount; ++j) {
          dest[j] = data[lState] + (j - lState) * dif;}
      } else

      {
        dif = (data[lState] - data[j = nDataCount - 1]) / (nDataCount - lState);
        dest[j--] = data[nDataCount - 1];
        for (; j >= lState; j--) {
          dest[j] = data[nDataCount - 1] + (nDataCount - j) * dif;}
      }
    }

    return dest;
  };


  this.GetFirstVaildIndex = function (data)
  {
    for (var i = 0; i < data.length; ++i)
    {
      if (this.IsNumber(data[i]))
      return i;
    }
    return data.length;
  };

  this.JSDraw = null;
  this.CalculateZIGLine = function (firstData, secondData, thridData, data, result)
  {
    if (this.JSDraw == null) this.JSDraw = new JSDraw(this.ErrorHandler);
    var isUp = secondData.Up;
    var findData = firstData;
    if (isUp)
    {
      for (var i = firstData.ID + 1; i < thridData.ID; ++i) //查找最高点
      {
        var subItem = data[i];
        if (!this.IsNumber(subItem)) continue;
        if (findData.Value < subItem) findData = { ID: i, Value: subItem };
      }
    } else

    {
      for (var i = firstData.ID + 1; i < thridData.ID; ++i) //查找最低点
      {
        var subItem = data[i];
        if (!this.IsNumber(subItem)) continue;
        if (findData.Value > subItem) findData = { ID: i, Value: subItem };
      }
    }

    secondData.Value = findData.Value;
    secondData.ID = findData.ID;

    var lineCache = { Start: { ID: firstData.ID, Value: firstData.Value }, End: { ID: secondData.ID, Value: secondData.Value } };
    var lineData = this.JSDraw.CalculateDrawLine(lineCache); //计算2个点的线上 其他点的数值
    for (var i in lineData)
    {
      var lineItem = lineData[i];
      result[lineItem.ID] = lineItem.Value;
    }

    if (thridData.ID == data.length - 1) //最后一组数据
      {
        //最后2个点的数据连成线
        lineCache = { Start: { ID: secondData.ID, Value: secondData.Value }, End: { ID: thridData.ID, Value: thridData.Value } };
        lineData = this.JSDraw.CalculateDrawLine(lineCache); //计算2个点的线上 其他点的数值
        for (var i in lineData)
        {
          var lineItem = lineData[i];
          result[lineItem.ID] = lineItem.Value;
        }
      } else

    {
      firstData.ID = secondData.ID;
      firstData.Value = secondData.Value;

      secondData.ID = thridData.ID;
      secondData.Value = thridData.Value;
      secondData.Up = firstData.Value < secondData.Value;
    }
  };

  /*
     属于未来函数,前M个ZIG转向波谷到当前距离.
     用法:
     TROUGHBARS(K,N,M)表示之字转向ZIG(K,N)的前M个波谷到当前的周期数,M必须大于等于1
     例如:
     TROUGHBARS(2,5,2)表示%5最低价ZIG转向的前2个波谷到当前的周期数
     */
  this.TROUGHBARS = function (data, n, n2)
  {
    var zigData = this.ZIG(data, n); //计算ZIG
    var dest = [];

    var lEnd = n2;
    if (lEnd < 1) return dest;

    var nDataCount = zigData.length;
    var trough = [];
    for (var i = 0; i < lEnd; ++i) {trough[i] = 0;}
    var lFlag = 0;
    var i = this.GetFirstVaildIndex(zigData) + 1;
    for (lEnd--; i < nDataCount && zigData[i] > zigData[i - 1]; ++i) {;}

    for (; i < nDataCount && zigData[i] < zigData[i - 1]; ++i) {;}

    for (trough[0] = --i; i < nDataCount - 1; ++i)
    {
      if (zigData[i] < zigData[i + 1])
      {
        if (lFlag)
        {
          if (lEnd)
          {
            var tempTrough = trough.slice(0);
            for (var j = 0; j < lEnd; ++j)
            {
              trough[j + 1] = tempTrough[j];
            }
          }
          trough[lFlag = 0] = i;
        }
      } else
      lFlag = 1;
      if (trough[lEnd]) dest[i] = i - trough[lEnd];
    }
    if (trough[lEnd]) dest[i] = i - trough[lEnd];

    return dest;
  };

  this.TROUGH = function (data, n, n2)
  {
    var zigData = this.ZIG(data, n); //计算ZIG
    var dest = [];

    var End = n2;
    if (End < 1) return dest;

    var nDataCount = zigData.length;
    var trough = [];
    for (var i = 0; i < End; ++i) {trough[i] = 0;}
    var i = 1,Flag = 0;
    var i = this.GetFirstVaildIndex(zigData) + 1;

    for (End--; i < nDataCount && zigData[i] > zigData[i - 1]; ++i) {;}

    for (; i < nDataCount && zigData[i] < zigData[i - 1]; ++i) {;}

    for (trough[0] = --i; i < nDataCount - 1; ++i)
    {
      if (zigData[i] < zigData[i + 1])
      {
        if (Flag)
        {
          if (End)
          {
            var tempTrough = trough.slice(0);
            for (var j = 0; j < End; ++j)
            {
              trough[j + 1] = tempTrough[j];
            }
          }
          trough[Flag = 0] = i;
        }
      } else
      Flag = 1;
      if (trough[End]) dest[i] = zigData[trough[End]];
    }
    if (trough[End]) dest[i] = zigData[trough[End]];

    return dest;
  };

  /*
     属于未来函数,前M个ZIG转向波峰到当前距离.
     用法:
     PEAKBARS(K,N,M)表示之字转向ZIG(K,N)的前M个波峰到当前的周期数,M必须大于等于1
     例如:
     PEAKBARS(0,5,1)表示%5开盘价ZIG转向的上一个波峰到当前的周期数
     */
  this.PEAKBARS = function (data, n, n2)
  {
    var zigData = this.ZIG(data, n); //计算ZIG
    var dest = [];

    var nDataCount = zigData.length;
    var lEnd = n2;
    if (lEnd < 1) return dest;

    var peak = [];
    for (var i = 0; i < lEnd; ++i) {peak[i] = 0;}
    var lFlag = 0;

    var i = this.GetFirstVaildIndex(zigData) + 1;
    for (lEnd--; i < nDataCount && zigData[i] < zigData[i - 1]; ++i) {;}

    for (; i < nDataCount && zigData[i] > zigData[i - 1]; ++i) {;}

    for (peak[0] = --i; i < nDataCount - 1; ++i)
    {
      if (zigData[i] > zigData[i + 1])
      {
        if (lFlag)
        {
          if (lEnd)
          {
            var tempPeak = peak.slice(0);
            for (var j = 0; j < lEnd; ++j)
            {
              peak[j + 1] = tempPeak[j];
            }
          }
          peak[lFlag = 0] = i;
        }
      } else
      lFlag = 1;
      if (peak[lEnd]) dest[i] = i - peak[lEnd];
    }
    if (peak[lEnd]) dest[i] = i - peak[lEnd];

    return dest;
  };


  this.PEAK = function (data, n, n2)
  {
    var zigData = this.ZIG(data, n); //计算ZIG
    var dest = [];

    var nDataCount = zigData.length;
    var lEnd = n2;
    if (lEnd < 1) return dest;

    var lFlag = 0;
    var peak = [];
    for (var i = 0; i < lEnd; ++i) {peak[i] = 0;}

    var i = this.GetFirstVaildIndex(zigData) + 1;
    for (lEnd--; i < nDataCount && zigData[i] < zigData[i - 1]; ++i) {;}

    for (; i < nDataCount && zigData[i] > zigData[i - 1]; ++i) {;}

    for (peak[0] = --i; i < nDataCount - 1; ++i)
    {
      if (zigData[i] > zigData[i + 1])
      {
        if (lFlag)
        {
          if (lEnd)
          {
            var tempPeak = peak.slice(0);
            for (var j = 0; j < lEnd; ++j)
            {
              peak[j + 1] = tempPeak[j];
            }
          }
          peak[lFlag = 0] = i;
        }
      } else
      lFlag = 1;
      if (peak[lEnd]) dest[i] = zigData[peak[lEnd]];
    }
    if (peak[lEnd]) dest[i] = zigData[peak[lEnd]];

    return dest;
  };

  /*
     一直存在.
     例如:
     EVERY(CLOSE>OPEN,N) 
     表示N日内一直阳线(N应大于0,小于总周期数,N支持变量)
     */
  this.EVERY = function (data, n)
  {
    var result = [];
    if (n < 1) return result;
    var i = 0;
    for (; i < data.length; ++i)
    {
      result[i] = null;
      if (this.IsNumber(data[i])) break;
    }

    var flag = 0;
    for (; i < data.length; ++i)
    {
      if (data[i]) flag += 1;else
      flag = 0;

      if (flag == n)
      {
        result[i] = 1;
        --flag;
      } else

      {
        result[i] = 0;
      }
    }

    return result;
  };

  /*
     成本分布情况.
     用法:
     COST(10),表示10%获利盘的价格是多少,即有10%的持仓量在该价格以下,其余90%在该价格以上,为套牢盘
     该函数仅对日线分析周期有效
     */
  this.COST = function (data, node)
  {
    var result = [];
    var rate = data / 100;
    if (rate < 0.000001 || rate > 1) return result;

    var kData = this.SymbolData.Data.Data;
    if (!kData || kData.length <= 0) return result;
    var aryCapital = this.SymbolData.GetStockCacheData({ FunctionName: "FINANCE", Args: [7], ArgCount: 1, Node: node }); //流通股本

    var dMaxPrice = kData[0].High,dMinPrice = kData[0].Low;
    for (var i = 0; i < kData.length; ++i)
    {
      var item = kData[i];
      dMinPrice = Math.min(dMinPrice, item.Low);
      dMaxPrice = Math.max(dMaxPrice, item.High);
    }

    if (dMinPrice > 2000 || dMinPrice < 0 || dMaxPrice > 2000 || dMinPrice < 0)
    this.ThrowUnexpectedNode(node, 'COST() 历史K线最大最小值错误, 超出(0,1000)范围');

    var lMaxPrice = parseInt(dMaxPrice * 100 + 1);
    var lMinPrice = parseInt(dMinPrice * 100 - 1);
    var lLow = 0,lHigh = 0,lClose = 0;
    //去掉小数
    dMaxPrice = lMaxPrice / 100.0;
    dMinPrice = lMinPrice / 100.0;
    var lSpeed = lMaxPrice - lMinPrice + 1;
    if (lSpeed < 1) return result;

    var aryVolPrice = [],aryPerVol = [];
    for (var i = 0; i < lSpeed; ++i)
    {
      aryVolPrice[i] = 0;
      aryPerVol[i] = 0;
    }

    var dHSL = 0,dTotalVol = 0,dVol = 0,dCost = 0;
    for (var i = 0; i < kData.length; ++i)
    {
      if (i >= aryCapital.length) continue;
      if (aryCapital[i] > 1)
      {
        var kItem = kData[i];
        dHSL = kItem.Vol / aryCapital[i];

        for (var j = 0; j < lSpeed; j++) {
          aryVolPrice[j] *= 1 - dHSL;}

        lLow = parseInt(Math.min(lMaxPrice, Math.max(lMinPrice, kItem.Low * 100))) - lMinPrice;
        lHigh = parseInt(Math.min(lMaxPrice, Math.max(lMinPrice, kItem.High * 100))) - lMinPrice;
        lClose = parseInt(Math.min(lMaxPrice, Math.max(lMinPrice, kItem.Close * 100))) - lMinPrice;

        for (var j = 0; j < lSpeed; ++j) {aryPerVol[j] = 0;}

        var lHalf = parseInt((lLow + lHigh + 2 * lClose) / 4);
        if (lHalf == lHigh || lHalf == lLow)
        {
          aryPerVol[lHalf] += kItem.Vol;
        } else

        {
          var dVH = kItem.Vol / (lHalf - lLow);
          for (var k = lLow; k < lHalf; ++k)
          {
            aryPerVol[k] += (k - lLow) * (dVH / (lHalf - lLow));
          }
          for (k; k <= lHigh; ++k)
          {
            aryPerVol[k] += (k - lHigh) * (dVH / (lHalf - lHigh));
          }
        }

        var dTotalVol = 0;
        for (var j = lLow; j <= lHigh; j++)
        {
          aryVolPrice[j] += aryPerVol[j];
        }

        for (var j = 0; j < lSpeed; j++)
        {
          dTotalVol += aryVolPrice[j];
        }

        for (j = 0, dCost = dVol = 0; j < lSpeed; ++j)
        {
          dVol += aryVolPrice[j];
          if (dVol >= dTotalVol * rate)
          {
            dCost = (dMaxPrice - dMinPrice) * j / lSpeed + dMinPrice;
            break;
          }
        }
      }

      result[i] = dCost;
    }

    return result;
  };

  /*
     获利盘比例.
     用法:
     WINNER(CLOSE),表示以当前收市价卖出的获利盘比例,例如返回0.1表示10%获利盘;WINNER(10.5)表示10.5元价格的获利盘比例
     该函数仅对日线分析周期有效
     ！！！！计算比较耗时间
     */
  this.WINNER = function (data, node)
  {
    var result = [];
    var kData = this.SymbolData.Data.Data;
    if (!kData || kData.length <= 0) return result;
    var aryCapital = this.SymbolData.GetStockCacheData({ FunctionName: "FINANCE", Args: [7], ArgCount: 1, Node: node }); //流通股本

    var dMaxPrice = kData[0].High,dMinPrice = kData[0].Low;
    for (var i = 0; i < kData.length; ++i)
    {
      var item = kData[i];
      dMinPrice = Math.min(dMinPrice, item.Low);
      dMaxPrice = Math.max(dMaxPrice, item.High);
    }

    if (dMinPrice > 1000 || dMinPrice < 0 || dMaxPrice > 1000 || dMinPrice < 0)
    this.ThrowUnexpectedNode(node, 'WINNER() 历史K线最大最小值错误, 超出(0,1000)范围');

    var lMaxPrice = parseInt(dMaxPrice * 100 + 1);
    var lMinPrice = parseInt(dMinPrice * 100 - 1);
    var lLow = 0,lHigh = 0,lClose = 0;
    //去掉小数
    dMaxPrice = lMaxPrice / 100.0;
    dMinPrice = lMinPrice / 100.0;
    var lSpeed = lMaxPrice - lMinPrice + 1;
    if (lSpeed < 1) return result;

    var aryVolPrice = [],aryPerVol = [];
    for (var i = 0; i < lSpeed; ++i)
    {
      aryVolPrice[i] = 0;
      aryPerVol[i] = 0;
    }

    var dHSL = 0,dTotalVol = 0,dVol = 0;
    for (var i = 0; i < kData.length; ++i)
    {
      if (i >= aryCapital.length) continue;
      if (!(aryCapital[i] > 1)) continue;
      var kItem = kData[i];
      dHSL = kItem.Vol / aryCapital[i];

      for (var j = 0; j < lSpeed; j++) {
        aryVolPrice[j] *= 1 - dHSL;}

      lLow = parseInt(Math.min(lMaxPrice, Math.max(lMinPrice, kItem.Low * 100))) - lMinPrice;
      lHigh = parseInt(Math.min(lMaxPrice, Math.max(lMinPrice, kItem.High * 100))) - lMinPrice;
      lClose = parseInt(Math.min(lMaxPrice, Math.max(lMinPrice, kItem.Close * 100))) - lMinPrice;

      for (var j = 0; j < lSpeed; ++j) {aryPerVol[j] = 0;}

      var lHalf = parseInt((lLow + lHigh + 2 * lClose) / 4);
      if (lHalf == lHigh || lHalf == lLow)
      {
        aryPerVol[lHalf] += kItem.Vol;
      } else

      {
        var dVH = kItem.Vol / (lHalf - lLow);
        for (var k = lLow; k < lHalf; ++k)
        {
          aryPerVol[k] += (k - lLow) * (dVH / (lHalf - lLow));
        }
        for (k; k <= lHigh; ++k)
        {
          aryPerVol[k] += (k - lHigh) * (dVH / (lHalf - lHigh));
        }
      }

      var dTotalVol = 0;
      for (var j = lLow; j <= lHigh; j++)
      {
        aryVolPrice[j] += aryPerVol[j];
      }

      for (var j = 0; j < lSpeed; j++)
      {
        dTotalVol += aryVolPrice[j];
      }

      if (Array.isArray(data))
      lHigh = parseInt(Math.min(data[i] * 100 - lMinPrice, lSpeed - 1));else

      lHigh = parseInt(Math.min(data * 100 - lMinPrice, lSpeed - 1));

      for (var j = 0, dVol = 0; j <= lHigh; j++)
      {
        dVol += aryVolPrice[j];
      }

      if (dTotalVol > 0) result[i] = dVol / dTotalVol;else
      if (i - 1 >= 0) result[i] = result[i - 1];
    }

    return result;
  };

  //计算截至到某一天的历史所有筹码
  this.CalculateChip = function (index, exchangeData, hisData, dRate)
  {
    var result = { Min: null, Max: null, Data: [] };
    var seed = 1; //筹码历史衰减换手系数
    var max = null,min = null;
    for (var i = index; i >= 0; --i)
    {
      var _item = {}; //Vol:量 High:最高 Low:最低
      var kData = hisData[i];
      if (i == index) _item.Vol = kData.Vol * exchangeData[i];else
      _item.Vol = kData.Vol * seed;

      _item.Date = kData.Date;
      _item.High = kData.High;
      _item.Low = kData.Low;

      if (max == null) max = _item.High;else
      if (max < _item.High) max = _item.High;
      if (min == null) min = _item.Low;else
      if (min < _item.Low) min = _item.Low;

      result.Data[i] = _item;

      seed *= 1 - exchangeData[i] / 100 * dRate; //换手率累乘
    }

    result.Max = max;
    result.Min = min;

    return result;
  };

  /*
     返回是否连涨周期数.
     用法:
     UPNDAY(CLOSE,M)
     表示连涨M个周期,M为常量
     */
  this.UPNDAY = function (data, n)
  {
    var result = [];
    if (n < 1) return result;
    if (data == null || n > data.length) return result;

    var days = 0;
    for (var i = 0; i < data.length; ++i)
    {
      result[i] = 0;
      if (i - 1 < 0) continue;
      if (!this.IsNumber(data[i]) || !this.IsNumber(data[i - 1])) //无效数都不算连涨
        {
          days = 0;
          continue;
        }

      if (data[i] > data[i - 1]) ++days;else
      days = 0;

      if (days == n)
      {
        result[i] = 1;
        --days;
      }
    }

    return result;
  };

  /*
     返回是否连跌周期.
     用法:
     DOWNNDAY(CLOSE,M)
     表示连跌M个周期,M为常量
     */
  this.DOWNNDAY = function (data, n)
  {
    var result = [];
    if (n < 1) return result;
    if (data == null || n > data.length) return result;

    var days = 0;
    for (var i = 0; i < data.length; ++i)
    {
      result[i] = 0;
      if (i - 1 < 0) continue;
      if (!this.IsNumber(data[i]) || !this.IsNumber(data[i - 1])) //无效数都不算连涨
        {
          days = 0;
          continue;
        }

      if (data[i] < data[i - 1]) ++days;else
      days = 0;

      if (days == n)
      {
        result[i] = 1;
        --days;
      }
    }

    return result;
  };

  /*
     返回是否持续存在X>Y
     用法:
     NDAY(CLOSE,OPEN,3)
     表示连续3日收阳线
     */
  this.NDAY = function (data, data2, n)
  {
    var result = [];
    if (n < 1) return result;
    if (!Array.isArray(data) && !Array.isArray(data2)) return result;
    if (data == null || data2 == null) return result;

    if (Array.isArray(data) && Array.isArray(data2))
    {
      if (n >= data.length || n >= data2.length) return result;
      var count = Math.max(data.length, data2.length);
      var days = 0;
      for (var i = 0; i < count; ++i)
      {
        result[i] = 0;
        if (i >= data.length || i >= data2.length) continue;
        if (!this.IsNumber(data[i]) || !this.IsNumber(data2[i]))
        {
          days = 0;
          continue;
        }

        if (data[i] > data2[i]) ++days;else
        days = 0;

        if (days == n)
        {
          result[i] = 1;
          --days;
        }
      }
    } else
    if (Array.isArray(data) && !Array.isArray(data2))
    {
      if (n >= data.length || !this.IsNumber(data2)) return;
      var days = 0;
      for (var _i32 in data)
      {
        result[_i32] = 0;
        if (!this.IsNumber(data[_i32]))
        {
          days = 0;
          continue;
        }

        if (data[_i32] > data2) ++days;else
        days = 0;

        if (days == n)
        {
          result[_i32] = 1;
          --days;
        }
      }
    } else
    if (!Array.isArray(data) && Array.isArray(data2))
    {
      if (n >= data2.length || !this.IsNumber(data)) return;
      var days = 0;
      for (var _i33 in data2)
      {
        result[_i33] = 0;
        if (!this.IsNumber(data2[_i33]))
        {
          days = 0;
          continue;
        }

        if (data > data2[_i33]) ++days;else
        days = 0;

        if (days == n)
        {
          result[_i33] = 1;
          --days;
        }
      }
    }

    return result;
  };

  /*
     两条线维持一定周期后交叉.
     用法:LONGCROSS(A,B,N)表示A在N周期内都小于B,本周期从下方向上穿过B时返回1,否则返回0
     */
  this.LONGCROSS = function (data, data2, n)
  {
    var result = [];
    var count = Math.max(data.length, data2.length);
    for (var i = 0; i < count; ++i)
    {
      result[i] = 0;
      if (i - 1 < 0) continue;
      if (i >= data.length || i >= data2.length) continue;
      if (!this.IsNumber(data[i]) || !this.IsNumber(data2[i]) || !this.IsNumber(data[i - 1]) || !this.IsNumber(data2[i - 1])) continue;

      if (data[i] > data2[i] && data[i - 1] < data2[i - 1]) result[i] = 1;
    }

    for (var _i34 = 0, j = 0; _i34 < count; ++_i34)
    {
      if (!result[_i34]) continue;

      for (j = 1; j <= n && _i34 - j >= 0; ++j)
      {
        if (data[_i34 - j] >= data2[_i34 - j])
        {
          result[_i34] = 0;
          break;
        }
      }
    }

    return result;
  };

  /*
     EXISTR(X,A,B):是否存在(前几日到前几日间).
     例如: EXISTR(CLOSE>OPEN,10,5) 
     表示从前10日内到前5日内存在着阳线
     若A为0,表示从第一天开始,B为0,表示到最后日止
     */
  this.EXISTR = function (data, n, n2)
  {
    var result = [];
    if (!Array.isArray(data)) return result;

    n = parseInt(n);
    n2 = parseInt(n2);
    if (n <= 0) n = data.length;
    if (n2 <= 0) n2 = 1;
    if (n2 > n) return result;

    var result = [];
    var value;
    for (var i = 0, j = 0; i < data.length; ++i)
    {
      result[i] = null;
      if (i - n < 0 || i - n2 < 0) continue;

      result[i] = 0;
      for (j = n; j >= n2; --j)
      {
        var value = data[i - j];
        if (this.IsNumber(value) && value)
        {
          result[i] = 1;
          break;
        }
      }
    }

    return result;
  };

  /*
     RELATE(X,Y,N) 返回X和Y的N周期的相关系数
     RELATE(X,Y,N)=(∑[(Xi-Avg(X))(Yi-Avg(y))])/N ÷ √((∑(Xi-Avg(X))^2)/N * (∑(Yi-Avg(Y))^2)/N)
     其中 avg(x)表示x的N周期均值：  avg(X) = (∑Xi)/N  
     √(...)表示开平方
     */
  this.RELATE = function (data, data2, n)
  {
    var result = [];
    if (n < 1) n = 1;

    if (!Array.isArray(data) || !Array.isArray(data2)) return result;

    var dataAverage = this.CalculateAverage(data, n);
    var data2Average = this.CalculateAverage(data2, n);

    var count = Math.max(data.length, data2.length);
    for (var i = 0, j = 0; i < count; ++i)
    {
      result[i] = null;

      if (i >= data.length || i >= data2.length || i >= dataAverage.length || i >= data2Average.length) continue;

      var average = dataAverage[i];
      var average2 = data2Average[i];

      var total = 0,total2 = 0,total3 = 0;
      for (j = i - n + 1; j <= i; ++j)
      {
        total += (data[j] - average) * (data2[j] - average2); //∑[(Xi-Avg(X))(Yi-Avg(y))])
        total2 += Math.pow(data[j] - average, 2); //∑(Xi-Avg(X))^2
        total3 += Math.pow(data2[j] - average2, 2); //∑(Yi-Avg(Y))^2)
      }

      result[i] = total / n / (Math.sqrt(total2 / n) * Math.sqrt(total3 / n));
    }

    return result;
  };

  //计算数组n周期内的均值
  this.CalculateAverage = function (data, n)
  {
    var result = [];
    if (n < 1) return result;

    var total = 0;

    for (var i = 0; i < data.length; ++i) //去掉开始的无效数
    {
      if (this.IsNumber(data[i])) break;
    }

    for (; i < data.length && i < n; ++i) //计算第1个周期的数据
    {
      result[i] = null;
      var value = data[i];
      if (!this.IsNumber(value)) continue;
      total += value;
    }
    result[i - 1] = total / n;

    for (; i < data.length; ++i) //计算后面的周期数据
    {
      var value = data[i];
      var preValue = data[i - n]; //上一个周期的第1个数据
      if (!this.IsNumber(value)) value = 0;
      if (!this.IsNumber(preValue)) preValue = 0;

      total = total - preValue + value; //当前周期的数据 等于上一个周期数据 去掉上一个周期的第1个数据 加上这个周期的最后1个数据
      result[i] = total / n;
    }

    return result;
  };

  /*
     COVAR(X,Y,N) 返回X和Y的N周期的协方差
     */
  this.COVAR = function (data, data2, n)
  {
    var result = [];
    if (n < 1) n = 1;

    if (!Array.isArray(data) || !Array.isArray(data2)) return result;

    var dataAverage = this.CalculateAverage(data, n);
    var data2Average = this.CalculateAverage(data2, n);

    var count = Math.max(data.length, data2.length);

    var count = Math.max(data.length, data2.length);
    for (var i = 0, j = 0; i < count; ++i)
    {
      result[i] = null;

      if (i >= data.length || i >= data2.length || i >= dataAverage.length || i >= data2Average.length) continue;

      var average = dataAverage[i];
      var average2 = data2Average[i];

      var total = 0;
      for (j = i - n + 1; j <= i; ++j)
      {
        total += (data[j] - average) * (data2[j] - average2);
      }

      result[i] = total / n;
    }

    return result;
  };

  /*
     求上一高点到当前的周期数.
     用法:
     HHVBARS(X,N):求N周期内X最高值到当前周期数,N=0表示从第一个有效值开始统计
     例如:
     HHVBARS(HIGH,0)求得历史新高到到当前的周期数
     */
  this.HHVBARS = function (data, n)
  {
    var result = [];
    if (!Array.isArray(data)) return result;
    if (Array.isArray(n))
    {
      for (var i = 0; i < n.length; ++i)
      {
        result[i] = null;
        var period = n[i];
        if (!this.IsNumber(period)) continue;

        var start = i - period;
        if (start < 0) start = 0;
        var nMax = null;
        var j = start;
        for (; j < data.length; ++j)
        {
          if (this.IsNumber(data[j]))
          {
            nMax = j;
            break;
          }
        }

        for (var k = 0; j < data.length && k < period; ++k, ++j)
        {
          if (data[j] >= data[nMax]) nMax = j;
        }

        if (nMax != null)
        result[i] = i - nMax;
      }
    } else

    {
      if (n < 1) n = data.length;

      var nMax = null; //最大值索引
      for (var i = 0; i < data.length; ++i)
      {
        result[i] = null;
        if (this.IsNumber(data[i])) {
          nMax = i;
          break;
        }
      }

      var j = 0;
      for (i = nMax + 1; i < data.length && j < n; ++i, ++j) //求第1个最大值
      {
        if (data[i] >= data[nMax]) nMax = i;
        if (n == data.length) result[i] = i - nMax;
      }

      for (; i < data.length; ++i)
      {
        if (i - nMax < n)
        {
          if (data[i] >= data[nMax]) nMax = i;
        } else

        {
          nMax = i - n + 1;
          for (j = nMax; j <= i; ++j) //计算区间最大值
          {
            if (data[j] >= data[nMax]) nMax = j;
          }
        }

        result[i] = i - nMax;
      }
    }

    return result;
  };

  /*
     求上一低点到当前的周期数.
     用法: LLVBARS(X,N):求N周期内X最低值到当前周期数,N=0表示从第一个有效值开始统计
     例如: LLVBARS(HIGH,20)求得20日最低点到当前的周期数
     */
  this.LLVBARS = function (data, n)
  {
    var result = [];
    if (!Array.isArray(data)) return result;
    if (Array.isArray(n))
    {
      for (var i = 0; i < n.length; ++i)
      {
        result[i] = null;
        var period = n[i];
        if (!this.IsNumber(period)) continue;

        var start = i - period;
        if (start < 0) start = 0;
        var nMin = null;
        var j = start;
        for (; j < data.length; ++j)
        {
          if (this.IsNumber(data[j]))
          {
            nMin = j;
            break;
          }
        }

        for (var k = 0; j < data.length && k < period; ++k, ++j)
        {
          if (data[j] <= data[nMin]) nMin = j;
        }

        if (nMin != null)
        result[i] = i - nMin;
      }
    } else

    {
      if (n < 1) n = data.length;

      var nMin = null; //最小值索引
      for (var i = 0; i < data.length; ++i)
      {
        result[i] = null;
        if (this.IsNumber(data[i]))
        {
          nMin = i;
          break;
        }
      }

      var j = 0;
      for (i = nMin + 1; i < data.length && j < n; ++i, ++j) //求第1个最大值
      {
        if (data[i] <= data[nMin]) nMin = i;
        if (n == data.length) result[i] = i - nMin;
      }

      for (; i < data.length; ++i)
      {
        if (i - nMin < n)
        {
          if (data[i] <= data[nMin]) nMin = i;
        } else

        {
          nMin = i - n + 1;
          for (j = nMin; j <= i; ++j) //计算区间最小值
          {
            if (data[j] <= data[nMin]) nMin = j;
          }
        }

        result[i] = i - nMin;
      }
    }

    return result;
  };

  /*
     β(Beta)系数
     BETA(N) 返回当前证券N周期收益与对应大盘指数收益相比的贝塔系数
     需要下载上证指数历史数据
     涨幅(X)=(现价-上一个交易日收盘价）/上一个交易日收盘价
     公式=股票和指数协方差/股票方差
     */
  this.BETA = function (n)
  {
    var result = [];
    var stockData = this.SymbolData.Data;
    var indexData = this.SymbolData.IndexData;
    if (n <= 0) n = 1;

    var stockProfit = []; //股票涨幅
    var indexProfit = []; //指数涨幅

    for (var _i35 = 0; _i35 < stockData.Data.length; ++_i35)
    {
      stockProfit[_i35] = 0;
      indexProfit[_i35] = 0;

      var stockItem = stockData.Data[_i35];
      var indexItem = indexData.Data[_i35];

      if (stockItem.Close > 0 && stockItem.YClose > 0) stockProfit[_i35] = (stockItem.Close - stockItem.YClose) / stockItem.YClose;
      if (indexItem.Close > 0 && indexItem.YClose > 0) indexProfit[_i35] = (indexItem.Close - indexItem.YClose) / indexItem.YClose;
    }

    //计算均值数组
    var averageStockProfit = this.CalculateAverage(stockProfit, n);
    var averageIndexProfit = this.CalculateAverage(indexProfit, n);

    for (var i = 0, j = 0; i < stockData.Data.length; ++i)
    {
      result[i] = null;
      if (i >= stockProfit.length || i >= indexProfit.length || i >= averageStockProfit.length || i >= averageIndexProfit.length) continue;

      var averageStock = averageStockProfit[i];
      var averageIndex = averageIndexProfit[i];

      var covariance = 0; //协方差
      var variance = 0; //方差
      for (j = i - n + 1; j <= i; ++j)
      {
        var value = indexProfit[j] - averageIndex;
        var value2 = stockProfit[j] - averageStock;
        covariance += value * value2;
        variance += value * value;
      }

      if (this.IsDivideNumber(variance) && this.IsNumber(covariance))
      result[i] = covariance / variance; //(covariance/n)/(variance/n)=covariance/variance;
    }

    return result;
  };

  /*
     用法:BETA2(X,Y,N)为X与Y的N周期相关放大系数,表示Y变化1%,则X将变化N%
     例如:BETA2(CLOSE,INDEXC,10)表示收盘价与大盘指数之间的10周期相关放大率
     */
  this.BETA2 = function (x, y, n)
  {
    var result = [];
    if (n <= 0) n = 1;

    var xProfit = [null]; //x数据的涨幅
    var yProfit = [null]; //y数据的涨幅

    var count = Math.max(x.length, y.length);

    var lastItem = { X: x[0], Y: y[0] };
    for (var i = 1; i < count; ++i)
    {
      xProfit[i] = 0;
      yProfit[i] = 0;

      var xItem = x[i];
      var yItem = y[i];

      if (lastItem.X > 0) xProfit[i] = (xItem - lastItem.X) / lastItem.X;
      if (lastItem.Y > 0) yProfit[i] = (yItem - lastItem.Y) / lastItem.Y;

      lastItem = { X: xItem, Y: yItem };
    }

    //计算均值数组
    var averageXProfit = this.CalculateAverage(xProfit, n);
    var averageYProfit = this.CalculateAverage(yProfit, n);

    for (var i = 0, j = 0; i < count; ++i)
    {
      result[i] = null;

      if (i >= xProfit.length || i >= yProfit.length || i >= averageXProfit.length || i >= averageYProfit.length) continue;

      var averageX = averageXProfit[i];
      var averageY = averageYProfit[i];

      var covariance = 0; //协方差
      var variance = 0; //方差
      for (j = i - n + 1; j <= i; ++j)
      {
        var value = xProfit[j] - averageX;
        var value2 = yProfit[j] - averageY;
        covariance += value * value2;
        variance += value * value;
      }

      if (this.IsDivideNumber(variance) && this.IsNumber(covariance))
      result[i] = covariance / variance; //(covariance/n)/(variance/n)=covariance/variance;
    }

    return result;
  };

  /*
     抛物转向.
     用法:
     SAR(N,S,M),N为计算周期,S为步长,M为极值
     例如:
     SAR(10,2,20)表示计算10日抛物转向,步长为2%,极限值为20%
     */
  this.SAR = function (n, step, exValue)
  {
    var result = [];
    var stockData = this.SymbolData.Data;
    if (n >= stockData.Data.length) return result;

    var high = null,low = null;
    for (var i = 0; i < n; ++i)
    {
      var item = stockData.Data[i];
      if (high == null) high = item.High;else
      if (high < item.High) high = item = high;
      if (low == null) low = item.Low;else
      if (low > item.Low) low = item.Low;
    }

    var SAR_LONG = 0,SAR_SHORT = 1;
    var position = SAR_LONG;
    result[n - 1] = low;
    var nextSar = low,sip = stockData.Data[0].High,af = exValue / 100;
    for (var i = n; i < stockData.Data.length; ++i)
    {
      var ysip = sip;
      var item = stockData.Data[i];
      var yitem = stockData.Data[i - 1];

      if (position == SAR_LONG)
      {
        if (item.Low < result[i - 1])
        {
          position = SAR_SHORT;
          sip = item.Low;
          af = step / 100;
          nextSar = Math.max(item.High, yitem.High);
          nextSar = Math.max(nextSar, ysip + af * (sip - ysip));
        } else

        {
          position = SAR_LONG;
          if (item.High > ysip)
          {
            sip = item.High;
            af = Math.min(af + step / 100, exValue / 100);
          }
          nextSar = Math.min(item.Low, yitem.Low);
          nextSar = Math.min(nextSar, result[i - 1] + af * (sip - result[i - 1]));
        }
      } else
      if (position == SAR_SHORT)
      {
        if (item.High > result[i - 1])
        {
          position = SAR_LONG;
          sip = item.High;
          af = step / 100;
          nextSar = Math.min(item.Low, yitem.Low);
          nextSar = Math.min(nextSar, result[i - 1] + af * (sip - ysip));
        } else

        {
          position = SAR_SHORT;
          if (item.Low < ysip)
          {
            sip = item.Low;
            af = Math.min(af + step / 100, exValue / 100);
          }
          nextSar = Math.max(item.High, yitem.High);
          nextSar = Math.max(nextSar, result[i - 1] + af * (sip - result[i - 1]));
        }
      }

      result[i] = nextSar;
    }

    return result;
  };

  /*
     抛物转向点.
     用法:
     SARTURN(N,S,M),N为计算周期,S为步长,M为极值,若发生向上转向则返回1,若发生向下转向则返回-1,否则为0
     其用法与SAR函数相同
     */
  this.SARTURN = function (n, step, exValue)
  {
    var result = [];
    var sar = this.SAR(n, step, exValue);
    var stockData = this.SymbolData.Data;
    var index = 0;
    for (index = 0; index < sar.length; ++index)
    {
      if (this.IsNumber(sar[index])) break;
    }
    var flag = 0;
    if (index < stockData.Data.length) flag = stockData.Data[index].Close > sar[index];

    for (var i = index + 1; i < stockData.Data.length; ++i)
    {
      var item = stockData.Data[i];
      if (item.Close < sar[i] && flag) result[i] = -1;else
      result[i] = item.Close > sar[i] && !flag ? 1 : 0;

      flag = item.Close > sar[i];
    }

    return result;
  };

  /*
     属于未来函数,将当前位置到若干周期前的数据设为1.
     用法:
     BACKSET(X,N),若X非0,则将当前位置到N周期前的数值设为1.
     例如:
     BACKSET(CLOSE>OPEN,2)若收阳则将该周期及前一周期数值设为1,否则为0
     */
  this.BACKSET = function (condition, n)
  {
    var result = [];
    if (!condition) return result;
    var dataCount = condition.length;
    if (!this.IsNumber(dataCount) || dataCount <= 0) return result;
    if (Array.isArray(n))
    {
      for (var i = 0; i < dataCount; ++i) //初始化0
      {
        result[i] = 0;
      }

      for (var i = 0; i < dataCount; ++i)
      {
        var value = condition[i];
        var period = n[i];
        if (this.IsNumber(value) && value && this.IsNumber(period))
        {
          for (var j = i, k = 0; j >= 0 && k < period; --j, ++k)
          {
            result[j] = 1;
          }
        }
      }
    } else

    {
      for (var i = 0; i < dataCount; ++i) //初始化0
      {
        result[i] = 0;
      }

      for (var pos = 0; pos < dataCount; ++pos)
      {
        if (this.IsNumber(condition[pos])) break;
      }
      if (pos == dataCount) return result;

      var num = Math.min(dataCount - pos, Math.max(n, 1));

      for (var i = dataCount - 1, j = 0; i >= 0; --i)
      {
        var value = condition[i];
        if (this.IsNumber(value) && value)
        {
          for (j = i; j > i - num; --j)
          {
            result[j] = 1;
          }
        }
      }

      if (condition[i])
      {
        for (j = i; j >= pos; --j) {result[j] = 1;}
      }
    }

    return result;
  };

  //STRCAT(A,B):将两个字符串A,B(非序列化)相加成一个字符串C.
  //用法: STRCAT('多头','开仓')将两个字符串'多头','开仓'相加成一个字符串'多头开仓'
  this.STRCAT = function (str1, str2)
  {
    var result = [];
    if (this.IsString(str1) && this.IsString(str2))
    result = str1 + str2;
    return result;
  };

  //VARCAT(A,B):将两个字符串A,B相加成一个字符串C.
  //用法: DRAWTEXT(CLOSE>OPEN,LOW,VARCAT('多头',VAR2STR(C,2))) 将两个字符串相加成一个字符串并按条件显示出来
  this.VARCAT = function (data, data2)
  {
    var result = [];
    if (Array.isArray(data) && Array.isArray(data2))
    {
      var nCount = Math.max(data.length, data2.length);
      var strValue = "";
      for (var i = 0; i < nCount; ++i)
      {
        result[i] = null;
        strValue = "";
        if (i < data.length)
        {
          var item = data[i];
          if (this.IsString(item))
          strValue += item;
        }

        if (i < data2.length)
        {
          var item = data2[i];
          if (this.IsString(item))
          strValue += item;
        }

        if (strValue != "")
        result[i] = strValue;
      }
    } else
    if (this.IsString(data) && Array.isArray(data2))
    {
      for (var i = 0; i < data2.length; ++i)
      {
        result[i] = null;
        var item = data2[i];
        if (this.IsString(item))
        {
          result[i] = data + item;
        }
      }
    } else
    if (Array.isArray(data) && this.IsString(data2))
    {
      for (var i = 0; i < data.length; ++i)
      {
        result[i] = null;
        var item = data[i];
        if (this.IsString(item))
        {
          result[i] = item + data2;
        }
      }
    } else
    if (this.IsString(data) && this.IsString(data2))
    {
      result = data + data2;
    }

    return result;
  };

  //STRSPACE(A):字符串附带一空格
  this.STRSPACE = function (data)
  {
    var result = [];
    if (Array.isArray(data))
    {
      for (var i = 0; i < data.length; ++i)
      {
        result[i] = null;
        var item = data[i];
        if (TouchList.IsString(item))
        result[i] = item + ' ';
      }
    } else

    {
      if (this.IsString(data))
      result = data + " ";
    }

    return result;
  };

  //CON2STR(A,N):取A最后的值(非序列值)转为字符串,小数位数N.
  //用法: CON2STR(FINANCE(20),3)表示取营业收入,以3位小数转为字符串
  this.CON2STR = function (data, n)
  {
    var result = [];
    if (Array.isArray(data))
    {
      for (var i = data.length - 1; i >= 0; --i)
      {
        var item = data[i];
        if (this.IsNumber(item))
        {
          result = item.toFixed(n);
          return result;
        }
      }
    } else

    {
      if (this.IsNumber(data))
      result = data.toFixed(n);
    }

    return result;
  };

  //VAR2STR(A,N):取A的每一个值转为字符串,小数位数N.
  //用法: VAR2STR(C,3)表示取收盘价,以3位小数转为字符串
  this.VAR2STR = function (data, n)
  {
    var result = [];
    if (Array.isArray(data))
    {
      for (var i = 0; i < data.length; ++i)
      {
        result[i] = null;
        var item = data[i];
        if (this.IsNumber(item))
        result[i] = item.toFixed(n);
      }
    } else

    {
      if (this.IsNumber(data))
      result = data.toFixed(n);
    }

    return result;
  };

  this.ZTPRICE = function (data, rate)
  {
    if (!this.IsNumber(rate)) return null;

    if (Array.isArray(data))
    {
      var result = [];
      for (var i in data)
      {
        var item = data[i];
        if (this.IsNumber(item)) result[i] = (1 + rate) * item;else
        result[i] = null;
      }

      return result;
    } else
    if (this.IsNumber(data))
    {
      var result = (1 + rate) * data;
      return result;
    }
  };

  this.DTPRICE = function (data, rate)
  {
    if (!this.IsNumber(rate)) return null;

    if (Array.isArray(data))
    {
      var result = [];
      for (var i in data)
      {
        var item = data[i];
        if (this.IsNumber(item)) result[i] = (1 - rate) * item;else
        result[i] = null;
      }

      return result;
    } else
    if (this.IsNumber(data))
    {
      var result = (1 - rate) * data;
      return result;
    }

  };

  /*
     FRACPART(A)	 取得小数部分
     含义:FRACPART(A)返回数值的小数部分
     阐释:例如FRACPART(12.3)求得0.3,FRACPART(-3.5)求得-0.5
     */
  this.FRACPART = function (data)
  {
    if (Array.isArray(data))
    {
      var result = [];
      var integer = 0;
      for (var i in data)
      {
        var item = data[i];
        if (this.IsNumber(item))
        {
          integer = parseInt(item);
          result[i] = item - integer;
        } else
        result[i] = null;
      }

      return result;
    } else
    if (this.IsNumber(data))
    {
      integer = parseInt(data);
      var result = data - integer;
      return result;
    }
  };

  /*
     统计连续满足条件的周期数.
     用法: BARSLASTCOUNT(X),统计连续满足X条件的周期数.
     例如: BARSLASTCOUNT(CLOSE>OPEN)表示统计连续收阳的周期数
     */
  this.BARSLASTCOUNT = function (data)
  {
    var result = null;
    if (Array.isArray(data))
    {
      result = [];
      if (data.length > 0)
      {
        var count = 0;
        for (var i = data.length - 1; i >= 0; --i)
        {
          count = 0;
          for (var j = i; j >= 0; --j)
          {
            if (data[j]) ++count;else
            break;
          }
          result[i] = count;
        }
      }
    } else

    {
      if (data) result = 1;else
      result = 0;
    }
    return result;
  };

  //取整.
  //用法: INTPART(A)返回沿A绝对值减小方向最接近的整数
  //例如:INTPART(12.3)求得12,INTPART(-3.5)求得-3
  this.INTPART = function (data)
  {
    var result = null;
    if (Array.isArray(data))
    {
      result = [];
      for (var i in data)
      {
        var item = data[i];
        if (this.IsNumber(item)) result[i] = parseInt(item);else
        result[i] = null;
      }
    } else
    if (this.IsNumber(data))
    {
      result = parseInt(data);
    }

    return result;
  };

  //函数调用
  this.CallFunction = function (name, args, node)
  {
    switch (name) {

      case 'MAX':
        return this.MAX(args[0], args[1]);
      case 'MIN':
        return this.MIN(args[0], args[1]);
      case 'REF':
        return this.REF(args[0], args[1]);
      case "REFV":
        return this.REFV(args[0], args[1]);
      case 'REFX':
        return this.REFX(args[0], args[1]);
      case "REFXV":
        return this.REFXV(args[0], args[1]);
      case 'ABS':
        return this.ABS(args[0]);
      case 'MA':
        return this.MA(args[0], args[1]);
      case "EMA":
        return this.EMA(args[0], args[1]);
      case "SMA":
        return this.SMA(args[0], args[1], args[2]);
      case "DMA":
        return this.DMA(args[0], args[1]);
      case "XMA":
        return this.XMA(args[0], args[1]);
      case 'EXPMA':
        return this.EXPMA(args[0], args[1]);
      case 'EXPMEMA':
        return this.EXPMEMA(args[0], args[1]);
      case 'COUNT':
        return this.COUNT(args[0], args[1]);
      case 'LLV':
        return this.LLV(args[0], args[1]);
      case 'LLVBARS':
        return this.LLVBARS(args[0], args[1]);
      case 'HHV':
        return this.HHV(args[0], args[1]);
      case 'HHVBARS':
        return this.HHVBARS(args[0], args[1]);
      case 'MULAR':
        return this.MULAR(args[0], args[1]);
      case 'CROSS':
        return this.CROSS(args[0], args[1]);
      case 'LONGCROSS':
        return this.LONGCROSS(args[0], args[1], args[2]);
      case 'AVEDEV':
        return this.AVEDEV(args[0], args[1]);
      case 'STD':
        return this.STD(args[0], args[1]);
      case 'IF':
      case 'IFF':
        return this.IF(args[0], args[1], args[2]);
      case 'IFN':
        return this.IFN(args[0], args[1], args[2]);
      case 'NOT':
        return this.NOT(args[0]);
      case 'SUM':
        return this.SUM(args[0], args[1]);
      case 'RANGE':
        return this.RANGE(args[0], args[1], args[2]);
      case 'EXIST':
        return this.EXIST(args[0], args[1]);
      case 'EXISTR':
        return this.EXISTR(args[0], args[1], args[2]);
      case 'FILTER':
        return this.FILTER(args[0], args[1]);
      case 'TFILTER':
        return this.TFILTER(args[0], args[1], args[2]);
      case 'SLOPE':
        return this.SLOPE(args[0], args[1]);
      case 'BARSLAST':
        return this.BARSLAST(args[0]);
      case 'BARSCOUNT':
        return this.BARSCOUNT(args[0]);
      case 'BARSSINCEN':
        return this.BARSSINCEN(args[0], args[1]);
      case 'BARSSINCE':
        return this.BARSSINCE(args[0]);
      case 'LAST':
        return this.LAST(args[0], args[1], args[2]);
      case 'EVERY':
        return this.EVERY(args[0], args[1]);
      case 'ZIG':
        return this.ZIG(args[0], args[1]);
      case 'TROUGHBARS':
        return this.TROUGHBARS(args[0], args[1], args[2]);
      case "TROUGH":
        return this.TROUGH(args[0], args[1], args[2]);
      case 'PEAKBARS':
        return this.PEAKBARS(args[0], args[1], args[2]);
      case 'PEAK':
        return this.PEAK(args[0], args[1], args[2]);
      case 'COST':
        return this.COST(args[0], node);
      case 'WINNER':
        return this.WINNER(args[0], node);
      case 'UPNDAY':
        return this.UPNDAY(args[0], args[1]);
      case 'DOWNNDAY':
        return this.DOWNNDAY(args[0], args[1]);
      case 'NDAY':
        return this.NDAY(args[0], args[1], args[2]);
      case 'DEVSQ':
        return this.DEVSQ(args[0], args[1]);
      case 'FORCAST':
        return this.FORCAST(args[0], args[1]);
      case 'STDP':
        return this.STDP(args[0], args[1]);
      case 'VAR':
        return this.VAR(args[0], args[1]);
      case 'VARP':
        return this.VARP(args[0], args[1]);
      case 'RELATE':
        return this.RELATE(args[0], args[1], args[2]);
      case 'COVAR':
        return this.COVAR(args[0], args[1], args[2]);
      case 'BETA':
        return this.BETA(args[0]);
      case 'BETA2':
        return this.BETA2(args[0], args[1], args[2]);
      case 'WMA':
        return this.WMA(args[0], args[1]);
      case 'MEMA':
        return this.MEMA(args[0], args[1]);
      case 'SUMBARS':
        return this.SUMBARS(args[0], args[1]);
      case 'REVERSE':
        return this.REVERSE(args[0]);
      case 'SAR':
        return this.SAR(args[0], args[1], args[2]);
      case 'SARTURN':
        return this.SARTURN(args[0], args[1], args[2]);
      case 'BACKSET':
        return this.BACKSET(args[0], args[1]);
      case 'STRCAT':
        return this.STRCAT(args[0], args[1]);
      case "VARCAT":
        return this.VARCAT(args[0], args[1]);
      case "VAR2STR":
        return this.VAR2STR(args[0], args[1]);
      case 'CON2STR':
        return this.CON2STR(args[0], args[1]);
      case "STRSPACE":
        return this.STRSPACE(args[0]);
      case 'DTPRICE':
        return this.DTPRICE(args[0], args[1]);
      case 'ZTPRICE':
        return this.ZTPRICE(args[0], args[1]);
      case 'FRACPART':
        return this.FRACPART(args[0]);
      case 'BARSLASTCOUNT':
        return this.BARSLASTCOUNT(args[0]);
      case 'INTPART':
        return this.INTPART(args[0]);
      //三角函数
      case 'ATAN':
        return this.Trigonometric(args[0], Math.atan);
      case 'ACOS':
        return this.ACOS(args[0]);
      case 'ASIN':
        return this.ASIN(args[0]);
      case 'COS':
        return this.Trigonometric(args[0], Math.cos);
      case 'SIN':
        return this.Trigonometric(args[0], Math.sin);
      case 'TAN':
        return this.Trigonometric(args[0], Math.tan);
      case 'LN':
        return this.Trigonometric(args[0], Math.log);
      case 'LOG':
        return this.Trigonometric(args[0], Math.log10);
      case 'EXP':
        return this.Trigonometric(args[0], Math.exp);
      case 'SQRT':
        return this.Trigonometric(args[0], Math.sqrt);
      default:
        this.ThrowUnexpectedNode(node, '函数' + name + '不存在');}

  };

  //调用自定义函数 返回数据格式{Out:输出数据, Draw:绘图数据(可选)}
  this.CallCustomFunction = function (name, args, symbolData, node)
  {
    var functionInfo = g_JSComplierResource.CustomFunction.Data.get(name);
    var dwonloadData = symbolData.GetStockCacheData({ CustomName: name, Node: node });
    if (!functionInfo.Invoke)
    return { Out: dwonloadData };

    _umychartConsoleWechat.JSConsole.Complier.Log('[JSAlgorithm::CallCustomFunction] call custom function functionInfo=', functionInfo);

    var self = this;
    var obj =
    {
      Name: name,
      Args: args,
      Symbol: symbolData.Symbol, Period: symbolData.Period, Right: symbolData.Right,
      KData: symbolData.Data, //K线数据
      DownloadData: dwonloadData,
      ThrowError: function ThrowError(error)
      {
        self.ThrowUnexpectedNode(node, error);
      } };


    return functionInfo.Invoke(obj);
  };

  this.ThrowUnexpectedNode = function (node, message)
  {
    var marker = node.Marker;
    var msg = message || "执行异常";

    return this.ErrorHandler.ThrowError(marker.Index, marker.Line, marker.Column, msg);

  };
}

//是否有是有效的数字
JSAlgorithm.prototype.IsNumber = function (value)
{
  if (value == null) return false;
  if (isNaN(value)) return false;

  return true;
};

//是否是整形
JSAlgorithm.prototype.IsInteger = function (x)
{
  return typeof x === 'number' && x % 1 === 0;
};


//是否有是有效的除数
JSAlgorithm.prototype.IsDivideNumber = function (value)
{
  if (value == null) return false;
  if (isNaN(value)) return false;
  if (value == 0) return false;

  return true;
};

//是否是字符串
JSAlgorithm.prototype.IsString = function (value)
{
  if (value && typeof value == 'string') return true;
  return false;
};

/*
      绘图函数 
   */
function JSDraw(errorHandler, symbolData)
{
  this.ErrorHandler = errorHandler;
  this.SymbolData = symbolData;

  this.DRAWTEXT = function (condition, price, text)
  {
    var drawData = [];
    var result = { DrawData: drawData, DrawType: 'DRAWTEXT', Text: text };

    if (Array.isArray(condition))
    {
      var IsNumber = this.IsNumber(price);
      for (var i in condition)
      {
        drawData[i] = null;

        if (isNaN(condition[i]) || !condition[i]) continue;

        if (IsNumber)
        {
          drawData[i] = price;
        } else

        {
          if (this.IsNumber(price[i])) drawData[i] = price[i];
        }
      }
    } else
    if (this.IsNumber(condition) && condition)
    {
      var IsNumber = this.IsNumber(price);
      for (var i = 0; i < this.SymbolData.Data.Data.length; ++i)
      {
        if (IsNumber) drawData[i] = price;else
        if (this.IsNumber(price[i])) drawData[i] = price[i];
      }
    }



    return result;
  };

  this.DRAWTEXT_FIX = function (condition, x, y, type, text)
  {
    var result = { Position: null, DrawType: 'DRAWTEXT_FIX', Text: text };
    if (condition.length <= 0) return result;

    for (var i in condition)
    {
      if (isNaN(condition[i]) || !condition[i]) continue;

      result.Position = { X: x, Y: y, Type: type };
      return result;
    }

    return result;
  };

  //direction 文字Y轴位置 0=middle 1=价格的顶部 2=价格的底部
  //offset 文字Y轴偏移
  this.SUPERDRAWTEXT = function (condition, price, text, direction, offset)
  {
    var drawData = [];
    var result = { DrawData: drawData, DrawType: 'SUPERDRAWTEXT', Text: text, YOffset: offset, Direction: direction, TextAlign: 'center' };
    if (condition.length <= 0) return result;

    var IsNumber = typeof price == "number";

    for (var i in condition)
    {
      drawData[i] = null;

      if (isNaN(condition[i]) || !condition[i]) continue;

      if (IsNumber)
      {
        drawData[i] = price;
      } else

      {
        if (this.IsNumber(price[i])) drawData[i] = price[i];
      }
    }

    return result;
  };

  this.STICKLINE = function (condition, data, data2, width, type)
  {
    var drawData = [];
    var result = { DrawData: drawData, DrawType: 'STICKLINE', Width: width, Type: type };

    var IsNumber = typeof data == "number";
    var IsNumber2 = typeof data2 == "number";
    if (Array.isArray(condition)) //数组
      {
        if (condition.length <= 0) return result;

        for (var i in condition)
        {
          drawData[i] = null;

          if (isNaN(condition[i]) || !condition[i]) continue;

          if (IsNumber && IsNumber2)
          {
            drawData[i] = { Value: data, Value2: data2 };
          } else
          if (IsNumber && !IsNumber2)
          {
            if (isNaN(data2[i])) continue;
            drawData[i] = { Value: data, Value2: data2[i] };
          } else
          if (!IsNumber && IsNumber2)
          {
            if (isNaN(data[i])) continue;
            drawData[i] = { Value: data[i], Value2: data2 };
          } else

          {
            if (isNaN(data[i]) || isNaN(data2[i])) continue;
            drawData[i] = { Value: data[i], Value2: data2[i] };
          }
        }
      } else

    {
      if (!condition) return result;

      for (var i = 0; i < this.SymbolData.Data.Data.length; ++i) //以K线长度为数据长度
      {
        drawData[i] = null;

        if (IsNumber && IsNumber2)
        {
          drawData[i] = { Value: data, Value2: data2 };
        } else
        if (IsNumber && !IsNumber2)
        {
          if (!this.IsNumber(data2[i])) continue;
          drawData[i] = { Value: data, Value2: data2[i] };
        } else
        if (!IsNumber && IsNumber2)
        {
          if (!this.IsNumber(data[i])) continue;
          drawData[i] = { Value: data[i], Value2: data2 };
        } else

        {
          if (!this.IsNumber(data[i]) || !this.IsNumber(data2[i])) continue;
          drawData[i] = { Value: data[i], Value2: data2[i] };
        }
      }
    }



    return result;
  };

  /*
     DRAWLINE 绘制直线段
     在图形上绘制直线段。
     用法：　DRAWLINE(COND1，PRICE1，COND2，PRICE2，EXPAND)
     当COND1条件满足时，在PRICE1位置画直线起点，当COND2条件满足时，在PRICE2位置画直线终点，EXPAND为延长类型。
     例如：　DRAWLINE(HIGH>=HHV(HIGH,20),HIGH,LOW<=LLV(LOW,20),LOW,1)　表示在创20天新高与创20天新低之间画直线并且向右延长。
     */
  this.DRAWLINE = function (condition, data, condition2, data2, expand)
  {
    var drawData = [];
    var result = { DrawData: drawData, DrawType: 'DRAWLINE', Expand: expand };

    if (condition.length <= 0) return result;
    var count = Math.max(condition.length, condition2.length);

    var bFirstPoint = false;
    var bSecondPont = false;
    var lineCache = { Start: {}, End: {}, List: new Array() };

    for (var _i36 = 0; _i36 < count; ++_i36)
    {
      drawData[_i36] = null;
      if (_i36 < condition.length && _i36 < condition2.length)
      {
        if (bFirstPoint == false && bSecondPont == false)
        {
          if (condition[_i36] == null || !condition[_i36]) continue;

          bFirstPoint = true;
          lineCache.Start = { ID: _i36, Value: data[_i36] }; //第1个点
        } else
        if (bFirstPoint == true && bSecondPont == false)
        {
          var bCondition2 = condition2[_i36] != null && condition2[_i36]; //条件2
          if (!bCondition2) continue;

          if (bCondition2)
          {
            bSecondPont = true;
            lineCache.End = { ID: _i36, Value: data2[_i36] }; //第2个点
          }
        }

        if (bFirstPoint == true && bSecondPont == true) //2个点都有了, 等待下一次的点出现
          {
            var lineData = this.CalculateDrawLine(lineCache); //计算2个点的线上 其他点的数值

            for (var j in lineData)
            {
              var _item2 = lineData[j];
              drawData[_item2.ID] = _item2.Value;
            }

            bFirstPoint = bSecondPont = false;
            lineCache = { Start: {}, End: {} };
          }
      }
    }
    if (expand == 1) //右延长线
      {
        var x2 = null;
        for (var i = drawData.length - 1; i >= 0; --i)
        {
          if (this.IsNumber(drawData[i]))
          {
            x2 = i;
            break;
          }
        }
        //y3=(y1-y2)*(x3-x1)/(x2-x1)
        if (x2 != null && x2 - 1 >= 0)
        {
          var x1 = x2 - 1;
          for (var i = x2 + 1; i < drawData.length; ++i)
          {
            var y1 = drawData[x1];
            var y2 = drawData[x2];
            var y3 = (y1 - y2) * (i - x1) / (x2 - x1);
            drawData[i] = y1 - y3;
          }
        }
      }

    return result;
  };

  /*
     画出带状线.
     用法: DRAWBAND(VAL1,COLOR1,VAL2,COLOR2),当VAL1>VAL2时,在VAL1和VAL2之间填充COLOR1;当VAL1<VAL2时,填充COLOR2,这里的颜色均使用RGB函数计算得到.
     例如: DRAWBAND(OPEN,RGB(0,224,224),CLOSE,RGB(255,96,96));
     */
  this.DRAWBAND = function (data, color, data2, color2)
  {
    var drawData = [];
    var result = { DrawData: drawData, DrawType: 'DRAWBAND', Color: [color.toLowerCase(), color2.toLowerCase()] };
    var count = Math.max(data.length, data2.length);

    for (var i = 0; i < count; ++i)
    {
      var _item3 = { Value: null, Value2: null };
      if (i < data.length) _item3.Value = data[i];
      if (i < data2.length) _item3.Value2 = data2[i];

      drawData.push(_item3);
    }

    return result;
  };

  this.DRAWKLINE = function (high, open, low, close)
  {
    var drawData = [];
    var result = { DrawData: drawData, DrawType: 'DRAWKLINE' };
    var count = Math.max(high.length, open.length, low.length, close.length);

    for (var i = 0; i < count; ++i)
    {
      var _item4 = { Open: null, High: null, Low: null, Close: null };

      if (i < high.length && i < open.length && i < low.length && i < close.length)
      {
        _item4.Open = open[i];
        _item4.High = high[i];
        _item4.Low = low[i];
        _item4.Close = close[i];
      }

      drawData[i] = _item4;
    }

    return result;
  };

  //满足条件画一根K线
  this.DRAWKLINE_IF = function (condition, high, open, low, close)
  {
    var drawData = [];
    var result = { DrawData: drawData, DrawType: 'DRAWKLINE_IF' };
    var count = Math.max(condition.length, high.length, open.length, low.length, close.length);

    for (var i = 0; i < count; ++i) {
      var _item5 = { Open: null, High: null, Low: null, Close: null };

      if (i < high.length && i < open.length && i < low.length && i < close.length && i < condition.length)
      {
        if (condition[i])
        {
          _item5.Open = open[i];
          _item5.High = high[i];
          _item5.Low = low[i];
          _item5.Close = close[i];
        }
      }

      drawData[i] = _item5;
    }

    return result;
  };

  /*
     PLOYLINE 折线段
     在图形上绘制折线段。
     用法：　PLOYLINE(COND，PRICE)，当COND条件满足时，以PRICE位置为顶点画折线连接。
     例如：　PLOYLINE(HIGH>=HHV(HIGH,20),HIGH)表示在创20天新高点之间画折线。
     */
  this.POLYLINE = function (condition, data)
  {
    var drawData = [];
    var result = { DrawData: drawData, DrawType: 'POLYLINE' };
    var isNumber = typeof data == 'number';

    var bFirstPoint = false;
    var bSecondPont = false;
    if (isNumber)
    {
      for (var i in condition)
      {
        drawData[i] = null;
        if (bFirstPoint == false)
        {
          if (!condition[i]) continue;

          drawData[i] = data;
          bFirstPoint = true;
        } else
        {
          drawData[i] = data;
        }
      }
    } else

    {
      var lineCache = { Start: {}, End: {}, List: new Array() };
      for (var _i37 in condition)
      {
        drawData[_i37] = null;
        if (bFirstPoint == false && bSecondPont == false)
        {
          if (condition[_i37] == null || !condition[_i37]) continue;
          if (_i37 >= data.length || !this.IsNumber(data[_i37])) continue;

          bFirstPoint = true;
          lineCache.Start = { ID: parseInt(_i37), Value: data[_i37] }; //第1个点
        } else
        if (bFirstPoint == true && bSecondPont == false)
        {
          if (condition[_i37] == null || !condition[_i37]) continue;
          if (_i37 >= data.length || !this.IsNumber(data[_i37])) continue;

          lineCache.End = { ID: parseInt(_i37), Value: data[_i37] }; //第2个点
          //根据起始点和结束点 计算中间各个点的数据
          var lineData = this.CalculateDrawLine(lineCache); //计算2个点的线上 其他点的数值

          for (var j in lineData)
          {
            var _item6 = lineData[j];
            drawData[_item6.ID] = _item6.Value;
          }

          var start = { ID: lineCache.End.ID, Value: lineCache.End.Value };
          lineCache = { Start: start, End: {} };
        }
      }
    }

    return result;
  };

  /*
     画出数字.
     用法:
     DRAWNUMBER(COND,PRICE,NUMBER),当COND条件满足时,在PRICE位置书写数字NUMBER.
     例如:
     DRAWNUMBER(CLOSE/OPEN>1.08,LOW,C)表示当日实体阳线大于8%时在最低价位置显示收盘价.
     */
  this.DRAWNUMBER = function (condition, data, data2)
  {
    var drawData = { Value: new Array(), Text: new Array() };
    var result = { DrawData: drawData, DrawType: 'DRAWNUMBER' };
    var isArrayData = Array.isArray(data);
    var isNumber = typeof data2 == 'number';
    var text;
    if (isNumber)
    {
      if (this.IsInteger(data2)) text = data2.toString();else
      text = data2.toFixed(2);
    }

    for (var i in condition)
    {
      drawData.Value[i] = null;
      if (!condition[i]) continue;
      if (isArrayData)
      {
        if (i >= data.length || !this.IsNumber(data[i])) continue;

        if (isNumber)
        {
          drawData.Value[i] = data[i];
          drawData.Text[i] = text;
        } else

        {
          if (i >= data2.length || !data2[i]) continue;
          drawData.Value[i] = data[i];
          if (typeof data2[i] == 'number')
          drawData.Text[i] = data2[i].toFixed(2);else

          drawData.Text[i] = data2[i].toString();
        }
      } else
      if (this.IsNumber(data))
      {
        if (isNumber)
        {
          drawData.Value[i] = data;
          drawData.Text[i] = text;
        } else

        {
          if (i >= data2.length || !data2[i]) continue;
          drawData.Value[i] = data;
          if (this.IsNumber(data2[i]))
          drawData.Text[i] = data2[i].toFixed(2);else

          drawData.Text[i] = data2[i].toString();
        }
      }

    }

    return result;
  };

  /*
     在图形上绘制小图标.
     用法:
     DRAWICON(COND,PRICE,TYPE),当COND条件满足时,在PRICE位置画TYPE号图标(TYPE为1--41).
     例如:
     DRAWICON(CLOSE>OPEN,LOW,1)表示当收阳时在最低价位置画1号图标.
     */
  this.DRAWICON = function (condition, data, type)
  {
    //图标对应的字符代码
    var mapIcon = new Map([
    [1, { Symbol: '↑', Color: 'rgb(238,44,44)' }], [2, { Symbol: '↓', Color: 'rgb(0,139,69)' }],
    [3, { Symbol: '😧' }], [4, { Symbol: '😨' }], [5, { Symbol: '😁' }], [6, { Symbol: '😱' }],
    [7, { Symbol: '◼', Color: 'rgb(238,44,44)' }], [8, { Symbol: '◆', Color: 'rgb(0,139,69)' }],
    [9, { Symbol: '💰' }], [10, { Symbol: '📪' }], [11, { Symbol: '👆' }], [12, { Symbol: '👇' }],
    [13, { Symbol: 'B', Color: 'rgb(178,34,34)' }], [14, { Symbol: 'S', Color: 'rgb(0,139,69)' }],
    [36, { Symbol: 'Χ', Color: 'rgb(238,44,44)' }], [37, { Symbol: 'X', Color: 'rgb(0,139,69)' }],
    [38, { Symbol: '▲', Color: 'rgb(238,44,44)' }], [39, { Symbol: '▼', Color: 'rgb(0,139,69)' }]]);


    var icon = mapIcon.get(type);
    if (!icon) icon = { Symbol: '●', Color: 'rgb(0,139,69)' };
    var drawData = [];
    var result = { DrawData: drawData, DrawType: 'DRAWICON', Icon: icon };
    if (condition.length <= 0) return result;

    var IsNumber = typeof data == "number";
    if (typeof condition == 'number')
    {
      if (!condition) return result;

      for (var i = 0; i < this.SymbolData.Data.Data.length; ++i)
      {
        if (IsNumber)
        {
          drawData[i] = data;
        } else

        {
          if (i < data.length && this.IsNumber(data[i])) drawData[i] = data[i];else
          drawData[i] = null;
        }
      }
      return result;
    }

    for (var i in condition)
    {
      drawData[i] = null;

      if (!condition[i]) continue;

      if (IsNumber)
      {
        drawData[i] = data;
      } else

      {
        if (this.IsNumber(data[i])) drawData[i] = data[i];
      }
    }

    return result;
  };

  // 相对位置上画矩形.
  //用法: DRAWRECTREL(LEFT,TOP,RIGHT,BOTTOM,COLOR),以图形窗口(LEFT,TOP)为左上角,(RIGHT,BOTTOM)为右下角绘制矩形,坐标单位是窗口沿水平和垂直方向的1/1000,取值范围是0—999,超出范围则可能显示在图形窗口外,矩形中间填充颜色COLOR,COLOR为0表示不填充.
  //例如: DRAWRECTREL(0,0,500,500,RGB(255,255,0))表示在图形最左上部1/4位置用黄色绘制矩形
  this.DRAWRECTREL = function (left, top, right, bottom, color)
  {

    var drawData =
    {
      Rect:
      {
        Left: Math.min(left, right), Top: Math.min(top, bottom),
        Right: Math.max(left, right), Bottom: Math.max(top, bottom) },

      Color: color };

    if (color == 0) drawData.Color = null;
    var result = { DrawData: drawData, DrawType: 'DRAWRECTREL' };

    return result;
  };

  //填充背景.
  //用法: DRAWGBK(COND,COLOR1,COLOR2,colorAngle)  colorAngle=渐近色角度
  //例如: DRAWGBK(O>C,RGB(0,255,0),RGB(255,0,0),0);
  this.DRAWGBK = function (condition, color, color2, colorAngle)
  {
    var drawData = { Color: [], Angle: colorAngle };
    if (color) drawData.Color.push(color);
    if (color2) drawData.Color.push(color2);

    var result = { DrawData: null, DrawType: 'DRAWGBK' };
    if (Array.isArray(condition))
    {
      for (var i in condition)
      {
        var item = condition[i];
        if (item)
        {
          result.DrawData = drawData;
          break;
        }
      }
    } else

    {
      if (condition) result.DrawData = drawData;
    }

    return result;
  };

  this.DRAWGBK2 = function (condition, color, color2, colorAngle)
  {
    var drawData = { Color: [], Angle: colorAngle };
    if (color) drawData.Color.push(color);
    if (color2) drawData.Color.push(color2);

    var result = { DrawData: null, DrawType: 'DRAWGBK2' };
    if (Array.isArray(condition))
    {
      drawData.Data = [];
      for (var i in condition)
      {
        var item = condition[i];
        drawData.Data[i] = item ? 1 : 0;
      }

      result.DrawData = drawData;
    } else

    {
      if (condition)
      {
        result.DrawData = drawData;
        result.DrawType = "DRAWGBK";
      }
    }

    return result;
  };

  this.RGB = function (r, g, b)
  {
    var rgb = "rgb(".concat(r, ",").concat(g, ",").concat(b, ")");
    return rgb;
  };

  this.RGBA = function (r, g, b, a)
  {
    var rgba = "rgba(".concat(r, ",").concat(g, ",").concat(b, ",").concat(a, ")");
    return rgba;
  };
}


JSDraw.prototype.CalculateDrawLine = function (lineCache)
{
  lineCache.List = [];
  for (var i = lineCache.Start.ID; i <= lineCache.End.ID; ++i) {lineCache.List.push(i);}

  var height = Math.abs(lineCache.Start.Value - lineCache.End.Value);
  var width = lineCache.List.length - 1;

  var result = [];
  result.push({ ID: lineCache.Start.ID, Value: lineCache.Start.Value }); //第1个点

  if (lineCache.Start.Value > lineCache.End.Value)
  {
    for (var _i38 = 1; _i38 < lineCache.List.length - 1; ++_i38)
    {
      var value = height * (lineCache.List.length - 1 - _i38) / width + lineCache.End.Value;
      result.push({ ID: lineCache.List[_i38], Value: value });
    }
  } else

  {
    for (var _i39 = 1; _i39 < lineCache.List.length - 1; ++_i39)
    {
      var value = height * _i39 / width + lineCache.Start.Value;
      result.push({ ID: lineCache.List[_i39], Value: value });
    }
  }

  result.push({ ID: lineCache.End.ID, Value: lineCache.End.Value }); //最后一个点

  return result;
};

//是否有是有效的数字
JSDraw.prototype.IsNumber = function (value)
{
  if (value == null) return false;
  if (isNaN(value)) return false;

  return true;
};

//是否是整形
JSDraw.prototype.IsInteger = function (x)
{
  return typeof x === 'number' && x % 1 === 0;
};

JSDraw.prototype.IsDrawFunction = function (name)
{
  var setFunctionName = new Set(["STICKLINE", "DRAWTEXT", 'SUPERDRAWTEXT', "DRAWTEXT_FIX", 'DRAWLINE', 'DRAWBAND', 'DRAWKLINE', 'DRAWKLINE_IF', 'PLOYLINE', 'POLYLINE', 'DRAWNUMBER', 'DRAWICON', 'DRAWRECTREL', "DRAWGBK", "DRAWGBK2"]);
  if (setFunctionName.has(name)) return true;

  return false;
};

//http://www.newone.com.cn/helpcontroller/index?code=zszy_pc
var DYNAINFO_ARGUMENT_ID =
{
  YCLOSE: 3,
  OPEN: 4,
  HIGH: 5,
  LOW: 6,
  CLOSE: 7,
  VOL: 8,
  AMOUNT: 10,
  AMPLITUDE: 13, //振幅
  INCREASE: 14, //涨幅
  EXCHANGERATE: 37 //换手率
};

function JSSymbolData(ast, option, jsExecute)
{
  this.AST = ast; //语法树
  this.Execute = jsExecute;

  this.Symbol = '600000.sh';
  this.Name;
  this.Data = null; //个股数据
  this.SourceData = null; //不复权的个股数据
  this.MarketValue = null; //总市值
  this.Period = 0; //周期
  this.Right = 0; //复权
  this.DataType = 0; //默认K线数据 2=分钟走势图数据

  this.KLineApiUrl = g_JSComplierResource.Domain + "/API/KLine2"; //日线
  this.MinuteKLineApiUrl = g_JSComplierResource.Domain + '/API/KLine3'; //分钟K线
  this.RealtimeApiUrl = g_JSComplierResource.Domain + '/API/stock'; //实时行情
  this.StockHistoryDayApiUrl = g_JSComplierResource.Domain + '/API/StockHistoryDay'; //历史财务数据
  this.StockHistoryDay3ApiUrl = g_JSComplierResource.Domain + '/API/StockHistoryDay3'; //历史财务数据
  this.StockNewsAnalysisApiUrl = g_JSComplierResource.CacheDomain + '/cache/newsanalyze'; //新闻分析数据
  this.MaxReqeustDataCount = 1000;
  this.MaxRequestMinuteDayCount = 5;

  this.LatestData; //最新行情
  this.IndexData; //大盘指数
  this.MarginData = new Map(); //融资融券
  this.NewsAnalysisData = new Map(); //新闻统计
  this.ExtendData = new Map(); //其他的扩展数据

  //股票数据缓存 key=函数名(参数)  { Data: value=拟合的数据 , Error: } 
  //FinValue(id)
  this.StockData = new Map();

  this.NetworkFilter; //网络请求回调 function(data, callback);

  //使用option初始化
  if (option)
  {
    if (option.HQDataType) this.DataType = option.HQDataType;
    if (option.Data)
    {
      this.Data = option.Data;
      if (this.DataType != 2) //2=分钟走势图数据 没有周期和复权
        {
          this.Period = option.Data.Period; //周期
          this.Right = option.Data.Right; //复权
        }
      //this.Data=null;
    }

    if (option.SourceData) this.SourceData = option.SourceData;
    if (option.Symbol) this.Symbol = option.Symbol;
    if (option.Symbol) this.Symbol = option.Symbol;
    if (option.MaxReqeustDataCount > 0) this.MaxReqeustDataCount = option.MaxReqeustDataCount;
    if (option.MaxRequestMinuteDayCount > 0) this.MaxRequestMinuteDayCount = option.MaxRequestMinuteDayCount;
    if (option.KLineApiUrl) this.KLineApiUrl = option.KLineApiUrl;
    if (option.NetworkFilter) this.NetworkFilter = option.NetworkFilter;
  }

  //最新行情
  this.GetLatestData = function ()
  {
    if (this.LatestData) return this.Execute.RunNextJob();

    var self = this;
    wx.request({
      url: self.RealtimeApiUrl,
      data:
      {
        "field": ["name", "symbol", "yclose", "open", "price", "high", "low", "vol", "amount", "date", "time", "increase", "exchangerate", "amplitude"],
        "symbol": [this.Symbol] },

      method: "POST",
      dataType: "json",
      success: function success(recvData)
      {
        self.RecvLatestData(recvData);
        self.Execute.RunNextJob();
      },
      error: function error(request)
      {
        self.RecvError(request);
      } });

  };

  this.RecvLatestData = function (recvData)
  {
    var data = recvData.data;
    if (!data.stock || data.stock.length != 1) return;

    var stock = data.stock[0];
    this.LatestData = { Symbol: stock.symbol, Name: stock.name, Date: stock.date, Time: stock.time,
      YClose: stock.yclose, Price: stock.price, Open: stock.open, High: stock.high, Low: stock.low, Vol: stock.vol, Amount: stock.amount,
      Increase: stock.increase, Exchangerate: stock.exchangerate, Amplitude: stock.amplitude };

    _umychartConsoleWechat.JSConsole.Complier.Log('[JSSymbolData::RecvLatestData]', this.LatestData);
  };

  this.GetLatestCacheData = function (dataname)
  {
    if (!this.LatestData) return null;

    switch (dataname) {

      case DYNAINFO_ARGUMENT_ID.YCLOSE:
        return this.LatestData.YClose;
      case DYNAINFO_ARGUMENT_ID.OPEN:
        return this.LatestData.Open;
      case DYNAINFO_ARGUMENT_ID.HIGH:
        return this.LatestData.High;
      case DYNAINFO_ARGUMENT_ID.LOW:
        return this.LatestData.Low;
      case DYNAINFO_ARGUMENT_ID.VOL:
        return this.LatestData.Vol;
      case DYNAINFO_ARGUMENT_ID.AMOUNT:
        return this.LatestData.Amount;
      case DYNAINFO_ARGUMENT_ID.INCREASE:
        return this.LatestData.Increase;
      case DYNAINFO_ARGUMENT_ID.EXCHANGERATE:
        return this.LatestData.Exchangerate;
      case DYNAINFO_ARGUMENT_ID.AMPLITUDE:
        return this.LatestData.Amplitude;
      case DYNAINFO_ARGUMENT_ID.CLOSE:
        return this.LatestData.Price;
      default:
        return null;}

  };

  this.GetVolRateData = function (job, node) {
    var volrKey = job.ID.toString() + '-VolRate-' + this.Symbol;
    if (this.ExtendData.has(volrKey)) return this.Execute.RunNextJob();

    var self = this;
    wx.request({
      url: self.RealtimeApiUrl,
      data:
      {
        "field": ["name", "symbol", "avgvol5", 'date'],
        "symbol": [this.Symbol] },

      method: "POST",
      dataType: "json",
      async: true,
      success: function success(recvData)
      {
        self.RecvVolRateData(recvData, volrKey);
        self.Execute.RunNextJob();
      },
      error: function error(request)
      {
        self.RecvError(request);
      } });

  };

  this.RecvVolRateData = function (recvData, key)
  {
    var data = recvData.data;
    if (!data.stock || data.stock.length != 1) return;
    var avgVol5 = data.stock[0].avgvol5;
    var date = data.stock[0].date;
    var item = { AvgVol5: avgVol5, Date: date };
    this.ExtendData.set(key, item);

    _umychartConsoleWechat.JSConsole.Complier.Log('[JSSymbolData::RecvVolRateData]', item);
  };

  this.GetVolRateCacheData = function (node)
  {
    var key = JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_VOLR_DATA.toString() + '-VolRate-' + this.Symbol;
    if (!key || !this.ExtendData.has(key)) this.Execute.ThrowUnexpectedNode(node, '不支持VOLR');

    var result = [];
    var value = this.ExtendData.get(key);
    var avgVol5 = value.AvgVol5 / 241;
    var totalVol = 0;
    //5日成交总量只取了最新一天的,历史的暂时没有取,所以数据计算的时候只计算最新的一天, 其他都空
    for (var i = 0, j = 0; i < this.Data.Data.length; ++i)
    {
      result[i] = null;
      var item = this.Data.Data[i];
      var dateTime = item.DateTime; //日期加时间
      if (!dateTime) continue;
      var aryValue = dateTime.split(' ');
      if (aryValue.length != 2) continue;
      var date = parseInt(aryValue[0]);
      if (date != value.Date) continue;

      totalVol += item.Vol;
      if (avgVol5 > 0) result[i] = totalVol / (j + 1) / avgVol5 * 100;
      ++j;
    }

    return result;
  };

  this.GetGroupData = function (job)
  {
    var key = job.ID.toString() + '-Group-' + this.Symbol;
    if (this.ExtendData.has(key)) return this.Execute.RunNextJob();

    var self = this;

    if (this.NetworkFilter) {
      var obj =
      {
        Name: 'JSSymbolData::GetGroupData', //类名::
        Explain: 'HYBLOCK|DYBLOCK',
        Request: {
          Url: self.RealtimeApiUrl, Type: 'POST',
          Data: { symbol: [this.Symbol], field: ["name", "symbol", "industry", 'concept', 'region'] } },

        Self: this,
        PreventDefault: false };

      this.NetworkFilter(obj, function (data) {
        self.RecvGroupData(data, key);
        self.Execute.RunNextJob();
      });

      if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求
    }


    wx.request({
      url: self.RealtimeApiUrl,
      data:
      {
        "field": ["name", "symbol", "industry", 'concept', 'region'],
        "symbol": [this.Symbol] },

      method: 'POST',
      dataType: "json",
      async: true,
      success: function success(recvData)
      {
        self.RecvGroupData(recvData, key);
        self.Execute.RunNextJob();
      },
      error: function error(request)
      {
        self.RecvError(request);
      } });

  };

  this.RecvGroupData = function (recvData, key)
  {
    var data = recvData.data;
    if (!data.stock) return;
    if (data.stock.length != 1) return;
    var stock = data.stock[0];
    var industry = stock.industry;
    var concept = stock.concept;
    var region = stock.region;

    var groupData = { Industry: [], Concept: [], Region: [] };
    if (industry)
    {
      for (var i in industry)
      {
        var item = industry[i];
        groupData.Industry.push({ Name: item.name, Symbol: item.symbol });
        break; //就存一个1级分类
      }
    }

    if (concept)
    {
      for (var i in concept)
      {
        var item = concept[i];
        groupData.Concept.push({ Name: item.name, Symbol: item.symbol });
      }
    }

    if (region)
    {
      for (var i in region)
      {
        var item = region[i];
        groupData.Region.push({ Name: item.name, Symbol: item.symbol });
      }
    }

    this.ExtendData.set(key, groupData);
  };


  //获取大盘指数数据
  this.GetIndexData = function ()
  {
    if (this.IndexData) return this.Execute.RunNextJob();

    var self = this;
    if (_umychartDataWechat.JSCommonData.ChartData.IsDayPeriod(this.Period, true)) //请求日线数据
      {
        wx.request({
          url: self.KLineApiUrl,
          data:
          {
            "field": ["name", "symbol", "yclose", "open", "price", "high", "low", "vol", 'up', 'down', 'stop', 'unchanged'],
            "symbol": '000001.sh',
            "start": -1,
            "count": self.MaxReqeustDataCount + 500 //多请求2年的数据 确保股票剔除停牌日期以后可以对上
          },
          method: 'POST',
          dataType: "json",
          success: function success(recvData)
          {
            self.RecvIndexHistroyData(recvData);
            self.Execute.RunNextJob();
          },
          error: function error(request)
          {
            self.RecvError(request);
          } });

      } else
    if (_umychartDataWechat.JSCommonData.ChartData.IsMinutePeriod(this.Period, true)) //请求分钟数据
      {
        wx.request({
          url: self.MinuteKLineApiUrl,
          data:
          {
            "field": ["name", "symbol", "yclose", "open", "price", "high", "low", "vol"],
            "symbol": '000001.sh',
            "start": -1,
            "count": self.MaxRequestMinuteDayCount + 5 },

          method: 'POST',
          dataType: "json",
          success: function success(data)
          {
            self.RecvIndexMinuteHistroyData(data);
            self.Execute.RunNextJob();
          },
          error: function error(request)
          {
            self.RecvError(request);
          } });

      }
  };

  this.RecvIndexHistroyData = function (recvData)
  {
    var data = recvData.data;
    _umychartConsoleWechat.JSConsole.Complier.Log('[JSSymbolData::RecvIndexHistroyData] recv data', data);

    var hisData = this.JsonDataToHistoryData(data);
    this.IndexData = new _umychartDataWechat.JSCommonData.ChartData();
    this.IndexData.DataType = 0; /*日线数据 */
    this.IndexData.Data = hisData;

    var aryOverlayData = this.SourceData.GetOverlayData(this.IndexData.Data); //和主图数据拟合以后的数据
    this.IndexData.Data = aryOverlayData;

    if (_umychartDataWechat.JSCommonData.ChartData.IsDayPeriod(this.Period, false)) //周期数据
      {
        var periodData = this.IndexData.GetPeriodData(this.Period);
        this.IndexData.Data = periodData;
      }
  };

  this.RecvIndexMinuteHistroyData = function (recvData)
  {
    var data = recvData.data;
    _umychartConsoleWechat.JSConsole.Complier.Log('[JSSymbolData::RecvIndexMinuteHistroyData] recv data', data);

    var hisData = this.JsonDataToMinuteHistoryData(data);
    this.IndexData = new _umychartDataWechat.JSCommonData.ChartData();
    this.IndexData.DataType = 1; /*分钟线数据 */
    this.IndexData.Data = hisData;

    if (_umychartDataWechat.JSCommonData.ChartData.IsMinutePeriod(this.Period, false)) //周期数据
      {
        var periodData = this.IndexData.GetPeriodData(this.Period);
        this.IndexData.Data = periodData;
      }
  };

  //获取大盘指数缓存数据
  this.GetIndexCacheData = function (dataName)
  {
    if (!this.IndexData) return new Array();

    switch (dataName) {

      case 'INDEXA':
        return this.IndexData.GetAmount();
      case 'INDEXC':
        return this.IndexData.GetClose();
      case 'INDEXH':
        return this.IndexData.GetHigh();
      case 'INDEXL':
        return this.IndexData.GetLow();
      case 'INDEXO':
        return this.IndexData.GetOpen();
      case 'INDEXV':
        return this.IndexData.GetVol();
      case 'INDEXADV':
        return this.IndexData.GetUp();
      case 'INDEXDEC':
        return this.IndexData.GetDown();}

  };

  //分钟涨幅股票个数统计数据下载
  this.GetIndexIncreaseData = function (job)
  {
    var upKey = job.ID.toString() + '-UpCount-' + job.Symbol;
    var downKey = job.ID.toString() + '-DownCount-' + job.Symbol;
    if (this.ExtendData.has(upKey) && this.ExtendData.has(downKey)) return this.Execute.RunNextJob();

    var symbol = job.Symbol;
    symbol = symbol.replace('.CI', '.ci');
    var self = this;
    var apiUrl = g_JSComplierResource.CacheDomain + '/cache/analyze/increaseanalyze/' + symbol + '.json';
    _umychartConsoleWechat.JSConsole.Complier.Log('[JSSymbolData::GetIndexIncreaseData] Get url=', apiUrl);
    wx.request({
      url: apiUrl,
      method: "GET",
      dataType: "json",
      success: function success(data)
      {
        self.RecvMinuteIncreaseData(data, { UpKey: upKey, DownKey: downKey });
        self.Execute.RunNextJob();
      },
      error: function error(request)
      {
        self.RecvError(request);
      } });

  };

  this.RecvMinuteIncreaseData = function (recvData, key)
  {
    _umychartConsoleWechat.JSConsole.Complier.Log('[JSSymbolData::RecvMinuteIncreaseData] recv data', recvData);
    var data = recvData.data;
    if (!data.minute) return;
    var minuteData = data.minute;
    if (!minuteData.time || !minuteData.up || !minuteData.down) return;
    var upData = [],downData = [];
    for (var i = 0; i < minuteData.time.length; ++i) {
      upData[i] = minuteData.up[i];
      downData[i] = minuteData.down[i];
    }

    this.ExtendData.set(key.UpKey, upData);
    this.ExtendData.set(key.DownKey, downData);
  };

  //分钟涨幅股票个数统计数据
  this.GetIndexIncreaseCacheData = function (funcName, symbol, node) {
    var key;
    if (funcName == 'UPCOUNT') key = JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_INDEX_INCREASE_DATA.toString() + '-UpCount-' + symbol;else
    if (funcName == 'DOWNCOUNT') key = JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_INDEX_INCREASE_DATA.toString() + '-DownCount-' + symbol;

    if (!key || !this.ExtendData.has(key)) this.Execute.ThrowUnexpectedNode(node, '不支持函数' + funcName + '(' + symbol + ')');

    return this.ExtendData.get(key);
  };

  this.GetSymbolData = function ()
  {
    if (this.Data) return this.Execute.RunNextJob();

    var self = this;

    if (this.DataType === 2) //当天分钟数据
      {
        wx.request({
          url: self.RealtimeApiUrl,
          data:
          {
            "field": ["name", "symbol", "yclose", "open", "price", "high", "low", "vol", "amount", "date", "minute", "time", "minutecount"],
            "symbol": [self.Symbol],
            "start": -1 },

          method: 'POST',
          dataType: "json",
          async: true,
          success: function success(recvData) {
            self.RecvMinuteData(recvData);
            self.Execute.RunNextJob();
          } });

        return;
      }

    if (_umychartDataWechat.JSCommonData.ChartData.IsDayPeriod(this.Period, true)) //请求日线数据
      {
        wx.request({
          url: self.KLineApiUrl,
          data:
          {
            "field": ["name", "symbol", "yclose", "open", "price", "high", "low", "vol"],
            "symbol": self.Symbol,
            "start": -1,
            "count": self.MaxReqeustDataCount },

          method: 'POST',
          dataType: "json",
          async: true,
          success: function success(recvData)
          {
            self.RecvHistroyData(recvData);
            self.Execute.RunNextJob();
          },
          error: function error(request)
          {
            self.RecvError(request);
          } });

      } else
    if (_umychartDataWechat.JSCommonData.ChartData.IsMinutePeriod(this.Period, true)) //请求分钟数据
      {
        wx.request({
          url: this.MinuteKLineApiUrl,
          data:
          {
            "field": ["name", "symbol", "yclose", "open", "price", "high", "low", "vol"],
            "symbol": self.Symbol,
            "start": -1,
            "count": self.MaxRequestMinuteDayCount },

          method: 'POST',
          dataType: "json",
          async: true,
          success: function success(data)
          {
            self.RecvMinuteHistroyData(data);
            self.Execute.RunNextJob();
          },
          error: function error(request)
          {
            self.RecvError(request);
          } });

      }
  };

  this.RecvHistroyData = function (recvData)
  {
    var data = recvData.data;
    _umychartConsoleWechat.JSConsole.Complier.Log('[JSSymbolData::RecvHistroyData] recv data', data);

    var hisData = this.JsonDataToHistoryData(data);
    this.Data = new _umychartDataWechat.JSCommonData.ChartData();
    this.Data.DataType = 0; /*日线数据 */
    this.Data.Data = hisData;
    this.SourceData = new _umychartDataWechat.JSCommonData.ChartData();
    this.SourceData.Data = hisData;

    if (this.Right > 0) //复权
      {
        var rightData = this.Data.GetRightDate(this.Right);
        this.Data.Data = rightData;
      }

    if (_umychartDataWechat.JSCommonData.ChartData.IsDayPeriod(this.Period, false)) //周期数据
      {
        var periodData = this.Data.GetPeriodData(this.Period);
        this.Data.Data = periodData;
      }

    this.Name = data.name;
  };

  this.RecvMinuteHistroyData = function (recvData)
  {
    var data = recvData.data;
    _umychartConsoleWechat.JSConsole.Complier.Log('[JSSymbolData::RecvMinuteHistroyData] recv data', data);

    var hisData = this.JsonDataToMinuteHistoryData(data);
    this.Data = new _umychartDataWechat.JSCommonData.ChartData();
    this.Data.DataType = 1; /*分钟线数据 */
    this.Data.Data = hisData;
    this.SourceData = new _umychartDataWechat.JSCommonData.ChartData();
    this.SourceData.Data = hisData;

    if (_umychartDataWechat.JSCommonData.ChartData.IsMinutePeriod(this.Period, false)) //周期数据
      {
        var periodData = this.Data.GetPeriodData(this.Period);
        this.Data.Data = periodData;
      }

    this.Name = data.name;
  };

  //最新的分钟数据走势图
  this.RecvMinuteData = function (recvData)
  {
    var data = recvData.data;
    _umychartConsoleWechat.JSConsole.Complier.Log('[JSSymbolData::RecvMinuteData] recv data', data);

    var aryMinuteData = this.JsonDataToMinuteData(data);
    this.Data = new _umychartDataWechat.JSCommonData.ChartData();
    this.Data.DataType = 2; /*分钟走势图数据 */
    this.Data.Data = aryMinuteData;

    this.Name = data.stock[0].name;
  };

  this.GetSymbolCacheData = function (dataName)
  {
    if (!this.Data) return new Array();

    switch (dataName) {

      case 'CLOSE':
      case 'C':
        return this.Data.GetClose();
      case 'VOL':
      case 'V':
        return this.Data.GetVol();
      case 'OPEN':
      case 'O':
        return this.Data.GetOpen();
      case 'HIGH':
      case 'H':
        return this.Data.GetHigh();
      case 'LOW':
      case 'L':
        return this.Data.GetLow();
      case 'AMOUNT':
      case 'AMO':
        return this.Data.GetAmount();
      case 'VOLINSTK':
        return this.Data.GetPosition();}

  };

  this.GetCurrBarsCount = function ()
  {
    if (!this.Data || !this.Data.Data || !this.Data.Data.length) return new Array();

    var lCount = this.Data.Data.length;
    var result = [];
    for (var i = lCount - 1; i >= 0; --i) {
      result.push(i);}

    return result;
  };

  this.GetIsLastBar = function ()
  {
    var result = [];
    if (!this.Data || !this.Data.Data || !this.Data.Data.length) return result;

    var lCount = this.Data.Data.length;
    for (var i = 0; i < lCount; ++i)
    {
      if (i == lCount - 1) result.push(1);else
      result.push(0);
    }

    return result;
  };

  //融资融券函数
  this.GetMarginCacheData = function (id, node)
  {
    var jobID = JS_EXECUTE_JOB_ID.GetMarginJobID(id);
    if (!jobID) this.Execute.ThrowUnexpectedNode(node, '不支持MARGIN(' + id + ')');
    if (this.MarginData.has(jobID)) return this.MarginData.get(jobID);

    return [];
  };

  //下融资融券
  this.GetMarginData = function (jobID)
  {
    if (this.MarginData.has(jobID)) return this.Execute.RunNextJob();

    _umychartConsoleWechat.JSConsole.Complier.Log('[JSSymbolData::GetMarginData] jobID=', jobID);
    var self = this;
    var fieldList = ["name", "date", "symbol"];

    switch (jobID) {

      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BALANCE: //融资融券余额
        fieldList.push("margin.balance");
        break;
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_RATE: //融资占比
        fieldList.push("margin.rate");
        break;

      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_BALANCE: //买入信息-融资余额
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_AMOUNT: //买入信息-买入额
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_REPAY: //买入信息-偿还额
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_NET: //买入信息-融资净买入
        fieldList.push("margin.buy");
        break;

      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_BALANCE: //卖出信息-融券余量
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_VOLUME: //卖出信息-卖出量
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_REPAY: //卖出信息-偿还量
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_NET: //卖出信息-融券净卖出
        fieldList.push("margin.sell");
        break;}


    //请求数据
    wx.request({
      url: this.StockHistoryDayApiUrl,
      data:
      {
        "field": fieldList,
        "symbol": [this.Symbol],
        "orderfield": "date" },

      method: 'POST',
      dataType: "json",
      async: true,
      success: function success(recvData) {
        self.RecvMarginData(recvData, jobID);
        self.Execute.RunNextJob();
      } });

  };

  this.RecvMarginData = function (recvData, jobID)
  {
    var data = recvData.data;
    //JSConsole.Complier.Log(data);
    if (!data.stock || data.stock.length != 1) return;

    var stock = data.stock[0];
    var aryData = new Array();
    var aryData2 = [],aryData3 = [],aryData4 = []; //其他3个数据
    for (var i in stock.stockday)
    {
      var item = stock.stockday[i];
      var marginData = item.margin;
      if (!marginData) continue;

      var indexData = new _umychartDataWechat.JSCommonData.SingleData();
      indexData.Date = item.date;

      switch (jobID) {

        case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BALANCE:
          if (!this.IsNumber(marginData.balance)) continue;
          indexData.Value = marginData.balance; //融资融券余额
          aryData.push(indexData);
          break;
        case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_RATE:
          if (!this.IsNumber(marginData.rate)) continue;
          indexData.Value = marginData.rate; //融资占比
          aryData.push(indexData);
          break;

        case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_BALANCE: //买入信息-融资余额
        case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_AMOUNT: //买入信息-买入额
        case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_REPAY: //买入信息-偿还额
        case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_NET: //买入信息-融资净买入
          var buyData = marginData.buy;
          if (!buyData) continue;
          if (!this.IsNumber(buyData.balance) || !this.IsNumber(buyData.amount) || !this.IsNumber(buyData.repay) || !this.IsNumber(buyData.net)) continue;

          indexData.Value = buyData.balance;
          var indexData2 = new _umychartDataWechat.JSCommonData.SingleData();
          indexData2.Date = item.date;
          indexData2.Value = buyData.amount;
          var indexData3 = new _umychartDataWechat.JSCommonData.SingleData();
          indexData3.Date = item.date;
          indexData3.Value = buyData.repay;
          var indexData4 = new _umychartDataWechat.JSCommonData.SingleData();
          indexData4.Date = item.date;
          indexData4.Value = buyData.net;

          aryData.push(indexData);
          aryData2.push(indexData2);
          aryData3.push(indexData3);
          aryData4.push(indexData4);
          break;
        case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_BALANCE: //卖出信息-融券余量
        case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_VOLUME: //卖出信息-卖出量
        case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_REPAY: //卖出信息-偿还量
        case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_NET: //卖出信息-融券净卖出
          var sellData = marginData.sell;
          if (!sellData) continue;
          if (!this.IsNumber(sellData.balance) || !this.IsNumber(sellData.volume) || !this.IsNumber(sellData.repay) || !this.IsNumber(sellData.net)) continue;

          indexData.Value = buyData.balance;
          var indexData2 = new _umychartDataWechat.JSCommonData.SingleData();
          indexData2.Date = item.date;
          indexData2.Value = buyData.volume;
          var indexData3 = new _umychartDataWechat.JSCommonData.SingleData();
          indexData3.Date = item.date;
          indexData3.Value = buyData.repay;
          var indexData4 = new _umychartDataWechat.JSCommonData.SingleData();
          indexData4.Date = item.date;
          indexData4.Value = buyData.net;

          aryData.push(indexData);
          aryData2.push(indexData2);
          aryData3.push(indexData3);
          aryData4.push(indexData4);
          break;
        default:
          continue;}

    }

    var allData = [];
    if (jobID === JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BALANCE || jobID === JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_RATE)
    {
      allData.push({ JobID: jobID, Data: aryData });
    } else
    if (jobID === JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_BALANCE || jobID === JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_AMOUNT ||
    jobID === JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_REPAY || jobID === JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_NET)
    {
      allData.push({ JobID: JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_BALANCE, Data: aryData });
      allData.push({ JobID: JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_AMOUNT, Data: aryData2 });
      allData.push({ JobID: JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_REPAY, Data: aryData3 });
      allData.push({ JobID: JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_NET, Data: aryData4 });
    } else
    if (jobID === JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_BALANCE || jobID === JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_VOLUME ||
    jobID === JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_REPAY || jobID === JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_NET)
    {
      allData.push({ JobID: JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_BALANCE, Data: aryData });
      allData.push({ JobID: JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_VOLUME, Data: aryData2 });
      allData.push({ JobID: JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_REPAY, Data: aryData3 });
      allData.push({ JobID: JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_NET, Data: aryData4 });
    }

    for (var _i40 in allData)
    {
      var aryFixedData = this.Data.GetFittingData(allData[_i40].Data);

      var bindData = new _umychartDataWechat.JSCommonData.ChartData();
      bindData.Data = aryFixedData;
      bindData.Period = this.Period; //周期

      if (bindData.Period > 0) //周期数据
        {
          var periodData = bindData.GetPeriodSingleData(bindData.Period);
          bindData.Data = periodData;
        }

      var _data = bindData.GetValue();
      this.MarginData.set(allData[_i40].JobID, _data);
    }
  };

  this.GetNewsAnalysisCacheData = function (id, node)
  {

    var jobID = JS_EXECUTE_JOB_ID.GetNewsAnalysisID(id);
    if (!jobID) this.Execute.ThrowUnexpectedNode(node, '不支持NEWS(' + id + ')');
    if (this.NewsAnalysisData.has(jobID)) return this.NewsAnalysisData.get(jobID);

    return [];
  };

  //下载新闻统计
  this.GetNewsAnalysisData = function (jobID)
  {
    if (this.NewsAnalysisData.has(jobID)) return this.Execute.RunNextJob();

    var self = this;
    var mapFolder = new Map([
    [JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_NEGATIVE, "negative"],
    [JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_RESEARCH, 'research'],
    [JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_INTERACT, 'interact'],
    [JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_HOLDERCHANGE, 'holderchange'], //NEWS(4)   股东增持
    [JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_HOLDERCHANGE2, 'holderchange'], //NEWS(5)   股东减持
    [JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_TRUSTHOLDER, 'trustholder'], //NEWS(6)   信托持股
    [JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_BLOCKTRADING, 'Blocktrading'], //NEWS(7)   大宗交易
    [JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_COMPANYNEWS, 'companynews'], //NEWS(8)   官网新闻
    [JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_TOPMANAGERS, 'topmanagers'], //NEWS(9)   高管要闻
    [JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_PLEDGE, 'Pledge'] //NEWS(10)  股权质押
    ]);

    if (!mapFolder.has(jobID))
    {
      this.Execute.RunNextJob();
      return;
    }

    var folderName = mapFolder.get(jobID);
    var url = this.StockNewsAnalysisApiUrl + '/' + folderName + '/' + this.Symbol + '.json';

    //请求数据
    wx.request({
      url: url,
      method: 'GET',
      dataType: "json",
      async: true,
      success: function success(recvData)
      {
        if (recvData.statusCode == 200)
        self.RecvNewsAnalysisData(recvData, jobID);else

        self.RecvNewsAnalysisDataError(recvData, jobID);
        self.Execute.RunNextJob();
      },
      fail: function fail(request, textStatus)
      {
        //self.RecvNewsAnalysisDataError(request, textStatus, jobID);
        self.Execute.RunNextJob();
      } });

  };

  this.RecvNewsAnalysisDataError = function (recvData, jobID)
  {
    _umychartConsoleWechat.JSConsole.Complier.Log('[JSSymbolData::RecvNewsAnalysisDataError] request error.', recvData.statusCode);

    //没有新闻使用0数据填充
    var aryData = [];
    for (var i = 0; i < this.Data.Data.length; ++i)
    {
      var item = new _umychartDataWechat.JSCommonData.SingleData();
      item.Date = this.Data.Data[i].Date;
      item.Value = 0;
      aryData.push(item);
    }

    var bindData = new _umychartDataWechat.JSCommonData.ChartData();
    bindData.Data = aryData;
    this.NewsAnalysisData.set(jobID, bindData.GetValue());
  };

  this.RecvNewsAnalysisData = function (recvData, jobID)
  {
    var data = recvData.data;
    if (!data.data || !data.date) return;
    if (data.data.length <= 0 || data.data.length != data.date.length) return;

    _umychartConsoleWechat.JSConsole.Complier.Log('[JSSymbolData::RecvNewsAnalysisData] jobID', jobID, data.update);
    if (jobID == JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_HOLDERCHANGE || jobID == JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_HOLDERCHANGE2)
    {
      var aryData = [],aryData2 = [];
      for (var i = 0; i < data.data.length; ++i)
      {
        var item = new _umychartDataWechat.JSCommonData.SingleData();
        item.Date = data.date[i];
        item.Value = data.data[i];
        if (this.IsNumber(item.Value)) aryData.push(item);

        if (i < data.data2.length)
        {
          item = new _umychartDataWechat.JSCommonData.SingleData();
          item.Date = data.date[i];
          item.Value = data.data2[i];
          if (this.IsNumber(item.Value)) aryData2.push(item);
        }
      }

      var aryFixedData = this.Data.GetFittingData2(aryData, 0);
      var bindData = new _umychartDataWechat.JSCommonData.ChartData();
      bindData.Data = aryFixedData;
      this.NewsAnalysisData.set(JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_HOLDERCHANGE, bindData.GetValue());

      aryFixedData = this.Data.GetFittingData2(aryData2, 0);
      bindData = new _umychartDataWechat.JSCommonData.ChartData();
      bindData.Data = aryFixedData;
      this.NewsAnalysisData.set(JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_HOLDERCHANGE2, bindData.GetValue());
    } else

    {
      var aryData = [];
      for (var i = 0; i < data.data.length; ++i)
      {
        var item = new _umychartDataWechat.JSCommonData.SingleData();
        item.Date = data.date[i];
        item.Value = data.data[i];
        aryData.push(item);
      }

      var _aryFixedData = this.Data.GetFittingData2(aryData, 0);

      var bindData = new _umychartDataWechat.JSCommonData.ChartData();
      bindData.Data = _aryFixedData;

      this.NewsAnalysisData.set(jobID, bindData.GetValue());
    }
  };

  this.GetStockDataKey = function (jobItem, aryArgs)
  {
    var key = jobItem.FunctionName;
    if (aryArgs.length > 0)
    {
      key += "(";
      for (var i = 0; i < aryArgs.length; ++i)
      {
        if (i > 0) key += ",";
        key += aryArgs[i].toString();
      }
      key += ")";
    }
    return key;
  };

  this.GetFinOne = function (jobItem)
  {
    var aryArgs = this.JobArgumentsToArray(jobItem, 3);
    var key = this.GetStockDataKey(jobItem, aryArgs);
    if (this.StockData.has(key)) return this.Execute.RunNextJob();
    var self = this;
    if (this.NetworkFilter)
    {
      var dateRange = this.Data.GetDateRange();
      var obj =
      {
        Name: 'JSSymbolData::GetFinOne', //类名::
        Explain: '财务数据FINONE(ID,Y,MMDD)',
        JobID: jobItem.ID,
        Request: { Url: self.StockHistoryDayApiUrl, Type: 'POST', Data: { Args: aryArgs, symbol: this.Symbol, daterange: dateRange } },
        Self: this,
        PreventDefault: false };

      this.NetworkFilter(obj, function (recvData)
      {
        self.RecvStockValue(recvData, jobItem, key, 1);
        self.Execute.RunNextJob();
      });

      if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求
    }

    var apiDownload = new DownloadFinOneData(
    {
      Job: jobItem,
      Symbol: this.Symbol,
      Url: this.StockHistoryDayApiUrl,
      Args: aryArgs,
      DataKey: key,
      Callback: function Callback(recvData, jobItem, key)
      {
        self.RecvStockValue(recvData, jobItem, key, 1);
        self.Execute.RunNextJob();
      },
      ErrorCallback: function ErrorCallback(strError)
      {
        self.AddStockValueError(key, strError);
      } });


    apiDownload.Download();
  };

  this.GetFinValue = function (jobItem)
  {
    var aryArgs = this.JobArgumentsToArray(jobItem, 1);
    var lID = aryArgs[0];
    var key = this.GetStockDataKey(jobItem, aryArgs);
    if (this.StockData.has(key)) return this.Execute.RunNextJob();
    var self = this;
    if (this.NetworkFilter)
    {
      var dateRange = this.Data.GetDateRange();
      var obj =
      {
        Name: 'JSSymbolData::GetFinValue', //类名::
        Explain: '财务数据FINVALUE(ID)',
        JobID: jobItem.ID,
        Request: { Url: self.StockHistoryDayApiUrl, Type: 'POST', Data: { id: lID, symbol: this.Symbol, daterange: dateRange } },
        Self: this,
        PreventDefault: false };

      this.NetworkFilter(obj, function (recvData)
      {
        self.RecvStockValue(recvData, jobItem, key, 0);
        self.Execute.RunNextJob();
      });

      if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求
    }

    var apiDownload = new DownloadFinValueData(
    {
      Job: jobItem,
      Symbol: this.Symbol,
      Url: this.StockHistoryDayApiUrl,
      Args: aryArgs,
      DataKey: key,
      Callback: function Callback(recvData, jobItem, key)
      {
        self.RecvStockValue(recvData, jobItem, key, 0);
        self.Execute.RunNextJob();
      },
      ErrorCallback: function ErrorCallback(strError)
      {
        self.AddStockValueError(key, strError);
      } });


    apiDownload.Download();
  };


  this.GetFinance = function (jobItem)
  {
    var aryArgs = this.JobArgumentsToArray(jobItem, 1);
    var lID = aryArgs[0];
    var key = this.GetStockDataKey(jobItem, aryArgs);
    if (this.StockData.has(key)) return this.Execute.RunNextJob();

    var self = this;
    if (this.NetworkFilter)
    {
      var dateRange = this.Data.GetDateRange();
      var obj =
      {
        Name: 'JSSymbolData::GetFinance', //类名::
        Explain: '财务数据FINANCE(ID)',
        JobID: jobItem.ID,
        Request: { Url: self.RealtimeApiUrl, Type: 'POST', Data: { id: lID, symbol: this.Symbol, daterange: dateRange } },
        Self: this,
        PreventDefault: false };

      this.NetworkFilter(obj, function (recvData)
      {
        self.RecvStockValue(recvData, jobItem, key, 0);
        self.Execute.RunNextJob();
      });

      if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求
    }

    var apiDownload = new DownloadFinanceData(
    {
      Job: jobItem,
      Symbol: this.Symbol,
      Url: this.StockHistoryDayApiUrl,
      RealtimeUrl: this.RealtimeApiUrl,
      Args: aryArgs,
      DataKey: key,
      Callback: function Callback(recvData, jobItem, key)
      {
        self.RecvStockValue(recvData, jobItem, key, 0);
        self.Execute.RunNextJob();
      },
      ErrorCallback: function ErrorCallback(strError)
      {
        self.AddStockValueError(key, strError);
      } });


    apiDownload.Download();
  };

  this.GetVariantData = function (jobItem)
  {
    var key = jobItem.VariantName;
    if (this.StockData.has(key)) return this.Execute.RunNextJob();

    var self = this;
    if (this.NetworkFilter)
    {
      var dateRange = this.Data.GetDateRange();
      var obj =
      {
        Name: 'JSSymbolData::GetVariantData', //类名::
        Explain: '变量数据下载',
        JobID: jobItem.ID,
        Request: { Url: "www.121287.com", Type: 'POST', Data: { VariantName: jobItem.VariantName, symbol: this.Symbol, daterange: dateRange } },
        Self: this,
        PreventDefault: false };

      this.NetworkFilter(obj, function (recvData)
      {
        self.RecvStockValue(recvData, jobItem, key, 0);
        self.Execute.RunNextJob();
      });

      if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求
    }

    var callback = function callback(recvData, jobItem, key)
    {
      self.RecvStockValue(recvData, jobItem, key, 0);
      self.Execute.RunNextJob();
    };

    var errorCallback = function errorCallback(strError)
    {
      self.AddStockValueError(key, strError);
    };

    var apiDownload;
    if (jobItem.VariantName == "CAPITAL" || jobItem.VariantName == "TOTALCAPITAL" || jobItem.VariantName == "EXCHANGE")
    {
      apiDownload = new DownloadFinanceData(
      {
        Job: jobItem,
        Symbol: this.Symbol,
        Url: this.StockHistoryDayApiUrl,
        RealtimeUrl: this.RealtimeApiUrl,
        Args: [jobItem.VariantName],
        DataKey: key,
        Callback: callback,
        ErrorCallback: errorCallback });

    }

    apiDownload.Download();
  };

  this.GetGPJYValue = function (jobItem)
  {
    var aryArgs = this.JobArgumentsToArray(jobItem, 3);
    var key = this.GetStockDataKey(jobItem, aryArgs);
    if (this.StockData.has(key)) return this.Execute.RunNextJob();

    var self = this;
    //TYPE:为1表示做平滑处理,没有数据的周期返回上一周期的值;为0表示不做平滑处理
    var dataType = aryArgs[2] == 1 ? 0 : 2;
    if (this.NetworkFilter)
    {
      var dateRange = this.Data.GetDateRange();
      var obj =
      {
        Name: 'JSSymbolData::GetGPJYValue', //类名::
        Explain: '股票交易类数据GPJYVALUE(ID,N,TYPE)',
        JobID: jobItem.ID,
        Request: { Url: self.StockHistoryDayApiUrl, Type: 'POST', Data: { Args: aryArgs, symbol: this.Symbol, daterange: dateRange } },
        Self: this,
        PreventDefault: false };

      this.NetworkFilter(obj, function (recvData)
      {
        self.RecvStockValue(recvData, jobItem, key, dataType);
        self.Execute.RunNextJob();
      });

      if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求
    }

    var apiDownload = new DownloadGPJYValue(
    {
      Job: jobItem,
      Symbol: this.Symbol,
      Url: this.StockHistoryDayApiUrl,
      Args: aryArgs,
      DataKey: key,
      Callback: function Callback(recvData, jobItem, key)
      {
        self.RecvStockValue(recvData, jobItem, key, dataType);
        self.Execute.RunNextJob();
      },
      ErrorCallback: function ErrorCallback(strError)
      {
        self.AddStockValueError(key, strError);
      } });


    apiDownload.Download();
  };

  //自定义变量数据下载
  this.GetCustomVariantData = function (jobItem)
  {
    var key = jobItem.VariantName;
    if (this.StockData.has(key)) return this.Execute.RunNextJob();

    var variantInfo = g_JSComplierResource.CustomVariant.Data.get(key);
    var self = this;
    if (this.NetworkFilter)
    {
      var dateRange = this.Data.GetDateRange();
      var obj =
      {
        Name: 'JSSymbolData::GetCustomVariantData', //类名::函数名
        Explain: '自定义变量数据下载',
        JobID: jobItem.ID,
        Request: { Url: "www.121287.com", Type: 'POST', Data: { VariantName: jobItem.VariantName, symbol: this.Symbol, daterange: dateRange } },
        Self: this,
        VariantInfo: variantInfo,
        PreventDefault: false };

      this.NetworkFilter(obj, function (recvData)
      {
        if (recvData.Error) self.AddStockValueError(key, recvData.Error);else
        self.RecvStockValue(recvData.Data, jobItem, key, recvData.DataType);
        self.Execute.RunNextJob();
      });
    } else

    {
      this.AddStockValueError(key, "\u81EA\u5B9A\u4E49\u53D8\u91CF".concat(key, "\u4E0B\u8F7D\u5931\u8D25"));
      this.Execute.RunNextJob();
    }
  };

  this.GetCustomFunctionData = function (jobItem)
  {
    var key = jobItem.FunctionName;
    var functionInfo = g_JSComplierResource.CustomFunction.Data.get(key);
    if (!functionInfo.IsDownload) return this.Execute.RunNextJob();
    if (this.StockData.has(key)) return this.Execute.RunNextJob(); //一个函数只能缓存一个数据, 保存多个外部自己保存

    var self = this;
    if (this.NetworkFilter)
    {
      var dateRange = this.Data.GetDateRange();
      var obj =
      {
        Name: 'JSSymbolData::GetCustomFunctionData', //类名::函数名
        Explain: '自定义函数数据下载',
        JobID: jobItem.ID,
        Request:
        {
          Url: "www.121287.com", Type: 'POST',
          Data:
          {
            FunctionName: jobItem.FunctionName,
            symbol: this.Symbol, daterange: dateRange,
            JobItem: jobItem //函数编译信息
          } },

        Self: this,
        FunctionInfo: functionInfo,
        PreventDefault: false };

      this.NetworkFilter(obj, function (recvData)
      {
        if (recvData.Error) self.AddStockValueError(key, recvData.Error);else
        self.RecvStockValue(recvData.Data, jobItem, key, recvData.DataType);
        self.Execute.RunNextJob();
      });
    } else

    {
      this.AddStockValueError(key, "\u81EA\u5B9A\u4E49\u51FD\u6570".concat(key, "\u4E0B\u8F7D\u5931\u8D25"));
      this.Execute.RunNextJob();
    }
  };

  this.RecvStockValue = function (recvData, jobItem, key, dataType)
  {
    if (!recvData)
    {
      //JSConsole.Complier.Log(`[JSSymbolData::RecvStockValue] key=${key} data is null`);
      return;
    }

    if (dataType == 0)
    {
      if (Array.isArray(recvData))
      {
        var kdata = this.Data; //K线
        var aryFittingData;
        if (_umychartDataWechat.JSCommonData.ChartData.IsDayPeriod(this.Period, true))
        aryFittingData = kdata.GetFittingFinanceData(recvData); //数据和主图K线拟合
        else if (_umychartDataWechat.JSCommonData.ChartData.IsMinutePeriod(this.Period, true))
          aryFittingData = kdata.GetMinuteFittingFinanceData(recvData); //数据和主图K线拟合
          else
            return;

        var bindData = new _umychartDataWechat.JSCommonData.ChartData();
        bindData.Data = aryFittingData;
        var result = bindData.GetValue();

        if (key == "EXCHANGE") //计算换手率=成交量/流通股本*100
          {
            for (var i in result)
            {
              var kitem = kdata.Data[i];
              if (result[i] > 0)
              result[i] = kitem.Vol / result[i] * 100;
            }
          }

        this.StockData.set(key, { Data: result });
      } else

      {
        this.StockData.set(key, { Data: recvData.Value });
      }
    } else
    if (dataType == 1) //单数值
      {
        this.StockData.set(key, { Data: recvData.Value });
      } else
    if (dataType == 2) //数据不做平滑处理
      {
        var kdata = this.Data; //K线
        var aryFittingData;
        if (_umychartDataWechat.JSCommonData.ChartData.IsDayPeriod(this.Period, true))
        aryFittingData = kdata.GetFittingTradeData(recvData, 0, false); //数据和主图K线拟合
        else if (_umychartDataWechat.JSCommonData.ChartData.IsMinutePeriod(this.Period, true))
          aryFittingData = kdata.GetMinuteFittingTradeData(recvData, 0, false); //数据和主图K线拟合
          else
            return;

        var bindData = new _umychartDataWechat.JSCommonData.ChartData();
        bindData.Data = aryFittingData;
        var result = bindData.GetValue();

        this.StockData.set(key, { Data: result });
      }
  };

  this.AddStockValueError = function (key, message)
  {
    this.StockData.set(key, { Error: message });
  };

  this.GetStockCacheData = function (obj)
  {
    var key;
    if (obj.FunctionName)
    key = this.GetStockDataKey({ FunctionName: obj.FunctionName }, obj.Args);else
    if (obj.VariantName)
    key = obj.VariantName;else
    if (obj.CustomName)
    key = obj.CustomName; //自定义名字
    else
      return null;

    if (!this.StockData.has(key)) return null;
    var data = this.StockData.get(key);

    if (data.Error) this.Execute.ThrowUnexpectedNode(obj.Node, data.Error);
    return data.Data;
  };

  this.JobArgumentsToArray = function (job, lCount)
  {
    var args = job.Args;
    if (args.length != lCount)
    {
      var token = job.Token;
      this.Execute.ErrorHandler.ThrowError(token.Index, token.Line, 0, "".concat(job.FunctionName, "() Error: argument count error."));
    }

    var aryValue = [];
    for (var i = 0; i < args.length; ++i)
    {
      var item = args[i];
      if (this.IsNumber(item))
      {
        aryValue.push(item);
      } else
      if (item.Type == Syntax.Literal)
      {
        aryValue.push(item.Value);
      } else
      if (item.Type == Syntax.Identifier) //变量 !!只支持默认的变量值
        {
          var isFind = false;
          for (var j in this.Arguments)
          {
            var argItem = this.Arguments[j];
            if (argItem.Name == item.Name)
            {
              aryValue.push(argItem.Value);
              isFind = true;
              break;
            }
          }

          if (!isFind)
          {
            var token = job.Token;
            this.Execute.ErrorHandler.ThrowError(token.Index, token.Line, 0, "".concat(job.FunctionName, "() Error: can't read ").concat(item.Name));
          }
        }
    }

    return aryValue;
  };

  this.DownloadCustomAPIData = function (job)
  {
    if (!this.NetworkFilter) return this.Execute.RunNextJob();

    var args = [];
    for (var i in job.Args)
    {
      var item = job.Args[i];
      if (item.Type == Syntax.Literal)
      {
        args.push(item.Value);
      } else
      if (item.Type == Syntax.Identifier) //变量 !!只支持默认的变量值
        {
          var isFind = false;
          for (var j in this.Arguments)
          {
            var argItem = this.Arguments[j];
            if (argItem.Name == item.Name)
            {
              args.push(argItem.Value);
              isFind = true;
              break;
            }
          }

          if (!isFind)
          {
            var token = job.Token;
            this.Execute.ErrorHandler.ThrowError(token.Index, token.Line, 0, "LoadAPIData() Error: can't read ".concat(item.Name));
          }
        } else

      {
        return this.Execute.RunNextJob();
      }
    }

    var self = this;
    var obj =
    {
      Name: 'JSSymbolData::DownloadCustomAPIData', //类名::函数名
      Explain: '下载自定义api数据',
      Period: this.Period,
      Right: this.Right,
      Symbol: this.Symbol,
      KData: this.Data, //K线数据
      Cache: this.CustomAPIData,
      Args: args,
      Self: this,
      PreventDefault: false };


    this.NetworkFilter(obj, function (data) {
      self.RecvCustomAPIData(data, args);
      self.Execute.RunNextJob();
    });

    if (obj.PreventDefault == true) return; //已被上层替换,不调用默认的网络请求

    this.Execute.RunNextJob();
  };

  this.RecvCustomAPIData = function (recvData, args)
  {
    if (!recvData || !recvData.data) return;

    var data = recvData.data;
    var apiKey = this.GenerateCustomAPIKey(args);
    if (_umychartDataWechat.JSCommonData.ChartData.IsMinutePeriod(this.Period, true))
    {
      if (!data.date || !data.time) return;

      var date = data.date;
      var time = data.time;
      for (var key in data)
      {
        if (key == 'date' || key == 'time') continue;
        var item = data[key];
      }
    } else
    if (_umychartDataWechat.JSCommonData.ChartData.IsDayPeriod(this.Period, true))
    {
      if (!data.date) return;

      var date = data.date;
      var result = { __Type__: "Object" };
      for (var key in data) {
        if (key == 'date') continue;

        var item = data[key];
        if (Array.isArray(item))
        {
          var value = this.FittingCustomAPIArray(item, date);
          result[key] = value;
        } else
        if (this.IsNumber(item))
        {
          result[key] = item;
        }
      }

      this.CustomAPIData.set(apiKey, result);
    }
  };

  this.FittingCustomAPIArray = function (data, date, time)
  {
    var kdata = this.Data; //K线

    var arySingleData = [];
    for (var i in data)
    {
      var value = data[i];
      var indexItem = new _umychartDataWechat.JSCommonData.SingleData(); //单列指标数据
      indexItem.Date = date[i];
      if (time && i < time.length) indexItem.Time = time[i];
      indexItem.Value = value;
      arySingleData.push(indexItem);
    }

    var aryFittingData;
    if (_umychartDataWechat.JSCommonData.ChartData.IsDayPeriod(this.Period, true))
    aryFittingData = kdata.GetFittingData(arySingleData); //数据和主图K线拟合
    else if (_umychartDataWechat.JSCommonData.ChartData.IsMinutePeriod(this.Period, true))
      aryFittingData = kdata.GetMinuteFittingData(arySingleData); //数据和主图K线拟合
      else
        return null;

    var bindData = new _umychartDataWechat.JSCommonData.ChartData();
    bindData.Data = aryFittingData;
    var result = bindData.GetValue();
    return result;
  };

  this.JsonDataToHistoryData = function (data)
  {
    var list = data.data;
    var aryDayData = new Array();
    var date = 0,yclose = 1,open = 2,high = 3,low = 4,close = 5,vol = 6,amount = 7;
    var up = 8,down = 9,stop = 10,unchanged = 11;
    for (var i = 0; i < list.length; ++i)
    {
      var item = new _umychartDataWechat.JSCommonData.HistoryData();

      item.Date = list[i][date];
      item.Open = list[i][open];
      item.YClose = list[i][yclose];
      item.Close = list[i][close];
      item.High = list[i][high];
      item.Low = list[i][low];
      item.Vol = list[i][vol]; //原始单位股
      item.Amount = list[i][amount];

      if (isNaN(item.Open) || item.Open <= 0) continue; //停牌的数据剔除

      //上涨 下跌家数
      if (list[i].length > up) item.Up = list[i][up];
      if (list[i].length > down) item.Down = list[i][down];
      if (list[i].length > stop) item.Stop = list[i][stop];
      if (list[i].length > unchanged) item.Unchanged = list[i][unchanged];

      aryDayData.push(item);
    }

    return aryDayData;
  };

  this.JsonDataToMinuteHistoryData = function (data)
  {
    var list = data.data;
    var aryDayData = new Array();
    var date = 0,yclose = 1,open = 2,high = 3,low = 4,close = 5,vol = 6,amount = 7,time = 8;
    for (var i = 0; i < list.length; ++i)
    {
      var _item7 = new _umychartDataWechat.JSCommonData.HistoryData();

      _item7.Date = list[i][date];
      _item7.Open = list[i][open];
      _item7.YClose = list[i][yclose];
      _item7.Close = list[i][close];
      _item7.High = list[i][high];
      _item7.Low = list[i][low];
      _item7.Vol = list[i][vol]; //原始单位股
      _item7.Amount = list[i][amount];
      _item7.Time = list[i][time];

      // if (isNaN(item.Open) || item.Open<=0) continue; //停牌的数据剔除
      aryDayData.push(_item7);
    }

    // 无效数据处理
    for (var _i41 = 0; _i41 < aryDayData.length; ++_i41)
    {
      var minData = aryDayData[_i41];
      if (minData == null) coninue;
      if (isNaN(minData.Open) || minData.Open <= 0 || isNaN(minData.High) || minData.High <= 0 || isNaN(minData.Low) || minData.Low <= 0 ||
      isNaN(minData.Close) || minData.Close <= 0 || isNaN(minData.YClose) || minData.YClose <= 0)
      {
        if (_i41 == 0)
        {
          if (minData.YClose > 0)
          {
            minData.Open = minData.YClose;
            minData.High = minData.YClose;
            minData.Low = minData.YClose;
            minData.Close = minData.YClose;
          }
        } else
          // 用前一个有效数据填充
          {
            for (var j = _i41 - 1; j >= 0; --j)
            {
              var minData2 = aryDayData[j];
              if (minData2 == null) coninue;
              if (minData2.Open > 0 && minData2.High > 0 && minData2.Low > 0 && minData2.Close > 0)
              {
                if (minData.YClose <= 0) minData.YClose = minData2.Close;
                minData.Open = minData2.Open;
                minData.High = minData2.High;
                minData.Low = minData2.Low;
                minData.Close = minData2.Close;
                break;
              }
            }
          }
      }
    }
    return aryDayData;
  };

  //API 返回数据 转化为array[]
  this.JsonDataToMinuteData = function (data)
  {
    var aryMinuteData = new Array();
    for (var i in data.stock[0].minute)
    {
      var jsData = data.stock[0].minute[i];
      var item = new _umychartDataWechat.JSCommonData.MinuteData();

      item.Close = jsData.price;
      item.Open = jsData.open;
      item.High = jsData.high;
      item.Low = jsData.low;
      item.Vol = jsData.vol; //股
      item.Amount = jsData.amount;
      if (i == 0) //第1个数据 写死9：25
        item.DateTime = data.stock[0].date.toString() + " 0925";else

      item.DateTime = data.stock[0].date.toString() + " " + jsData.time.toString();
      item.Date = data.stock[0].date;
      item.Time = jsData.time;
      item.Increate = jsData.increate;
      item.Risefall = jsData.risefall;
      item.AvPrice = jsData.avprice;

      aryMinuteData[i] = item;
    }

    return aryMinuteData;
  };

  //CODELIKE 模糊股票代码
  this.CODELIKE = function (value)
  {
    if (this.Symbol.indexOf(value) == 0) return 1;

    return 0;
  };

  this.NAMELIKE = function (value)
  {
    if (this.Name && this.Name.indexOf(value) == 0) return 1;
    return 0;
  };

  /*
     SETCODE 市场类型
     0:深圳 1:上海,47:中金所期货 28:郑州商品 29:大连商品 30:上海商品,27:香港指数 31:香港主板,48:香港创业板... 
     */
  this.SETCODE = function ()
  {
    if (this.Symbol.indexOf('.sh')) return 1;
    if (this.Symbol.indexOf('.sz')) return 0;

    return 0;
  };

  this.GetSymbol = function () {return this.Symbol;};

  this.GetName = function () {return this.Name;};

  this.GetIndustry = function () //行业
  {
    var key = JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_GROUP_DATA.toString() + '-Group-' + this.Symbol;
    if (!this.ExtendData.has(key)) return '';

    var group = this.ExtendData.get(key);
    if (!group.Industry || group.Industry.length <= 0) return '';

    var result = '';
    for (var i in group.Industry)
    {
      var item = group.Industry[i];
      if (result.length > 0) result += ' ';
      result += item.Name;
    }

    return result;
  };

  this.GetRegion = function () //地区
  {
    var key = JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_GROUP_DATA.toString() + '-Group-' + this.Symbol;
    if (!this.ExtendData.has(key)) return '';

    var group = this.ExtendData.get(key);
    if (!group.Region || group.Region.length <= 0) return '';

    var result = '';
    for (var i in group.Region)
    {
      var item = group.Region[i];
      if (result.length > 0) result += ' ';
      result += item.Name;
    }

    return result;
  };

  this.GetConcept = function () //概念
  {
    var key = JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_GROUP_DATA.toString() + '-Group-' + this.Symbol;
    if (!this.ExtendData.has(key)) return '';

    var group = this.ExtendData.get(key);
    if (!group.Concept || group.Concept.length <= 0) return '';

    var result = '';
    for (var i in group.Concept)
    {
      var item = group.Concept[i];
      if (result.length > 0) result += ' ';
      result += item.Name;
    }

    return result;
  };

  this.TIME = function ()
  {
    var result = [];
    if (!this.Data || !this.Data.Data || !this.Data.Data.length) return result;

    for (var i in this.Data.Data)
    {
      var item = this.Data.Data[i];
      if (this.IsNumber(item.Time))
      result[i] = item.Time;else

      result[i] = 0;
    }

    return result;
  };

  this.DATE = function ()
  {
    var result = [];
    if (!this.Data || !this.Data.Data || !this.Data.Data.length) return result;

    for (var i in this.Data.Data)
    {
      var item = this.Data.Data[i];
      result[i] = item.Date - 19000000;;
    }

    return result;
  };

  this.YEAR = function ()
  {
    var result = [];
    if (!this.Data || !this.Data.Data || !this.Data.Data.length) return result;

    for (var i in this.Data.Data)
    {
      var item = this.Data.Data[i];
      if (this.IsNumber(item.Date))
      result[i] = parseInt(item.Date / 10000);else

      result[i] = null;
    }

    return result;
  };

  this.MONTH = function ()
  {
    var result = [];
    if (!this.Data || !this.Data.Data || !this.Data.Data.length) return result;

    for (var i in this.Data.Data)
    {
      var item = this.Data.Data[i];
      if (this.IsNumber(item.Date))
      result[i] = parseInt(item.Date % 10000 / 100);else

      result[i] = null;
    }

    return result;
  };

  //星期 1-7
  this.WEEK = function ()
  {
    var result = [];
    if (!this.Data || !this.Data.Data || !this.Data.Data.length) return result;

    var tempDate = new Date();
    for (var i in this.Data.Data)
    {
      var item = this.Data.Data[i];
      result[i] = null;
      if (!this.IsNumber(item.Date)) continue;

      var year = parseInt(item.Date / 10000);
      var month = parseInt(item.Date % 10000 / 100);
      var day = item.Date % 100;

      tempDate.setFullYear(year);
      tempDate.setMonth(month - 1);
      tempDate.setDate(day);

      result[i] = tempDate.getDay();
    }

    return result;
  };

  this.REFDATE = function (data, date)
  {
    var result = null;

    var findDate = null;
    if (Array.isArray(date))
    {
      if (date.length > 0) findDate = date[date.length - 1];
    } else
    if (this.IsNumber(date))
    {
      findDate = date;
    }
    if (findDate == null) return null;
    if (findDate < 5000000) findDate += 19000000;

    var index = null;
    for (var i in this.Data.Data) //查找日期对应的索引
    {
      if (this.Data.Data[i].Date == findDate)
      {
        index = parseInt(i);
        break;
      }
    }

    if (index == null || index >= data.length) return null;

    return data[index];
  };

  //用法:结果从0到11,依次分别是1/5/15/30/60分钟,日/周/月,多分钟,多日,季,年
  this.PERIOD = function ()
  {
    //Period周期 0=日线 1=周线 2=月线 3=年线 9=季线 4=1分钟 5=5分钟 6=15分钟 7=30分钟 8=60分钟
    var PERIOD_MAP = [5, 6, 7, 11, 0, 1, 2, 3, 4, 5, 9];
    if (this.Period >= 0 && this.Period <= PERIOD_MAP.length - 1)
    return PERIOD_MAP[this.Period];

    return this.Period;
  };

  this.GetDrawNull = function ()
  {
    var result = [];
    if (!this.Data || !this.Data.Data || !this.Data.Data.length) return result;

    for (var i in this.Data.Data)
    {
      result[i] = null;
    }

    return result;
  };
}

//是否有是有效的数字
JSSymbolData.prototype.IsNumber = function (value)
{
  if (value == null) return false;
  if (isNaN(value)) return false;

  return true;
};

JSSymbolData.prototype.IsDivideNumber = function (value)
{
  if (value == null) return false;
  if (isNaN(value)) return false;
  if (value == 0) return false;

  return true;
};

JSSymbolData.prototype.JsonDataToFinance = function (data)
{
  var financeData;

  for (var i = 1; i <= 4; ++i)
  {
    switch (i) {

      case 1:
        var finance = data.finance1;
        var announcement = data.announcement1;
        break;
      case 2:
        var finance = data.finance2;
        var announcement = data.announcement2;
        break;
      case 3:
        var finance = data.finance3;
        var announcement = data.announcement3;
        break;
      case 4:
        var finance = data.finance4;
        var announcement = data.announcement4;
        break;
      default:
        break;}


    if (!finance || !announcement || !this.IsNumber(announcement.year) || !this.IsNumber(announcement.quarter)) continue;
    if (financeData) //如果存在1天公布多个报告期数据 只取最新的一个公告期数据
      {
        if (financeData.Announcement.year < announcement.year)
        financeData = { Date: item.date, Finance: finance, Announcement: announcement };
      } else

    {
      financeData = { Date: data.date, Finance: finance, Announcement: announcement };
    }

  }

  return financeData;
};

var JS_EXECUTE_DEBUG_LOG = false;

var JS_EXECUTE_JOB_ID = (_JS_EXECUTE_JOB_ID = {

  JOB_DOWNLOAD_SYMBOL_DATA: 1, //下载股票的K线数据
  JOB_DOWNLOAD_INDEX_DATA: 2, //下载大盘的K线数据
  JOB_DOWNLOAD_SYMBOL_LATEST_DATA: 3, //最新的股票行情数据
  JOB_DOWNLOAD_INDEX_INCREASE_DATA: 4, //涨跌股票个数统计数据
  JOB_DOWNLOAD_VOLR_DATA: 5, //5日量比均量下载量比数据
  JOB_DOWNLOAD_GROUP_DATA: 6, //所属行业|地区|概念

  JOB_DOWNLOAD_FINVALUE: 301, //引用专业财务数据 FINVALUE(ID),ID为数据编号
  JOB_DOWNLOAD_FINONE: 302, //引用指定年和月日的某类型的财务数据 FINONE(ID,Y,MMDD),ID为数据编号,Y和MMDD表示年和月日.
  JOB_DOWNLOAD_FINANCE: 303, //FINANCE(ID) 基础财务数据
  JOB_DOWNLOAD_GPJYVALUE: 304, //引用股票交易类数据 GPJYVALUE(ID,N,TYPE),ID为数据编号,N表示第几个数据,TYPE:为1表示做平滑处理,没有数据的周期返回上一周期的值;为0表示不做平滑处理
  JOB_DOWNLOAD_VARIANT: 305, //CAPITAL , TOTALCAPITAL, EXCHANGE

  JOB_CUSTOM_FUNCTION_DATA: 6000, //自定义函数
  JOB_CUSTOM_VARIANT_DATA: 6001, //自定义变量

  JOB_DOWNLOAD_MARGIN_BALANCE: 1000, //融资融券余额
  JOB_DOWNLOAD_MARGIN_RATE: 1001, //融资占比

  JOB_DOWNLOAD_MARGIN_BUY_BALANCE: 1010, //买入信息-融资余额
  JOB_DOWNLOAD_MARGIN_BUY_AMOUNT: 1011, //买入信息-买入额
  JOB_DOWNLOAD_MARGIN_BUY_REPAY: 1012, //买入信息-偿还额
  JOB_DOWNLOAD_MARGIN_BUY_NET: 1013, //买入信息-融资净买入

  JOB_DOWNLOAD_MARGIN_SELL_BALANCE: 1020, //卖出信息-融券余量
  JOB_DOWNLOAD_MARGIN_SELL_VOLUME: 1021, //卖出信息-卖出量
  JOB_DOWNLOAD_MARGIN_SELL_REPAY: 1022, //卖出信息-偿还量
  JOB_DOWNLOAD_MARGIN_SELL_NET: 1023, //卖出信息-融券净卖出

  JOB_DOWNLOAD_NEWS_ANALYSIS_NEGATIVE: 2000, //负面新闻统计
  JOB_DOWNLOAD_NEWS_ANALYSIS_RESEARCH: 2001, //机构调研
  JOB_DOWNLOAD_NEWS_ANALYSIS_INTERACT: 2002, //互动易
  JOB_DOWNLOAD_NEWS_ANALYSIS_HOLDERCHANGE: 2003, //股东增持
  JOB_DOWNLOAD_NEWS_ANALYSIS_HOLDERCHANGE2: 2004, //股东减持
  JOB_DOWNLOAD_NEWS_ANALYSIS_TRUSTHOLDER: 2005, //信托持股
  JOB_DOWNLOAD_NEWS_ANALYSIS_BLOCKTRADING: 2006, //大宗交易
  JOB_DOWNLOAD_NEWS_ANALYSIS_COMPANYNEWS: 2007, //官网新闻
  JOB_DOWNLOAD_NEWS_ANALYSIS_TOPMANAGERS: 2008, //高管要闻
  JOB_DOWNLOAD_NEWS_ANALYSIS_PLEDGE: 2009 }, _defineProperty(_JS_EXECUTE_JOB_ID, "JOB_CUSTOM_FUNCTION_DATA",

6000), _defineProperty(_JS_EXECUTE_JOB_ID, "JOB_CUSTOM_VARIANT_DATA",
6001), _defineProperty(_JS_EXECUTE_JOB_ID, "JOB_DOWNLOAD_CUSTOM_API_DATA",

30000), _defineProperty(_JS_EXECUTE_JOB_ID, "JOB_RUN_SCRIPT",

10000), _defineProperty(_JS_EXECUTE_JOB_ID, "GetMarginJobID",


function GetMarginJobID(value)
{
  var dataMap = new Map([
  [1, JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BALANCE], //MARGIN(1)   融资融券余额
  [2, JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_RATE], //MARGIN(2)   融资占比

  [3, JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_BALANCE], //MARGIN(3)   买入信息-融资余额
  [4, JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_AMOUNT], //MARGIN(4)   买入信息-买入额
  [5, JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_REPAY], //MARGIN(5)   买入信息-偿还额
  [6, JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_NET], //MARGIN(6)   买入信息-融资净买入

  [7, JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_BALANCE], //MARGIN(7)   卖出信息-融券余量
  [8, JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_VOLUME], //MARGIN(8)   卖出信息-卖出量
  [9, JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_REPAY], //MARGIN(9)   卖出信息-偿还量
  [10, JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_NET] //MARGIN(10)  卖出信息-融券净卖出
  ]);

  if (dataMap.has(value)) return dataMap.get(value);

  return null;
}), _defineProperty(_JS_EXECUTE_JOB_ID, "GetNewsAnalysisID",

function GetNewsAnalysisID(value)
{
  var dataMap = new Map([
  [1, JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_NEGATIVE], //NEWS(1)   负面新闻统计
  [2, JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_RESEARCH], //NEWS(2)   机构调研统计
  [3, JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_INTERACT], //NEWS(3)   互动易
  [4, JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_HOLDERCHANGE], //NEWS(4)   股东增持
  [5, JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_HOLDERCHANGE2], //NEWS(5)   股东减持
  [6, JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_TRUSTHOLDER], //NEWS(6)   信托持股
  [7, JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_BLOCKTRADING], //NEWS(7)   大宗交易
  [8, JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_COMPANYNEWS], //NEWS(8)   官网新闻
  [9, JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_TOPMANAGERS], //NEWS(9)   高管要闻
  [10, JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_PLEDGE] //NEWS(10)  股权质押    
  ]);

  if (dataMap.has(value)) return dataMap.get(value);

  return null;
}), _JS_EXECUTE_JOB_ID);



function JSExecute(ast, option)
{
  this.AST = ast; //语法树

  this.ErrorHandler = new ErrorHandler();
  this.VarTable = new Map(); //变量表
  this.OutVarTable = new Array(); //输出变量
  this.Arguments = [];

  //脚本自动变量表, 只读
  this.ConstVarTable = new Map([
  //个股数据
  ['CLOSE', null], ['VOL', null], ['OPEN', null], ['HIGH', null], ['LOW', null], ['AMOUNT', null], ['AMO', null], ['VOLINSTK', null],
  ['C', null], ['V', null], ['O', null], ['H', null], ['L', null], ['VOLR', null],

  //日期类
  ['DATE', null], ['YEAR', null], ['MONTH', null], ['PERIOD', null], ['WEEK', null], ["TIME", null],

  //大盘数据
  ['INDEXA', null], ['INDEXC', null], ['INDEXH', null], ['INDEXL', null], ['INDEXO', null], ['INDEXV', null],
  ['INDEXADV', null], ['INDEXDEC', null],

  ['CURRBARSCOUNT', null], //到最后交易日的周期数
  ['ISLASTBAR', null], //判断是否为最后一个周期

  ["TOTALCAPITAL", null], //总股本
  ['CAPITAL', null], //流通股本（手）
  ['EXCHANGE', null], //换手率
  ['SETCODE', null], //市场类型
  ['CODE', null], //品种代码
  ['STKNAME', null], //品种名称 

  ['HYBLOCK', null], //所属行业板块
  ['DYBLOCK', null], //所属地域板块
  ['GNBLOCK', null], //所属概念

  ['DRAWNULL', null]]);


  this.SymbolData = new JSSymbolData(this.AST, option, this);
  this.Algorithm = new JSAlgorithm(this.ErrorHandler, this.SymbolData);
  this.Draw = new JSDraw(this.ErrorHandler, this.SymbolData);
  this.JobList = []; //执行的任务队列

  this.UpdateUICallback = null; //回调
  this.CallbackParam = null;

  if (option)
  {
    if (option.Callback) this.UpdateUICallback = option.Callback;
    if (option.CallbackParam) this.CallbackParam = option.CallbackParam;
    if (option.Arguments) this.Arguments = option.Arguments;
  }

  this.Execute = function ()
  {
    //JSConsole.Complier.Log('[JSExecute::Execute] JobList', this.JobList);
    this.RunNextJob();
  };

  this.RunNextJob = function ()
  {
    if (this.JobList.length <= 0) return;

    var jobItem = this.JobList.shift();

    switch (jobItem.ID) {

      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_SYMBOL_DATA:
        return this.SymbolData.GetSymbolData();
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_INDEX_DATA:
        return this.SymbolData.GetIndexData();
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_INDEX_INCREASE_DATA:
        return this.SymbolData.GetIndexIncreaseData(jobItem);
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_SYMBOL_LATEST_DATA:
        return this.SymbolData.GetLatestData();
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_VOLR_DATA: //量比
        return this.SymbolData.GetVolRateData(jobItem);
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_GROUP_DATA:
        return this.SymbolData.GetGroupData(jobItem); //行业|概念|地区

      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_FINONE:
        return this.SymbolData.GetFinOne(jobItem);
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_FINVALUE:
        return this.SymbolData.GetFinValue(jobItem);
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_FINANCE:
        return this.SymbolData.GetFinance(jobItem);
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_GPJYVALUE:
        return this.SymbolData.GetGPJYValue(jobItem);

      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_VARIANT: //CAPITAL, TOTALCAPITAL 
        return this.SymbolData.GetVariantData(jobItem);

      case JS_EXECUTE_JOB_ID.JOB_CUSTOM_VARIANT_DATA:
        return this.SymbolData.GetCustomVariantData(jobItem);

      case JS_EXECUTE_JOB_ID.JOB_CUSTOM_FUNCTION_DATA:
        return this.SymbolData.GetCustomFunctionData(jobItem);

      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BALANCE:
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_RATE:
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_BALANCE: //买入信息-融资余额
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_AMOUNT: //买入信息-买入额
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_REPAY: //买入信息-偿还额
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_BUY_NET: //买入信息-融资净买入
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_BALANCE: //卖出信息-融券余量
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_VOLUME: //卖出信息-卖出量
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_REPAY: //卖出信息-偿还量
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_MARGIN_SELL_NET: //卖出信息-融券净卖出
        return this.SymbolData.GetMarginData(jobItem.ID);

      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_NEGATIVE: //负面新闻
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_RESEARCH: //机构调研
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_INTERACT: //互动易
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_HOLDERCHANGE: //股东增持
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_HOLDERCHANGE2: //股东减持
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_TRUSTHOLDER: //信托持股
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_BLOCKTRADING: //大宗交易
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_COMPANYNEWS: //官网新闻
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_TOPMANAGERS: //高管要闻
      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_NEWS_ANALYSIS_PLEDGE: //股权质押
        return this.SymbolData.GetNewsAnalysisData(jobItem.ID);

      case JS_EXECUTE_JOB_ID.JOB_DOWNLOAD_CUSTOM_API_DATA:
        return this.SymbolData.DownloadCustomAPIData(jobItem);

      case JS_EXECUTE_JOB_ID.JOB_RUN_SCRIPT:
        return this.Run();}

  };

  this.ReadSymbolData = function (name, node)
  {
    switch (name) {

      case 'CLOSE':
      case 'C':
      case 'VOL':
      case 'V':
      case 'OPEN':
      case 'O':
      case 'HIGH':
      case 'H':
      case 'LOW':
      case 'L':
      case 'AMOUNT':
      case 'VOLINSTK':
        return this.SymbolData.GetSymbolCacheData(name);
      case 'VOLR':
        return this.SymbolData.GetVolRateCacheData(node);

      //大盘数据
      case 'INDEXA':
      case 'INDEXC':
      case 'INDEXH':
      case 'INDEXO':
      case 'INDEXV':
      case 'INDEXL':
      case 'INDEXADV':
      case 'INDEXDEC':
        return this.SymbolData.GetIndexCacheData(name);

      case 'CURRBARSCOUNT':
        return this.SymbolData.GetCurrBarsCount();
      case 'ISLASTBAR':
        return this.SymbolData.GetIsLastBar();
      case "TOTALCAPITAL":
      case 'CAPITAL':
      case 'EXCHANGE':
        return this.SymbolData.GetStockCacheData({ VariantName: name, Node: node });
      case 'SETCODE':
        return this.SymbolData.SETCODE();

      case 'CODE':
        return this.SymbolData.GetSymbol();
      case 'STKNAME':
        return this.SymbolData.GetName();
      case 'HYBLOCK':
        return this.SymbolData.GetIndustry();
      case 'DYBLOCK':
        return this.SymbolData.GetRegion();
      case 'GNBLOCK':
        return this.SymbolData.GetConcept();

      case 'TIME':
        return this.SymbolData.TIME();
      case 'DATE':
        return this.SymbolData.DATE();
      case 'YEAR':
        return this.SymbolData.YEAR();
      case 'MONTH':
        return this.SymbolData.MONTH();
      case 'WEEK':
        return this.SymbolData.WEEK();
      case 'PERIOD':
        return this.SymbolData.PERIOD();

      case 'DRAWNULL':
        return this.SymbolData.GetDrawNull();}

  };

  this.ReadCustomVariant = function (name, node)
  {
    return this.SymbolData.GetStockCacheData({ VariantName: name, Node: node });
  };

  //读取变量
  this.ReadVariable = function (name, node)
  {
    if (this.ConstVarTable.has(name))
    {
      var data = this.ConstVarTable.get(name);

      if (data == null) //动态加载,用到再加载
        {
          data = this.ReadSymbolData(name, node);
          this.ConstVarTable.set(name, data);
        }

      return data;
    }

    if (g_JSComplierResource.IsCustomVariant(name)) return this.ReadCustomVariant(name, node); //读取自定义变量

    if (this.VarTable.has(name)) return this.VarTable.get(name);

    this.ThrowUnexpectedNode(node, '变量' + name + '不存在');
    return null;
  };

  this.ReadMemberVariable = function (node)
  {
    var obj = node.Object;
    var member = node.Property;

    var maiObj;
    if (obj.Type == Syntax.BinaryExpression || obj.Type == Syntax.LogicalExpression)
    maiObj = this.VisitBinaryExpression(obj);else
    if (obj.Type == Syntax.CallExpression)
    maiObj = this.VisitCallExpression(obj);else

    maiObj = this.GetNodeValue(obj);

    if (!maiObj) return null;
    var value = maiObj[member.Name];
    if (value) return value;

    return null;
  };

  //单数据转成数组 个数和历史数据一致
  this.SingleDataToArrayData = function (value)
  {
    var count = this.SymbolData.Data.Data.length;
    var result = [];
    for (var i = 0; i < count; ++i)
    {
      result[i] = value;
    }

    return result;
  };

  this.RunAST = function ()
  {
    //预定义的变量
    for (var i in this.Arguments)
    {
      var _item8 = this.Arguments[i];
      this.VarTable.set(_item8.Name, _item8.Value);
    }

    if (!this.AST) this.ThrowError();
    if (!this.AST.Body) this.ThrowError();

    for (var _i42 in this.AST.Body)
    {
      var _item9 = this.AST.Body[_i42];
      this.VisitNode(_item9);

      //输出变量
      if (_item9.Type == Syntax.ExpressionStatement && _item9.Expression)
      {
        if (_item9.Expression.Type == Syntax.AssignmentExpression && _item9.Expression.Operator == ':' && _item9.Expression.Left)
        {
          var assignmentItem = _item9.Expression;
          var _varName = assignmentItem.Left.Name;
          var _outVar = this.VarTable.get(_varName);
          if (!Array.isArray(_outVar))
          {
            if (typeof _outVar == 'string') _outVar = this.SingleDataToArrayData(parseFloat(_outVar));else
            _outVar = this.SingleDataToArrayData(_outVar);
          }

          this.OutVarTable.push({ Name: _varName, Data: _outVar, Type: 0 });
        } else
        if (_item9.Expression.Type == Syntax.CallExpression)
        {
          var callItem = _item9.Expression;
          if (this.Draw.IsDrawFunction(callItem.Callee.Name))
          {
            var draw = callItem.Draw;
            draw.Name = callItem.Callee.Name;
            this.OutVarTable.push({ Name: draw.Name, Draw: draw, Type: 1 });
          } else

          {
            var _outVar2 = callItem.Out;
            varName = "__temp_c_".concat(callItem.Callee.Name, "_").concat(_i42, "__");
            var type = 0;
            if (!Array.isArray(_outVar2)) _outVar2 = this.SingleDataToArrayData(_outVar2);
            this.OutVarTable.push({ Name: varName, Data: _outVar2, Type: type, NoneName: true });
          }
        } else
        if (_item9.Expression.Type == Syntax.Identifier)
        {
          var _varName2 = _item9.Expression.Name;
          var _outVar3 = this.ReadVariable(_varName2, _item9.Expression);
          var type = 0;
          if (!Array.isArray(_outVar3))
          {
            if (typeof _outVar3 == 'string') _outVar3 = this.SingleDataToArrayData(parseFloat(_outVar3));else
            _outVar3 = this.SingleDataToArrayData(_outVar3);
          }

          _varName2 = "__temp_i_" + _i42 + "__";
          this.OutVarTable.push({ Name: _varName2, Data: _outVar3, Type: type, NoneName: true });
        } else
        if (_item9.Expression.Type == Syntax.BinaryExpression)
        {
          var varName = "__temp_b_" + _i42 + "__";
          var _outVar4 = _item9.Expression.Out;
          var type = 0;
          if (!Array.isArray(_outVar4)) _outVar4 = this.SingleDataToArrayData(_outVar4);
          this.OutVarTable.push({ Name: varName, Data: _outVar4, Type: type, NoneName: true });
        } else
        if (_item9.Expression.Type == Syntax.LogicalExpression) //逻辑语句 如 T1 AND T2 
          {
            var varName = "__temp_l_" + _i42 + "__";
            var _outVar5 = _item9.Expression.Out;
            var type = 0;
            if (!Array.isArray(_outVar5)) _outVar5 = this.SingleDataToArrayData(_outVar5);
            this.OutVarTable.push({ Name: varName, Data: _outVar5, Type: type, NoneName: true });
          } else
        if (_item9.Expression.Type == Syntax.SequenceExpression)
        {
          var _varName3 = void 0;
          var _draw = void 0;
          var color = void 0;
          var lineWidth = void 0;
          var colorStick = false;
          var pointDot = false;
          var circleDot = false;
          var lineStick = false;
          var stick = false;
          var volStick = false;
          var isShow = true;
          var isExData = false;
          var isDotLine = false;
          var isOverlayLine = false; //叠加线
          var isNoneName = false;
          var isShowTitle = true;
          //显示在位置之上,对于DRAWTEXT和DRAWNUMBER等函数有用,放在语句的最后面(不能与LINETHICK等函数共用),比如:
          //DRAWNUMBER(CLOSE>OPEN,HIGH,CLOSE),DRAWABOVE;
          var isDrawAbove = false;
          for (var j in _item9.Expression.Expression)
          {
            var itemExpression = _item9.Expression.Expression[j];
            if (itemExpression.Type == Syntax.AssignmentExpression && itemExpression.Operator == ':' && itemExpression.Left)
            {
              _varName3 = itemExpression.Left.Name;
              var varValue = this.VarTable.get(_varName3);
              if (!Array.isArray(varValue))
              {
                varValue = this.SingleDataToArrayData(varValue);
                this.VarTable.set(_varName3, varValue); //把常量放到变量表里
              }
            } else
            if (itemExpression.Type == Syntax.Identifier)
            {
              var value = itemExpression.Name;
              if (value === 'COLORSTICK') colorStick = true;else
              if (value === 'POINTDOT') pointDot = true;else
              if (value === 'CIRCLEDOT') circleDot = true;else
              if (value == 'DOTLINE') isDotLine = true;else
              if (value === 'LINESTICK') lineStick = true;else
              if (value === 'STICK') stick = true;else
              if (value === 'VOLSTICK') volStick = true;else
              if (value === "DRAWABOVE") isDrawAbove = true;else
              if (value.indexOf('COLOR') == 0) color = value;else
              if (value.indexOf('LINETHICK') == 0) lineWidth = value;else
              if (value.indexOf('NODRAW') == 0) isShow = false;else
              if (value.indexOf('EXDATA') == 0) isExData = true; //扩展数据, 不显示再图形里面
              else if (value.indexOf('LINEOVERLAY') == 0) isOverlayLine = true;else
                if (value.indexOf("NOTEXT") == 0 || value.indexOf("NOTITLE") == 0) isShowTitle = false; //标题不显示
                else
                  {
                    _varName3 = itemExpression.Name;
                    var _varValue = this.ReadVariable(_varName3, itemExpression);
                    if (!Array.isArray(_varValue)) _varValue = this.SingleDataToArrayData(_varValue);
                    _varName3 = "__temp_si_" + _i42 + "__";
                    isNoneName = true;
                    this.VarTable.set(_varName3, _varValue); //放到变量表里
                  }
            } else
            if (itemExpression.Type == Syntax.Literal) //常量
              {
                var aryValue = this.SingleDataToArrayData(itemExpression.Value);
                _varName3 = itemExpression.Value.toString();
                this.VarTable.set(_varName3, aryValue); //把常量放到变量表里
              } else
            if (itemExpression.Type == Syntax.CallExpression)
            {
              if (this.Draw.IsDrawFunction(itemExpression.Callee.Name))
              {
                _draw = itemExpression.Draw;
                _draw.Name = itemExpression.Callee.Name;
              } else

              {
                var _varValue2 = itemExpression.Out;
                _varName3 = "__temp_sc_".concat(itemExpression.Callee.Name, "_").concat(_i42, "__");
                isNoneName = true;
                this.VarTable.set(_varName3, _varValue2);
              }
            } else
            if (itemExpression.Type == Syntax.BinaryExpression)
            {
              _varName3 = "__temp_sb_" + _i42 + "__";
              var _aryValue = itemExpression.Out;
              isNoneName = true;
              this.VarTable.set(_varName3, _aryValue);
            }
          }

          if (pointDot && _varName3) //圆点
            {
              var _outVar6 = this.VarTable.get(_varName3);
              var _value = { Name: _varName3, Data: _outVar6, Radius: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.POINTDOT.Radius, Type: 3 };
              if (color) _value.Color = color;
              if (lineWidth) _value.LineWidth = lineWidth;
              this.OutVarTable.push(_value);
            } else
          if (circleDot && _varName3) //圆点
            {
              var _outVar7 = this.VarTable.get(_varName3);
              var _value2 = { Name: _varName3, Data: _outVar7, Radius: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.CIRCLEDOT.Radius, Type: 3 };
              if (color) _value2.Color = color;
              if (lineWidth) _value2.LineWidth = lineWidth;
              this.OutVarTable.push(_value2);
            } else
          if (lineStick && _varName3) //LINESTICK  同时画出柱状线和指标线
            {
              var _outVar8 = this.VarTable.get(_varName3);
              var _value3 = { Name: _varName3, Data: _outVar8, Type: 4 };
              if (color) _value3.Color = color;
              if (lineWidth) _value3.LineWidth = lineWidth;
              this.OutVarTable.push(_value3);
            } else
          if (stick && _varName3) //STICK 画柱状线
            {
              var _outVar9 = this.VarTable.get(_varName3);
              var _value4 = { Name: _varName3, Data: _outVar9, Type: 5 };
              if (color) _value4.Color = color;
              if (lineWidth) _value4.LineWidth = lineWidth;
              this.OutVarTable.push(_value4);
            } else
          if (volStick && _varName3) //VOLSTICK   画彩色柱状线
            {
              var _outVar10 = this.VarTable.get(_varName3);
              var _value5 = { Name: _varName3, Data: _outVar10, Type: 6 };
              if (color) _value5.Color = color;
              this.OutVarTable.push(_value5);
            } else
          if (colorStick && _varName3) //CYW: SUM(VAR4,10)/10000, COLORSTICK; 画上下柱子
            {
              var _outVar11 = this.VarTable.get(_varName3);
              var _value6 = { Name: _varName3, Data: _outVar11, Color: color, Type: 2 };
              if (lineWidth) _value6.LineWidth = lineWidth;
              if (color) _value6.Color = color;
              this.OutVarTable.push(_value6);
            } else
          if (_varName3 && color)
          {
            var _outVar12 = this.VarTable.get(_varName3);
            var _value7 = { Name: _varName3, Data: _outVar12, Color: color, Type: 0 };
            if (lineWidth) _value7.LineWidth = lineWidth;
            if (isShow == false) _value7.IsShow = false;
            if (isExData == true) _value7.IsExData = true;
            if (isDotLine == true) _value7.IsDotLine = true;
            if (isOverlayLine == true) _value7.IsOverlayLine = true;
            if (isNoneName == true) _value7.NoneName = true;
            if (isShowTitle == false) _value7.IsShowTitle = false;
            this.OutVarTable.push(_value7);
          } else
          if (_draw)
          {
            var outVar = { Name: _draw.Name, Draw: _draw, Type: 1 };
            if (color) outVar.Color = color;
            if (lineWidth) outVar.LineWidth = lineWidth;
            if (isDrawAbove) outVar.IsDrawAbove = true;
            this.OutVarTable.push(outVar);
          } else
          if (_varName3)
          {
            var _outVar13 = this.VarTable.get(_varName3);
            var _value8 = { Name: _varName3, Data: _outVar13, Type: 0 };
            if (color) _value8.Color = color;
            if (lineWidth) _value8.LineWidth = lineWidth;
            if (isShow == false) _value8.IsShow = false;
            if (isExData == true) _value8.IsExData = true;
            if (isDotLine == true) _value8.IsDotLine = true;
            if (isOverlayLine == true) _value8.IsOverlayLine = true;
            if (isShowTitle == false) _value8.IsShowTitle = false;
            this.OutVarTable.push(_value8);
          }
        }
      }
    }

    //JSConsole.Complier.Log('[JSExecute::Run]', this.VarTable);

    return this.OutVarTable;
  };

  this.Run = function ()
  {
    var data = this.RunAST(); //执行脚本
    //JSConsole.Complier.Log('[JSComplier.Run] execute finish', data);

    if (this.UpdateUICallback)
    {
      //JSConsole.Complier.Log('[JSComplier.Run] invoke UpdateUICallback.');
      this.UpdateUICallback(data, this.CallbackParam);
    }
  };

  this.VisitNode = function (node)
  {
    switch (node.Type) {

      case Syntax.SequenceExpression:
        this.VisitSequenceExpression(node);
        break;
      case Syntax.ExpressionStatement:
        this.VisitNode(node.Expression);
        break;
      case Syntax.AssignmentExpression:
        this.VisitAssignmentExpression(node);
        break;
      case Syntax.BinaryExpression:
      case Syntax.LogicalExpression:
        this.VisitBinaryExpression(node);
        break;
      case Syntax.CallExpression:
        this.VisitCallExpression(node);
        break;}

  };

  this.VisitSequenceExpression = function (node)
  {
    for (var i in node.Expression)
    {
      var _item10 = node.Expression[i];
      this.VisitNode(_item10);
    }
  };

  //函数调用
  this.VisitCallExpression = function (node)
  {
    var funcName = node.Callee.Name;
    var args = [];
    for (var i in node.Arguments)
    {
      var _item11 = node.Arguments[i];
      var value = void 0;
      if (_item11.Type == Syntax.BinaryExpression || _item11.Type == Syntax.LogicalExpression)
      value = this.VisitBinaryExpression(_item11);else
      if (_item11.Type == Syntax.CallExpression)
      value = this.VisitCallExpression(_item11);else

      value = this.GetNodeValue(_item11);
      args.push(value);
    }

    //if (JS_EXECUTE_DEBUG_LOG) JSConsole.Complier.Log('[JSExecute::VisitCallExpression]' , funcName, '(', args.toString() ,')');
    if (g_JSComplierResource.IsCustomFunction(funcName)) //自定义函数 
      {
        var data = this.Algorithm.CallCustomFunction(funcName, args, this.SymbolData, node);
        node.Out = [];
        node.Draw = null;

        if (data)
        {
          if (data.Out) node.Out = data.Out;
          if (data.Draw) node.Draw = data.Draw;
        }

        return node.Out;
      }

    switch (funcName) {

      case 'DYNAINFO': //行情最新数据
        node.Out = this.SymbolData.GetLatestCacheData(args[0]);
        break;
      case 'STICKLINE':
        node.Draw = this.Draw.STICKLINE(args[0], args[1], args[2], args[3], args[4]);
        node.Out = [];
        break;
      case 'DRAWTEXT':
        node.Draw = this.Draw.DRAWTEXT(args[0], args[1], args[2]);
        node.Out = [];
        break;
      case 'SUPERDRAWTEXT':
        node.Draw = this.Draw.SUPERDRAWTEXT(args[0], args[1], args[2], args[3], args[4]);
        node.Out = [];
        break;
      case 'DRAWTEXT_FIX':
        node.Draw = this.Draw.DRAWTEXT_FIX(args[0], args[1], args[2], args[3], args[4]);
        node.Out = [];
        break;
      case 'DRAWICON':
        node.Draw = this.Draw.DRAWICON(args[0], args[1], args[2]);
        node.Out = [];
        break;
      case 'DRAWLINE':
        node.Draw = this.Draw.DRAWLINE(args[0], args[1], args[2], args[3], args[4]);
        node.Out = node.Draw.DrawData;
        break;
      case 'DRAWBAND':
        node.Draw = this.Draw.DRAWBAND(args[0], args[1], args[2], args[3]);
        node.Out = [];
        break;
      case 'DRAWKLINE':
        node.Draw = this.Draw.DRAWKLINE(args[0], args[1], args[2], args[3]);
        node.Out = [];
        break;
      case 'DRAWKLINE_IF':
        node.Draw = this.Draw.DRAWKLINE_IF(args[0], args[1], args[2], args[3], args[4]);
        node.Out = [];
        break;
      case 'PLOYLINE':
      case 'POLYLINE':
        node.Draw = this.Draw.POLYLINE(args[0], args[1]);
        node.Out = node.Draw.DrawData;
        break;
      case 'DRAWNUMBER':
        node.Draw = this.Draw.DRAWNUMBER(args[0], args[1], args[2]);
        node.Out = node.Draw.DrawData.Value;
        break;
      case 'RGB':
        node.Out = this.Draw.RGB(args[0], args[1], args[2]);
        break;
      case 'RGBA':
        node.Out = this.Draw.RGBA(args[0], args[1], args[2], args[3]);
        break;
      case 'DRAWRECTREL':
        node.Draw = this.Draw.DRAWRECTREL(args[0], args[1], args[2], args[3], args[4]);
        node.Out = [];
        break;
      case 'DRAWGBK':
        node.Draw = this.Draw.DRAWGBK(args[0], args[1], args[2], args[3]);
        node.Out = [];
        break;
      case 'DRAWGBK2':
        node.Draw = this.Draw.DRAWGBK2(args[0], args[1], args[2], args[3]);
        node.Out = [];
        break;
      case 'CODELIKE':
        node.Out = this.SymbolData.CODELIKE(args[0]);
        break;
      case 'NAMELIKE':
        node.Out = this.SymbolData.NAMELIKE(args[1]);
        break;
      case 'REFDATE':
        node.Out = this.SymbolData.REFDATE(args[0], args[1]);
        break;
      case 'FINANCE':
        node.Out = this.SymbolData.GetStockCacheData({ FunctionName: funcName, Args: args, ArgCount: 1, Node: node });
        break;
      case "FINVALUE":
        node.Out = this.SymbolData.GetStockCacheData({ FunctionName: funcName, Args: args, ArgCount: 1, Node: node });
        break;
      case "FINONE":
        node.Out = this.SymbolData.GetStockCacheData({ FunctionName: funcName, Args: args, ArgCount: 3, Node: node });
        break;
      case "GPJYVALUE":
        node.Out = this.SymbolData.GetStockCacheData({ FunctionName: funcName, Args: args, ArgCount: 3, Node: node });
        break;
      case "MARGIN":
        node.Out = this.SymbolData.GetMarginCacheData(args[0], node);
        break;
      case "NEWS":
        node.Out = this.SymbolData.GetNewsAnalysisCacheData(args[0], node);
        break;
      case 'UPCOUNT':
      case 'DOWNCOUNT':
        node.Out = this.SymbolData.GetIndexIncreaseCacheData(funcName, args[0], node);
        break;
      case 'LOADAPIDATA':
        node.Out = this.SymbolData.GetCustomApiData(args);
        break;
      default:
        node.Out = this.Algorithm.CallFunction(funcName, args, node);
        break;}


    return node.Out;
  };

  //赋值
  this.VisitAssignmentExpression = function (node)
  {
    var left = node.Left;
    if (left.Type != Syntax.Identifier) this.ThrowUnexpectedNode(node);

    var varName = left.Name;

    var right = node.Right;
    var value = null;
    if (right.Type == Syntax.BinaryExpression || right.Type == Syntax.LogicalExpression)
    value = this.VisitBinaryExpression(right);else
    if (right.Type == Syntax.CallExpression)
    value = this.VisitCallExpression(right);else
    if (right.Type == Syntax.Literal)
    value = right.Value;else
    if (right.Type == Syntax.Identifier) //右值是变量
      value = this.ReadVariable(right.Name, right);else
    if (right.Type == Syntax.MemberExpression)
    value = this.ReadMemberVariable(right);

    if (JS_EXECUTE_DEBUG_LOG) _umychartConsoleWechat.JSConsole.Complier.Log('[JSExecute::VisitAssignmentExpression]', varName, ' = ', value);
    this.VarTable.set(varName, value);
  };

  //逻辑运算
  this.VisitBinaryExpression = function (node)
  {
    var stack = [];
    stack.push(node);
    var temp = null;

    while (stack.length != 0)
    {
      temp = stack[stack.length - 1];
      if (temp.Left && node != temp.Left && node != temp.Right)
      {
        stack.push(temp.Left);
      } else
      if (temp.Right && node != temp.Right)
      {
        stack.push(temp.Right);
      } else

      {
        var value = stack.pop();
        if (value.Type == Syntax.BinaryExpression) //只遍历操作符就可以
          {
            var leftValue = this.GetNodeValue(value.Left);
            var rightValue = this.GetNodeValue(value.Right);

            if (JS_EXECUTE_DEBUG_LOG) _umychartConsoleWechat.JSConsole.Complier.Log('[JSExecute::VisitBinaryExpression] BinaryExpression', value, leftValue, rightValue);
            value.Out = null; //保存中间值

            switch (value.Operator) {

              case '-':
                value.Out = this.Algorithm.Subtract(leftValue, rightValue);
                break;
              case '*':
                value.Out = this.Algorithm.Multiply(leftValue, rightValue);
                break;
              case '/':
                value.Out = this.Algorithm.Divide(leftValue, rightValue);
                break;
              case '+':
                value.Out = this.Algorithm.Add(leftValue, rightValue);
                break;
              case '>':
                value.Out = this.Algorithm.GT(leftValue, rightValue);
                break;
              case '>=':
                value.Out = this.Algorithm.GTE(leftValue, rightValue);
                break;
              case '<':
                value.Out = this.Algorithm.LT(leftValue, rightValue);
                break;
              case '<=':
                value.Out = this.Algorithm.LTE(leftValue, rightValue);
                break;
              case '==':
              case '=':
                value.Out = this.Algorithm.EQ(leftValue, rightValue);
                break;
              case '!=':
              case '<>':
                value.Out = this.Algorithm.NEQ(leftValue, rightValue);
                break;}


            if (JS_EXECUTE_DEBUG_LOG) _umychartConsoleWechat.JSConsole.Complier.Log('[JSExecute::VisitBinaryExpression] BinaryExpression', value);
          } else
        if (value.Type == Syntax.LogicalExpression)
        {
          var _leftValue = this.GetNodeValue(value.Left);
          var _rightValue = this.GetNodeValue(value.Right);

          if (JS_EXECUTE_DEBUG_LOG) _umychartConsoleWechat.JSConsole.Complier.Log('[JSExecute::VisitBinaryExpression] LogicalExpression', value, _leftValue, _rightValue);
          value.Out = null; //保存中间值

          switch (value.Operator) {

            case '&&':
            case 'AND':
              value.Out = this.Algorithm.And(_leftValue, _rightValue);
              break;
            case '||':
            case 'OR':
              value.Out = this.Algorithm.Or(_leftValue, _rightValue);
              break;}


          if (JS_EXECUTE_DEBUG_LOG) _umychartConsoleWechat.JSConsole.Complier.Log('[JSExecute::VisitBinaryExpression] LogicalExpression', value);
        }

        node = temp;
      }
    }

    return node.Out;

  };

  this.GetNodeValue = function (node)
  {
    switch (node.Type) {

      case Syntax.Literal: //数字
        return node.Value;
      case Syntax.UnaryExpression:
        if (node.Operator == '-')
        {
          var _value9 = this.GetNodeValue(node.Argument);
          return this.Algorithm.Subtract(0, _value9);
        }
        return node.Argument.Value;
      case Syntax.Identifier:
        var value = this.ReadVariable(node.Name, node);
        return value;
      case Syntax.BinaryExpression:
      case Syntax.LogicalExpression:
        return node.Out;
      case Syntax.CallExpression:
        return this.VisitCallExpression(node);
      default:
        this.ThrowUnexpectedNode(node);}

  };

  this.ThrowUnexpectedNode = function (node, message)
  {
    var marker = node.Marker;
    var msg = message || "执行异常";

    return this.ErrorHandler.ThrowError(marker.Index, marker.Line, marker.Column, msg);

  };

  this.ThrowError = function ()
  {

  };
}

//对外导出类
function JSComplier()
{

}


//词法分析
JSComplier.Tokenize = function (code)
{
  //JSConsole.Complier.Log('[JSComplier.Tokenize]', code);
  var tokenizer = new Tokenizer(code);
  var tokens = [];
  try
  {
    while (true)
    {
      var token = tokenizer.GetNextToken();
      if (!token) break;

      tokens.push(token);
    }
  }
  catch (e)
  {

  }

  return tokens;
};

//语法解析 生成抽象语法树(Abstract Syntax Tree)
JSComplier.Parse = function (code)
{
  //JSConsole.Complier.Log('[JSComplier.Parse]',code);

  var parser = new JSParser(code);
  parser.Initialize();
  var program = parser.ParseScript();
  var ast = program;
  return ast;
};

/*
       执行
       option.Symbol=股票代码
       option.Name=股票名称
       option.Data=这个股票的ChartData
       option.Right=复权
       option.MaxReqeustDataCount=请求数据的最大个数
   */

function timeout(ms) {
  return new Promise(function (resolve) {
    setTimeout(resolve, ms);
  });
}


JSComplier.Execute = function (code, option, errorCallback)
{
  //异步调用
  var asyncExecute = function asyncExecute()
  {
    try
    {
      //JSConsole.Complier.Log('[JSComplier.Execute] code ',code);

      //JSConsole.Complier.Log('[JSComplier.Execute] parser .....');
      var parser = new JSParser(code);
      parser.Initialize();
      var program = parser.ParseScript();

      var ast = program;
      //JSConsole.Complier.Log('[JSComplier.Execute] parser finish.', ast);

      //JSConsole.Complier.Log('[JSComplier.Execute] execute .....');
      var execute = new JSExecute(ast, option);
      execute.JobList = parser.Node.GetDataJobList();
      execute.JobList.push({ ID: JS_EXECUTE_JOB_ID.JOB_RUN_SCRIPT });

      var result = execute.Execute();

    } catch (error)
    {
      _umychartConsoleWechat.JSConsole.Complier.Log(error);

      if (errorCallback) errorCallback(error);
    }
  };

  asyncExecute();

  //JSConsole.Complier.Log('[JSComplier.Execute] async execute.');
};

JSComplier.SetDomain = function (domain, cacheDomain)
{
  if (domain) g_JSComplierResource.Domain = domain;
  if (cacheDomain) g_JSComplierResource.CacheDomain = cacheDomain;
};

JSComplier.AddFunction = function (obj) //添加函数 { Name:函数名, Description:描述信息, IsDownload:是否需要下载数据, Invoke:函数执行(可选) }
{
  if (!obj || !obj.Name) return;

  var ID = obj.Name.toUpperCase();
  g_JSComplierResource.CustomFunction.Data.set(ID, obj);
};

JSComplier.AddVariant = function (obj) //{ Name:变量名, Description:描述信息 }
{
  if (!obj || !obj.Name) return;

  var ID = obj.Name.toUpperCase();
  g_JSComplierResource.CustomVariant.Data.set(ID, obj);
};


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//数据下载
function DownloadFinanceData(obj)
{
  this.Url = obj.Url;
  this.RealtimeUrl = obj.RealtimeUrl;
  this.Job = obj.Job;
  this.Symbol = obj.Symbol;
  this.Args = obj.Args;
  this.DataKey = obj.DataKey;
  this.RecvCallback = obj.Callback;
  this.ErrorCallback = obj.ErrorCallback;

  this.Download = function ()
  {
    var id = this.Args[0];
    switch (id) {

      case 1: //FINANCE(1) 总股本(随时间可能有变化) 股
      case 7: //FINANCE(7) 流通股本(随时间可能有变化) 股
      case "EXCHANGE": //换手率
        this.DownloadHistoryData(id);
        break;

      case 9: //FINANCE(9)  资产负债率
      case 18: //FINANCE(18)  每股公积金
      case 30: //FINANCE(30)  净利润
      case 32: //FINANCE(32)  每股未分配利润
      case 33: //FINANCE(33)  每股收益(折算为全年收益),对于沪深品种有效
      case 34: //FINANCE(34)  每股净资产
      case 38: //FINANCE(38)  每股收益(最近一期季报)
      case 40: //FINANCE(40)  流通市值 
      case 41: //FINANCE(41)  总市值
      case 42: //FINANCE(42)  上市的天数
      case 43: //FINANCE(43)  利润同比

      case "CAPITAL":
      case "TOTALCAPITAL":

      //定制
      case 100: //股东人数
        this.DownloadRealtimeData(id);
        break;

      default:
        this.DownloadRealtimeData(id);
        break;}

  };

  //最新一期数据
  this.DownloadRealtimeData = function (id)
  {
    var self = this;
    var fieldList = this.GetFieldList();
    if (!fieldList)
    {
      if (this.Job.FunctionName2) message = "".concat(this.Job.FunctionName2, " can't support.");else
      if (this.Job.FunctionName) message = "".concat(this.Job.FunctionName, "(").concat(this.Args[0], ") can't support.");else
      message = "".concat(this.Args[0], " can't support.");
      this.ErrorCallback(message);
      self.RecvCallback(null, self.Job, self.DataKey);
      return;
    }

    //请求数据
    wx.request({
      url: this.RealtimeUrl,
      data:
      {
        "field": fieldList,
        "symbol": [this.Symbol],
        "condition": [],
        "start": 0,
        "end": 10 },

      method: 'POST',
      dataType: "json",
      async: true,
      success: function success(recvData)
      {
        var data = self.RealtimeDataToHQChartData(recvData.data);
        self.RecvCallback(data, self.Job, self.DataKey);
      } });

  };

  //历史数据
  this.DownloadHistoryData = function (id)
  {
    var self = this;
    var fieldList = this.GetFieldList();
    if (!fieldList)
    {
      message = "".concat(this.Job.FunctionName, "(").concat(this.Args[0], ") can't support.");
      this.ErrorCallback(message);
      self.RecvCallback(null, self.Job, self.DataKey);
      return;
    }

    //请求数据
    wx.request({
      url: this.Url,
      data:
      {
        "field": fieldList,
        "symbol": [this.Symbol],
        "condition": [],
        "start": 0,
        "end": 200 },

      method: 'POST',
      dataType: "json",
      async: true,
      success: function success(recvData)
      {
        var data = self.ToHQChartData(recvData.data);
        if (data) //排序
          data.sort(function (a, b) {return a.Date - b.Date;});

        self.RecvCallback(data, self.Job, self.DataKey);
      } });

  };

  this.GetFieldList = function ()
  {
    var id = this.Args[0];
    switch (id) {

      case 1:
        return ["capital.total", "capital.date"];
      case 7:
        return ["capital.a", "capital.date"];
      case "EXCHANGE":
        return ["capital.a", "capital.date"];

      case 9:
        return ["finance.peruprofit", "symbol", "date"];
      case 18:
        return ["finance.percreserve", "symbol", "date"];
      case 30:
        return ["finance.nprofit", "symbol", "date"];
      case 32:
        return ["finance.peruprofit", "symbol", "date"];
      case 33:
        return ["finance.persearning", "symbol", "date"];
      case 34:
        return ["finance.pernetasset", "symbol", "date"];
      case 38:
        return ["finance.persearning", "symbol", "date"];
      case 40:
        return ["capital.a", "capital.date", "symbol", "date", "price"];
      case 41:
        return ["capital.total", "capital.date", "symbol", "date", "price"];
      case "CAPITAL":
        return ["capital.a", "capital.date", "symbol", "date"];
      case "TOTALCAPITAL":
        return ["capital.total", "capital.date", "symbol", "date"];
      case 42:
        return ["company.releasedate", "symbol", "date"];
      case 43:
        return ["dividendyield", "symbol", "date"];
      case 100:
        return ["shareholder", "symbol", "date"];
      default:
        return null;}

  };

  //最新报告期数据
  this.RealtimeDataToHQChartData = function (recvData, id)
  {
    if (!recvData.stock || recvData.stock.length != 1) return null;
    var stock = recvData.stock[0];
    var id = this.Args[0];
    var date = stock.date;
    switch (id) {

      case 9:
        if (!stock.finance) return null;
        return { Date: date, Value: stock.finance.peruprofit };
      case 18:
        if (!stock.finance) return null;
        return { Date: date, Value: stock.finance.percreserve };
      case 30:
        if (!stock.finance) return null;
        return { Date: date, Value: stock.finance.nprofit };
      case 32:
        if (!stock.finance) return null;
        return { Date: date, Value: stock.finance.peruprofit };
      case 33:
        if (!stock.finance) return null;
        return { Date: date, Value: stock.finance.persearning };
      case 34:
        if (!stock.finance) return null;
        return { Date: date, Value: stock.finance.pernetasset };
      case 38:
        if (!stock.finance) return null;
        return { Date: date, Value: stock.finance.persearning };
      case 40: //FINANCE(40)  流通市值
        if (!stock.capital) return null;
        return { Date: date, Value: stock.capital.a * stock.price }; //流通股*最新价格
      case 41: //FINANCE(41)  总市值 
        if (!stock.capital) return null;
        return { Date: date, Value: stock.capital.total * stock.price }; //总股本*最新价格
      case 42: //FINANCE(42)  上市的天数
        if (!stock.company) return null;
        {
          var releaseDate = stock.company.releasedate;
          var year = parseInt(releaseDate / 10000);
          var month = parseInt(releaseDate % 10000 / 100);
          var day = releaseDate % 100;
          var firstDate = new Date(year, month - 1, day);
          var nowDate = new Date();
          var days = parseInt((nowDate.getTime() - firstDate.getTime()) / (1000 * 60 * 60 * 24));
          return { Date: date, Value: days + 1 };
        }
      case 43:
        if (!stock.dividendyield) return null;
        return { Date: date, Value: stock.dividendyield.quarter4 };
      case 100:
        if (!stock.shareholder) return null;
        return { Date: date, Value: stock.shareholder.count };
      case "CAPITAL":
        if (!stock.capital) return null;
        return { Date: date, Value: stock.capital.a / 100 }; //当前流通股本 手
      case "TOTALCAPITAL":
        if (!stock.capital) return null;
        return { Date: date, Value: stock.capital.total / 100 }; //当前流通股本 手    
    }
  };

  //历史数据转
  this.ToHQChartData = function (recvData)
  {
    if (!recvData.stock || recvData.stock.length != 1) return null;

    var aryData = [];
    var setDate = new Set(); //有重复数据 去掉
    var stock = recvData.stock[0];
    var id = this.Args[0];
    for (var i in stock.stockday)
    {
      var item = stock.stockday[i];

      var hqchartItem = this.ToHQChartItemData(item, id);
      if (hqchartItem && !setDate.has(hqchartItem.Date))
      {
        aryData.push(hqchartItem);
        setDate.add(hqchartItem.Date);
      }
    }

    return aryData;
  };

  this.ToHQChartItemData = function (item, id)
  {
    if (!item) return null;
    var date = item.date;
    switch (id) {

      case 1:
        if (!item.capital) return null;
        return { Date: date, Value: item.capital.total };
      case 7:
      case "EXCHANGE": //换手率 历史流通股本
        if (!item.capital) return null;
        return { Date: date, Value: item.capital.a };

      default:
        return null;}

  };
}


//////////////////////////////////////////////////////////////////////////////////////////////
//内置财务数据下载
//
function DownloadFinValueData(obj)
{
  this.Url = obj.Url;
  this.Job = obj.Job;
  this.Symbol = obj.Symbol;
  this.Args = obj.Args;
  this.DataKey = obj.DataKey;
  this.RecvCallback = obj.Callback;
  this.ErrorCallback = obj.ErrorCallback;

  this.Download = function ()
  {
    var self = this;
    var fieldList = this.GetFieldList();
    if (!fieldList)
    {
      message = "".concat(this.Job.FunctionName, "(").concat(this.Args[0], ") can't support.");
      this.ErrorCallback(message);
      self.RecvCallback(null, self.Job, self.DataKey);
      return;
    }

    //请求数据
    wx.request({
      url: this.Url,
      data:
      {
        "field": fieldList,
        "symbol": [this.Symbol],
        "condition": [{ "item": ["finance", "doc", "exists", "true"] }],
        "start": 0,
        "end": 200 },

      method: 'POST',
      dataType: "json",
      async: true,
      success: function success(recvData)
      {
        var data = self.ToHQChartData(recvData.data);
        if (data) //排序
          data.sort(function (a, b) {return a.Date - b.Date;});

        self.RecvCallback(data, self.Job, self.DataKey);
      } });

  };

  this.ToHQChartData = function (recvData)
  {
    if (!recvData.stock || recvData.stock.length != 1) return null;

    var aryData = [];
    var setDate = new Set(); //有重复数据 去掉
    var stock = recvData.stock[0];
    for (var i in stock.stockday)
    {
      var item = stock.stockday[i];
      if (item.announcement1)
      {
        var hqchartItem = this.ToHQChartItemData(item.announcement1, item.finance1, item);
        if (hqchartItem && !setDate.has(hqchartItem.Date))
        {
          aryData.push(hqchartItem);
          setDate.add(hqchartItem.Date);
        }
      }

      if (item.announcement2)
      {
        var hqchartItem = this.ToHQChartItemData(item.announcement2, item.finance2, item);
        if (hqchartItem && !setDate.has(hqchartItem.Date))
        {
          aryData.push(hqchartItem);
          setDate.add(hqchartItem.Date);
        }
      }

      if (item.announcement3)
      {
        var hqchartItem = this.ToHQChartItemData(item.announcement3, item.finance3, item);
        if (hqchartItem && !setDate.has(hqchartItem.Date))
        {
          aryData.push(hqchartItem);
          setDate.add(hqchartItem.Date);
        }
      }

      if (item.announcement4)
      {
        var hqchartItem = this.ToHQChartItemData(item.announcement4, item.finance4, item);
        if (hqchartItem && !setDate.has(hqchartItem.Date))
        {
          aryData.push(hqchartItem);
          setDate.add(hqchartItem.Date);
        }
      }
    }

    return aryData;
  };

  //{ Date：日期 , Value:数值 }
  this.ToHQChartItemData = function (announcement, finance, sourceItem)
  {
    var id = this.Args[0];
    var date = announcement.year * 10000;
    var quarter = announcement.quarter;
    switch (quarter) {

      case 1:
        date += 331;
        break;
      case 2:
        date += 630;
        break;
      case 3:
        date += 930;
        break;
      case 4:
        date += 1231;
        break;
      default:
        return null;}


    var result = { Date: date, Value: 0 };
    switch (id) {

      case 0:
        result.Value = date % 1000000; //0--返回报告期(YYMMDD格式),150930表示为2015年第三季
        break;
      case 1:
        result.Value = finance.persearning;
        break;
      case 3:
        result.Value = finance.peruprofit;
        break;
      case 4:
        result.Value = finance.pernetasset;
        break;
      case 5:
        result.Value = finance.percreserve;
        break;
      case 6:
        result.Value = finance.woewa;
        break;
      case 7:
        result.Value = finance.perccfo;
        break;
      case 8:
        result.Value = finance.monetaryfunds;
        break;
      case 11:
        result.Value = finance.areceivable;
        break;}


    return result;
  };

  this.GetFieldList = function ()
  {
    var id = this.Args[0];
    switch (id) {

      case 0:
        return ["finance.date"];
      case 1: //persearning	每股收益
        return ["finance.persearning"];
      case 3: //peruprofit	每股未分配利润
        return ["finance.peruprofit"];
      case 4: //pernetasset	每股净资产
        return ["finance.pernetasset"];
      case 5: //percreserve	每股资本公积金
        return ["finance.percreserve"];
      case 6: //woewa	加权平均净资产收益
        return ["finance.woewa"];
      case 7: //perccfo	每股经营性现金流
        return ["finance.perccfo"];
      case 8: //monetaryfunds	货币资金
        return ["finance.monetaryfunds"];
      case 11: //areceivable	应收账款
        return ["finance.areceivable"];
      default:
        return null;}

  };
}


/////////////////////////////////////////////////////////
// 内置财务数据下载 某一期的数据
//
function DownloadFinOneData(obj)
{
  this.newMethod = DownloadFinValueData; //派生
  this.newMethod(obj);
  delete this.newMethod;

  this.Download = function ()
  {
    var self = this;
    var fieldList = this.GetFieldList();
    if (!fieldList)
    {
      message = "".concat(this.Job.FunctionName, "(").concat(this.Args[0], ", ").concat(this.Args[1], ", ").concat(this.Args[2], ") can't support.");
      this.ErrorCallback(message);
      self.RecvCallback(null, self.Job, self.DataKey);
      return;
    }

    var aryCondition = [{ "item": ["finance", "doc", "exists", "true"] }];

    var year = this.Args[1];
    var month = this.Args[2];
    var dataIndex = 0;
    var dataEnd = 3;
    var preYear = null;
    if (year == 0 && month == 0) //如果Y和MMDD都为0,表示最新的财报;
      {

      } else
    if (year == 0 && month < 300) //如果Y为0,MMDD为小于300的数字,表示最近一期向前推MMDD期的数据,如果是331,630,930,1231这些,表示最近一期的对应季报的数据;
      {
        dataIndex = month;
        dataEnd = 200;
      } else
    if (month == 0 && year < 1000) //如果Y为0,MMDD为小于300的数字,表示最近一期向前推MMDD期的数据,如果是331,630,930,1231这些,表示最近一期的对应季报的数据;
      {
        preYear = year;
      } else
    if (year > 1909)
    {
      if (month == 331)
      {
        aryCondition =
        [
        { "item": ["announcement1.year", "int32", "eq", year] },
        { "item": ["finance1", "doc", "exists", "true"] }];


        fieldList.push("announcement1.year");
        fieldList.push("announcement1.quarter");
      } else
      if (month == 630)
      {
        aryCondition =
        [
        { "item": ["announcement2.year", "int32", "eq", year] },
        { "item": ["finance2", "doc", "exists", "true"] }];


        fieldList.push("announcement2.year");
        fieldList.push("announcement2.quarter");
      } else
      if (month == 930)
      {
        aryCondition =
        [
        { "item": ["announcement3.year", "int32", "eq", year] },
        { "item": ["finance3", "doc", "exists", "true"] }];


        fieldList.push("announcement4.year");
        fieldList.push("announcement4.quarter");
      } else

      {
        aryCondition =
        [
        { "item": ["announcement4.year", "int32", "eq", year] },
        { "item": ["finance4", "doc", "exists", "true"] }];


        fieldList.push("announcement4.year");
        fieldList.push("announcement4.quarter");
      }
    }

    //请求数据
    wx.request({
      url: this.Url,
      data:
      {
        "field": fieldList,
        "symbol": [this.Symbol],
        "condition": aryCondition,
        "start": 0,
        "end": dataEnd },

      method: 'POST',
      dataType: "json",
      async: true,
      success: function success(recvData)
      {
        var data = self.ToHQChartData(recvData.data);
        var result = null;
        if (data && data.length > 0)
        {
          data.sort(function (a, b) {return b.Date - a.Date;});
          if (preYear == null)
          result = data[dataIndex]; //返回一个数据
          else
            result = self.GetPreYearData(data, preYear);
        }
        self.RecvCallback(result, self.Job, self.DataKey);
      } });

  };

  this.GetPreYearData = function (data, preYear)
  {
    //331,630,930,1231这些,表示最近一期的对应季报的数据;
    if (preYear == 331 || preYear == 630 || preYear == 930 || preYear == 1231)
    {
      for (var i in data)
      {
        var item = data[i];
        if (item.Date % 10000 == preYear) return item;
      }
    } else

    {
      //如果MMDD为0,Y为一数字,表示最近一期向前推Y年的同期数据;
      var month = data[0].Date % 1000;
      for (var i = 1, j = 0; i < data.length; ++i)
      {
        var item = data[i];
        if (item.Date % 10000 == month)
        {
          ++j;
          if (j == preYear) return item;
        }
      }

      return null;
    }
  };
}

function DownloadGPJYValue(obj)
{
  this.Url = obj.Url;
  this.RealtimeUrl = obj.RealtimeUrl;
  this.Job = obj.Job;
  this.Symbol = obj.Symbol;
  this.Args = obj.Args;
  this.DataKey = obj.DataKey;
  this.RecvCallback = obj.Callback;
  this.ErrorCallback = obj.ErrorCallback;

  this.Download = function ()
  {
    var self = this;
    var fieldList = this.GetFieldList();
    if (!fieldList)
    {
      message = "".concat(this.Job.FunctionName, "(").concat(this.Args[0], ", ").concat(this.Args[1], ", ").concat(this.Args[2], ") can't support.");
      this.ErrorCallback(message);
      self.RecvCallback(null, self.Job, self.DataKey, true);
      return;
    }

    //请求数据
    wx.request({
      url: this.Url,
      data:
      {
        "field": fieldList,
        "symbol": [this.Symbol],
        "orderfield": "date",
        "order": -1,
        "start": 0,
        "end": 5 },

      method: 'POST',
      dataType: "json",
      async: true,
      success: function success(recvData)
      {
        var data = self.ToHQChartData(recvData.data);
        if (data && data.length > 0)
        {
          data.sort(function (a, b) {return a.Date - b.Date;});
        }
        self.RecvCallback(data, self.Job, self.DataKey);
      } });

  };

  this.GetFieldList = function ()
  {
    var id = this.Args[0];
    switch (id) {

      case 1: //1--股东人数 股东户数(户)           
        return ["shareholder", "date", "symbol"];
      case 2: //2--龙虎榜   买入总计(万元) 卖出总计(万元)
        return ["tradedetail.buy", "tradedetail.sell", "date", "symbol"];
      case 3: //3--融资融券1 融资余额(万元) 融券余量(股)
        return ["margin", "date", "symbol"];
      case 4: //4--大宗交易 成交均价(元) 成交额(万元)
        return ["blocktrading.amount", "blocktrading.price", "date", "symbol"];
      default:
        return null;}

  };

  this.ToHQChartData = function (recvData)
  {
    if (!recvData.stock || recvData.stock.length != 1) return null;

    var aryData = [];
    var setDate = new Set(); //有重复数据 去掉
    var stock = recvData.stock[0];
    var id = this.Args[0];
    var subID = this.Args[1];
    for (var i in stock.stockday)
    {
      var item = stock.stockday[i];

      var hqchartItem = this.ToHQChartItemData(item, id, subID);
      if (hqchartItem && !setDate.has(hqchartItem.Date))
      {
        aryData.push(hqchartItem);
        setDate.add(hqchartItem.Date);
      }
    }

    return aryData;
  };

  this.ToHQChartItemData = function (item, id, subID)
  {
    if (!item) return null;
    var date = item.date;
    switch (id) {

      case 1:
        if (!item.shareholder) return null;
        return { Date: date, Value: item.shareholder.count };
      case 2:
        if (!item.tradedetail && item.tradedetail[0]) return null;
        if (subID == 0)
        return { Date: date, Value: item.tradedetail[0].buy };else

        return { Date: date, Value: item.tradedetail[0].sell };
      case 3:
        if (!item.margin) return null;
        if (subID == 0)
        {
          if (item.margin.buy)
          return { Date: date, Value: item.margin.buy.balance };
        } else

        {
          if (item.margin.sell)
          return { Date: date, Value: item.margin.sell.balance };
        }
        return null;
      case 4:
        if (!item.blocktrading) return null;
        if (subID == 0)
        return { Date: date, Value: item.blocktrading.price };else

        return { Date: date, Value: item.blocktrading.amount };
      default:
        return null;}

  };
}

/* 测试例子
  var code1='VARHIGH:IF(VAR1<=REF(HH,-1),REF(H,BARSLAST(VAR1>=REF(HH,1))),DRAWNULL),COLORYELLOW;';
  var code2='VAR1=((SMA(MAX((CLOSE - LC),0),3,1) / SMA(ABS((CLOSE - LC)),3,1)) * 100);';
  var code3='mm1=1-2*-9+20;';
  
  JSConsole.Complier.Log(code1+code2)
  var tokens=JSComplier.Tokenize(code1+code2);
  var ast=JSComplier.Parse(code2+code1);
  
  JSConsole.Complier.Log(ast);
  */


module.exports =
{
  JSCommonComplier:
  {
    JSComplier: JSComplier } };

/***/ }),
/* 108 */
/*!**********************************************************************!*\
  !*** I:/out-project/FCoinEx/static/js/umychart.index.data.wechat.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
    copyright (c) 2018 jones

    http://www.apache.org/licenses/LICENSE-2.0

    开源项目 https://github.com/jones2000/HQChart

    jones_2000@163.com

    系统录入的指标
*/

/*
       指标数据脚本 系统内置指标都写在这里
       Name：指标名字
       Args:参数 { Name:名字, Value=值 }
       Description：指标描述信息
       IsMainIndex：是否是主图指标 true=主图指标 false=副图指标
       KLineType:K线设置 -1=主图不显示K线(只在主图有效) 0=在副图显示K线 1=在副图显示K线(收盘价线) 2=在副图显示K线(美国线)
       InstructionType: 1=专家指示  2=五彩K线
       FloatPrecision: 小数位数 缺省=2
       StringFormat: 1=带单位万/亿 2=原始格式  缺省=1
       YSplitScale:  Y固定刻度 [1,8,10]
       YSpecificMaxMin: 固定Y轴最大最小值 { Max: 9, Min: 0, Count: 3 };
       OutName:动态输出变量名字 [{Name:原始变量名, DynamicName:动态名字格式}] 如 {Name:"MA1", DynamicName:"MA{M1}"};
   */

//周期条件枚举
var CONDITION_PERIOD =
{
  MINUTE_ID: 101, //分钟      走势图
  MULTIDAY_MINUTE_ID: 102, //多日分钟  走势图
  HISTORY_MINUTE_ID: 103, //历史分钟  走势图

  //K线周期
  KLINE_DAY_ID: 0,
  KLINE_WEEK_ID: 1,
  KLINE_MONTH_ID: 2,
  KLINE_YEAR_ID: 3,
  KLINE_MINUTE_ID: 4,
  KLINE_5_MINUTE_ID: 5,
  KLINE_15_MINUTE_ID: 6,
  KLINE_30_MINUTE_ID: 7,
  KLINE_60_MINUTE_ID: 8 };


//自定义的指标脚本
function CustomIndexScript()
{
  this.DataMap = new Map(); //key=指标id, value=data {ID:, Name：指标名字, Description：指标描述信息 Args:参数 ......}

  this.Get = function (id)
  {
    if (!this.DataMap.has(id)) return null;
    return this.DataMap.get(id);
  };

  this.Add = function (data)
  {
    this.DataMap.set(data.ID, data);
  };
}

var g_CustomIndex = new CustomIndexScript();

function JSIndexScript()
{
  this.DataMap = new Map(
  [
  ['MA', this.MA], ['均线', this.MA], ['BOLL', this.BOLL], ['BBI', this.BBI],
  ["MA4", this.MA4], ["MA5", this.MA5], ["MA6", this.MA6], ["MA7", this.MA7], ["MA8", this.MA8],
  ['DKX', this.DKX], ['MIKE', this.MIKE], ['PBX', this.PBX],
  ['ENE', this.ENE], ['MACD', this.MACD], ['KDJ', this.KDJ], ["MACD2", this.MACD2],
  ['VOL', this.VOL], ['成交量', this.VOL], ['RSI', this.RSI], ['BRAR', this.BRAR],
  ['WR', this.WR], ['BIAS', this.BIAS], ['OBV', this.OBV],
  ['DMI', this.DMI], ['CR', this.CR], ['PSY', this.PSY],
  ['CCI', this.CCI], ['DMA', this.DMA], ['TRIX', this.TRIX],
  ['VR', this.VR], ['EMV', this.EMV], ['ROC', this.ROC],
  ['MIM', this.MIM], ['FSL', this.FSL], ['CYR', this.CYR],
  ['MASS', this.MASS], ['WAD', this.WAD], ['CHO', this.CHO],
  ['ADTM', this.ADTM], ['HSL', this.HSL], ['BIAS36', this.BIAS36],
  ['BIAS_QL', this.BIAS_QL], ['DPO', this.DPO], ['OSC', this.OSC],
  ['ATR', this.ATR], ['NVI', this.NVI], ['PVI', this.PVI],
  ['UOS', this.UOS], ['CYW', this.CYW], ['LON', this.LON],
  ['NDB', this.NDB], ['SKDJ', this.SKDJ], ['KD', this.KD], ['FKX', this.FKX],
  ['DKCOL', this.DKCOL], ['UDL', this.UDL], ['MFI', this.MFI], ['LWR', this.LWR],
  ['MARSI', this.MARSI], ['CYD', this.CYD], ['CYF', this.CYF], ['TAPI', this.TAPI],
  ['VMACD', this.VMACD], ['QACD', this.QACD], ['VPT', this.VPT], ['WVAD', this.WVAD],
  ['DBQR', this.DBQR], ['JS', this.JS], ['CYE', this.CYE], ['QR', this.QR], ['GDX', this.GDX],
  ['JLHB', this.JLHB], ['PCNT', this.PCNT], ['BTX', this.BTX], ['AMO', this.AMO],
  ['VRSI', this.VRSI], ['HSCOL', this.HSCOL], ['DBQRV', this.DBQRV], ['DBLB', this.DBLB],
  ['ACD', this.ACD], ['EXPMA', this.EXPMA], ['EXPMA_S', this.EXPMA_S], ['HMA', this.HMA],
  ['LMA', this.LMA], ['VMA', this.VMA], ['AMV', this.AMV], ['BBIBOLL', this.BBIBOLL],
  ['ALLIGAT', this.ALLIGAT], ['ZX', this.ZX], ['XS', this.XS], ['XS2', this.XS2],
  ['SG-XDT', this.SG_XDT], ['SG-SMX', this.SG_SMX], ['SG-LB', this.SG_LB], ['SG-PF', this.SG_PF],
  ['RAD', this.RAD], ['SHT', this.SHT], ['ZLJC', this.ZLJC], ['ZLMM', this.ZLMM], ['SLZT', this.SLZT],
  ['ADVOL', this.ADVOL], ['CYC', this.CYC], ['CYS', this.CYS], ['CYQKL', this.CYQKL], ["SQJZ", this.SQJZ], ["XT", this.XT], ["CFJT", this.CFJT],
  ["CYX", this.CYX], ["WAVE", this.WAVE],
  ['SCR', this.SCR], ['ASR', this.ASR], ['SAR', this.SAR], ['TJCJL', this.TJCJL], ['量比', this.VOLRate],

  ['EMPTY', this.EMPTY], //什么都不显示的指标
  ['操盘BS点', this.FXG_BSPoint],

  ['CJL2', this.CJL], //期货持仓量

  ['Zealink-资金吸筹', this.Zealink_Index1], ['Zealink-牛熊区间', this.Zealink_Index2], ['Zealink-持仓信号', this.Zealink_Index3],
  ['Zealink-增减持', this.Zealink_Index4], ['Zealink-大宗交易', this.Zealink_Index5], ['Zealink-信托持股', this.Zealink_Index6],
  ['Zealink-官网新闻', this.Zealink_Index7], ['Zealink-高管要闻', this.Zealink_Index8], ['Zealink-股权质押', this.Zealink_Index9],

  ['飞龙四式', this.Dragon4_Main], ['飞龙四式-附图', this.Dragon4_Fig],
  ['资金分析', this.FundsAnalysis], ['融资占比', this.MarginProportion],
  ['负面新闻', this.NewsNegative], ['机构调研', this.NewsResearch], ['董秘连线', this.NewsInteract], ['涨跌趋势', this.UpDownAnalyze],

  //外包指标
  ['放心股-操盘BS点', this.FXG_BSPoint],
  ['放心股-涨停多空线', this.FXG_INDEX],
  ['放心股-涨停吸筹区', this.FXG_INDEX2],
  ['放心股-量能黄金点', this.FXG_INDEX3],

  //五彩K线(函数COLOR_开头)
  ['五彩K线-十字星', this.COLOR_KSTAR1], ['五彩K线-早晨之星', this.COLOR_KSTAR2], ['五彩K线-黄昏之星', this.COLOR_KSTAR3], ['五彩K线-长十字', this.COLOR_SHI1],
  ['五彩K线-身怀六甲', this.COLOR_K220], ['五彩K线-三个白武士', this.COLOR_K300], ['五彩K线-三只乌鸦', this.COLOR_K310], ['五彩K线-光头阳线', this.COLOR_K380],
  ['五彩K线-光脚阴线', this.COLOR_K390], ['五彩K线-垂死十字', this.COLOR_K134], ['五彩K线-早晨十字星', this.COLOR_K140], ['五彩K线-黄昏十字星', this.COLOR_K150],
  ['五彩K线-射击之星', this.COLOR_K160], ['五彩K线-倒转锤头', this.COLOR_K165], ['五彩K线-锤头', this.COLOR_K170], ['五彩K线-吊颈', this.COLOR_K180],
  ['五彩K线-穿头破脚', this.COLOR_K190], ['五彩K线-出水芙蓉', this.COLOR_CSFR], ['五彩K线-乌云盖顶', this.COLOR_WYGD], ['五彩K线-曙光初现', this.COLOR_SGCJ],
  ['五彩K线-十字胎', this.COLOR_SZTAI], ['五彩K线-剑', this.COLOR_SWORD], ['五彩K线-平顶', this.COLOR_PINGDING], ['五彩K线-平底', this.COLOR_PINGDI],
  ['五彩K线-大阳烛', this.COLOR_DAYANZHU], ['五彩K线-大阴烛', this.COLOR_DAYINGZHU],

  ['五彩K线-好友反攻', this.COLOR_HYFG], ['五彩K线-跳空缺口', this.COLOR_TKQK],
  ['五彩K线-双飞乌鸦', this.COLOR_SFWY], ['五彩K线-上升三部曲', this.COLOR_SSSBQ], ['五彩K线-下跌三部曲', this.COLOR_XDSBQ], ['五彩K线-长下影', this.COLOR_CHXY],
  ['五彩K线-长上影', this.COLOR_CHSY], ['五彩K线-分离', this.COLOR_FENLI],

  //交易系统
  ['交易系统-BIAS', this.TRADE_BIAS], ['交易系统-CCI', this.TRADE_CCI], ['交易系统-DMI', this.TRADE_DMI], ['交易系统-KD', this.TRADE_KD],
  ['交易系统-BOLL', this.TRADE_BOLL], ['交易系统-KDJ', this.TRADE_KDJ], ['交易系统-MA', this.TRADE_MA], ['交易系统-MACD', this.TRADE_MACD],
  ['交易系统-MTM', this.TRADE_MTM], ['交易系统-PSY', this.TRADE_PSY], ['交易系统-ROC', this.TRADE_ROC], ['交易系统-RSI', this.TRADE_RSI],
  ['交易系统-VR', this.TRADE_VR], ['交易系统-DPSJ', this.TRADE_DPSJ],

  ['TEST', this.TEST] //测试用
  ]);

}

JSIndexScript.AddIndex = function (aryIndex) //添加自定义指标
{
  for (var i in aryIndex)
  {
    g_CustomIndex.Add(aryIndex[i]);
  }
};

JSIndexScript.prototype.Get = function (id)
{
  var data = g_CustomIndex.Get(id);
  if (data) return data;

  var func = this.DataMap.get(id);
  if (func) return func();

  console.log("[JSIndexScript::Get] can't find index by id=".concat(id));
  return null;
};

JSIndexScript.prototype.MA = function ()
{
  var data =
  {
    Name: 'MA', Description: '均线', IsMainIndex: true, StringFormat: 2,
    Args: [{ Name: 'M1', Value: 5 }, { Name: 'M2', Value: 10 }, { Name: 'M3', Value: 20 }],
    OutName: [{ Name: 'MA1', DynamicName: "MA{M1}" }, { Name: 'MA2', DynamicName: "MA{M2}" }, { Name: 'MA3', DynamicName: "MA{M3}" }],
    Script: //脚本
    'MA1:MA(CLOSE,M1);\n\
MA2:MA(CLOSE,M2);\n\
MA3:MA(CLOSE,M3);' };



  return data;
};

JSIndexScript.prototype.MA4 = function () {
  var data =
  {
    Name: 'MA', Description: '均线', IsMainIndex: true, StringFormat: 2,
    Args: [{ Name: 'M1', Value: 5 }, { Name: 'M2', Value: 10 }, { Name: 'M3', Value: 20 }, { Name: 'M4', Value: 60 }],
    OutName: [{ Name: 'MA1', DynamicName: "MA{M1}" }, { Name: 'MA2', DynamicName: "MA{M2}" }, { Name: 'MA3', DynamicName: "MA{M3}" }, { Name: 'MA4', DynamicName: "MA{M4}" }],
    Script: //脚本
    'MA1:MA(CLOSE,M1);\n\
MA2:MA(CLOSE,M2);\n\
MA3:MA(CLOSE,M3);\n\
MA4:MA(CLOSE,M4);' };



  return data;
};

JSIndexScript.prototype.MA5 = function () {
  var data =
  {
    Name: 'MA', Description: '均线', IsMainIndex: true, StringFormat: 2,
    Args: [{ Name: 'M1', Value: 5 }, { Name: 'M2', Value: 10 }, { Name: 'M3', Value: 20 }, { Name: 'M4', Value: 60 }, { Name: 'M5', Value: 0 }],
    OutName: [{ Name: 'MA1', DynamicName: "MA{M1}" }, { Name: 'MA2', DynamicName: "MA{M2}" }, { Name: 'MA3', DynamicName: "MA{M3}" }, { Name: 'MA4', DynamicName: "MA{M4}" }, { Name: 'MA5', DynamicName: "MA{M5}" }],
    Script: //脚本
    'MA1:MA(CLOSE,M1);\n\
MA2:MA(CLOSE,M2);\n\
MA3:MA(CLOSE,M3);\n\
MA4:MA(CLOSE,M4);\n\
MA5:MA(CLOSE,M5);' };



  return data;
};

JSIndexScript.prototype.MA6 = function () {
  var data =
  {
    Name: 'MA', Description: '均线', IsMainIndex: true, StringFormat: 2,
    Args:
    [
    { Name: 'M1', Value: 5 }, { Name: 'M2', Value: 10 }, { Name: 'M3', Value: 20 }, { Name: 'M4', Value: 60 },
    { Name: 'M5', Value: 0 }, { Name: 'M6', Value: 0 }],

    OutName:
    [
    { Name: 'MA1', DynamicName: "MA{M1}" }, { Name: 'MA2', DynamicName: "MA{M2}" }, { Name: 'MA3', DynamicName: "MA{M3}" }, { Name: 'MA4', DynamicName: "MA{M4}" },
    { Name: 'MA5', DynamicName: "MA{M5}" }, { Name: 'MA6', DynamicName: "MA{M6}" }],

    Script: //脚本
    'MA1:MA(CLOSE,M1);\n\
MA2:MA(CLOSE,M2);\n\
MA3:MA(CLOSE,M3);\n\
MA4:MA(CLOSE,M4);\n\
MA5:MA(CLOSE,M5);\n\
MA6:MA(CLOSE,M6);' };



  return data;
};

JSIndexScript.prototype.MA7 = function () {
  var data =
  {
    Name: 'MA', Description: '均线', IsMainIndex: true, StringFormat: 2,
    Args:
    [
    { Name: 'M1', Value: 5 }, { Name: 'M2', Value: 10 }, { Name: 'M3', Value: 20 }, { Name: 'M4', Value: 60 },
    { Name: 'M5', Value: 0 }, { Name: 'M6', Value: 0 }, { Name: 'M7', Value: 0 }],

    OutName:
    [
    { Name: 'MA1', DynamicName: "MA{M1}" }, { Name: 'MA2', DynamicName: "MA{M2}" }, { Name: 'MA3', DynamicName: "MA{M3}" }, { Name: 'MA4', DynamicName: "MA{M4}" },
    { Name: 'MA5', DynamicName: "MA{M5}" }, { Name: 'MA6', DynamicName: "MA{M6}" }, { Name: 'MA7', DynamicName: "MA{M7}" }],

    Script: //脚本
    'MA1:MA(CLOSE,M1);\n\
MA2:MA(CLOSE,M2);\n\
MA3:MA(CLOSE,M3);\n\
MA4:MA(CLOSE,M4);\n\
MA5:MA(CLOSE,M5);\n\
MA6:MA(CLOSE,M6);\n\
MA7:MA(CLOSE,M7);' };



  return data;
};

JSIndexScript.prototype.MA8 = function () {
  var data =
  {
    Name: 'MA', Description: '均线', IsMainIndex: true, StringFormat: 2,
    Args:
    [
    { Name: 'M1', Value: 5 }, { Name: 'M2', Value: 10 }, { Name: 'M3', Value: 20 }, { Name: 'M4', Value: 60 },
    { Name: 'M5', Value: 0 }, { Name: 'M6', Value: 0 }, { Name: 'M7', Value: 0 }, { Name: 'M8', Value: 0 }],

    OutName:
    [
    { Name: 'MA1', DynamicName: "MA{M1}" }, { Name: 'MA2', DynamicName: "MA{M2}" }, { Name: 'MA3', DynamicName: "MA{M3}" }, { Name: 'MA4', DynamicName: "MA{M4}" },
    { Name: 'MA5', DynamicName: "MA{M5}" }, { Name: 'MA6', DynamicName: "MA{M6}" }, { Name: 'MA7', DynamicName: "MA{M7}" }, { Name: 'MA8', DynamicName: "MA{M8}" }],

    Script: //脚本
    'MA1:MA(CLOSE,M1);\n\
MA2:MA(CLOSE,M2);\n\
MA3:MA(CLOSE,M3);\n\
MA4:MA(CLOSE,M4);\n\
MA5:MA(CLOSE,M5);\n\
MA6:MA(CLOSE,M6);\n\
MA7:MA(CLOSE,M7);\n\
MA8:MA(CLOSE,M8);' };



  return data;
};

JSIndexScript.prototype.BOLL = function ()
{
  var data =
  {
    Name: 'BOLL', Description: '布林线', IsMainIndex: true, KLineType: 2,
    Args: [{ Name: 'M', Value: 20 }],
    Script: //脚本
    'BOLL:MA(CLOSE,M);\n\
UB:BOLL+2*STD(CLOSE,M);\n\
LB:BOLL-2*STD(CLOSE,M);' };



  return data;
};

JSIndexScript.prototype.BBI = function ()
{
  var data =
  {
    Name: 'BBI', Description: '多空均线', IsMainIndex: true,
    Args: [{ Name: 'M1', Value: 3 }, { Name: 'M2', Value: 6 }, { Name: 'M3', Value: 12 }, { Name: 'M4', Value: 24 }],
    Script: //脚本
    'BBI:(MA(CLOSE,M1)+MA(CLOSE,M2)+MA(CLOSE,M3)+MA(CLOSE,M4))/4;' };



  return data;
};

JSIndexScript.prototype.DKX = function ()
{
  var data =
  {
    Name: 'DKX', Description: '多空线', IsMainIndex: false,
    Args: [{ Name: 'M', Value: 10 }],
    Script: //脚本
    'MID:=(3*CLOSE+LOW+OPEN+HIGH)/6;\n\
DKX:(20*MID+19*REF(MID,1)+18*REF(MID,2)+17*REF(MID,3)+\n\
16*REF(MID,4)+15*REF(MID,5)+14*REF(MID,6)+\n\
13*REF(MID,7)+12*REF(MID,8)+11*REF(MID,9)+\n\
10*REF(MID,10)+9*REF(MID,11)+8*REF(MID,12)+\n\
7*REF(MID,13)+6*REF(MID,14)+5*REF(MID,15)+\n\
4*REF(MID,16)+3*REF(MID,17)+2*REF(MID,18)+REF(MID,20))/210;\n\
MADKX:MA(DKX,M);' };



  return data;
};

JSIndexScript.prototype.MIKE = function ()
{
  var data =
  {
    Name: 'MIKE', Description: '麦克支撑压力', IsMainIndex: true,
    Args: [{ Name: 'N', Value: 10 }],
    Script: //脚本
    'HLC:=REF(MA((HIGH+LOW+CLOSE)/3,N),1);\n\
HV:=EMA(HHV(HIGH,N),3);\n\
LV:=EMA(LLV(LOW,N),3);\n\
STOR:EMA(2*HV-LV,3);\n\
MIDR:EMA(HLC+HV-LV,3);\n\
WEKR:EMA(HLC*2-LV,3);\n\
WEKS:EMA(HLC*2-HV,3);\n\
MIDS:EMA(HLC-HV+LV,3);\n\
STOS:EMA(2*LV-HV,3);' };



  return data;
};

JSIndexScript.prototype.PBX = function ()
{
  var data =
  {
    Name: 'PBX', Description: '瀑布线', IsMainIndex: true,
    Args: [{ Name: 'M1', Value: 4 }, { Name: 'M2', Value: 6 }, { Name: 'M3', Value: 9 }, { Name: 'M4', Value: 13 }, { Name: 'M5', Value: 18 }, { Name: 'M6', Value: 24 }],
    Script: //脚本
    'PBX1:(EMA(CLOSE,M1)+MA(CLOSE,M1*2)+MA(CLOSE,M1*4))/3;\n\
PBX2:(EMA(CLOSE,M2)+MA(CLOSE,M2*2)+MA(CLOSE,M2*4))/3;\n\
PBX3:(EMA(CLOSE,M3)+MA(CLOSE,M3*2)+MA(CLOSE,M3*4))/3;\n\
PBX4:(EMA(CLOSE,M4)+MA(CLOSE,M4*2)+MA(CLOSE,M4*4))/3;\n\
PBX5:(EMA(CLOSE,M5)+MA(CLOSE,M5*2)+MA(CLOSE,M5*4))/3;\n\
PBX6:(EMA(CLOSE,M6)+MA(CLOSE,M6*2)+MA(CLOSE,M6*4))/3;' };



  return data;
};

JSIndexScript.prototype.ENE = function ()
{
  var data =
  {
    Name: 'ENE', Description: '轨道线', IsMainIndex: true,
    Args: [{ Name: 'N', Value: 25 }, { Name: 'M1', Value: 6 }, { Name: 'M2', Value: 6 }],
    Script: //脚本
    'UPPER:(1+M1/100)*MA(CLOSE,N);\n\
LOWER:(1-M2/100)*MA(CLOSE,N);\n\
ENE:(UPPER+LOWER)/2;' };



  return data;
};

JSIndexScript.prototype.MACD = function ()
{
  var data =
  {
    Name: 'MACD', Description: '平滑异同平均', IsMainIndex: false,
    Args: [{ Name: 'SHORT', Value: 12 }, { Name: 'LONG', Value: 26 }, { Name: 'MID', Value: 9 }],
    Script: //脚本
    'DIF:EMA(CLOSE,SHORT)-EMA(CLOSE,LONG);\n\
DEA:EMA(DIF,MID);\n\
MACD:(DIF-DEA)*2,COLORSTICK;' };



  return data;
};

//上下柱子
JSIndexScript.prototype.MACD2 = function ()
{
  var data =
  {
    Name: 'MACD', Description: '平滑异同平均', IsMainIndex: false,
    Args: [{ Name: 'SHORT', Value: 12 }, { Name: 'LONG', Value: 26 }, { Name: 'MID', Value: 9 }],
    Script: //脚本
    'DIF2:=EMA(CLOSE,SHORT)-EMA(CLOSE,LONG);\n\
DEA2:=EMA(DIF2,MID);\n\
MACD:(DIF2-DEA2)*2,COLORSTICK,LINETHICK50;\n\
DIF:DIF2;\n\
DEA:DEA2;' };



  return data;
};

JSIndexScript.prototype.KDJ = function ()
{
  var data =
  {
    Name: 'KDJ', Description: '随机指标', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 9 }, { Name: 'M1', Value: 3 }, { Name: 'M2', Value: 3 }],
    Script: //脚本
    'RSV:=(CLOSE-LLV(LOW,N))/(HHV(HIGH,N)-LLV(LOW,N))*100;\n\
K:SMA(RSV,M1,1);\n\
D:SMA(K,M2,1);\n\
J:3*K-2*D;' };



  return data;
};

JSIndexScript.prototype.VOL = function ()
{
  var data =
  {
    Name: 'VOL', Description: '成交量', IsMainIndex: false, FloatPrecision: 0,
    Args: [{ Name: 'M1', Value: 5 }, { Name: 'M2', Value: 10 }],
    OutName: [{ Name: 'MA1', DynamicName: "MA{M1}" }, { Name: 'MA2', DynamicName: "MA{M2}" }],
    Script: //脚本
    'VOLUME:=VOL;\n\
VOL:VOL,VOLSTICK;\n\
MA1:MA(VOLUME,M1);\n\
MA2:MA(VOLUME,M2);' };



  return data;
};

JSIndexScript.prototype.RSI = function ()
{
  var data =
  {
    Name: 'RSI', Description: '相对强弱指标', IsMainIndex: false,
    Args: [{ Name: 'N1', Value: 6 }, { Name: 'N2', Value: 12 }, { Name: 'N3', Value: 24 }],
    Script: //脚本
    'LC:=REF(CLOSE,1);\n\
RSI1:SMA(MAX(CLOSE-LC,0),N1,1)/SMA(ABS(CLOSE-LC),N1,1)*100;\n\
RSI2:SMA(MAX(CLOSE-LC,0),N2,1)/SMA(ABS(CLOSE-LC),N2,1)*100;\n\
RSI3:SMA(MAX(CLOSE-LC,0),N3,1)/SMA(ABS(CLOSE-LC),N3,1)*100;' };



  return data;
};

JSIndexScript.prototype.BRAR = function ()
{
  var data =
  {
    Name: 'BRAR', Description: '情绪指标', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 26 }],
    Script: //脚本
    'BR:SUM(MAX(0,HIGH-REF(CLOSE,1)),N)/SUM(MAX(0,REF(CLOSE,1)-LOW),N)*100;\n\
AR:SUM(HIGH-OPEN,N)/SUM(OPEN-LOW,N)*100;' };



  return data;
};

JSIndexScript.prototype.WR = function ()
{
  var data =
  {
    Name: 'WR', Description: '威廉指标', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 10 }, { Name: 'N1', Value: 6 }],
    Script: //脚本
    'WR1:100*(HHV(HIGH,N)-CLOSE)/(HHV(HIGH,N)-LLV(LOW,N));\n\
WR2:100*(HHV(HIGH,N1)-CLOSE)/(HHV(HIGH,N1)-LLV(LOW,N1));' };



  return data;
};

JSIndexScript.prototype.BIAS = function ()
{
  var data =
  {
    Name: 'BIAS', Description: '乖离率', IsMainIndex: false,
    Args: [{ Name: 'N1', Value: 6 }, { Name: 'N2', Value: 12 }, { Name: 'N3', Value: 24 }],
    Script: //脚本
    'BIAS1 :(CLOSE-MA(CLOSE,N1))/MA(CLOSE,N1)*100;\n\
BIAS2 :(CLOSE-MA(CLOSE,N2))/MA(CLOSE,N2)*100;\n\
BIAS3 :(CLOSE-MA(CLOSE,N3))/MA(CLOSE,N3)*100;' };



  return data;
};

JSIndexScript.prototype.OBV = function ()
{
  var data =
  {
    Name: 'OBV', Description: '累积能量线', IsMainIndex: false,
    Args: [{ Name: 'M', Value: 30 }],
    Script: //脚本
    'VA:=IF(CLOSE>REF(CLOSE,1),VOL,-VOL);\n\
OBV:SUM(IF(CLOSE==REF(CLOSE,1),0,VA),0);\n\
MAOBV:MA(OBV,M);' };



  return data;
};

JSIndexScript.prototype.DMI = function ()
{
  var data =
  {
    Name: 'DMI', Description: '趋向指标', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 14 }, { Name: 'MM', Value: 6 }],
    Script: //脚本
    'MTR:=EXPMEMA(MAX(MAX(HIGH-LOW,ABS(HIGH-REF(CLOSE,1))),ABS(REF(CLOSE,1)-LOW)),N);\n\
HD :=HIGH-REF(HIGH,1);\n\
LD :=REF(LOW,1)-LOW;\n\
DMP:=EXPMEMA(IF(HD>0&&HD>LD,HD,0),N);\n\
DMM:=EXPMEMA(IF(LD>0&&LD>HD,LD,0),N);\n\
PDI: DMP*100/MTR;\n\
MDI: DMM*100/MTR;\n\
ADX: EXPMEMA(ABS(MDI-PDI)/(MDI+PDI)*100,MM);\n\
ADXR:EXPMEMA(ADX,MM);' };



  return data;
};

JSIndexScript.prototype.CR = function ()
{
  var data =
  {
    Name: 'CR', Description: '带状能量线', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 26 }, { Name: 'M1', Value: 10 }, { Name: 'M2', Value: 20 }, { Name: 'M3', Value: 40 }, { Name: 'M4', Value: 62 }],
    Script: //脚本
    'MID:=REF(HIGH+LOW,1)/2;\n\
CR:SUM(MAX(0,HIGH-MID),N)/SUM(MAX(0,MID-LOW),N)*100;\n\
MA1:REF(MA(CR,M1),M1/2.5+1);\n\
MA2:REF(MA(CR,M2),M2/2.5+1);\n\
MA3:REF(MA(CR,M3),M3/2.5+1);\n\
MA4:REF(MA(CR,M4),M4/2.5+1);' };



  return data;
};

JSIndexScript.prototype.PSY = function ()
{
  var data =
  {
    Name: 'PSY', Description: '心理线', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 12 }, { Name: 'M', Value: 6 }],
    Script: //脚本
    'PSY:COUNT(CLOSE>REF(CLOSE,1),N)/N*100;\r\
PSYMA:MA(PSY,M);' };



  return data;
};

JSIndexScript.prototype.CCI = function ()
{
  var data =
  {
    Name: 'CCI', Description: '商品路径指标', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 14 }],
    Script: //脚本
    'TYP:=(HIGH+LOW+CLOSE)/3;\n\
CCI:(TYP-MA(TYP,N))/(0.015*AVEDEV(TYP,N));' };



  return data;
};

JSIndexScript.prototype.DMA = function ()
{
  var data =
  {
    Name: 'DMA', Description: '平均差', IsMainIndex: false,
    Args: [{ Name: 'N1', Value: 10 }, { Name: 'N2', Value: 50 }, { Name: 'M', Value: 10 }],
    Script: //脚本
    'DIF:MA(CLOSE,N1)-MA(CLOSE,N2);\n\
DIFMA:MA(DIF,M);' };



  return data;
};

JSIndexScript.prototype.TRIX = function ()
{
  var data =
  {
    Name: 'TRIX', Description: '三重指数平均线', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 12 }, { Name: 'M', Value: 9 }],
    Script: //脚本
    'MTR:=EMA(EMA(EMA(CLOSE,N),N),N);\n\
TRIX:(MTR-REF(MTR,1))/REF(MTR,1)*100;\n\
MATRIX:MA(TRIX,M) ;' };



  return data;
};

JSIndexScript.prototype.VR = function ()
{
  var data =
  {
    Name: 'VR', Description: '成交量变异率', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 26 }, { Name: 'M', Value: 6 }],
    Script: //脚本
    'TH:=SUM(IF(CLOSE>REF(CLOSE,1),VOL,0),N);\n\
TL:=SUM(IF(CLOSE<REF(CLOSE,1),VOL,0),N);\n\
TQ:=SUM(IF(CLOSE==REF(CLOSE,1),VOL,0),N);\n\
VR:100*(TH*2+TQ)/(TL*2+TQ);\n\
MAVR:MA(VR,M);' };



  return data;
};

JSIndexScript.prototype.EMV = function ()
{
  var data =
  {
    Name: 'EMV', Description: '简易波动指标', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 14 }, { Name: 'M', Value: 9 }],
    Script: //脚本
    'VOLUME:=MA(VOL,N)/VOL;\n\
MID:=100*(HIGH+LOW-REF(HIGH+LOW,1))/(HIGH+LOW);\n\
EMV:MA(MID*VOLUME*(HIGH-LOW)/MA(HIGH-LOW,N),N);\n\
MAEMV:MA(EMV,M);' };



  return data;
};

JSIndexScript.prototype.ROC = function ()
{
  var data =
  {
    Name: 'ROC', Description: '变动率指标', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 12 }, { Name: 'M', Value: 6 }],
    Script: //脚本
    'ROC:100*(CLOSE-REF(CLOSE,N))/REF(CLOSE,N);\n\
MAROC:MA(ROC,M);' };



  return data;
};

JSIndexScript.prototype.MIM = function ()
{
  var data =
  {
    Name: 'MIM', Description: '动量线', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 12 }, { Name: 'M', Value: 6 }],
    Script: //脚本
    'MTM:CLOSE-REF(CLOSE,N);\n\
MAMTM:MA(MTM,M);' };



  return data;
};

JSIndexScript.prototype.FSL = function ()
{
  var data =
  {
    Name: 'FSL', Description: '分水岭', IsMainIndex: false,
    Args: [],
    Script: //脚本
    'SWL:(EMA(CLOSE,5)*7+EMA(CLOSE,10)*3)/10;\n\
SWS:DMA(EMA(CLOSE,12),MAX(1,100*(SUM(VOL,5)/(3*CAPITAL))));' };



  return data;
};

JSIndexScript.prototype.CYR = function ()
{
  var data =
  {
    Name: 'CYR', Description: '市场强弱', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 13 }, { Name: 'M', Value: 5 }],
    Script: //脚本
    'DIVE:=0.01*EMA(AMOUNT,N)/EMA(VOL,N);\n\
CYR:(DIVE/REF(DIVE,1)-1)*100;\n\
MACYR:MA(CYR,M);' };



  return data;
};

JSIndexScript.prototype.MASS = function ()
{
  var data =
  {
    Name: 'MASS', Description: '市场强弱', IsMainIndex: false,
    Args: [{ Name: 'N1', Value: 9 }, { Name: 'N2', Value: 25 }, { Name: 'M', Value: 6 }],
    Script: //脚本
    'MASS:SUM(MA(HIGH-LOW,N1)/MA(MA(HIGH-LOW,N1),N1),N2);\n\
MAMASS:MA(MASS,M);' };



  return data;
};

JSIndexScript.prototype.WAD = function ()
{
  var data =
  {
    Name: 'WAD', Description: '威廉多空力度线', IsMainIndex: false,
    Args: [{ Name: 'M', Value: 30 }],
    Script: //脚本
    'MIDA:=CLOSE-MIN(REF(CLOSE,1),LOW);\n\
MIDB:=IF(CLOSE<REF(CLOSE,1),CLOSE-MAX(REF(CLOSE,1),HIGH),0);\n\
WAD:SUM(IF(CLOSE>REF(CLOSE,1),MIDA,MIDB),0);\n\
MAWAD:MA(WAD,M);' };



  return data;
};

JSIndexScript.prototype.CHO = function ()
{
  var data =
  {
    Name: 'CHO', Description: '佳庆指标', IsMainIndex: false,
    Args: [{ Name: 'N1', Value: 10 }, { Name: 'N2', Value: 20 }, { Name: 'M', Value: 6 }],
    Script: //脚本
    'MID:=SUM(VOL*(2*CLOSE-HIGH-LOW)/(HIGH+LOW),0);\n\
CHO:MA(MID,N1)-MA(MID,N2);\n\
MACHO:MA(CHO,M);' };



  return data;
};

JSIndexScript.prototype.ADTM = function ()
{
  var data =
  {
    Name: 'ADTM', Description: '动态买卖气指标', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 23 }, { Name: 'M', Value: 8 }],
    Script: //脚本
    'DTM:=IF(OPEN<=REF(OPEN,1),0,MAX((HIGH-OPEN),(OPEN-REF(OPEN,1))));\n\
DBM:=IF(OPEN>=REF(OPEN,1),0,MAX((OPEN-LOW),(OPEN-REF(OPEN,1))));\n\
STM:=SUM(DTM,N);\n\
SBM:=SUM(DBM,N);\n\
ADTM:IF(STM>SBM,(STM-SBM)/STM,IF(STM==SBM,0,(STM-SBM)/SBM));\n\
MAADTM:MA(ADTM,M);' };



  return data;
};

JSIndexScript.prototype.HSL = function ()
{
  var data =
  {
    Name: 'HSL', Description: '换手线', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 5 }],
    Script: //脚本
    'HSL:IF((SETCODE==0||SETCODE==1),100*VOL,VOL)/(FINANCE(7)/100);\n\
MAHSL:MA(HSL,N);' };



  return data;
};

JSIndexScript.prototype.BIAS36 = function ()
{
  var data =
  {
    Name: 'BIAS36', Description: '三六乖离', IsMainIndex: false,
    Args: [{ Name: 'M', Value: 6 }],
    Script: //脚本
    'BIAS36:MA(CLOSE,3)-MA(CLOSE,6);\n\
BIAS612:MA(CLOSE,6)-MA(CLOSE,12);\n\
MABIAS:MA(BIAS36,M);' };



  return data;
};

JSIndexScript.prototype.BIAS_QL = function ()
{
  var data =
  {
    Name: 'BIAS_QL', Description: '乖离率-传统版', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 6 }, { Name: 'M', Value: 6 }],
    Script: //脚本
    'BIAS :(CLOSE-MA(CLOSE,N))/MA(CLOSE,N)*100;\n\
BIASMA :MA(BIAS,M);' };



  return data;
};

JSIndexScript.prototype.DPO = function ()
{
  var data =
  {
    Name: 'DPO', Description: '区间震荡线', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 20 }, { Name: 'M', Value: 6 }],
    Script: //脚本
    'DPO:CLOSE-REF(MA(CLOSE,N),N/2+1);\n\
MADPO:MA(DPO,M);' };



  return data;
};

JSIndexScript.prototype.OSC = function ()
{
  var data =
  {
    Name: 'OSC', Description: '变动速率线', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 20 }, { Name: 'M', Value: 6 }],
    Script: //脚本
    'OSC:100*(CLOSE-MA(CLOSE,N));\n\
MAOSC:EXPMEMA(OSC,M);' };



  return data;
};

JSIndexScript.prototype.ATR = function ()
{
  var data =
  {
    Name: 'ATR', Description: '真实波幅', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 14 }],
    Script: //脚本
    'MTR:MAX(MAX((HIGH-LOW),ABS(REF(CLOSE,1)-HIGH)),ABS(REF(CLOSE,1)-LOW));\n\
ATR:MA(MTR,N);' };



  return data;
};

JSIndexScript.prototype.NVI = function ()
{
  var data =
  {
    Name: 'ATR', Description: '负成交量', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 72 }],
    Script: //脚本
    'NVI:100*MULAR(IF(V<REF(V,1),C/REF(C,1),1),0);\n\
MANVI:MA(NVI,N);' };



  return data;
};

JSIndexScript.prototype.PVI = function ()
{
  var data =
  {
    Name: 'PVI', Description: '正成交量', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 72 }],
    Script: //脚本
    'NVI:100*MULAR(IF(V>REF(V,1),C/REF(C,1),1),0);\n\
MANVI:MA(NVI,N);' };



  return data;
};

JSIndexScript.prototype.UOS = function ()
{
  var data =
  {
    Name: 'UOS', Description: '终极指标', IsMainIndex: false,
    Args: [{ Name: 'N1', Value: 7 }, { Name: 'N2', Value: 14 }, { Name: 'N3', Value: 28 }, { Name: 'M', Value: 6 }],
    Script: //脚本
    'TH:=MAX(HIGH,REF(CLOSE,1));\n\
TL:=MIN(LOW,REF(CLOSE,1));\n\
ACC1:=SUM(CLOSE-TL,N1)/SUM(TH-TL,N1);\n\
ACC2:=SUM(CLOSE-TL,N2)/SUM(TH-TL,N2);\n\
ACC3:=SUM(CLOSE-TL,N3)/SUM(TH-TL,N3);\n\
UOS:(ACC1*N2*N3+ACC2*N1*N3+ACC3*N1*N2)*100/(N1*N2+N1*N3+N2*N3);\n\
MAUOS:EXPMEMA(UOS,M);' };



  return data;
};

JSIndexScript.prototype.CYW = function ()
{
  var data =
  {
    Name: 'CYW', Description: '主力控盘', IsMainIndex: false,
    Args: [],
    Script: //脚本
    'VAR1:=CLOSE-LOW;\n\
VAR2:=HIGH-LOW;\n\
VAR3:=CLOSE-HIGH;\n\
VAR4:=IF(HIGH>LOW,(VAR1/VAR2+VAR3/VAR2)*VOL,0);\n\
CYW: SUM(VAR4,10)/10000, COLORSTICK;' };



  return data;
};

JSIndexScript.prototype.LON = function ()
{
  var data =
  {
    Name: 'LON', Description: '龙系长线', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 10 }],
    Script: //脚本
    'LC := REF(CLOSE,1);\n\
VID := SUM(VOL,2)/(((HHV(HIGH,2)-LLV(LOW,2)))*100);\n\
RC := (CLOSE-LC)*VID;\n\
LONG := SUM(RC,0);\n\
DIFF := SMA(LONG,10,1);\n\
DEA := SMA(LONG,20,1);\n\
LON : DIFF-DEA;\n\
LONMA : MA(LON,10);\n\
LONT : LON, COLORSTICK;' };



  return data;
};

JSIndexScript.prototype.NDB = function ()
{
  var data =
  {
    Name: 'NDB', Description: '脑电波', IsMainIndex: false,
    Args: [{ Name: 'P1', Value: 5 }, { Name: 'P2', Value: 10 }],
    Script: //脚本
    'HH:=IF(C/REF(C,1)>1.098 AND L>REF(H,1),2*C-REF(C,1)-H,2*C-H-L);\n\
V1:= BARSCOUNT(C) - 1;\n\
V2:= 2 * REF(C, V1) - REF(H, V1) - REF(L, V1);\n\
DK: SUM(HH, 0) + V2;\n\
MDK5: MA(DK, P1);\n\
MDK10: MA(DK, P2);' };



  return data;
};

JSIndexScript.prototype.SKDJ = function ()
{
  var data =
  {
    Name: 'SKDJ', Description: '慢速随机指标', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 9 }, { Name: 'M', Value: 3 }],
    Script: //脚本
    'LOWV:=LLV(LOW,N);\n\
HIGHV:=HHV(HIGH,N);\n\
RSV:=EMA((CLOSE-LOWV)/(HIGHV-LOWV)*100,M);\n\
K:EMA(RSV,M);\n\
D:MA(K,M);' };



  return data;
};

JSIndexScript.prototype.KD = function ()
{
  var data =
  {
    Name: 'KD', Description: '随机指标KD', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 9 }, { Name: 'M1', Value: 3 }, { Name: 'M2', Value: 3 }],
    Script: //脚本
    'RSV:=(CLOSE-LLV(LOW,N))/(HHV(HIGH,N)-LLV(LOW,N))*100;\n\
K:SMA(RSV,M1,1);\n\
D:SMA(K,M2,1);' };



  return data;
};

JSIndexScript.prototype.FKX = function ()
{
  var data =
  {
    Name: 'FKX', Description: '反K线', IsMainIndex: true,
    Args: [],
    Script: //脚本
    'DRAWKLINE(-LOW, -OPEN, -HIGH, -CLOSE);' };


  return data;
};

JSIndexScript.prototype.DKCOL = function ()
{
  var data =
  {
    Name: 'DKCOL', Description: '多空能量柱(适用于分时主图)', IsMainIndex: true,
    Args: [{ Name: 'N', Value: 5 }],
    Script: //脚本
    'FF:=(C-REF(C,N))/REF(C,N);\n\
STICKLINE(FF>0,DYNAINFO(3),DYNAINFO(3)*(1+FF),0.5,0),COLORRED;\n\
STICKLINE(FF<0,DYNAINFO(3),DYNAINFO(3)*(1+FF),0.5,0),COLORGREEN;' };



  return data;
};

JSIndexScript.prototype.UDL = function ()
{
  var data =
  {
    Name: 'UDL', Description: '引力线', IsMainIndex: false,
    Args: [{ Name: 'N1', Value: 3 }, { Name: 'N2', Value: 5 }, { Name: 'N3', Value: 10 }, { Name: 'N4', Value: 20 }, { Name: 'M', Value: 6 }],
    Script: //脚本
    'UDL:(MA(CLOSE,N1)+MA(CLOSE,N2)+MA(CLOSE,N3)+MA(CLOSE,N4))/4;\n\
MAUDL:MA(UDL,M);' };



  return data;
};

JSIndexScript.prototype.MFI = function ()
{
  var data =
  {
    Name: 'MFI', Description: '资金流量指标', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 14 }, { Name: 'N2', Value: 6 }],
    Script: //脚本
    'TYP := (HIGH + LOW + CLOSE)/3;\n\
V1:=SUM(IF(TYP>REF(TYP,1),TYP*VOL,0),N)/SUM(IF(TYP<REF(TYP,1),TYP*VOL,0),N);\n\
MFI:100-(100/(1+V1));' };



  return data;
};


JSIndexScript.prototype.LWR = function ()
{
  var data =
  {
    Name: 'LWR', Description: 'LWR威廉指标', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 9 }, { Name: 'M1', Value: 3 }, { Name: 'M2', Value: 3 }],
    Script: //脚本
    'RSV:= (HHV(HIGH,N)-CLOSE)/(HHV(HIGH,N)-LLV(LOW,N))*100;\n\
LWR1:SMA(RSV,M1,1);\n\
LWR2:SMA(LWR1,M2,1);' };



  return data;
};

JSIndexScript.prototype.MARSI = function ()
{
  var data =
  {
    Name: 'MARSI', Description: '相对强弱平均线', IsMainIndex: false,
    Args: [{ Name: 'M1', Value: 10 }, { Name: 'M2', Value: 6 }],
    Script: //脚本
    'DIF:=CLOSE-REF(CLOSE,1);\n\
VU:=IF(DIF>=0,DIF,0);\n\
VD:=IF(DIF<0,-DIF,0);\n\
MAU1:=MEMA(VU,M1);\n\
MAD1:=MEMA(VD,M1);\n\
MAU2:=MEMA(VU,M2);\n\
MAD2:=MEMA(VD,M2);\n\
RSI10:MA(100*MAU1/(MAU1+MAD1),M1);\n\
RSI6:MA(100*MAU2/(MAU2+MAD2),M2);' };



  return data;
};

JSIndexScript.prototype.CYD = function ()
{
  var data =
  {
    Name: 'CYD', Description: '承接因子', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 21 }],
    Script: //脚本
    'CYDS:WINNER(CLOSE)/(VOL/CAPITAL);\n\
CYDN:WINNER(CLOSE)/MA(VOL/CAPITAL,N);' };



  return data;
};

JSIndexScript.prototype.CYF = function ()
{
  var data =
  {
    Name: 'CYF', Description: '市场能量', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 21 }],
    Script: //脚本
    'CYF:100-100/(1+EMA(HSL,N));' };



  return data;
};

JSIndexScript.prototype.TAPI = function ()
{
  var data =
  {
    Name: 'TAPI', Description: '加权指数成交值', IsMainIndex: false,
    Args: [{ Name: 'M', Value: 6 }],
    Script: //脚本
    'TAPI:AMOUNT/INDEXC;\n\
MATAIP:MA(TAPI,M);' };



  return data;
};

JSIndexScript.prototype.VMACD = function ()
{
  var data =
  {
    Name: 'VMACD', Description: '量平滑异同平均', IsMainIndex: false,
    Args: [{ Name: 'SHORT', Value: 12 }, { Name: 'LONG', Value: 26 }, { Name: 'MID', Value: 9 }],
    Script: //脚本
    'DIF:EMA(VOL,SHORT)-EMA(VOL,LONG);\n\
DEA:EMA(DIF,MID);\n\
MACD:DIF-DEA,COLORSTICK;' };



  return data;
};

JSIndexScript.prototype.QACD = function ()
{
  var data =
  {
    Name: 'QACD', Description: '快速异同平均', IsMainIndex: false,
    Args: [{ Name: 'N1', Value: 12 }, { Name: 'N2', Value: 26 }, { Name: 'M', Value: 9 }],
    Script: //脚本
    'DIF:EMA(CLOSE,N1)-EMA(CLOSE,N2);\n\
MACD:EMA(DIF,M);\n\
DDIF:DIF-MACD;' };



  return data;
};

JSIndexScript.prototype.VPT = function ()
{
  var data =
  {
    Name: 'VPT', Description: '量价曲线', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 51 }, { Name: 'M', Value: 6 }],
    Script: //脚本
    'VPT:SUM(VOL*(CLOSE-REF(CLOSE,1))/REF(CLOSE,1),N);\n\
MAVPT:MA(VPT,M);' };



  return data;
};

JSIndexScript.prototype.WVAD = function ()
{
  var data =
  {
    Name: 'WVAD', Description: '威廉变异离散量', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 24 }, { Name: 'M', Value: 6 }],
    Script: //脚本
    'WVAD:SUM((CLOSE-OPEN)/(HIGH-LOW)*VOL,N)/10000;\n\
MAWVAD:MA(WVAD,M);' };



  return data;
};

JSIndexScript.prototype.DBQR = function ()
{
  var data =
  {
    Name: 'WVAD', Description: '对比强弱', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 5 }, { Name: 'M1', Value: 10 }, { Name: 'M2', Value: 20 }, { Name: 'M3', Value: 60 }],
    Script: //脚本
    'ZS:(INDEXC-REF(INDEXC,N))/REF(INDEXC,N);\n\
GG:(CLOSE-REF(CLOSE,N))/REF(CLOSE,N);\n\
MADBQR1:MA(GG,M1);\n\
MADBQR2:MA(GG,M2);\n\
MADBQR3:MA(GG,M3);' };



  return data;
};

JSIndexScript.prototype.JS = function ()
{
  var data =
  {
    Name: 'JS', Description: '加速线', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 5 }, { Name: 'M1', Value: 5 }, { Name: 'M2', Value: 10 }, { Name: 'M3', Value: 20 }],
    Script: //脚本
    'JS:100*(CLOSE-REF(CLOSE,N))/(N*REF(CLOSE,N));\n\
MAJS1:MA(JS,M1);\n\
MAJS2:MA(JS,M2);\n\
MAJS3:MA(JS,M3);' };



  return data;
};

JSIndexScript.prototype.CYE = function ()
{
  var data =
  {
    Name: 'CYE', Description: '市场趋势', IsMainIndex: false,
    Args: [],
    Script: //脚本
    'MAL:=MA(CLOSE,5);\n\
MAS:=MA(MA(CLOSE,20),5);\n\
CYEL:(MAL-REF(MAL,1))/REF(MAL,1)*100;\n\
CYES:(MAS-REF(MAS,1))/REF(MAS,1)*100;' };



  return data;
};

JSIndexScript.prototype.QR = function ()
{
  var data =
  {
    Name: 'QR', Description: '强弱指标', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 21 }],
    Script: //脚本
    '个股: (CLOSE-REF(CLOSE,N))/REF(CLOSE,N)*100; \n\
大盘: (INDEXC-REF(INDEXC,N))/REF(INDEXC,N)*100; \n\
强弱值:EMA(个股-大盘,2),COLORSTICK;' };



  return data;
};

JSIndexScript.prototype.GDX = function ()
{
  var data =
  {
    Name: 'GDX', Description: '轨道线', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 30 }, { Name: 'M', Value: 9 }],
    Script: //脚本
    'AA:=ABS((2*CLOSE+HIGH+LOW)/4-MA(CLOSE,N))/MA(CLOSE,N); \n\
轨道:DMA(CLOSE,AA);\n\
压力线:(1+M/100)*轨道; \n\
支撑线:(1-M/100)*轨道;' };



  return data;
};

JSIndexScript.prototype.JLHB = function ()
{
  var data =
  {
    Name: 'JLHB', Description: '绝路航标', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 7 }, { Name: 'M', Value: 5 }],
    Script: //脚本
    'VAR1:=(CLOSE-LLV(LOW,60))/(HHV(HIGH,60)-LLV(LOW,60))*80; \n\
B:SMA(VAR1,N,1); \n\
VAR2:SMA(B,M,1); \n\
绝路航标:IF(CROSS(B,VAR2) AND B<40,50,0);' };



  return data;
};

JSIndexScript.prototype.PCNT = function ()
{
  var data =
  {
    Name: 'PCNT', Description: '幅度比', IsMainIndex: false,
    Args: [{ Name: 'M', Value: 5 }],
    Script: //脚本
    'PCNT:(CLOSE-REF(CLOSE,1))/CLOSE*100;\n\
MAPCNT:EXPMEMA(PCNT,M);' };



  return data;
};

JSIndexScript.prototype.AMO = function ()
{
  var data =
  {
    Name: 'AMO', Description: '成交金额', IsMainIndex: false,
    Args: [{ Name: 'M1', Value: 5 }, { Name: 'M2', Value: 10 }],
    Script: //脚本
    'AMOW:AMOUNT/10000.0,VOLSTICK;\n\
AMO1:MA(AMOW,M1);\n\
AMO2:MA(AMOW,M2);' };



  return data;
};

JSIndexScript.prototype.VRSI = function ()
{
  var data =
  {
    Name: 'VRSI', Description: '相对强弱量', IsMainIndex: false,
    Args: [{ Name: 'N1', Value: 6 }, { Name: 'N2', Value: 12 }, { Name: 'N3', Value: 24 }],
    Script: //脚本
    'LC:=REF(VOL,1);\n\
RSI1:SMA(MAX(VOL-LC,0),N1,1)/SMA(ABS(VOL-LC),N1,1)*100;\n\
RSI2:SMA(MAX(VOL-LC,0),N2,1)/SMA(ABS(VOL-LC),N2,1)*100;\n\
RSI3:SMA(MAX(VOL-LC,0),N3,1)/SMA(ABS(VOL-LC),N3,1)*100;' };



  return data;
};

JSIndexScript.prototype.HSCOL = function ()
{
  var data =
  {
    Name: 'HSCOL', Description: '换手柱', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 5 }],
    Script: //脚本
    'HSCOL:IF((SETCODE==0||SETCODE==1),100*VOL,VOL)/(FINANCE(7)/100),VOLSTICK;\n\
MAHSL:MA(HSCOL,N);' };



  return data;
};

JSIndexScript.prototype.DBQRV = function ()
{
  var data =
  {
    Name: 'DBQRV', Description: '对比强弱量(需下载日线)', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 5 }],
    Script: //脚本
    'ZS:(INDEXV-REF(INDEXV,N))/REF(INDEXV,N);\n\
GG:(VOL-REF(VOL,N))/REF(VOL,N);' };



  return data;
};

JSIndexScript.prototype.DBLB = function ()
{
  var data =
  {
    Name: 'DBLB', Description: '对比量比(需下载日线)', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 5 }, { Name: 'M', Value: 5 }],
    Script: //脚本
    'GG:=VOL/SUM(REF(VOL,1),N);\n\
ZS:=INDEXV/SUM(REF(INDEXV,1),N);\n\
DBLB:GG/ZS;\n\
MADBLB:MA(DBLB,M);' };



  return data;
};

JSIndexScript.prototype.ACD = function ()
{
  var data =
  {
    Name: 'ACD', Description: '升降线', IsMainIndex: false,
    Args: [{ Name: 'M', Value: 20 }],
    Script: //脚本
    'LC:=REF(CLOSE,1);\n\
DIF:=CLOSE-IF(CLOSE>LC,MIN(LOW,LC),MAX(HIGH,LC));\n\
ACD:SUM(IF(CLOSE==LC,0,DIF),0);\n\
MAACD:EXPMEMA(ACD,M);' };



  return data;
};

JSIndexScript.prototype.EXPMA = function ()
{
  var data =
  {
    Name: 'EXPMA', Description: '指数平均线', IsMainIndex: true,
    Args: [{ Name: 'M1', Value: 12 }, { Name: 'M2', Value: 50 }],
    Script: //脚本
    'EXP1:EMA(CLOSE,M1);\n\
EXP2:EMA(CLOSE,M2);' };



  return data;
};

JSIndexScript.prototype.EXPMA_S = function ()
{
  var data =
  {
    Name: 'EXPMA_S', Description: '指数平均线-副图', IsMainIndex: false,
    Args: [{ Name: 'M1', Value: 12 }, { Name: 'M2', Value: 50 }],
    Script: //脚本
    'EXP1:EMA(CLOSE,M1);\n\
EXP2:EMA(CLOSE,M2);' };



  return data;
};

JSIndexScript.prototype.HMA = function ()
{
  var data =
  {
    Name: 'HMA', Description: '高价平均线', IsMainIndex: true,
    Args: [{ Name: 'M1', Value: 6 }, { Name: 'M2', Value: 12 }, { Name: 'M3', Value: 30 }, { Name: 'M4', Value: 72 }, { Name: 'M5', Value: 144 }],
    Script: //脚本
    'HMA1:MA(HIGH,M1);\n\
HMA2:MA(HIGH,M2);\n\
HMA3:MA(HIGH,M3);\n\
HMA4:MA(HIGH,M4);\n\
HMA5:MA(HIGH,M5);' };



  return data;
};

JSIndexScript.prototype.LMA = function ()
{
  var data =
  {
    Name: 'LMA', Description: '低价平均线', IsMainIndex: true,
    Args: [{ Name: 'M1', Value: 6 }, { Name: 'M2', Value: 12 }, { Name: 'M3', Value: 30 }, { Name: 'M4', Value: 72 }, { Name: 'M5', Value: 144 }],
    Script: //脚本
    'LMA1:MA(LOW,M1);\n\
LMA2:MA(LOW,M2);\n\
LMA3:MA(LOW,M3);\n\
LMA4:MA(LOW,M4);\n\
LMA5:MA(LOW,M5);' };



  return data;
};

JSIndexScript.prototype.VMA = function ()
{
  var data =
  {
    Name: 'VMA', Description: '变异平均线', IsMainIndex: true,
    Args: [{ Name: 'M1', Value: 6 }, { Name: 'M2', Value: 12 }, { Name: 'M3', Value: 30 }, { Name: 'M4', Value: 72 }, { Name: 'M5', Value: 144 }],
    Script: //脚本
    'VV:=(HIGH+OPEN+LOW+CLOSE)/4;\n\
VMA1:MA(VV,M1);\n\
VMA2:MA(VV,M2);\n\
VMA3:MA(VV,M3);\n\
VMA4:MA(VV,M4);\n\
VMA5:MA(VV,M5);' };



  return data;
};


JSIndexScript.prototype.AMV = function ()
{
  var data =
  {
    Name: 'AMV', Description: '成本价均线', IsMainIndex: false,
    Args: [{ Name: 'M1', Value: 6 }, { Name: 'M2', Value: 12 }, { Name: 'M3', Value: 30 }, { Name: 'M4', Value: 72 }, { Name: 'M5', Value: 144 }],
    Script: //脚本
    'AMOV:=VOL*(OPEN+CLOSE)/2;\n\
AMV1:SUM(AMOV,M1)/SUM(VOL,M1);\n\
AMV2:SUM(AMOV,M2)/SUM(VOL,M2);\n\
AMV3:SUM(AMOV,M3)/SUM(VOL,M3);\n\
AMV4:SUM(AMOV,M4)/SUM(VOL,M4);' };



  return data;
};

JSIndexScript.prototype.BBIBOLL = function ()
{
  var data =
  {
    Name: 'BBIBOLL', Description: '多空布林线', IsMainIndex: true,
    Args: [{ Name: 'N', Value: 11 }, { Name: 'M', Value: 6 }],
    Script: //脚本
    'CV:=CLOSE;\n\
BBIBOLL:(MA(CV,3)+MA(CV,6)+MA(CV,12)+MA(CV,24))/4;\n\
UPR:BBIBOLL+M*STD(BBIBOLL,N);\n\
DWN:BBIBOLL-M*STD(BBIBOLL,N);' };



  return data;
};

JSIndexScript.prototype.ALLIGAT = function ()
{
  var data =
  {
    Name: 'ALLIGAT', Description: '鳄鱼线', IsMainIndex: true,
    Args: [],
    Script: //脚本
    'NN:=(H+L)/2;\n\
上唇:REF(MA(NN,5),3),COLOR40FF40;\n\
牙齿:REF(MA(NN,8),5),COLOR0000C0;\n\
下颚:REF(MA(NN,13),8),COLORFF4040;' };



  return data;
};

JSIndexScript.prototype.ZX = function ()
{
  var data =
  {
    Name: 'ZX', Description: '重心线', IsMainIndex: false,
    Args: [],
    Script: //脚本
    'AV:0.01*AMOUNT/VOL;' };



  return data;
};

JSIndexScript.prototype.XS = function ()
{
  var data =
  {
    Name: 'XS', Description: '薛斯通道', IsMainIndex: true,
    Args: [{ Name: 'N', Value: 13 }],
    Script: //脚本
    'VAR2:=CLOSE*VOL;\n\
VAR3:=EMA((EMA(VAR2,3)/EMA(VOL,3)+EMA(VAR2,6)/EMA(VOL,6)+EMA(VAR2,12)/EMA(VOL,12)+EMA(VAR2,24)/EMA(VOL,24))/4,N);\n\
SUP:1.06*VAR3;\n\
SDN:VAR3*0.94;\n\
VAR4:=EMA(CLOSE,9);\n\
LUP:EMA(VAR4*1.14,5);\n\
LDN:EMA(VAR4*0.86,5);' };



  return data;
};

JSIndexScript.prototype.XS2 = function ()
{
  var data =
  {
    Name: 'XS2', Description: '薛斯通道II', IsMainIndex: true,
    Args: [{ Name: 'N', Value: 102 }, { Name: 'M', Value: 7 }],
    Script: //脚本
    'AA:=MA((2*CLOSE+HIGH+LOW)/4,5); \n\
通道1:AA*N/100; \n\
通道2:AA*(200-N)/100; \n\
CC:=ABS((2*CLOSE+HIGH+LOW)/4-MA(CLOSE,20))/MA(CLOSE,20); \n\
DD:=DMA(CLOSE,CC); \n\
通道3:(1+M/100)*DD; \n\
通道4:(1-M/100)*DD;' };



  return data;
};

JSIndexScript.prototype.SG_XDT = function ()
{
  var data =
  {
    Name: 'SG-XDT', Description: '心电图(需下载日线)', IsMainIndex: false,
    Args: [{ Name: 'P1', Value: 5 }, { Name: 'P2', Value: 10 }],
    Script: //脚本
    'QR:CLOSE/INDEXC*1000;\n\
MQR1:MA(QR,5);\n\
MQR2:MA(QR,10);' };



  return data;
};

JSIndexScript.prototype.SG_SMX = function ()
{
  var data =
  {
    Name: 'SG-SMX', Description: '生命线(需下载日线)', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 50 }],
    Script: //脚本
    'H1:=HHV(HIGH,N);\n\
L1:=LLV(LOW,N);\n\
H2:=HHV(INDEXH,N);\n\
L2:=LLV(INDEXL,N);\n\
ZY:=CLOSE/INDEXC*2000;\n\
ZY1:EMA(ZY,3);\n\
ZY2:EMA(ZY,17);\n\
ZY3:EMA(ZY,34);' };



  return data;
};

JSIndexScript.prototype.SG_LB = function ()
{
  var data =
  {
    Name: 'SG-LB', Description: '量比(需下载日线)', IsMainIndex: false,
    Args: [],
    Script: //脚本
    'ZY2:=VOL/INDEXV*1000;\n\
量比:ZY2;\n\
MA5:MA(ZY2,5);\n\
MA10:MA(ZY2,10);' };



  return data;
};

JSIndexScript.prototype.SG_PF = function ()
{
  var data =
  {
    Name: 'SG-PF', Description: '强势股评分(需下载日线)', IsMainIndex: false,
    Args: [],
    Script: //脚本
    'ZY1:=CLOSE/INDEXC*1000;\n\
A1:=IF(ZY1>HHV(ZY1,3),10,0);\n\
A2:=IF(ZY1>HHV(ZY1,5),15,0);\n\
A3:=IF(ZY1>HHV(ZY1,10),20,0);\n\
A4:=IF(ZY1>HHV(ZY1,2),10,0);\n\
A5:=COUNT(ZY1>REF(ZY1,1) ,9)*5;\n\
强势股评分:A1+A2+A3+A4+A5;' };



  return data;
};

JSIndexScript.prototype.RAD = function ()
{
  var data =
  {
    Name: 'RAD', Description: '威力雷达(需下载日线)', IsMainIndex: false,
    Args: [{ Name: 'D', Value: 3 }, { Name: 'S', Value: 30 }, { Name: 'M', Value: 30 }],
    Script: //脚本
    'SM:=(OPEN+HIGH+CLOSE+LOW)/4;\n\
SMID:=MA(SM,D);\n\
IM:=(INDEXO+INDEXH+INDEXL+INDEXC)/4;\n\
IMID:=MA(IM,D);\n\
SI1:=(SMID-REF(SMID,1))/SMID;\n\
II:=(IMID-REF(IMID,1))/IMID;\n\
RADER1:SUM((SI1-II)*2,S)*1000;\n\
RADERMA:SMA(RADER1,M,1);' };



  return data;
};

JSIndexScript.prototype.SHT = function ()
{
  var data =
  {
    Name: 'SHT', Description: '龙系短线', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 5 }],
    Script: //脚本
    'VAR1:=MA((VOL-REF(VOL,1))/REF(VOL,1),5);\n\
VAR2:=(CLOSE-MA(CLOSE,24))/MA(CLOSE,24)*100;\n\
MY: VAR2*(1+VAR1);\n\
SHT: MY, COLORSTICK;\n\
SHTMA: MA(SHT,N);' };



  return data;
};

JSIndexScript.prototype.ZLJC = function ()
{
  var data =
  {
    Name: 'ZLJC', Description: '主力进出', IsMainIndex: false,
    Args: [],
    Script: //脚本
    'VAR1:=(CLOSE+LOW+HIGH)/3; \n\
VAR2:=SUM(((VAR1-REF(LOW,1))-(HIGH-VAR1))*VOL/100000/(HIGH-LOW),0); \n\
VAR3:=EMA(VAR2,1); \n\
JCS:VAR3; \n\
JCM:MA(VAR3,12); \n\
JCL:MA(VAR3,26);' };



  return data;
};

JSIndexScript.prototype.ZLMM = function ()
{
  var data =
  {
    Name: 'ZLMM', Description: '主力买卖', IsMainIndex: false,
    Args: [],
    Script: //脚本
    'LC :=REF(CLOSE,1);\n\
RSI2:=SMA(MAX(CLOSE-LC,0),12,1)/SMA(ABS(CLOSE-LC),12,1)*100;\n\
RSI3:=SMA(MAX(CLOSE-LC,0),18,1)/SMA(ABS(CLOSE-LC),18,1)*100;\n\
MMS:MA(3*RSI2-2*SMA(MAX(CLOSE-LC,0),16,1)/SMA(ABS(CLOSE-LC),16,1)*100,3);\n\
MMM:EMA(MMS,8);\n\
MML:MA(3*RSI3-2*SMA(MAX(CLOSE-LC,0),12,1)/SMA(ABS(CLOSE-LC),12,1)*100,5);' };



  return data;
};

JSIndexScript.prototype.SLZT = function ()
{
  var data =
  {
    Name: 'SLZT', Description: '神龙在天', IsMainIndex: false,
    Args: [],
    Script: //脚本
    '白龙: MA(CLOSE,125);\n\
黄龙: 白龙+2*STD(CLOSE,170);\n\
紫龙: 白龙-2*STD(CLOSE,145);\n\
青龙: SAR(125,1,7), LINESTICK;\n\
VAR2:=HHV(HIGH,70);\n\
VAR3:=HHV(HIGH,20);\n\
红龙: VAR2*0.83;\n\
蓝龙: VAR3*0.91;' };



  return data;
};

JSIndexScript.prototype.ADVOL = function ()
{
  var data =
  {
    Name: 'ADVOL', Description: '龙系离散量', IsMainIndex: false,
    Args: [],
    Script: //脚本
    'A:=SUM(((CLOSE-LOW)-(HIGH-CLOSE))*VOL/10000/(HIGH-LOW),0);\n\
ADVOL:A;\n\
MA1:MA(A,30);\n\
MA2:MA(MA1,100);' };



  return data;
};

JSIndexScript.prototype.CYC = function ()
{
  var data =
  {
    Name: 'CYC', Description: '成本均线', IsMainIndex: true,
    Args: [{ Name: 'P1', Value: 5 }, { Name: 'P2', Value: 13 }, { Name: 'P3', Value: 34 }],
    Script: //脚本
    'JJJ:=IF(DYNAINFO(8)>0.01,0.01*DYNAINFO(10)/DYNAINFO(8),DYNAINFO(3));\n\
DDD:=(DYNAINFO(5)<0.01 || DYNAINFO(6)<0.01);\n\
JJJT:=IF(DDD,1,(JJJ<(DYNAINFO(5)+0.01) && JJJ>(DYNAINFO(6)-0.01)));\n\
CYC1:IF(JJJT,0.01*EMA(AMOUNT,P1)/EMA(VOL,P1),EMA((HIGH+LOW+CLOSE)/3,P1));\n\
CYC2:IF(JJJT,0.01*EMA(AMOUNT,P2)/EMA(VOL,P2),EMA((HIGH+LOW+CLOSE)/3,P2));\n\
CYC3:IF(JJJT,0.01*EMA(AMOUNT,P3)/EMA(VOL,P3),EMA((HIGH+LOW+CLOSE)/3,P3));\n\
CYC4:IF(JJJT,DMA(AMOUNT/(100*VOL),100*VOL/FINANCE(7)),EMA((HIGH+LOW+CLOSE)/3,120));' };



  return data;
};

JSIndexScript.prototype.CYS = function ()
{
  var data =
  {
    Name: 'CYS', Description: '市场盈亏', IsMainIndex: false,
    Args: [],
    Script: //脚本
    'CYC13:EMA(AMOUNT,13)/EMA(VOL,13);\n\
CYS:(CLOSE-CYC13)/CYC13*100;' };



  return data;
};

JSIndexScript.prototype.CYQKL = function ()
{
  var data =
  {
    Name: 'CYQKL', Description: '博弈K线长度', IsMainIndex: false,
    Args: [],
    Script: //脚本
    'KL:100*(WINNER(CLOSE)-WINNER(OPEN));' };



  return data;
};

JSIndexScript.prototype.SCR = function ()
{
  var data =
  {
    Name: 'SCR', Description: '筹码集中度', IsMainIndex: false,
    Args: [{ Name: 'P1', Value: 90 }],
    Script: //脚本
    'A:=P1+(100-P1)/2;\n\
B:=(100-P1)/2;\n\
CC:=COST(A);\n\
DD:=COST(B);\n\
SCR:(CC-DD)/(CC+DD)*100/2;' };



  return data;
};


JSIndexScript.prototype.ASR = function ()
{
  var data =
  {
    Name: 'ASR', Description: '浮筹比例', IsMainIndex: false,
    Args: [],
    Script: //脚本
    'ASR:(WINNER(C*1.1)-WINNER(C*0.9))/WINNER(HHV(H,0))*100;' };



  return data;
};

JSIndexScript.prototype.SAR = function ()
{
  var data =
  {
    Name: 'SAR', Description: '抛物转向', IsMainIndex: true,
    Args: [{ Name: 'P', Value: 10 }, { Name: 'STEP', Value: 2 }, { Name: 'MAXP', Value: 20 }],
    Script: //脚本
    'S:SAR(P,STEP,MAXP),CIRCLEDOT;' };



  return data;
};

JSIndexScript.prototype.TJCJL = function ()
{
  var data =
  {
    Name: '太极成交量', Description: '太极成交量', IsMainIndex: true,
    Args: [],
    Script: //脚本
    '总手:VOL,NODRAW;\n\
ZZ:=IF(REF(C,1)>REF(O,1) AND O>REF(C,1)*1.014 AND C<O*1.02,1,3);\n\
V5:=MA(V,5);\n\
V12:=MA(V,12);\n\
V34:=MA(V,34);\n\
C6:=MA(C,6);\n\
STICKLINE(VOL,0,VOL,10,0),COLORLIGRAY;\n\
STICKLINE(CROSS(C,C6) AND V>V5*1.2 AND V>V12*1.2 AND ZZ>2 AND C>H*0.975,0,VOL,10,0),COLORRED;\n\
STICKLINE(CROSS(C6,C) AND V>V5*1.2 AND V>V12*1.2,0,VOL,10,0),COLORGREEN;\n\
STICKLINE(VOL>MA(VOL,5)*2 AND V>V34*3 AND C<REF(C,1)*1.05,0,VOL,10,0),COLORYELLOW;\n\
STICKLINE(VOL<MA(VOL,5)/2 AND V<V12/2,0,VOL,10,0),COLORBLUE;\n\
STICKLINE(VOL>MA(VOL,5)*2 AND V>V34*3 AND C<REF(C,1)*1.05 AND CROSS(C,C6) AND V>V5*1.2 AND V>V12*1.2 AND ZZ>2 AND C>H*0.975,VOL*0.5,0,10,0),COLORRED;\n\
STICKLINE(VOL>MA(VOL,5)*2 AND V>V34*3 AND C<REF(C,1)*1.05 AND CROSS(C6,C) AND V>V5*1.2 AND V>V12*1.2,VOL*0.5,0,10,0),COLORRED;' };



  return data;
};

JSIndexScript.prototype.VOLRate = function ()
{
  var data =
  {
    Name: '量比', Description: '量比', IsMainIndex: false, Condition: { Period: [CONDITION_PERIOD.MINUTE_ID, CONDITION_PERIOD.MULTIDAY_MINUTE_ID] },
    Args: [],
    Script: //脚本
    "LIANGBI:VOLR;" };


  return data;
};

/*
       飞龙四式-主图
   */
JSIndexScript.prototype.Dragon4_Main = function ()
{
  var data =
  {
    Name: '飞龙四式', Description: '飞龙四式', IsMainIndex: true,
    Args: [{ Name: 'N1', Value: 5 }, { Name: 'N2', Value: 10 }, { Name: 'N3', Value: 50 }, { Name: 'N4', Value: 60 }],
    Script: //脚本
    '蜻蜓点水:=EMA(CLOSE,N1),COLORGRAY;\n\
魔界:=EMA(CLOSE,N2),COLORGREEN;\n\
水:=EMA(CLOSE,N3),COLORRED;\n\
DRAWKLINE(HIGH,OPEN,LOW,CLOSE);\n\
生命线:MA(CLOSE,N4),COLORBLUE,LINETHICK2;\n\
DRAWBAND(魔界,\'RGB(186,225,250)\',水,\'RGB(253,194,124)\');\n\
DRAWBAND(蜻蜓点水,\'RGB(128,138,135)\',魔界,\'RGB(0,0,255)\');' };



  return data;
};

JSIndexScript.prototype.Dragon4_Fig = function () {
  var data =
  {
    Name: '飞龙四式', Description: '飞龙四式', IsMainIndex: false,
    Args: [],
    Script: //脚本
    '倍:VOL>=REF(V,1)*1.90 AND C>REF(C,1),COLORYELLOW;\n\
低:VOL<REF(LLV(VOL,13),1),COLORGREEN;\n\
地:VOL<REF(LLV(VOL,100),1),COLORMAGENTA; \n\
平:=ABS(VOL-HHV(REF(VOL,1),5))/HHV(REF(VOL,1),5)<=0.03 OR ABS(VOL-REF(VOL,1))/REF(VOL,1)<=0.03,NODRAW,COLORWHITE;\n\
倍缩:VOL<=REF(V,1)*0.5,COLORFF8000;\n\
梯量:COUNT(V>REF(V,1),3)==3 AND COUNT(C>O,3)==3,COLORBROWN;\n\
缩量涨:COUNT(C>REF(C,1),2)==2 AND COUNT(V<REF(V,1),2)==2,COLORBLUE;\n\
STICKLINE(C>=REF(C,1),V,0,2,0),COLORRED;\n\
STICKLINE(C<REF(C,1),V,0,2,0),COLORGREEN;\n\
STICKLINE(倍,0,V,2,0),COLORYELLOW;\n\
STICKLINE(低,0,V,2,0),COLORGREEN;\n\
STICKLINE(地,0,V,2,0),COLORLIMAGENTA;\n\
STICKLINE(平,0,V,2,0),COLORGRAY;\n\
STICKLINE(倍缩,0,V,2,0),COLORFF8000;\n\
STICKLINE(梯量,0,V,2,0),COLORBROWN;\n\
STICKLINE(缩量涨,0,V,2,0),COLORBLUE;' };



  return data;
};


/*
   能图-资金分析
   M:=55;
   N:=34;
   LC:=REF(CLOSE,1);
   RSI:=((SMA(MAX((CLOSE - LC),0),3,1) / SMA(ABS((CLOSE - LC)),3,1)) * 100);
   FF:=EMA(CLOSE,3);
   MA15:=EMA(CLOSE,21); DRAWTEXT(CROSS(85,RSI),75,'▼'),COLORGREEN;
   VAR1:=IF(YEAR>=2038 AND MONTH>=1,0,1);
   VAR2:=REF(LOW,1)*VAR1;
   VAR3:=SMA(ABS(LOW-VAR2),3,1)/SMA(MAX(LOW-VAR2,0),3,1)*100*VAR1;
   VAR4:=EMA(IF(CLOSE*1.3,VAR3*10,VAR3/10),3)*VAR1;
   VAR5:=LLV(LOW,30)*VAR1;
   VAR6:=HHV(VAR4,30)*VAR1;
   VAR7:=IF(MA(CLOSE,58),1,0)*VAR1;
   VAR8:=EMA(IF(LOW<=VAR5,(VAR4+VAR6*2)/2,0),3)/618*VAR7*VAR1;
   吸筹A:IF(VAR8>100,100,VAR8)*VAR1,COLORRED;
   吸筹B:STICKLINE(吸筹A>-150,0,吸筹A,8,0),COLORRED;
   
   散户线: 100*(HHV(HIGH,M)-CLOSE)/(HHV(HIGH,M)-LLV(LOW,M)),COLORFFFF00,LINETHICK2;
   RSV:=(CLOSE-LLV(LOW,N))/(HHV(HIGH,N)-LLV(LOW,N))*100;
   K:=SMA(RSV,3,1);
   D:=SMA(K,3,1);
   J:=3*K-2*D;
   主力线:EMA(J,5),COLORFF00FF,LINETHICK2;
   DRAWICON(CROSS(主力线,散户线),主力线,1);
   DRAWICON(CROSS(散户线,主力线),主力线,2);
   */

JSIndexScript.prototype.FundsAnalysis = function ()
{
  var data =
  {
    Name: '资金分析', Description: '资金分析', IsMainIndex: false,
    Args: [{ Name: 'M', Value: 55 }, { Name: 'N', Value: 34 }],
    Script: //脚本
    'LC:=REF(CLOSE,1);\n\
RSI:=((SMA(MAX((CLOSE - LC),0),3,1) / SMA(ABS((CLOSE - LC)),3,1)) * 100);\n\
FF:=EMA(CLOSE,3);\n\
MA15:=EMA(CLOSE,21); DRAWTEXT(CROSS(85,RSI),75,\'▼\'),COLORGREEN;\n\
VAR1:=IF(YEAR>=2038 AND MONTH>=1,0,1);\n\
VAR2:=REF(LOW,1)*VAR1;\n\
VAR3:=SMA(ABS(LOW-VAR2),3,1)/SMA(MAX(LOW-VAR2,0),3,1)*100*VAR1;\n\
VAR4:=EMA(IF(CLOSE*1.3,VAR3*10,VAR3/10),3)*VAR1;\n\
VAR5:=LLV(LOW,30)*VAR1;\n\
VAR6:=HHV(VAR4,30)*VAR1;\n\
VAR7:=IF(MA(CLOSE,58),1,0)*VAR1;\n\
VAR8:=EMA(IF(LOW<=VAR5,(VAR4+VAR6*2)/2,0),3)/618*VAR7*VAR1;\n\
吸筹A:IF(VAR8>100,100,VAR8)*VAR1,COLORFB2F3B;\n\
{吸筹B}STICKLINE(吸筹A>-150,0,吸筹A,8,0),COLORFB2F3B;\n\
\n\
散户线: 100*(HHV(HIGH,M)-CLOSE)/(HHV(HIGH,M)-LLV(LOW,M)),COLORAA89BD,LINETHICK2;\n\
RSV:=(CLOSE-LLV(LOW,N))/(HHV(HIGH,N)-LLV(LOW,N))*100;\n\
K:=SMA(RSV,3,1);\n\
D:=SMA(K,3,1);\n\
J:=3*K-2*D;\n\
主力线:EMA(J,5),COLORF39800,LINETHICK2;\n\
DRAWICON(CROSS(主力线,散户线),主力线,1);\n\
DRAWICON(CROSS(散户线,主力线),主力线,2);' };


  return data;
};

JSIndexScript.prototype.MarginProportion = function ()
{
  var data =
  {
    Name: '融资占比(%)', Description: '融资占比', IsMainIndex: false,
    Args: [],
    Script: //脚本
    '占比:MARGIN(2);' };


  return data;
};

JSIndexScript.prototype.BTX = function ()
{
  var data =
  {
    Name: 'BTX', Description: '宝塔线', IsMainIndex: false,
    Args: [],
    Script: //脚本
    'B1:=REF(C,1);\n\
B2:= REF(C, 2);\n\
SS:= IF(C > REF(C, 1) AND REF(C, 1) >= REF(C, 2), 1, IF(C < REF(C, 1) AND REF(C, 1) <= REF(C, 2), -1, IF(C > REF(C, 2) AND REF(C, 2) > REF(C, 1), 2, IF(C < REF(C, 2) AND REF(C, 2) < REF(C, 1), -2, 0))));\n\
SM:= IF(REF(SS, 1) <> 0, REF(SS, 1), IF(REF(SS, 2) <> 0, REF(SS, 2), IF(REF(SS, 3) <> 0, REF(SS, 3), IF(REF(SS, 5) <> 0, REF(SS, 5), IF(REF(SS, 6) <> 0, REF(SS, 6), IF(REF(SS, 7) <> 0, REF(SS, 7), 0))))));\n\
MC:= IF(REF(SS, 1) <> 0, B2, IF(SM > 0, MIN(B1, B2), MAX(B1, B2)));\n\
TOW1:= IF(C > REF(C, 1), C, REF(C, 1));\n\
TOW2:= IF((SS == -1 OR SS == -2) AND SM > 0, B2, TOW1);\n\
TOWER:= IF(TOW1 > TOW2, TOW1, TOW2);\n\
STICKLINE(SS == 1 OR SM >= 1 AND SS == 0, B1, C, 10, 1), COLORRED;\n\
STICKLINE(SS == -1 OR SM <= -1 AND SS == 0, B1, C, 10, 0), COLORCYAN;\n\
STICKLINE(SS == 2, B2, C, 10, 1), COLORRED;\n\
STICKLINE(SS == -2, B2, C, 10, 0), COLORCYAN;\n\
STICKLINE((SS == -1 OR SS == -2) AND SM > 0, B2, B1, 10, 1), COLORRED;\n\
STICKLINE((SS == 1 OR SS == 2) AND SM < 0, B2, B1, 10, 0), COLORCYAN;' };


  return data;
};


JSIndexScript.prototype.EMPTY = function ()
{
  var data =
  {
    Name: '', Description: '空指标', IsMainIndex: true,
    Args: [],
    Script: //脚本
    'VAR2:=C;' };


  return data;
};

JSIndexScript.prototype.FXG_BSPoint = function ()
{
  var data =
  {
    Name: '操盘BS点', Description: '操盘BS点', IsMainIndex: true,
    Args: [],
    Script: //脚本
    'MA5:MA(CLOSE,5);\n\
        MA13:MA(CLOSE,13);\n\
        MA21:MA(CLOSE,21);\n\
        MA34:MA(CLOSE,34);\n\
        {MA55:MA(CLOSE,55),COLOR0000FF;}\n\
        {MA120:=MA(CLOSE,120),COLORFFFF00;}\n\
        天使:=EMA(C,2),COLOR000000;\n\
        魔鬼:=EMA(SLOPE(C,21)*20+C,42),COLOR000000;\n\
        买:=CROSS(天使,魔鬼);\n\
        卖:=CROSS(魔鬼,天使);\n\
        DRAWICON(买,L*0.99,13),COLORYELLOW;\n\
        DRAWICON(卖,H*1.01,14),COLORGREEN;\n\
        DRAWKLINE_IF(天使>=魔鬼,HIGH,CLOSE,LOW,OPEN),COLORRED;\n\
        DRAWKLINE_IF(天使<魔鬼,HIGH,CLOSE,LOW,OPEN),COLORBLUE;\n\
        DRAWKLINE_IF(CROSS(天使,魔鬼),HIGH,CLOSE,LOW,OPEN),COLORYELLOW;\n\
        DRAWKLINE_IF(CROSS(魔鬼,天使),HIGH,CLOSE,LOW,OPEN),COLORBLACK;' };


  return data;
};

JSIndexScript.prototype.NewsNegative = function ()
{
  var data =
  {
    Name: '负面新闻', Description: '负面新闻统计', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 5 }, { Name: 'N2', Value: 10 }],
    Script: //脚本
    '负面:NEWS(1);\n\
                MA1:MA(负面,N);\n\
                MA2:MA(负面,N2);' };


  return data;
};

JSIndexScript.prototype.NewsResearch = function () {
  var data =
  {
    Name: '机构调研', Description: '机构调研统计', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 5 }, { Name: 'N2', Value: 10 }],
    Script: //脚本
    '次数:NEWS(2);\n\
                MA1:MA(次数,N);\n\
                MA2:MA(次数,N2);' };


  return data;
};

JSIndexScript.prototype.NewsInteract = function () {
  var data =
  {
    Name: '董秘连线', Description: '互动易统计', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 5 }, { Name: 'N2', Value: 10 }],
    Script: //脚本
    '个数:NEWS(3);\n\
                MA1:MA(个数,N);\n\
                MA2:MA(个数,N2);' };


  return data;
};

JSIndexScript.prototype.UpDownAnalyze = function ()
{
  var data =
  {
    Name: '涨跌趋势', Description: '涨跌趋势', IsMainIndex: false, FloatPrecision: 0,
    Args: [],
    Script: //脚本
    "上涨家数:UPCOUNT('CNA.CI'),COLORRED;\n\
下跌家数:DOWNCOUNT('CNA.CI'),COLORGREEN;" };


  return data;
};

//外包指标
JSIndexScript.prototype.FXG_BSPoint = function ()
{
  var data =
  {
    Name: '操盘BS点', Description: '操盘BS点', IsMainIndex: true,
    Args: [],
    Script: //脚本
    'MA5:MA(CLOSE,5);\n\
        MA13:MA(CLOSE,13);\n\
        MA21:MA(CLOSE,21);\n\
        MA34:MA(CLOSE,34);\n\
        {MA55:MA(CLOSE,55),COLOR0000FF;}\n\
        {MA120:=MA(CLOSE,120),COLORFFFF00;}\n\
        天使:=EMA(C,2),COLOR000000;\n\
        魔鬼:=EMA(SLOPE(C,21)*20+C,42),COLOR000000;\n\
        买:=CROSS(天使,魔鬼);\n\
        卖:=CROSS(魔鬼,天使);\n\
        SUPERDRAWTEXT(买,L,"B",2,5),COLORYELLOW;\n\
        SUPERDRAWTEXT(卖,L,"S",1,5),COLORGREEN;\n\
        DRAWKLINE_IF(天使>=魔鬼,HIGH,CLOSE,LOW,OPEN),COLORRED;\n\
        DRAWKLINE_IF(天使<魔鬼,HIGH,CLOSE,LOW,OPEN),COLORBLUE;\n\
        DRAWKLINE_IF(CROSS(天使,魔鬼),HIGH,CLOSE,LOW,OPEN),COLORYELLOW;\n\
        DRAWKLINE_IF(CROSS(魔鬼,天使),HIGH,CLOSE,LOW,OPEN),COLORBLACK;' };


  return data;
};

JSIndexScript.prototype.FXG_INDEX = function ()
{
  var data =
  {
    Name: '涨停多空线', Description: '涨停多空线', IsMainIndex: false,
    Args: [],
    Script: //脚本
    '做多能量线: SMA((CLOSE-LLV(LOW,9))/(HHV(HIGH,9)-LLV(LOW,9))*100,5,1)-8,COLORRED,LINETHICK3;\n\
做空能量线: SMA((HHV(HIGH,36)-CLOSE)/(HHV(HIGH,36)-LLV(LOW,36))*100,2,1),COLORGREEN,LINETHICK3;\n\
20,POINTDOT,COLORF00FF0;\n\
50,POINTDOT,COLORGREEN;\n\
80,POINTDOT,COLORLIBLUE;' };


  return data;
};

JSIndexScript.prototype.FXG_INDEX2 = function ()
{
  var data =
  {
    Name: '涨停吸筹区', Description: '涨停吸筹区', IsMainIndex: false,
    Args: [],
    Script: //脚本
    'VAR0:=EMA(HHV(HIGH,500),21); \n\
VAR1:=EMA(HHV(HIGH,250),21);\n\
VAR2:=EMA(HHV(HIGH,90),21); \n\
VAR3:=EMA(LLV(LOW,500),21); \n\
VAR4:=EMA(LLV(LOW,250),21); \n\
VAR5:=EMA(LLV(LOW,90),21);\n\
\n\
VAR6:=EMA((VAR3*0.96+VAR4*0.96+VAR5*0.96+VAR0*0.558+VAR1*0.558+VAR2*0.558)/6,21); \n\
VAR7:=EMA((VAR3*1.25+VAR4*1.23+VAR5*1.2+VAR0*0.55+VAR1*0.55+VAR2*0.65)/6,21); \n\
VAR8:=EMA((VAR3*1.3+VAR4*1.3+VAR5*1.3+VAR0*0.68+VAR1*0.68+VAR2*0.68)/6,21); \n\
VAR9:=EMA((VAR6*3+VAR7*2+VAR8)/6*1.738,21); \n\
VAR10:=REF(LOW,1); \n\
VAR11:=SMA(ABS(LOW-VAR10),3,1)/SMA(MAX(LOW-VAR10,0),3,1)*100; \n\
VAR12:=EMA(IFF(CLOSE*1.35<=VAR9,VAR11*10,VAR11/10),3); \n\
VAR13:=LLV(LOW,30); \n\
VAR14:=HHV(VAR12,30); \n\
VAR15:=IFF(MA(CLOSE,58),1,0); \n\
VAR16:=EMA(IFF(LOW<=VAR13,(VAR12+VAR14*2)/2,0),3)/618*VAR15;\n\
\n\
资金入场:IFF(VAR16>0,VAR16,0),LINETHICK,LINETHICK2, COLORFF0000; \n\
\n\
A1:IFF(资金入场>0,资金入场*1.2,0),STICK,LINETHICK5, COLORFF0000;\n\
A2:IFF(资金入场>0,资金入场*0.8,0),STICK,LINETHICK5, COLORFF6600;\n\
A3:IFF(资金入场>0,资金入场*0.6,0),STICK,LINETHICK5, COLORFF9900;\n\
A4:IFF(资金入场>0,资金入场*0.4,0) ,STICK,LINETHICK5,COLORFFCC00;\n\
A5:IFF(资金入场>0,资金入场*0.2,0) ,STICK,LINETHICK5,COLORFFFF00;' };


  return data;
};

JSIndexScript.prototype.FXG_INDEX3 = function ()
{
  var data =
  {
    Name: '量能黄金点', Description: '量能黄金点', IsMainIndex: false,
    Args: [],
    Script: //脚本
    'A:=IFF((CLOSE>126.32),VOL,VOL); \n\
主力:=MA(A,4),COLORRED;\n\
游资:=MA(A,8),COLORYELLOW;\n\
大户:=MA(A,16),COLORF0F000;\n\
散户:=MA(A,32),COLOR00FF00;\n\
主比:=ABS(((主力)/(主力 + 游资 + 大户 + 散户))*(100)),LINESTICK,COLORRED;\n\
游比:=ABS(((游资)/(主力 + 游资 + 大户 + 散户))*(100)),LINESTICK,COLORYELLOW;\n\
大比:=ABS(((大户)/(主力 + 游资 + 大户 + 散户))*(100)),LINESTICK,COLORF0F000;\n\
散比:=ABS(((散户)/(主力 + 游资 + 大户 + 散户))*(100)),LINESTICK,COLOR00FF00;\n\
警戒线:MA(A,180),COLORFF66FF;\n\
STICKLINE((主力 > 0),0,主力,2.5,0),COLOR1020BB;\n\
STICKLINE((主力 > 0),0,主力,0.7,0),COLORRED;\n\
STICKLINE((游资 > 0),0,游资,2.5,0),COLOR009CFF;\n\
STICKLINE((游资 > 0),0,游资,0.7,0),COLORYELLOW;\n\
STICKLINE((大户 > 0),0,大户,2.5,0),COLORFF8800;\n\
STICKLINE((大户 > 0),0,大户,0.7,0),COLORLIBLUE;\n\
STICKLINE((散户 > 0),0,散户,2.5,0),COLOR00CA00;\n\
STICKLINE((散户 > 0),0,散户,0.7,0),COLORGREEN;' };


  return data;
};

////////////////////////////////////////////////////////////////////////////////////////////////
//五彩K线

JSIndexScript.prototype.COLOR_KSTAR1 = function ()
{
  var data =
  {
    Name: '十字星', Description: '十字星', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'KSTAR:CLOSE==OPEN&&HIGH>LOW;' };


  return data;
};

JSIndexScript.prototype.COLOR_KSTAR2 = function ()
{
  var data =
  {
    Name: '早晨之星', Description: '早晨之星', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'KSTAR:(REF(CLOSE,2)/REF(OPEN,2)<0.95) && (REF(OPEN,1) < REF(CLOSE,2)) && (ABS(REF(OPEN,1)-REF(CLOSE,1))/REF(CLOSE,1)<0.03) && CLOSE/OPEN>1.05 && CLOSE>REF(CLOSE,2);' };


  return data;
};

JSIndexScript.prototype.COLOR_KSTAR3 = function ()
{
  var data =
  {
    Name: '黄昏之星', Description: '黄昏之星', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'KSTAR:REF(CLOSE,2)/REF(OPEN,2)>1.05 && REF(OPEN,1)>REF(CLOSE,2) && ABS(REF(OPEN,1)-REF(CLOSE,1))/REF(CLOSE,1)<0.03 && CLOSE/OPEN<0.95 && CLOSE<REF(CLOSE,2);' };


  return data;
};

JSIndexScript.prototype.COLOR_SHI1 = function ()
{
  var data =
  {
    Name: '长十字', Description: '长十字', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'KSTAR:CLOSE==OPEN&&HIGH/LOW>1.03;' };


  return data;
};

JSIndexScript.prototype.COLOR_K220 = function ()
{
  var data =
  {
    Name: '身怀六甲', Description: '身怀六甲', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'KSTAR:ABS(REF(CLOSE,1)-REF(OPEN,1))/REF(CLOSE,1)>0.04&&\n\
            ABS(CLOSE-OPEN)/CLOSE<0.005&&\n\
            MAX(CLOSE,OPEN)<MAX(REF(CLOSE,1),REF(OPEN,1))&&\n\
            MIN(CLOSE,OPEN)>MIN(REF(CLOSE,1),REF(OPEN,1));' };


  return data;
};

JSIndexScript.prototype.COLOR_K300 = function ()
{
  var data =
  {
    Name: '三个白武士', Description: '三个白武士', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'KSTAR:UPNDAY(CLOSE,3)&&NDAY(CLOSE,OPEN,3);' };


  return data;
};


JSIndexScript.prototype.COLOR_K310 = function ()
{
  var data =
  {
    Name: '三只乌鸦', Description: '三只乌鸦', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'KSTAR:DOWNNDAY(CLOSE,3)&&NDAY(OPEN,CLOSE,3);' };


  return data;
};

JSIndexScript.prototype.COLOR_K380 = function ()
{
  var data =
  {
    Name: '光头阳线', Description: '光头阳线', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'KSTAR:HIGH==CLOSE&&HIGH>LOW;' };


  return data;
};

JSIndexScript.prototype.COLOR_K390 = function ()
{
  var data =
  {
    Name: '光脚阴线', Description: '光脚阴线', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'KSTAR:LOW==CLOSE&&HIGH>LOW;' };


  return data;
};

JSIndexScript.prototype.COLOR_K134 = function ()
{
  var data =
  {
    Name: '垂死十字', Description: '垂死十字', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'KSTAR:CLOSE==OPEN&&CLOSE==LOW&&CLOSE<HIGH;' };


  return data;
};

JSIndexScript.prototype.COLOR_K140 = function ()
{
  var data =
  {
    Name: '早晨十字星', Description: '早晨十字星', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'KSTAR:REF(CLOSE,2)/REF(OPEN,2)<0.95&&\n\
REF(OPEN,1)<REF(CLOSE,2)&&\n\
REF(OPEN,1)==REF(CLOSE,1)&&\n\
CLOSE/OPEN>1.05&&CLOSE>REF(CLOSE,2);' };


  return data;
};

JSIndexScript.prototype.COLOR_K150 = function ()
{
  var data =
  {
    Name: '黄昏十字星', Description: '黄昏十字星', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'KSTAR:REF(CLOSE,2)/REF(OPEN,2)>1.05&&\n\
REF(OPEN,1)>REF(CLOSE,2)&&\n\
REF(OPEN,1)=REF(CLOSE,1)&&\n\
CLOSE/OPEN<0.95&&CLOSE<REF(CLOSE,2);' };


  return data;
};

JSIndexScript.prototype.COLOR_K160 = function ()
{
  var data =
  {
    Name: '射击之星', Description: '射击之星', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'KSTAR:MIN(OPEN,CLOSE)==LOW&&\n\
HIGH-LOW>3*(MAX(OPEN,CLOSE)-LOW)&&\n\
CLOSE>MA(CLOSE,5);' };


  return data;
};

JSIndexScript.prototype.COLOR_K165 = function ()
{
  var data =
  {
    Name: '倒转锤头', Description: '倒转锤头', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'KSTAR:MIN(OPEN,CLOSE)==LOW&&\n\
HIGH-LOW>3*(MAX(OPEN,CLOSE)-LOW)&&\n\
CLOSE<MA(CLOSE,5);' };


  return data;
};

JSIndexScript.prototype.COLOR_K170 = function ()
{
  var data =
  {
    Name: '锤头', Description: '锤头', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'OUT:HIGH==MAX(OPEN,CLOSE)&&\n\
HIGH-LOW>3*(HIGH-MIN(OPEN,CLOSE))&&\n\
CLOSE<MA(CLOSE,5);' };


  return data;
};

JSIndexScript.prototype.COLOR_K180 = function ()
{
  var data =
  {
    Name: '吊颈', Description: '吊颈', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'OUT:HIGH==MAX(OPEN,CLOSE)&&\n\
HIGH-LOW>3*(HIGH-MIN(OPEN,CLOSE))&&\n\
CLOSE>MA(CLOSE,5);' };


  return data;
};

JSIndexScript.prototype.COLOR_K190 = function ()
{
  var data =
  {
    Name: '穿头破脚', Description: '穿头破脚', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'OUT:(REF(CLOSE,1)/REF(OPEN,1)>1.03&&\n\
CLOSE/OPEN<0.96&&\n\
CLOSE<REF(OPEN,1)&&OPEN>REF(CLOSE,1))||\n\
(REF(CLOSE,1)/REF(OPEN,1)<0.97&&\n\
CLOSE/OPEN>1.04&&\n\
CLOSE>REF(OPEN,1)&&OPEN<REF(CLOSE,1));' };


  return data;
};

JSIndexScript.prototype.COLOR_SWORD = function ()
{
  var data =
  {
    Name: '剑', Description: '剑', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'AA:=VOL>REF(VOL,1)||VOL>(CAPITAL*0.1);\n\
BB:=OPEN>=(REF(HIGH,1))&&REF(HIGH,1)>(REF(HIGH,2)*1.06);\n\
CC:=CLOSE>(REF(CLOSE,1))-(REF(CLOSE,1)*0.01);\n\
DD:=CLOSE<(HIGH*0.965) && HIGH>(OPEN*1.05);\n\
EE:=LOW<OPEN && LOW<CLOSE&&HIGH>(REF(CLOSE,1)*1.06);\n\
FF:=(HIGH-(MAX(OPEN,CLOSE)))/2>(MIN(OPEN,CLOSE))-LOW;\n\
GG:=(ABS(OPEN-CLOSE))/2<(MIN(OPEN,CLOSE)-LOW);\n\
SWORDO:AA&&BB&&CC&&DD&&EE&&FF&&GG;' };


  return data;
};

JSIndexScript.prototype.COLOR_CSFR = function ()
{
  var data =
  {
    Name: '出水芙蓉', Description: '出水芙蓉', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'A:=CLOSE>OPEN;\n\
B:=A&&CLOSE>MA(CLOSE,S)&&CLOSE>MA(CLOSE,M)&&CLOSE>MA(CLOSE,LL);\n\
CC:=B&&OPEN<MA(CLOSE,M)&&OPEN<MA(CLOSE,LL);\n\
CSFRO:CC&&(CLOSE-OPEN)>0.0618*CLOSE;' };


  return data;
};

JSIndexScript.prototype.COLOR_WYGD = function ()
{
  var data =
  {
    Name: '乌云盖顶', Description: '乌云盖顶', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'VAR1:BACKSET( \n\
REF(CLOSE,1)/REF(OPEN,1)>1.03 AND \n\
CLOSE/OPEN<0.97 AND \n\
OPEN>REF(CLOSE,1) AND CLOSE<REF(CLOSE,1), 3);' };


  return data;
};

JSIndexScript.prototype.COLOR_SGCJ = function ()
{
  var data =
  {
    Name: '乌云盖顶', Description: '乌云盖顶', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'VAR1:BACKSET( \n\
REF(CLOSE,1)/REF(OPEN,1)<0.97 AND \n\
CLOSE/OPEN>1.03 AND \n\
OPEN<REF(CLOSE,1) AND CLOSE>REF(CLOSE,1), 3);' };


  return data;
};

JSIndexScript.prototype.COLOR_SZTAI = function ()
{
  var data =
  {
    Name: '十字胎', Description: '十字胎', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'VAR1:BACKSET( ABS(REF(CLOSE,1)-REF(OPEN,1))/REF(CLOSE,1) > 0.04 AND \n\
CLOSE==OPEN AND CLOSE < MAX(REF(CLOSE,1),REF(OPEN,1)) AND \n\
CLOSE > MIN(REF(CLOSE,1),REF(OPEN,1)), 2);' };


  return data;
};

JSIndexScript.prototype.COLOR_PINGDING = function ()
{
  var data =
  {
    Name: '平顶', Description: '平顶', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'VAR1:BACKSET(ABS(HIGH-REF(HIGH,1))/HIGH<0.001,2);' };


  return data;
};

JSIndexScript.prototype.COLOR_PINGDI = function ()
{
  var data =
  {
    Name: '平底', Description: '平底', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'VAR1:BACKSET((ABS(LOW-REF(LOW,1))/LOW<0.001 AND \n\
ABS(REF(LOW,1)-REF(LOW,2))/REF(LOW,1)<=0.001),2);' };


  return data;
};

JSIndexScript.prototype.COLOR_DAYANZHU = function ()
{
  var data =
  {
    Name: '大阳烛', Description: '大阳烛', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'VAR1:CLOSE/OPEN>1.05 AND HIGH/LOW < CLOSE/OPEN+0.018;' };


  return data;
};

JSIndexScript.prototype.COLOR_DAYINGZHU = function ()
{
  var data =
  {
    Name: '大阴烛', Description: '大阴烛', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'VAR1:OPEN/CLOSE > 1.05 AND HIGH/LOW < OPEN/CLOSE+0.018;' };


  return data;
};

JSIndexScript.prototype.COLOR_HYFG = function ()
{
  var data =
  {
    Name: '好友反攻', Description: '好友反攻', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'VAR1:BACKSET( (REF(CLOSE,1)<REF(OPEN,1) AND \n\
CLOSE>OPEN AND ABS(CLOSE-REF(CLOSE,1))/CLOSE<0.002),2);' };


  return data;
};

JSIndexScript.prototype.COLOR_TKQK = function ()
{
  var data =
  {
    Name: '跳空缺口', Description: '跳空缺口', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'VAR1:BACKSET( HIGH<REF(LOW,1) OR LOW>REF(HIGH,1),2);' };


  return data;
};

JSIndexScript.prototype.COLOR_SFWY = function ()
{
  var data =
  {
    Name: '双飞乌鸦', Description: '双飞乌鸦', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'VAR1:BACKSET( REF(CLOSE,1)<REF(OPEN,1) AND CLOSE<OPEN AND CLOSE/OPEN<0.98,1);' };


  return data;
};

JSIndexScript.prototype.COLOR_SSSBQ = function ()
{
  var data =
  {
    Name: '上升三部曲', Description: '上升三部曲', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'VAR1:BACKSET( \n\
REF(CLOSE,4)/REF(OPEN,4)>1.03 AND \n\
REF(CLOSE,3)<REF(OPEN,3) AND \n\
REF(CLOSE,2)<REF(OPEN,2) AND \n\
REF(CLOSE,1)<REF(OPEN,1) AND \n\
REF(LOW,4)<REF(LOW,3) AND \n\
REF(LOW,4)<REF(LOW,2) AND \n\
REF(LOW,4)<REF(LOW,1) AND \n\
REF(HIGH,4)>REF(HIGH,3) AND \n\
REF(HIGH,4)>REF(HIGH,2) AND \n\
REF(HIGH,4)>REF(HIGH,1) AND \n\
CLOSE/OPEN>1.03 AND \n\
CLOSE>REF(CLOSE,4), 5);' };


  return data;
};

JSIndexScript.prototype.COLOR_XDSBQ = function ()
{
  var data =
  {
    Name: '下跌三部曲', Description: '下跌三部曲', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'VAR1:BACKSET( \n\
REF(CLOSE,4)/REF(OPEN,4)<0.97 AND \n\
REF(CLOSE,3)>REF(OPEN,3) AND \n\
REF(CLOSE,2)>REF(OPEN,2) AND \n\
REF(CLOSE,1)>REF(OPEN,1) AND \n\
REF(LOW,4)<REF(LOW,3) AND \n\
REF(LOW,4)<REF(LOW,2) AND \n\
REF(LOW,4)<REF(LOW,1) AND \n\
REF(HIGH,4)>REF(HIGH,3) AND \n\
REF(HIGH,4)>REF(HIGH,2) AND \n\
REF(HIGH,4)>REF(HIGH,1) AND \n\
CLOSE/OPEN<0.97 AND \n\
CLOSE<REF(CLOSE,4), 5);' };


  return data;
};

JSIndexScript.prototype.COLOR_CHXY = function ()
{
  var data =
  {
    Name: '长下影', Description: '长下影', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'VAR2:(MIN(CLOSE,OPEN)-LOW)/(HIGH-LOW)>0.667;' };


  return data;
};

JSIndexScript.prototype.COLOR_CHSY = function ()
{
  var data =
  {
    Name: '长上影', Description: '长上影', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'VAR2:(HIGH-MAX(CLOSE,OPEN))/(HIGH-LOW)>0.667,COLORBLUE;' };


  return data;
};

JSIndexScript.prototype.COLOR_FENLI = function ()
{
  var data =
  {
    Name: '分离', Description: '分离', IsMainIndex: true, InstructionType: 2,
    Script: //脚本
    'VAR1:BACKSET( OPEN==REF(OPEN,1) AND (CLOSE-OPEN)*(REF(CLOSE,1)-REF(OPEN,1))<0,2);' };


  return data;
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//交易系统

JSIndexScript.prototype.TRADE_BIAS = function ()
{
  var data =
  {
    Name: 'BIAS', Description: '乖离率专家系统', IsMainIndex: true, InstructionType: 1,
    Args: [{ Name: 'N', Value: 12 }, { Name: 'LL', Value: 6 }, { Name: 'LH', Value: 6 }],
    Script: //脚本
    'BIAS:=(CLOSE-MA(CLOSE,N))/MA(CLOSE,N)*100;\n\
ENTERLONG:CROSS(-LL,BIAS);\n\
EXITLONG:CROSS(BIAS,LH);' };



  return data;
};

JSIndexScript.prototype.TRADE_CCI = function ()
{
  var data =
  {
    Name: 'CCI', Description: 'CCI专家系统', IsMainIndex: true, InstructionType: 1,
    Args: [{ Name: 'N', Value: 14 }],
    Script: //脚本
    'TYP:=(HIGH+LOW+CLOSE)/3;\n\
CCI:=(TYP-MA(TYP,N))/(0.015*AVEDEV(TYP,N));\n\
INDEX:=CCI;\n\
ENTERLONG:CROSS(INDEX,-100);\n\
EXITLONG:CROSS(100,INDEX);' };


  return data;
};

JSIndexScript.prototype.TRADE_DMI = function ()
{
  var data =
  {
    Name: 'DMI', Description: '趋向专家系统', IsMainIndex: true, InstructionType: 1,
    Args: [{ Name: 'N', Value: 14 }],
    Script: //脚本
    'MTR:=SUM(MAX(MAX(HIGH-LOW,ABS(HIGH-REF(CLOSE,1))),ABS(LOW-REF(CLOSE,1))),N);\n\
HD :=HIGH-REF(HIGH,1);\n\
LD :=REF(LOW,1)-LOW;\n\
PDM:=SUM(IF(HD>0&&HD>LD,HD,0),N);\n\
MDM:=SUM(IF(LD>0&&LD>HD,LD,0),N);\n\
PDI:=PDM*100/MTR;\n\
MDI:=MDM*100/MTR;\n\
ENTERLONG:CROSS(PDI,MDI);\n\
EXITLONG:CROSS(MDI,PDI);' };


  return data;
};

JSIndexScript.prototype.TRADE_KD = function ()
{
  var data =
  {
    Name: 'KD', Description: 'KD指标专家系统', IsMainIndex: true, InstructionType: 1,
    Args: [{ Name: 'N', Value: 9 }, { Name: 'M1', Value: 3 }, { Name: 'M2', Value: 3 }],
    Script: //脚本
    'WRSV:=(CLOSE-LLV(LOW,N))/(HHV(HIGH,N)-LLV(LOW,N))*100;\n\
WK:=SMA(WRSV,M1,1);\n\
D:=SMA(WK,M2,1);\n\
ENTERLONG:CROSS(WK,D)&&WK<20;\n\
EXITLONG:CROSS(D,WK)&&WK>80;' };


  return data;
};

JSIndexScript.prototype.TRADE_BOLL = function ()
{
  var data =
  {
    Name: 'BOLL', Description: '布林带专家系统', IsMainIndex: true, InstructionType: 1,
    Args: [{ Name: 'N', Value: 20 }],
    Script: //脚本
    'MID :=MA(CLOSE,N);\n\
UPPER:=MID+2*STD(CLOSE,N);\n\
LOWER:=MID-2*STD(CLOSE,N);\n\
ENTERLONG:CROSS(CLOSE,LOWER);\n\
EXITLONG:CROSS(CLOSE,UPPER);' };


  return data;
};

JSIndexScript.prototype.TRADE_KDJ = function ()
{
  var data =
  {
    Name: 'KDJ', Description: 'KDJ专家系统', IsMainIndex: true, InstructionType: 1,
    Args: [{ Name: 'N', Value: 9 }, { Name: 'M1', Value: 3 }],
    Script: //脚本
    'RSV:=(CLOSE-LLV(LOW,N))/(HHV(HIGH,N)-LLV(LOW,N))*100;\n\
K:=SMA(RSV,M1,1);\n\
D:=SMA(K,M1,1);\n\
J:=3*K-2*D;\n\
ENTERLONG:CROSS(J,0);\n\
EXITLONG:CROSS(100,J);' };


  return data;
};

JSIndexScript.prototype.TRADE_MA = function ()
{
  var data =
  {
    Name: 'MA', Description: '均线专家系统', IsMainIndex: true, InstructionType: 1,
    Args: [{ Name: 'SHORT', Value: 5 }, { Name: 'LONG', Value: 20 }],
    Script: //脚本
    'ENTERLONG:CROSS(MA(CLOSE,SHORT),MA(CLOSE,LONG));\n\
EXITLONG:CROSS(MA(CLOSE,LONG),MA(CLOSE,SHORT));' };


  return data;
};

JSIndexScript.prototype.TRADE_MACD = function ()
{
  var data =
  {
    Name: 'MACD', Description: 'MACD专家系统', IsMainIndex: true, InstructionType: 1,
    Args: [{ Name: 'LONG', Value: 26 }, { Name: 'SHORT', Value: 12 }, { Name: 'M', Value: 9 }],
    Script: //脚本
    'DIFF:=EMA(CLOSE,SHORT) - EMA(CLOSE,LONG);\n\
DEA  := EMA(DIFF,M);\n\
MACD := 2*(DIFF-DEA);\n\
ENTERLONG:CROSS(MACD,0);\n\
EXITLONG:CROSS(0,MACD);' };


  return data;
};

JSIndexScript.prototype.TRADE_MTM = function ()
{
  var data =
  {
    Name: 'MTM', Description: '动力指标专家系统', IsMainIndex: true, InstructionType: 1,
    Args: [{ Name: 'N', Value: 6 }],
    Script: //脚本
    'WMTM:=C-REF(C,N);\n\
ENTERLONG:CROSS(WMTM,0);\n\
EXITLONG:CROSS(0,WMTM);' };


  return data;
};

JSIndexScript.prototype.TRADE_PSY = function ()
{
  var data =
  {
    Name: 'PSY', Description: 'PSY心理线专家系统', IsMainIndex: true, InstructionType: 1,
    Args: [{ Name: 'N', Value: 12 }, { Name: 'LL', Value: 10 }, { Name: 'LH', Value: 85 }],
    Script: //脚本
    'MYPSY:=COUNT(CLOSE>REF(CLOSE,1),N)/N*100;\n\
ENTERLONG:CROSS(LL,MYPSY);\n\
EXITLONG:CROSS(MYPSY,LH);' };


  return data;
};

JSIndexScript.prototype.TRADE_ROC = function ()
{
  var data =
  {
    Name: 'ROC', Description: '变动速率专家系统', IsMainIndex: true, InstructionType: 1,
    Args: [{ Name: 'N', Value: 12 }, { Name: 'M', Value: 6 }],
    Script: //脚本
    'WROC:=MA(100*(CLOSE-REF(CLOSE,N))/REF(CLOSE,N),M);\n\
ENTERLONG:CROSS(WROC,0);\n\
EXITLONG:CROSS(0,WROC);' };


  return data;
};

JSIndexScript.prototype.TRADE_RSI = function ()
{
  var data =
  {
    Name: 'RSI', Description: '相对强弱专家系统', IsMainIndex: true, InstructionType: 1,
    Args: [{ Name: 'N', Value: 6 }, { Name: 'LL', Value: 20 }, { Name: 'LH', Value: 80 }],
    Script: //脚本
    'LC:=REF(CLOSE,1);\n\
WRSI:=SMA(MAX(CLOSE-LC,0),N,1)/SMA(ABS(CLOSE-LC),N,1)*100;\n\
ENTERLONG:CROSS(WRSI,LL);\n\
EXITLONG:CROSS(LH,WRSI);' };


  return data;
};

JSIndexScript.prototype.TRADE_VR = function ()
{
  var data =
  {
    Name: 'VR', Description: 'VR容量比率专家系统', IsMainIndex: true, InstructionType: 1,
    Args: [{ Name: 'N', Value: 26 }, { Name: 'LL', Value: 70 }, { Name: 'LH', Value: 250 }],
    Script: //脚本
    'WVR := SUM((IF(CLOSE>OPEN,VOL,0)+IF(CLOSE=OPEN,VOL/2,0)),N)/SUM((IF(CLOSE<OPEN,VOL,0)+IF(CLOSE=OPEN,VOL/2,0)),N)*100;\n\
ENTERLONG:CROSS(LL,WVR);\n\
EXITLONG:CROSS(WVR,LH);' };


  return data;
};

JSIndexScript.prototype.TRADE_DPSJ = function ()
{
  var data =
  {
    Name: 'DPSJ', Description: '大盘随机专家系统', IsMainIndex: true, InstructionType: 1,
    Args: [{ Name: 'N1', Value: 18 }, { Name: 'N2', Value: 12 }],
    Script: //脚本
    'RSV:=(INDEXC-LLV(INDEXL,N1))/(HHV(INDEXH,N1)-LLV(INDEXL,N1))*100;\n\
K:=SMA(RSV,N2,1);\n\
HSL:VOL/100/(FINANCE(7));\n\
ENTERLONG: CROSS(K,20);\n\
EXITLONG: (CROSS(HSL,5) OR CROSS(K,80));' };


  return data;
};

JSIndexScript.prototype.TEST = function ()
{
  var data =
  {
    Name: 'TEST', Description: '测试脚本', IsMainIndex: false,
    Args: [{ Name: 'N', Value: 10 }],
    Script: //脚本
    "买入压力:=H-REF(C,1)+(C-L);\n\
                卖出压力:=REF(C,1)-L+(H-C);\n\
                K1:=买入压力/(买入压力+卖出压力)/10;\n\
                K2:=卖出压力/(买入压力+卖出压力)/10;\n\
                A01:=(2*C+O+L+H)/5;\n\
                A02:=(WINNER((A01 * 1.04)) * 100);\n\
                套牢角度:=57.2958*ATAN(A02-REF(A02,1));\n\
                A03:=(WINNER((A01 * 0.96)) * 100);\n\
                盈利筹码:A03;\n\
                A04:=A03;\n\
                A08:=A02-A03;\n\
                A06:=(100 - A02);\n\
                套牢筹码:=A06;\n\
                STICKLINE( 1,0,A04, 2,0),COLOR0000FF;\n\
                STICKLINE( 1, 100,A02, 2,0),COLOR00FF00;\n\
                STICKLINE( 1,A04,(100-A06), 2,0),COLORYELLOW;" };


  return data;
};

JSIndexScript.prototype.Zealink_Index1 = function ()
{
  var data =
  {
    Name: '资金吸筹', Description: '资金吸筹', IsMainIndex: false,
    Args: [],
    Script: //脚本
    'VAR1:=REF((LOW+OPEN+CLOSE+HIGH)/4,1);  \n\
VAR2:= SMA(ABS(LOW - VAR1), 13, 1) / SMA(MAX(LOW - VAR1, 0), 10, 1);\n\
VAR3:= EMA(VAR2, 10);\n\
VAR4:= LLV(LOW, 33);\n\
VAR5:= EMA(IF(LOW <= VAR4, VAR3, 0), 3) * 0.2;\n\
主力进场: IF(VAR5 > REF(VAR5, 1), VAR5,0), COLORRED, NODRAW;\n\
洗盘: IF(VAR5 < REF(VAR5, 1), VAR5,0), COLORYELLOW, NODRAW;\n\
STICKLINE(VAR5> REF(VAR5, 1),0, VAR5, 50, 0), COLORRED;\n\
STICKLINE(VAR5 < REF(VAR5, 1), 0, VAR5, 50, 0), COLORYELLOW;' };


  return data;
};

JSIndexScript.prototype.Zealink_Index2 = function ()
{
  var data =
  {
    Name: '牛熊区间', Description: '牛熊区间', IsMainIndex: false, YSpecificMaxMin: { Max: 100, Min: 1, Count: 4 }, YSplitScale: [1, 50, 100],
    Args: [],
    Script: //脚本
    '短高H:=(20*H+19*REF(H,1)+18*REF(H,2)+17*REF(H,3)+16*REF(H,4)+15*REF(H,5)+14*REF(H,6)\n\
+ 13 * REF(H, 7) + 12 * REF(H, 8) + 11 * REF(H, 9) + 10 * REF(H, 10) + 9 * REF(H, 11) + 8 * REF(H, 12)\n\
+ 7 * REF(H, 13) + 6 * REF(H, 14) + 5 * REF(H, 15) + 4 * REF(H, 16) + 3 * REF(H, 17) + 2 * REF(H, 18) +\n\
REF(H, 20))/ 210, COLORBLUE, LINETHICK1;\n\
短低L:= (20 * L + 19 * REF(L, 1) + 18 * REF(L, 2) + 17 * REF(L, 3) + 16 * REF(L, 4) + 15 * REF(L, 5) + 14 * REF(L, 6)\n\
+ 13 * REF(L, 7) + 12 * REF(L, 8) + 11 * REF(L, 9) + 10 * REF(L, 10) + 9 * REF(L, 11) + 8 * REF(L, 12)\n\
+ 7 * REF(L, 13) + 6 * REF(L, 14) + 5 * REF(L, 15) + 4 * REF(L, 16) + 3 * REF(L, 17) + 2 * REF(L, 18) +\n\
REF(L, 20)) / 210, COLORBLUE, LINETHICK1;\n\
D90H:= EMA(短高H, 90), COLORRED, LINETHICK1;\n\
D90L:= EMA(短低L, 90), COLORRED, LINETHICK1;\n\
D90差:= D90H - D90L;\n\
D90顶:= D90H + D90差 * 2, COLORRED, LINETHICK1;\n\
D90底:= D90L - D90差 * 2, COLORRED, LINETHICK1;\n\
高0:= (EMA(EMA(H, 25), 25) - EMA(EMA(L, 25), 25)) * 1 + EMA(EMA(H, 25), 25), LINETHICK1, COLORWHITE;\n\
低0:= EMA(EMA(L, 25), 25) - (EMA(EMA(H, 25), 25) - EMA(EMA(L, 25), 25)) * 1, LINETHICK1, COLORWHITE;\n\
多头定位:= 低0 >= D90底 AND 高0 >= D90顶;\n\
空头定位:= 高0 <= D90顶 AND 低0 <= D90底;\n\
震荡定位:= 低0 >= D90底 AND 高0 <= D90顶;\n\
牛市: IF(多头定位 == 1, 100, 1), COLORRED, NODRAW;\n\
熊市: IF(空头定位 == 1, 100, 1), COLORGREEN, NODRAW;\n\
震荡: IF(震荡定位 == 1, 100, 1), COLORGRAY, NODRAW;\n\
STICKLINE(多头定位 == 1, 100, 1, 100, 0), COLORRED;\n\
STICKLINE(空头定位 == 1, 100, 1, 100, 0), COLORGREEN;\n\
STICKLINE(震荡定位 == 1, 100, 1, 100, 0), COLORGRAY;' };


  return data;
};

JSIndexScript.prototype.Zealink_Index3 = function ()
{
  var data =
  {
    Name: '持仓信号', Description: '持仓信号', IsMainIndex: true,
    Args: [],
    Script: //脚本
    '买线:=EMA(C,2);\n\
卖线:=EMA(SLOPE(C,30)*5+C,20); \n\
BU:=CROSS(买线,卖线);\n\
SEL:=CROSS(卖线,买线);\n\
\n\
STICKLINE(买线>=卖线 AND CLOSE>OPEN,LOW,HIGH,0,1),COLORRED;\n\
STICKLINE(买线>=卖线 AND CLOSE<OPEN,LOW,HIGH,0,1),COLORRED;\n\
STICKLINE(买线>=卖线 AND CLOSE>OPEN,CLOSE,OPEN,50,1),COLORRED;\n\
STICKLINE(买线>=卖线 AND CLOSE<OPEN,CLOSE,OPEN,50,0),COLORRED;\n\
STICKLINE(买线<卖线 AND CLOSE<OPEN,LOW,HIGH,0,1),COLORGREEN;\n\
STICKLINE(买线<卖线 AND CLOSE>OPEN,LOW,HIGH,0,1),COLORGREEN;\n\
STICKLINE(买线<卖线 AND CLOSE<OPEN,CLOSE,OPEN,50,0),COLORGREEN;\n\
STICKLINE(买线<卖线 AND CLOSE>OPEN,CLOSE,OPEN,50,1),COLORGREEN;\n\
\n\
HHJSJDA:=(3*CLOSE+OPEN+LOW+HIGH)/6;\n\
HHJSJDB:=(19*HHJSJDA+19*REF(HHJSJDA,1)+18*REF(HHJSJDA,2)+17*REF(HHJSJDA,3)+16*REF(HHJSJDA,4)+15*REF(HHJSJDA,5)+14*REF(HHJSJDA,6)\n\
+13*REF(HHJSJDA,7)+12*REF(HHJSJDA,8)+11*REF(HHJSJDA,9)+10*REF(HHJSJDA,10)+9*REF(HHJSJDA,11)+8*REF(HHJSJDA,12)+7*REF(HHJSJDA,13)+6*REF(HHJSJDA,14)+5*REF(HHJSJDA,15)+4*REF(HHJSJDA,16)+3*REF(HHJSJDA,17)+2*REF\n\
(HHJSJDA,20)+REF(HHJSJDA,19))/210,COLORYELLOW;\n\
HHJSJDC:=MA(HHJSJDB,5),COLORRED;\n\
快线:HHJSJDB,COLORYELLOW;\n\
慢线:HHJSJDC,COLORRED;\n\
\n\
SVAR11:=HHV(HIGH,34);\n\
SVAR14:=CLOSE-REF(CLOSE,1);\n\
SVAR15:=MAX(SVAR14,0);\n\
SVAR16:=ABS(SVAR14);\n\
SVAR17:=SMA(SVAR15,7,1)/SMA(SVAR16,7,1)*100;\n\
SVAR18:=SMA(SVAR15,13,1)/SMA(SVAR16,13,1)*100;\n\
SVAR19:=BARSCOUNT(CLOSE);\n\
SVAR20:=SMA(MAX(SVAR14,0),6,1)/SMA(ABS(SVAR14),6,1)*100;\n\
SVAR21:=(-200)*(HHV(HIGH,60)-CLOSE)/(HHV(HIGH,60)-LLV(LOW,60))+100;\n\
SVAR1A:=(CLOSE-LLV(LOW,15))/(HHV(HIGH,15)-LLV(LOW,15))*100;\n\
SVAR1B:=SMA((SMA(SVAR1A,4,1)-50)*2,3,1);\n\
SVAR1C:=(INDEXC-LLV(INDEXL,14))/(HHV(INDEXH,14)-LLV(INDEXL,14))*100;\n\
SVAR1D:=SMA(SVAR1C,4,1);\n\
SVAR1E:=SMA(SVAR1D,3,1);\n\
SVAR1F:=(HHV(HIGH,30)-CLOSE)/CLOSE*100;\n\
SVAR22:=SVAR20<=25 AND SVAR21<-95 AND SVAR1F>20 AND SVAR1B<-30 AND SVAR1E<30 AND SVAR11-CLOSE>=-0.25 AND SVAR17<22 AND SVAR18<28 AND SVAR19>50;\n\
BUY3:=CROSS(SVAR22,0.5) AND COUNT(SVAR22==1,10)==1;\n\
\n\
SVARF:=LOW*0.9;\n\
SVAR10X:=100-3*SMA((OPEN-LLV(LOW,75))/(HHV(HIGH,75)-LLV(LOW,75))*100,20,1)+2*SMA(SMA((OPEN-LLV(LOW,75))/(HHV(HIGH,75)-LLV(LOW,75))*100,20,1),15,1);\n\
SVAR11X:=SVARF<REF(SVAR10X,1) AND VOL>REF(VOL,1) AND CLOSE>REF(CLOSE,1);\n\
BUY2:=SVAR11X AND COUNT(SVAR11X,30)==1;\n\
\n\
VAR1:=(CLOSE+HIGH+LOW+OPEN)/4;\n\
VAR2:=SUMBARS(VOL,CAPITAL);\n\
VAR3:=HHV(VAR1,VAR2);\n\
VAR4:=LLV(VAR1,VAR2);\n\
VAR5:=(2*VAR1-VAR4-REF(VAR4,1))/(VAR3-VAR4);\n\
VAR6:=(VAR1-VAR4)/(VAR3-VAR4);\n\
VAR7:=IF(VAR1<=VAR4,VAR5*60,VAR6*60);\n\
VAR8:=600*(EMA(CLOSE,3)-EMA(LOW,30))/EMA(LOW,30);\n\
VAR9:=EMA(VAR8,7);\n\
VARC:=HHV(HIGH,9)-LLV(LOW,9);\n\
VARD:=HHV(HIGH,9)-CLOSE;\n\
VARE:=CLOSE-LLV(LOW,9);\n\
VARF:=VARD/VARC*100-70;\n\
VAR10:=(CLOSE-LLV(LOW,60))/(HHV(HIGH,60)-LLV(LOW,60))*100;\n\
VAR11:=(2*CLOSE+HIGH+LOW)/4;\n\
VAR12:=SMA(VARE/VARC*100,3,1);\n\
VAR13:=LLV(LOW,34);\n\
VAR14:=SMA(VAR12,3,1)-SMA(VARF,9,1);\n\
VAR15:=IF(VAR14>100,VAR14-100,0);\n\
VAR16:=HHV(HIGH,34);\n\
VAR17:=EMA((VAR11-VAR13)/(VAR16-VAR13)*100,8);\n\
VAR18:=EMA(VAR17,5);\n\
BUY:=STICKLINE(VAR17-VAR18>0,VAR17,VAR18,8,1),COLORRED;\n\
SELL:=STICKLINE(VAR17-VAR18<0,VAR17,VAR18,8,1),COLORGREEN;\n\
BUY1:=VAR17>VAR18 AND REF(VAR17,1)<REF(VAR18,1);\n\
SELL1:=VAR17<VAR18 AND REF(VAR17,1)>REF(VAR18,1);\n\
\n\
短高H:=(20*H+19*REF(H,1)+18*REF(H,2)+17*REF(H,3)+16*REF(H,4)+15*REF(H,5)+14*REF(H,6)\n\
+13*REF(H,7)+12*REF(H,8)+11*REF(H,9)+10*REF(H,10)+9*REF(H,11)+8*REF(H,12)\n\
+7*REF(H,13)+6*REF(H,14)+5*REF(H,15)+4*REF(H,16)+3*REF(H,17)+2*REF(H,18)+\n\
REF(H,20))/210,COLORBLUE,LINETHICK1;\n\
短低L:=(20*L+19*REF(L,1)+18*REF(L,2)+17*REF(L,3)+16*REF(L,4)+15*REF(L,5)+14*REF(L,6)\n\
+13*REF(L,7)+12*REF(L,8)+11*REF(L,9)+10*REF(L,10)+9*REF(L,11)+8*REF(L,12)\n\
+7*REF(L,13)+6*REF(L,14)+5*REF(L,15)+4*REF(L,16)+3*REF(L,17)+2*REF(L,18)+\n\
REF(L,20))/210,COLORBLUE,LINETHICK1;\n\
D90H:=EMA(短高H,90),COLORRED,LINETHICK1;\n\
D90L:=EMA(短低L,90),COLORRED,LINETHICK1;\n\
D90差:=D90H-D90L;\n\
D90顶:=D90H+D90差*2,COLORRED,LINETHICK1;\n\
D90底:=D90L-D90差*2,COLORRED,LINETHICK1;\n\
高0:=(EMA(EMA(H,25),25)-EMA(EMA(L,25),25))*1+EMA(EMA(H,25),25),LINETHICK1,COLORWHITE;\n\
低0:=EMA(EMA(L,25),25)-(EMA(EMA(H,25),25)-EMA(EMA(L,25),25))*1,LINETHICK1,COLORWHITE;\n\
多头定位:=低0>=D90底 AND 高0>=D90顶;\n\
空头定位:=高0<=D90顶 AND 低0<=D90底;\n\
震荡定位:=低0>=D90底 AND 高0<=D90顶;\n\
\n\
牛市:=多头定位==1;\n\
熊市:=空头定位==1;\n\
震荡:=震荡定位==1;\n\
\n\
非牛市:=熊市 OR 震荡;\n\
非熊市:=牛市 OR 震荡;\n\
\n\
BUY11:=BUY1 AND 非熊市;\n\
SELL11:=SELL1 AND 震荡定位==0;\n\
\n\
BUY111:=BUY11 AND COUNT(BUY11,10)<2;\n\
BUY0:=BUY111 AND COUNT(BUY111,21)==1;\n\
SELL111:=SELL11 AND COUNT(SELL11,10)<2;\n\
SELL0:=SELL111 AND COUNT(SELL111,10)==1;\n\
\n\
XK1:=EMA(100*(CLOSE-LLV(LOW,34))/(HHV(HIGH,34)-LLV(LOW,34)),3)/4;\n\
上穿:=REF(XK1,1)<5 AND XK1>=5;\n\
BUY4:=上穿 AND COUNT(XK1<2,12)<1;\n\
\n\
SELL2:=REF(XK1,1)<=22.5 AND XK1>22.5 AND COUNT(REF(XK1,1)>=22.5 AND XK1<22.5,5)>0;\n\
SELL3:=REF(XK1,1)>=21.5 AND XK1<21.5 AND COUNT(REF(XK1,1)>=22.5 AND XK1<22.5,12)>1;\n\
SELL4:=SELL2 OR SELL3 AND COUNT((SELL2 OR SELL3)==1,5)==1;\n\
\n\
SUPERDRAWTEXT(BUY0,L,"机会",2,10),COLORRED;\n\
SUPERDRAWTEXT(SELL0,H,"风险",1,10),COLORGREEN;\n\
SUPERDRAWTEXT(BUY2,L,"机会",2,10),COLORRED;\n\
SUPERDRAWTEXT(BUY4,L,"机会",2,10),COLORRED;\n\
SUPERDRAWTEXT(SELL4,H,"风险",1,10),COLORGREEN;' };


  return data;
};

JSIndexScript.prototype.Zealink_Index4 = function ()
{
  var data =
  {
    Name: '股东实际增减持', Description: '股东实际增减持', IsMainIndex: false, FloatPrecision: 0,
    Args: [],
    Script: //脚本
    '增持:NEWS(4),NODRAW,COLORRED;\n\
减持:NEWS(5),NODRAW,COLORGREEN;\n\
STICKLINE(增持>0,0,增持,1,0),COLORRED;\n\
STICKLINE(减持<0,0,减持,1,0),COLORGREEN;' };


  return data;
};

JSIndexScript.prototype.Zealink_Index5 = function ()
{
  var data =
  {
    Name: '大宗交易', Description: '大宗交易', IsMainIndex: false, FloatPrecision: 0,
    Args: [],
    Script: //脚本
    '交易次数:NEWS(7);' };


  return data;
};

JSIndexScript.prototype.Zealink_Index6 = function ()
{
  var data =
  {
    Name: '信托持股', Description: '信托持股', IsMainIndex: false, FloatPrecision: 0,
    Args: [],
    Script: //脚本
    '家数:NEWS(6);' };


  return data;
};

JSIndexScript.prototype.Zealink_Index7 = function () {
  var data =
  {
    Name: '官网新闻', Description: '官网新闻', IsMainIndex: false, FloatPrecision: 0,
    Args: [],
    Script: //脚本
    '个数:NEWS(8);' };


  return data;
};

JSIndexScript.prototype.Zealink_Index8 = function () {
  var data =
  {
    Name: '高管要闻', Description: '高管要闻', IsMainIndex: false, FloatPrecision: 0,
    Args: [],
    Script: //脚本
    '个数:NEWS(9);' };


  return data;
};

JSIndexScript.prototype.Zealink_Index9 = function ()
{
  var data =
  {
    Name: '股权质押', Description: '股权质押', IsMainIndex: false, FloatPrecision: 0,
    Args: [],
    Script: //脚本
    '次数:NEWS(10);' };


  return data;
};

JSIndexScript.prototype.CJL = function ()
{
  var data =
  {
    Name: 'CJL', Description: '期货持仓量', IsMainIndex: false,
    Args: [],
    Script: //脚本
    "成交量:VOL,VOLSTICK;\n\
持仓量:VOLINSTK,LINEOVERLAY;" };


  return data;
};

JSIndexScript.prototype.SQJZ = function ()
{
  var data =
  {
    Name: 'SQJZ', Description: '神奇九转', IsMainIndex: true,
    Script: //脚本
    "B:=C<REF(C,4);\n\
N:=CURRBARSCOUNT;\n\
B1:=(N=6 AND REFXV(COUNT(B,6),5)=6) OR (N=7 AND REFXV(COUNT(B,7),6)=7) OR (N=8 AND REFXV(COUNT(B,8),7)=8) OR (N>=9 AND REFXV(COUNT(B,9),8)=9);\n\
DRAWNUMBER(B1 AND REF(B,1)=0,L,1),COLORMAGENTA;\n\
B2:=(N=5 AND REFXV(COUNT(B,6),4)=6) OR (N=6 AND REFXV(COUNT(B,7),5)=7) OR (N=7 AND REFXV(COUNT(B,8),6)=8) OR (N>=8 AND REFXV(COUNT(B,9),7)=9);\n\
DRAWNUMBER(B2 AND REF(B,2)=0,L,2),COLORMAGENTA;\n\
B8:=(N=1 AND COUNT(B,8)=8) OR (N>=2 AND REFXV(COUNT(B,9),1)=9);\n\
DRAWNUMBER(B8 AND REF(B,8)=0,L,8),COLORMAGENTA;\n\
B9:=(N>=1 AND COUNT(B,9)=9);\n\
DRAWNUMBER(B9 AND REF(B,9)=0,L,9),COLORBROWN;\n\
S:=C>REF(C,4);\n\
S1:=(N=6 AND REFXV(COUNT(S,6),5)=6) OR (N=7 AND REFXV(COUNT(S,7),6)=7) OR (N=8 AND REFXV(COUNT(S,8),7)=8) OR (N>=9 AND REFXV(COUNT(S,9),8)=9);\n\
DRAWNUMBER(S1 AND REF(S,1)=0,H,1),COLORMAGENTA,DRAWABOVE;\n\
S2:=(N=5 AND REFXV(COUNT(S,6),4)=6) OR (N=6 AND REFXV(COUNT(S,7),5)=7) OR (N=7 AND REFXV(COUNT(S,8),6)=8) OR (N>=8 AND REFXV(COUNT(S,9),7)=9);\n\
DRAWNUMBER(S2 AND REF(S,2)=0,H,2),COLORMAGENTA,DRAWABOVE;\n\
S8:=(N=1 AND COUNT(S,8)=8) OR (N>=2 AND REFXV(COUNT(S,9),1)=9);\n\
DRAWNUMBER(S8 AND REF(S,8)=0,H,8),COLORMAGENTA,DRAWABOVE;\n\
S9:=(N>=1 AND COUNT(S,9)=9);\n\
DRAWNUMBER(S9 AND REF(S,9)=0,H,9),COLORGREEN,DRAWABOVE;" };


  return data;
};

JSIndexScript.prototype.XT = function ()
{
  var data =
  {
    Name: 'XT', Description: '箱体', IsMainIndex: true,
    Args: [{ Name: 'N', Value: 10 }],
    Script: //脚本
    "【箱顶】:PEAK(CLOSE,N,1)*0.98;\n\
【箱底】:TROUGH(CLOSE,N,1)*1.02;\n\
【箱高】:100*(【箱顶】-【箱底】)/【箱底】,NODRAW;" };


  return data;
};

JSIndexScript.prototype.CFJT = function ()
{
  var data =
  {
    Name: 'CFJT', Description: '财富阶梯', IsMainIndex: true,
    Script: //脚本
    "突破:=REF(EMA(C,14),1);\n\
A1X:=(EMA(C,10)-突破)/突破*100;\n\
多方:=IF(A1X>=0,REF(EMA(C,10),BARSLAST(CROSS(A1X,0))+1),DRAWNULL);\n\
空方:=IF(A1X<0,REF(EMA(C,10),BARSLAST(CROSS(0,A1X))+1),DRAWNULL);\n\
STICKLINE(A1X>=0,多方,突破,110,0),COLORRED;\n\
STICKLINE(A1X<0,空方,突破,110,0),COLORGREEN;" };


  return data;
};

JSIndexScript.prototype.CYX = function ()
{
  var data =
  {
    Name: 'CYX', Description: '撑压线', IsMainIndex: true,
    Args: [{ Name: 'N', Value: 7 }],
    Script: //脚本
    "Z1:=STRCAT(HYBLOCK,' ');\n\
Z2:=STRCAT(Z1,DYBLOCK);\n\
Z3:=STRCAT(Z2,' ');\n\
DRAWTEXT_FIX(ISLASTBAR,0,0,0,STRCAT(Z3,GNBLOCK)),COLOR00C0C0;\n\
A1:=REF(H,N)=HHV(H,2*N+1);\n\
B1:=FILTER(A1,N);\n\
C1:=BACKSET(B1,N+1);\n\
D1:=FILTER(C1,N);\n\
A2:=REF(L,N)=LLV(L,2*N+1);\n\
B2:=FILTER(A2,N);\n\
C2:=BACKSET(B2,N+1);\n\
D2:=FILTER(C2,N);\n\
E1:=(REF(LLV(L,2*N),1)+REF(HHV(H,2*N),1))/2;\n\
E2:=(H+L)/2;\n\
H1:=(D1 AND NOT(D2 AND E1>=E2)) OR ISLASTBAR OR BARSCOUNT(C)=1;\n\
L1:=(D2 AND NOT(D1 AND E1<E2));\n\
H2:=D1 AND NOT(D2 AND E1>=E2);\n\
X1:=REF(BARSLAST(H1),1)+1;\n\
F1:=BACKSET(H1 AND COUNT(L1,X1)>0,LLVBARS(IF(L1,L,10000),X1));\n\
G1:=F1>REF(F1,1);\n\
I1:=BACKSET(G1,2);\n\
LD:=I1>REF(I1,1);\n\
L2:=LD OR ISLASTBAR OR BARSCOUNT(C)=1;\n\
X2:=REF(BARSLAST(L2),1)+1;\n\
F2:=BACKSET(L2 AND COUNT(H2,X2)>0,HHVBARS(IF(H2,H,0),X2));\n\
G2:=F2>REF(F2,1);\n\
I2:=BACKSET(G2,2);\n\
HD:=I2>REF(I2,1);\n\
R1:=BACKSET(ISLASTBAR,BARSLAST(HD)+1);\n\
S1:=R1>REF(R1,1);\n\
T1:=BACKSET(ISLASTBAR,BARSLAST(LD)+1);\n\
U1:=T1>REF(T1,1);\n\
R2:=BACKSET(S1,REF(BARSLAST(HD),1)+2);\n\
S2:=R2>REF(R2,1);\n\
T2:=BACKSET(U1,REF(BARSLAST(LD),1)+2);\n\
U2:=T2>REF(T2,1);\n\
DRAWLINE(S2,H,S1,H,1),LINETHICK2,COLORRED;\n\
DRAWLINE(U2,L,U1,L,1),LINETHICK2,COLORGREEN;" };


  return data;
};

JSIndexScript.prototype.WAVE = function ()
{
  var data =
  {
    Name: 'WAVE', Description: '波浪分析', IsMainIndex: true,
    Args: [{ Name: 'N', Value: 5 }],
    Script: //脚本
    "ZIG(3,N);" };


  return data;
};


module.exports =
{
  JSCommonIndexScript:
  {
    JSIndexScript: JSIndexScript } };

/***/ }),
/* 109 */
/*!**************************************************************************!*\
  !*** I:/out-project/FCoinEx/static/js/umychart.hqIndexformula.wechat.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
    copyright (c) 2018 jones

    http://www.apache.org/licenses/LICENSE-2.0

    开源项目 https://github.com/jones2000/HQChart

    jones_2000@163.com

    指标计算方法 2.0 版本使用的算法
*/

function HQIndexFormula()
{

}

//指数平均数指标 EMA(close,10)
HQIndexFormula.EMA = function (data, dayCount)
{
  var result = [];

  var offset = 0;
  if (offset >= data.length) return result;

  //取首个有效数据
  for (; offset < data.length; ++offset)
  {
    if (data[offset] != null && !isNaN(data[offset]))
    break;
  }

  var p1Index = offset;
  var p2Index = offset + 1;

  result[p1Index] = data[p1Index];
  for (var i = offset + 1; i < data.length; ++i, ++p1Index, ++p2Index)
  {
    result[p2Index] = (2 * data[p2Index] + (dayCount - 1) * result[p1Index]) / (dayCount + 1);
  }

  return result;
};

HQIndexFormula.SMA = function (data, n, m)
{
  var result = [];

  var i = 0;
  var lastData = null;
  for (; i < data.length; ++i)
  {
    if (data[i] == null || isNaN(data[i])) continue;
    lastData = data[i];
    result[i] = lastData; //第一天的数据
    break;
  }

  for (++i; i < data.length; ++i)
  {
    result[i] = (m * data[i] + (n - m) * lastData) / n;
    lastData = result[i];
  }

  return result;
};


/*
       求动态移动平均.
       用法: DMA(X,A),求X的动态移动平均.
       算法: 若Y=DMA(X,A)则 Y=A*X+(1-A)*Y',其中Y'表示上一周期Y值,A必须小于1.
       例如:DMA(CLOSE,VOL/CAPITAL)表示求以换手率作平滑因子的平均价
   */
HQIndexFormula.DMA = function (data, data2)
{
  var result = [];
  if (data.length < 0 || data.length != data2.length) return result;

  var index = 0;
  for (; index < data.length; ++index)
  {
    if (data[index] != null && !isNaN(data[index]) && data2[index] != null && !isNaN(data2[index]))
    {
      result[index] = data[index];
      break;
    }
  }

  for (index = index + 1; index < data.length; ++index)
  {
    if (data[index] == null || data2[index] == null)
    result[index] = null;else

    {
      if (data[index] < 1)
      result[index] = data2[index] * data[index] + (1 - data2[index]) * result[index - 1];else

      result[index] = data[index];
    }
  }

  return result;
};


HQIndexFormula.HHV = function (data, n)
{
  var result = [];
  if (n > data.length) return result;

  var max = -10000;
  for (var i = n, j = 0; i < data.length; ++i, ++j)
  {
    if (i < n + max)
    {
      max = data[i] < data[max] ? max : i;
    } else

    {
      for (j = (max = i - n + 1) + 1; j <= i; ++j)
      {
        if (data[j] > data[max])
        max = j;
      }
    }

    result[i] = data[max];
  }

  return result;
};

HQIndexFormula.LLV = function (data, n)
{
  var result = [];
  if (n > data.length) return result;

  var min = -10000;

  for (var i = n; i < data.length; ++i, ++j)
  {
    if (i < n + min)
    {
      min = data[i] > data[min] ? min : i;
    } else

    {
      for (var j = (min = i - n + 1) + 1; j <= i; ++j)
      {
        if (data[j] < data[min])
        min = j;
      }
    }
    result[i] = data[min];
  }

  return result;
};

HQIndexFormula.REF = function (data, n)
{
  var result = [];

  if (data.length <= 0) return result;
  if (n >= data.length) return result;

  result = data.slice(0, data.length - n);

  for (var i = 0; i < n; ++i) {
    result.unshift(null);}

  return result;
};

HQIndexFormula.REFDATE = function (data, n)
{
  var result = [];

  if (data.length <= 0) return result;

  //暂时写死取最后一个
  n = data.length - 1;
  for (var i in data)
  {
    result[i] = data[n];
  }

  return result;
};



HQIndexFormula.SUM = function (data, n)
{
  var result = [];

  if (n == 0)
  {
    result[0] = data[0];

    for (var i = 1; i < data.length; ++i)
    {
      result[i] = result[i - 1] + data[i];
    }
  } else

  {

    for (var i = n - 1, j = 0; i < data.length; ++i, ++j)
    {
      for (var k = 0; k < n; ++k)
      {
        if (k == 0) result[i] = data[k + j];else
        result[i] += data[k + j];
      }
    }
  }

  return result;
};

//两个数组相减
HQIndexFormula.ARRAY_SUBTRACT = function (data, data2)
{
  var result = [];
  var IsNumber = typeof data2 == "number";
  if (IsNumber)
  {
    for (var i in data)
    {
      if (data[i] == null || isNaN(data[i]))
      result[i] = null;else

      result[i] = data[i] - data2;
    }
  } else

  {
    var count = Math.max(data.length, data2.length);

    for (var i = 0; i < count; ++i)
    {
      if (i < data.length && i < data2.length)
      {
        if (data[i] == null || data2[i] == null) result[i] = null;else
        result[i] = data[i] - data2[i];
      } else

      result[i] = null;
    }
  }

  return result;
};

//数组 data>data2比较 返回 0/1 数组
HQIndexFormula.ARRAY_GT = function (data, data2)
{
  var result = [];
  var IsNumber = typeof data2 == "number";
  if (IsNumber)
  {
    for (var i in data)
    {
      result[i] = data[i] > data2 ? 1 : 0;
    }
  } else

  {
    var count = Math.max(data.length, data2.length);

    for (var i = 0; i < count; ++i)
    {
      if (i < data.length && i < data2.length)
      result[i] = data[i] > data2[i] ? 1 : 0;else

      result[i] = null;
    }
  }

  return result;
};

//数组 data>=data2比较 返回 0/1 数组
HQIndexFormula.ARRAY_GTE = function (data, data2)
{
  var result = [];
  var IsNumber = typeof data2 == "number";
  if (IsNumber)
  {
    for (var i in data)
    {
      result[i] = data[i] >= data2 ? 1 : 0;
    }
  } else

  {
    var count = Math.max(data.length, data2.length);

    for (var i = 0; i < count; ++i)
    {
      if (i < data.length && i < data2.length)
      result[i] = data[i] >= data2[i] ? 1 : 0;else

      result[i] = null;
    }
  }

  return result;
};

//数组 data<data2比较 返回 0/1 数组
HQIndexFormula.ARRAY_LT = function (data, data2)
{
  var result = [];
  var IsNumber = typeof data2 == "number";
  if (IsNumber)
  {
    for (var i in data)
    {
      result[i] = data[i] < data2 ? 1 : 0;
    }
  } else

  {
    var count = Math.max(data.length, data2.length);

    for (var i = 0; i < count; ++i)
    {
      if (i < data.length && i < data2.length)
      result[i] = data[i] < data2[i] ? 1 : 0;else

      result[i] = null;
    }
  }

  return result;
};

//数组 data<=data2比较 返回 0/1 数组
HQIndexFormula.ARRAY_LTE = function (data, data2)
{
  var result = [];
  var IsNumber = typeof data2 == "number";
  if (IsNumber)
  {
    for (var i in data)
    {
      result[i] = data[i] <= data2 ? 1 : 0;
    }
  } else

  {
    var count = Math.max(data.length, data2.length);

    for (var i = 0; i < count; ++i)
    {
      if (i < data.length && i < data2.length)
      result[i] = data[i] <= data2[i] ? 1 : 0;else

      result[i] = null;
    }
  }

  return result;
};

//数组 data==data2比较 返回 0/1 数组
HQIndexFormula.ARRAY_EQ = function (data, data2)
{
  var result = [];
  var IsNumber = typeof data2 == "number";
  if (IsNumber)
  {
    for (var i in data)
    {
      result[i] = data[i] == data2 ? 1 : 0;
    }
  } else

  {
    var count = Math.max(data.length, data2.length);

    for (var i = 0; i < count; ++i)
    {
      if (i < data.length && i < data2.length)
      result[i] = data[i] == data2[i] ? 1 : 0;else

      result[i] = null;
    }
  }

  return result;
};

HQIndexFormula.ARRAY_IF = function (data, trueData, falseData)
{
  var result = [];
  var IsNumber = [typeof trueData == "number", typeof falseData == "number"];
  for (var i in data)
  {
    if (data[i])
    {
      if (IsNumber[0]) result[i] = trueData;else
      result[i] = trueData[i];
    } else

    {
      if (IsNumber[1]) result[i] = falseData;else
      result[i] = falseData[i];
    }
  }

  return result;
};

HQIndexFormula.ARRAY_AND = function (data, data2)
{
  var result = [];
  var IsNumber = typeof trueData == "number";
  if (IsNumber)
  {
    for (var i in data)
    {
      result[i] = data[i] && data2 ? 1 : 0;
    }
  } else

  {
    var count = Math.max(data.length, data2.length);

    for (var i = 0; i < count; ++i)
    {
      if (i < data.length && i < data2.length)
      result[i] = data[i] && data2[i] ? 1 : 0;else

      result[i] = 0;
    }
  }

  return result;
};
HQIndexFormula.ARRAY_OR = function (data, data2)
{
  var result = [];
  var IsNumber = typeof data2 == "number";
  if (IsNumber)
  {
    for (var i in data)
    {
      result[i] = data[i] || data2 ? 1 : 0;
    }
  } else

  {
    var count = Math.max(data.length, data2.length);

    for (var i = 0; i < count; ++i)
    {
      if (i < data.length && data[i])
      {
        result[i] = 1;
        continue;
      }
      if (i < data2.length && data2[i])
      {
        result[i] = 1;
        continue;
      }
      result[i] = 0;
    }
  }

  return result;
};
//数组相乘
//支持多个参数累乘 如:HQIndexFormula.ARRAY_MULTIPLY(data,data2,data3,data3) =data*data2*data3*data4
HQIndexFormula.ARRAY_MULTIPLY = function (data, data2)
{
  if (arguments.length == 2)
  {
    var result = [];
    var IsNumber = typeof data2 == "number";
    if (IsNumber)
    {
      for (var i in data)
      {
        if (data[i] == null || isNaN(data[i]))
        result[i] = null;else

        result[i] = data[i] * data2;
      }
    } else

    {
      var count = Math.max(data.length, data2.length);
      for (var i = 0; i < count; ++i)
      {
        if (i < data.length && i < data2.length)
        result[i] = data[i] * data2[i];else

        result[i] = null;
      }
    }

    return result;
  }

  var result = HQIndexFormula.ARRAY_MULTIPLY(arguments[0], arguments[1]);

  for (var i = 2; i < arguments.length; ++i)
  {
    result = HQIndexFormula.ARRAY_MULTIPLY(result, arguments[i]);
  }

  return result;
};

//数组相除
HQIndexFormula.ARRAY_DIVIDE = function (data, data2)
{
  var result = [];
  var IsNumber = typeof data2 == "number";
  if (IsNumber)
  {
    for (var i in data)
    {
      result[i] = data[i] / data2;
    }
  } else

  {
    var count = Math.max(data.length, data2.length);
    for (var i = 0; i < count; ++i)
    {
      if (i < data.length && i < data2.length)
      {
        if (data[i] == null || data2[i] == null || isNaN(data[i]) || isNaN(data2[i]))
        result[i] = null;else
        if (data2[i] == 0)
        result[i] = null;else

        result[i] = data[i] / data2[i];
      } else

      result[i] = null;
    }
  }

  return result;
};

//数组相加
//支持多个参数累加 如:HQIndexFormula.ARRAY_ADD(data,data2,data3,data3) =data+data2+data3+data4
HQIndexFormula.ARRAY_ADD = function (data, data2)
{
  if (arguments.length == 2)
  {
    var result = [];
    var IsNumber = typeof data2 == "number";
    if (IsNumber)
    {
      for (var i in data)
      {
        result[i] = data[i] + data2;
      }
    } else

    {
      var count = Math.max(data.length, data2.length);
      for (var i = 0; i < count; ++i)
      {
        if (i < data.length && i < data2.length)
        {
          if (data[i] == null || data2[i] == null || isNaN(data[i]) || isNaN(data2[i])) result[i] = null;else
          result[i] = data[i] + data2[i];
        } else

        {
          result[i] = null;
        }
      }
    }

    return result;
  }

  var result = HQIndexFormula.ARRAY_ADD(arguments[0], arguments[1]);

  for (var i = 2; i < arguments.length; ++i)
  {
    result = HQIndexFormula.ARRAY_ADD(result, arguments[i]);
  }

  return result;
};

HQIndexFormula.MAX = function (data, data2)
{
  var result = [];
  var IsNumber = typeof data2 == "number";
  if (IsNumber)
  {
    for (var i in data)
    {
      if (data[i] == null) result[i] = null;else
      result[i] = Math.max(data[i], data2);
    }
  } else

  {
    var count = Math.max(data.length, data2.length);
    for (var i = 0; i < count; ++i)
    {
      if (i < data.length && i < data2.length)
      {
        if (data[i] == null || data2[i] == null) result[i] = null;else
        result[i] = Math.max(data[i], data2[i]);
      } else

      result[i] = null;
    }
  }

  return result;
};

HQIndexFormula.MIN = function (data, data2)
{
  var result = [];
  var IsNumber = typeof data2 == "number";
  if (IsNumber)
  {
    for (var i in data)
    {
      if (data[i] == null) result[i] = null;else
      result[i] = Math.min(data[i], data2);
    }
  } else

  {
    var count = Math.max(data.length, data2.length);
    for (var i = 0; i < count; ++i)
    {
      if (i < data.length && i < data2.length)
      {
        if (data[i] == null || data2[i] == null) result[i] = null;else
        result[i] = Math.min(data[i], data2[i]);
      } else

      result[i] = null;
    }
  }

  return result;
};


HQIndexFormula.ABS = function (data)
{
  var result = [];
  for (var i in data)
  {
    if (data[i] == null) result[i] = null;else
    result[i] = Math.abs(data[i]);
  }

  return result;
};


HQIndexFormula.MA = function (data, dayCount)
{
  var result = [];

  for (var i = 0, len = data.length; i < len; i++)
  {
    if (i < dayCount)
    {
      result[i] = null;
      continue;
    }

    var sum = 0;
    for (var j = 0; j < dayCount; j++)
    {
      sum += data[i - j];
    }
    result[i] = sum / dayCount;
  }
  return result;
};

/*
       加权移动平均
       返回加权移动平均
       用法:EXPMA(X,M):X的M日加权移动平均
       EXPMA[i]=buffer[i]*para+(1-para)*EXPMA[i-1] para=2/(1+__para)
   */
HQIndexFormula.EXPMA = function (data, dayCount)
{
  var result = [];
  if (dayCount >= data.length) return result;

  var i = dayCount;
  for (; i < data.length; ++i) //获取第1个有效数据
  {
    if (data[i] != null)
    {
      result[i] = data[i];
      break;
    }
  }

  for (i = i + 1; i < data.length; ++i)
  {
    if (result[i - 1] != null && data[i] != null)
    result[i] = (2 * data[i] + (dayCount - 1) * result[i - 1]) / (dayCount + 1);else
    if (result[i - 1] != null)
    result[i] = result[i - 1];
  }

  return result;
};

//加权平滑平均,MEMA[i]=SMA[i]*para+(1-para)*SMA[i-1] para=2/(1+__para)
HQIndexFormula.EXPMEMA = function (data, dayCount)
{
  var result = [];
  if (dayCount >= data.length) return result;

  var index = 0;
  for (; index < data.length; ++index)
  {
    if (data[index] && !isNaN(data[index])) break;
  }

  var sum = 0;
  for (var i = 0; index < data.length && i < dayCount; ++i, ++index)
  {
    if (data[index] && !isNaN(data[index]))
    sum += data[index];else

    sum += data[index - 1];
  }

  result[index - 1] = sum / dayCount;
  for (; index < data.length; ++index)
  {
    if (result[index - 1] != null && data[index] != null)
    result[index] = (2 * data[index] + (dayCount - 1) * result[index - 1]) / (dayCount + 1);else
    if (result[index - 1] != null)
    result[index] = result[index - 1];
  }

  return result;
};


HQIndexFormula.STD = function (data, n)
{
  var result = [];

  var total = 0;
  var averageData = []; //平均值
  for (var i = n - 1; i < data.length; ++i)
  {
    total = 0;
    for (var j = 0; j < n; ++j)
    {
      total += data[i - j];
    }

    averageData[i] = total / n;
  }

  for (var i = n - 1; i < data.length; ++i)
  {
    total = 0;
    for (var j = 0; j < n; ++j)
    {
      total += Math.pow(data[i - j] - averageData[i], 2);
    }

    result[i] = Math.sqrt(total / n);
  }


  return result;
};

//平均绝对方差
HQIndexFormula.AVEDEV = function (data, n)
{
  var result = [];

  var total = 0;
  var averageData = []; //平均值
  for (var i = n - 1; i < data.length; ++i)
  {
    total = 0;
    for (var j = 0; j < n; ++j)
    {
      total += data[i - j];
    }

    averageData[i] = total / n;
  }

  for (var i = n - 1; i < data.length; ++i)
  {
    total = 0;
    for (var j = 0; j < n; ++j)
    {
      total += Math.abs(data[i - j] - averageData[i]);
    }

    result[i] = total / n;
  }


  return result;
};

HQIndexFormula.COUNT = function (data, n)
{
  var result = [];


  for (var i = n - 1; i < data.length; ++i)
  {
    var count = 0;
    for (var j = 0; j < n; ++j)
    {
      if (data[i - j]) ++count;
    }

    result[i] = count;
  }

  return result;
};

//上穿
HQIndexFormula.CROSS = function (data, data2)
{
  var result = [];
  if (data.length != data2.length) return result = [];

  var index = 0;
  for (; index < data.length; ++index)
  {
    if (data[index] != null && !isNaN(data[index]) && data2[index] != null && isNaN(data2[index]))
    break;
  }

  for (++index; index < data.length; ++index)
  {
    result[index] = data[index] > data2[index] && data[index - 1] < data2[index - 1] ? 1 : 0;
  }

  return result;
};

//累乘
HQIndexFormula.MULAR = function (data, n)
{
  var result = [];
  if (data.length < n) return result;

  var index = n;
  for (; index < data.length; ++index)
  {
    if (data[index] != null && !isNaN(data[index]))
    {
      result[index] = data[index];
      break;
    }
  }

  for (++index; index < data.length; ++index)
  {
    result[index] = result[index - 1] * data[index];
  }

  return result;
};


HQIndexFormula.STICKLINE = function (data, price1, price2)
{
  var result = [];
  if (data.length <= 0) return result;

  var IsNumber = typeof price1 == "number";
  var IsNumber2 = typeof price2 == "number";

  for (var i in data)
  {
    result[i] = null;
    if (isNaN(data[i])) continue;
    if (!data[i]) continue;

    if (IsNumber && IsNumber2)
    {
      result[i] = { Value: price1, Value2: price2 };
    } else
    if (IsNumber && !IsNumber2)
    {
      if (isNaN(price2[i])) continue;
      result[i] = { Value: price1, Value2: price2[i] };
    } else
    if (!IsNumber && IsNumber2)
    {
      if (isNaN(price1[i])) continue;
      result[i] = { Value: price1[i], Value2: price2 };
    } else

    {
      if (isNaN(price1[i]) || isNaN(price2[i])) continue;
      result[i] = { Value: price1[i], Value2: price2[i] };
    }
  }

  return result;
};

//导出统一使用JSCommon命名空间名
module.exports =
{
  //单个类导出
  JSCommon_HQIndexFormula: HQIndexFormula };

/***/ }),
/* 110 */
/*!**********************************************************************!*\
  !*** I:/out-project/FCoinEx/static/js/umychart.chartpaint.wechat.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";













var _umychartDataWechat = __webpack_require__(/*! ./umychart.data.wechat.js */ 103);






var _umychartResourceWechat = __webpack_require__(/*! ./umychart.resource.wechat.js */ 106);




var _umychartFramesplitWechat = __webpack_require__(/*! ./umychart.framesplit.wechat.js */ 111);




var _umychartCoordinatedataWechat = __webpack_require__(/*! ./umychart.coordinatedata.wechat.js */ 104); /*
                                                                                        copyright (c) 2018 jones
                                                                                    
                                                                                        http://www.apache.org/licenses/LICENSE-2.0
                                                                                    
                                                                                        开源项目 https://github.com/jones2000/HQChart
                                                                                    
                                                                                        jones_2000@163.com
                                                                                    
                                                                                        小程序图形库
                                                                                    */ //行情数据结构体 及涉及到的行情算法(复权,周期等) 
//配色
function JSChartPaintResource() {//指标不支持信息
  this.Index = { NotSupport: { Font: "14px 微软雅黑", TextColor: "rgb(52,52,52)" } };
}
var g_JSChartPaintResource = new JSChartPaintResource();


//图新画法接口类
function IChartPainting()
{
  this.Canvas; //画布
  this.ChartBorder; //边框信息
  this.ChartFrame; //框架画法
  this.Name; //名称
  this.ClassName = 'IChartPainting'; //类名
  this.Data = new _umychartDataWechat.JSCommon_ChartData(); //数据区

  this.NotSupportMessage = null;
  this.MessageFont = g_JSChartPaintResource.Index.NotSupport.Font;
  this.MessageColor = g_JSChartPaintResource.Index.NotSupport.TextColor;

  this.IsDrawFirst = false; //是否比K线先画
  this.IsShow = true; //是否显示

  this.Draw = function () {};

  this.IsMinuteFrame = function ()
  {
    var isMinute = this.ChartFrame.ClassName == "MinuteFrame" || this.ChartFrame.ClassName == "MinuteHScreenFrame";
    return isMinute;
  };

  this.DrawNotSupportmessage = function ()
  {
    this.Canvas.font = this.MessageFont;
    this.Canvas.fillStyle = this.MessageColor;

    var left = this.ChartBorder.GetLeft();
    var width = this.ChartBorder.GetWidth();
    var top = this.ChartBorder.GetTopEx();
    var height = this.ChartBorder.GetHeightEx();

    var x = left + width / 2;
    var y = top + height / 2;

    this.Canvas.textAlign = "center";
    this.Canvas.textBaseline = "middle";
    this.Canvas.fillText(this.NotSupportMessage, x, y);
  };

  this.GetTooltipData = function (x, y, tooltip)
  {
    return false;
  };

  this.GetMaxMin = function ()
  {
    var xPointCount = this.ChartFrame.XPointCount;
    var range = {};
    range.Min = null;
    range.Max = null;

    if (!this.Data || !this.Data.Data) return range;

    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j)
    {
      var value = this.Data.Data[i];
      if (value == null || isNaN(value)) continue;

      if (range.Max == null) range.Max = value;
      if (range.Min == null) range.Min = value;

      if (range.Max < value) range.Max = value;
      if (range.Min > value) range.Min = value;
    }

    return range;
  };

  this.GetDynamicFont = function (dataWidth) //根据宽度自动获取对应字体
  {
    var font;
    if (dataWidth < 5) font = '4px Arial'; //字体根据数据宽度动态调整
    else if (dataWidth < 7) font = '6px Arial';else
      if (dataWidth < 9) font = '8px Arial';else
      if (dataWidth < 11) font = '10px Arial';else
      if (dataWidth < 13) font = '12px Arial';else
      if (dataWidth < 15) font = '14px Arial';else
      font = '16px Arial';

    return font;
  };

  this.GetDynamicFontEx = function (dataWidth, distanceWidth, maxSize, minSize, zoom, fontname) //根据宽度自动获取对应字体
  {
    if (maxSize == minSize)
    {
      var font = "".concat(maxSize.toFixed(0), "px ").concat(fontname);
      return font;
    }

    var fontSize = dataWidth + distanceWidth;
    if (zoom)
    {
      if (zoom.Type == 0)
      {
        if (zoom.Value > 0) fontSize = dataWidth * zoom.Value;
      } else
      if (zoom.Type == 1)
      {
        if (zoom.Value > 0) fontSize = (dataWidth + distanceWidth) * zoom.Value;
      } else
      if (zoom.Type == 2)
      {
        if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(zoom.Value))
        fontSize = dataWidth + distanceWidth + 2 * zoom.Value;
      }
    }

    if (fontSize < minSize) fontSize = minSize;else
    if (fontSize > maxSize) fontSize = maxSize;

    var font = "".concat(fontSize.toFixed(0), "px ").concat(fontname);
    return font;
  };

  this.SetFillStyle = function (color, x0, y0, x1, y1)
  {
    if (Array.isArray(color))
    {
      var gradient = this.Canvas.createLinearGradient(x0, y0, x1, y1);
      var offset = 1 / color.length;
      for (var i in color)
      {
        gradient.addColorStop(i * offset, color[i]);
      }
      this.Canvas.fillStyle = gradient;
    } else

    {
      this.Canvas.fillStyle = color;
    }
  };
}

//K线画法
function ChartKLine()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = 'ChartKLine';
  this.Symbol; //股票代码
  this.DrawType = 0; // 0=K线  1=收盘价线 2=美国线 3=空心K线柱子 4=收盘价面积
  this.CloseLineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.CloseLineColor;
  this.CloseLineAreaColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.CloseLineAreaColor;
  this.UpColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.UpBarColor;
  this.DownColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DownBarColor;
  this.UnchagneColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.UnchagneBarColor; //平盘
  this.ColorData; //五彩K线颜色 >0 UpColor 其他 DownColor
  this.TradeData; //交易系统 包含买卖数据{Buy:, Sell:}

  this.IsShowMaxMinPrice = true; //是否显示最大最小值
  this.TextFont = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.KLine.MaxMin.Font;
  this.TextColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.KLine.MaxMin.Color;
  this.InfoPointColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.KLine.Info.Color;
  this.InfoPointColor2 = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.KLine.Info.Color2;
  this.InfoDrawType = 0; //0=在底部画远点  1=在最低价画三角

  this.PtMax; //最大值的位置
  this.PtMin; //最小值的位置

  this.MinBarWidth = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.MinKLineBarWidth; //最小的柱子宽度

  this.DrawAKLine = function () //美国线
  {
    var isHScreen = this.ChartFrame.IsHScreen === true;
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var xOffset = this.ChartBorder.GetLeft() + distanceWidth / 2.0 + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLeftMargin;
    if (isHScreen) xOffset = this.ChartBorder.GetTop() + distanceWidth / 2.0 + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLeftMargin;
    var chartright = this.ChartBorder.GetRight();
    if (isHScreen) chartright = this.ChartBorder.GetBottom();
    var xPointCount = this.ChartFrame.XPointCount;

    var ptMax = { X: null, Y: null, Value: null, Align: 'left' };
    var ptMin = { X: null, Y: null, Value: null, Align: 'left' };
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth)
    {
      var data = this.Data.Data[i];
      if (data.Open == null || data.High == null || data.Low == null || data.Close == null) continue;

      var left = xOffset;
      var right = xOffset + dataWidth;
      if (right > chartright) break;
      var x = left + (right - left) / 2;
      var yLow = this.ChartFrame.GetYFromData(data.Low);
      var yHigh = this.ChartFrame.GetYFromData(data.High);
      var yOpen = this.ChartFrame.GetYFromData(data.Open);
      var yClose = this.ChartFrame.GetYFromData(data.Close);

      if (ptMax.Value == null || ptMax.Value < data.High) //求最大值
        {
          ptMax.X = x;
          ptMax.Y = yHigh;
          ptMax.Value = data.High;
          ptMax.Align = j < xPointCount / 2 ? 'left' : 'right';
        }

      if (ptMin.Value == null || ptMin.Value > data.Low) //求最小值
        {
          ptMin.X = x;
          ptMin.Y = yLow;
          ptMin.Value = data.Low;
          ptMin.Align = j < xPointCount / 2 ? 'left' : 'right';
        }

      if (data.Open < data.Close) this.Canvas.strokeStyle = this.UpColor; //阳线
      else if (data.Open > data.Close) this.Canvas.strokeStyle = this.DownColor; //阳线
        else this.Canvas.strokeStyle = this.UnchagneColor; //平线

      this.Canvas.beginPath(); //最高-最低
      if (isHScreen) {
        this.Canvas.moveTo(yHigh, ToFixedPoint(x));
        this.Canvas.lineTo(yLow, ToFixedPoint(x));
      } else
      {
        this.Canvas.moveTo(ToFixedPoint(x), yHigh);
        this.Canvas.lineTo(ToFixedPoint(x), yLow);
      }

      this.Canvas.stroke();

      if (dataWidth >= this.MinBarWidth) {
        this.Canvas.beginPath(); //开盘
        if (isHScreen) {
          this.Canvas.moveTo(ToFixedPoint(yOpen), left);
          this.Canvas.lineTo(ToFixedPoint(yOpen), x);
        } else
        {
          this.Canvas.moveTo(left, ToFixedPoint(yOpen));
          this.Canvas.lineTo(x, ToFixedPoint(yOpen));
        }
        this.Canvas.stroke();

        this.Canvas.beginPath(); //收盘
        if (isHScreen) {
          this.Canvas.moveTo(ToFixedPoint(yClose), right);
          this.Canvas.lineTo(ToFixedPoint(yClose), x);
        } else
        {
          this.Canvas.moveTo(right, ToFixedPoint(yClose));
          this.Canvas.lineTo(x, ToFixedPoint(yClose));
        }
        this.Canvas.stroke();
      }

      if (this.Data.DataType == 0 && _umychartDataWechat.JSCommon_ChartData.IsDayPeriod(this.Data.Period, true)) //信息地雷
        {
          var infoItem = { X: x, Xleft: left, XRight: right, YMax: yHigh, YMin: yLow, DayData: data, Index: j };
          this.DrawInfoDiv(infoItem);
        }
    }

    this.PtMax = ptMax;
    this.PtMin = ptMin;
  };

  this.DrawCloseLine = function () //收盘价线
  {
    var isHScreen = this.ChartFrame.IsHScreen === true;
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var xOffset = this.ChartBorder.GetLeft() + distanceWidth / 2.0 + 2.0;
    if (isHScreen) xOffset = this.ChartBorder.GetTop() + distanceWidth / 2.0 + 2.0;
    var chartright = this.ChartBorder.GetRight();
    if (isHScreen) chartright = this.ChartBorder.GetBottom();
    var xPointCount = this.ChartFrame.XPointCount;

    var bFirstPoint = true;
    this.Canvas.beginPath();
    this.Canvas.strokeStyle = this.CloseLineColor;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth) {
      var data = this.Data.Data[i];
      if (data.Open == null || data.High == null || data.Low == null || data.Close == null) continue;

      var left = xOffset;
      var right = xOffset + dataWidth;
      if (right > chartright) break;
      var x = left + (right - left) / 2;
      var yClose = this.ChartFrame.GetYFromData(data.Close);

      if (bFirstPoint) {
        if (isHScreen) this.Canvas.moveTo(yClose, x);else
        this.Canvas.moveTo(x, yClose);
        bFirstPoint = false;
      } else
      {
        if (isHScreen) this.Canvas.lineTo(yClose, x);else
        this.Canvas.lineTo(x, yClose);
      }
    }

    if (bFirstPoint == false) this.Canvas.stroke();
  };

  this.DrawCloseArea = function () //收盘价面积
  {
    var isHScreen = this.ChartFrame.IsHScreen === true;
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var xOffset = this.ChartBorder.GetLeft() + distanceWidth / 2.0 + 2.0;
    if (isHScreen) xOffset = this.ChartBorder.GetTop() + distanceWidth / 2.0 + 2.0;
    var chartright = this.ChartBorder.GetRight();
    if (isHScreen) chartright = this.ChartBorder.GetBottom();
    var xPointCount = this.ChartFrame.XPointCount;

    var bFirstPoint = true;
    var firstPoint = null;
    this.Canvas.beginPath();
    this.Canvas.strokeStyle = this.CloseLineColor;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth) {
      var data = this.Data.Data[i];
      if (data.Open == null || data.High == null || data.Low == null || data.Close == null) continue;

      var left = xOffset;
      var right = xOffset + dataWidth;
      if (right > chartright) break;
      var x = left + (right - left) / 2;
      var yClose = this.ChartFrame.GetYFromData(data.Close);

      if (bFirstPoint) {
        if (isHScreen) {
          this.Canvas.moveTo(yClose, x);
          firstPoint = { X: yClose, Y: x };
        } else
        {
          this.Canvas.moveTo(x, yClose);
          firstPoint = { X: x, Y: yClose };
        }
        bFirstPoint = false;
      } else
      {
        if (isHScreen) this.Canvas.lineTo(yClose, x);else
        this.Canvas.lineTo(x, yClose);
      }
    }

    if (bFirstPoint) return;

    this.Canvas.stroke();
    //画面积
    if (isHScreen) {
      this.Canvas.lineTo(this.ChartBorder.GetLeft(), x);
      this.Canvas.lineTo(this.ChartBorder.GetLeft(), firstPoint.Y);
    } else
    {
      this.Canvas.lineTo(x, this.ChartBorder.GetBottom());
      this.Canvas.lineTo(firstPoint.X, this.ChartBorder.GetBottom());
    }
    this.Canvas.closePath();

    if (Array.isArray(this.CloseLineAreaColor)) {
      if (isHScreen) {
        var gradient = this.Canvas.createLinearGradient(this.ChartBorder.GetRightEx(), this.ChartBorder.GetTop(), this.ChartBorder.GetLeft(), this.ChartBorder.GetTop());
        gradient.addColorStop(0, this.CloseLineAreaColor[0]);
        gradient.addColorStop(1, this.CloseLineAreaColor[1]);
        this.Canvas.fillStyle = gradient;
      } else
      {
        var _gradient = this.Canvas.createLinearGradient(firstPoint.X, this.ChartBorder.GetTopEx(), firstPoint.X, this.ChartBorder.GetBottom());
        _gradient.addColorStop(0, this.CloseLineAreaColor[0]);
        _gradient.addColorStop(1, this.CloseLineAreaColor[1]);
        this.Canvas.fillStyle = _gradient;
      }
    } else
    {
      this.Canvas.fillStyle = this.CloseLineAreaColor;
    }
    this.Canvas.fill();
  };

  this.DrawKBar = function ()
  {
    var isHScreen = this.ChartFrame.IsHScreen === true;
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var xOffset = this.ChartBorder.GetLeft() + distanceWidth / 2.0 + 2.0;
    var chartright = this.ChartBorder.GetRight();
    var xPointCount = this.ChartFrame.XPointCount;

    if (isHScreen) {
      xOffset = this.ChartBorder.GetTop() + distanceWidth / 2.0 + 2.0;
      chartright = this.ChartBorder.GetBottom();
    }

    var ptMax = { X: null, Y: null, Value: null, Align: 'left' };
    var ptMin = { X: null, Y: null, Value: null, Align: 'left' };

    var upColor = this.UpColor;
    var downColor = this.DownColor;
    var unchagneColor = this.UnchagneColor;

    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth)
    {
      var data = this.Data.Data[i];
      if (data.Open == null || data.High == null || data.Low == null || data.Close == null) continue;

      var left = xOffset;
      var right = xOffset + dataWidth;
      if (right > chartright)
      break;

      var x = left + (right - left) / 2;
      var yLow = this.ChartFrame.GetYFromData(data.Low);
      var yHigh = this.ChartFrame.GetYFromData(data.High);
      var yOpen = this.ChartFrame.GetYFromData(data.Open);
      var yClose = this.ChartFrame.GetYFromData(data.Close);
      var y = yHigh;

      if (ptMax.Value == null || ptMax.Value < data.High) //求最大值
        {
          ptMax.X = x;
          ptMax.Y = yHigh;
          ptMax.Value = data.High;
          ptMax.Align = j < xPointCount / 2 ? 'left' : 'right';
        }

      if (ptMin.Value == null || ptMin.Value > data.Low) //求最小值
        {
          ptMin.X = x;
          ptMin.Y = yLow;
          ptMin.Value = data.Low;
          ptMin.Align = j < xPointCount / 2 ? 'left' : 'right';
        }

      if (this.ColorData) ///五彩K线颜色设置
        {
          if (i < this.ColorData.length)
          upColor = downColor = unchagneColor = this.ColorData[i] > 0 ? this.UpColor : this.DownColor;else

          upColor = downColor = unchagneColor = this.DownColor;
        }

      if (data.Open < data.Close) //阳线
        {
          if (dataWidth >= this.MinBarWidth)
          {
            this.Canvas.strokeStyle = upColor;
            if (data.High > data.Close) //上影线
              {
                this.Canvas.beginPath();
                if (isHScreen)
                {
                  this.Canvas.moveTo(ToFixedPoint(y), ToFixedPoint(x));
                  this.Canvas.lineTo(ToFixedPoint(this.DrawType == 3 ? Math.max(yClose, yOpen) : yClose), ToFixedPoint(x));
                } else

                {
                  this.Canvas.moveTo(ToFixedPoint(x), ToFixedPoint(y));
                  this.Canvas.lineTo(ToFixedPoint(x), ToFixedPoint(this.DrawType == 3 ? Math.min(yClose, yOpen) : yClose));
                }
                this.Canvas.stroke();
                y = yClose;
              } else

            {
              y = yClose;
            }

            this.Canvas.fillStyle = upColor;
            if (isHScreen)
            {
              if (Math.abs(yOpen - y) < 1)
              {
                this.Canvas.fillRect(ToFixedRect(y), ToFixedRect(left), 1, ToFixedRect(dataWidth)); //高度小于1,统一使用高度1
              } else

              {
                if (this.DrawType == 3) //空心柱
                  {
                    this.Canvas.beginPath();
                    this.Canvas.rect(ToFixedPoint(y), ToFixedPoint(left), ToFixedRect(yOpen - y), ToFixedRect(dataWidth));
                    this.Canvas.stroke();
                  } else

                {
                  //宽度是负数竟然不会画, h5就可以
                  //this.Canvas.fillRect(ToFixedRect(y), ToFixedRect(left), ToFixedRect(yOpen - y), ToFixedRect(dataWidth));
                  this.Canvas.fillRect(ToFixedRect(Math.min(yOpen, y)), ToFixedRect(left), ToFixedRect(Math.abs(yOpen - y)), ToFixedRect(dataWidth));
                }
              }
            } else

            {
              if (Math.abs(yOpen - y) < 1)
              {
                this.Canvas.fillRect(ToFixedRect(left), ToFixedRect(y), ToFixedRect(dataWidth), 1); //高度小于1,统一使用高度1
              } else

              {
                if (this.DrawType == 3) //空心柱
                  {
                    this.Canvas.beginPath();
                    this.Canvas.rect(ToFixedPoint(left), ToFixedPoint(y), ToFixedRect(dataWidth), ToFixedRect(yOpen - y));
                    this.Canvas.stroke();
                  } else

                {
                  this.Canvas.fillRect(ToFixedRect(left), ToFixedRect(y), ToFixedRect(dataWidth), ToFixedRect(yOpen - y));
                }
              }
            }

            if (data.Open > data.Low) //下影线
              {
                this.Canvas.beginPath();
                if (isHScreen)
                {
                  this.Canvas.moveTo(ToFixedPoint(this.DrawType == 3 ? Math.min(yClose, yOpen) : y), ToFixedPoint(x));
                  this.Canvas.lineTo(ToFixedPoint(yLow), ToFixedPoint(x));
                } else

                {
                  this.Canvas.moveTo(ToFixedPoint(x), ToFixedPoint(this.DrawType == 3 ? Math.max(yClose, yOpen) : y));
                  this.Canvas.lineTo(ToFixedPoint(x), ToFixedPoint(yLow));
                }
                this.Canvas.stroke();
              }
          } else

          {
            this.Canvas.beginPath();
            if (isHScreen)
            {
              this.Canvas.moveTo(yHigh, ToFixedPoint(x));
              this.Canvas.lineTo(yLow, ToFixedPoint(x));
            } else

            {
              this.Canvas.moveTo(ToFixedPoint(x), yHigh);
              this.Canvas.lineTo(ToFixedPoint(x), yLow);
            }
            this.Canvas.strokeStyle = upColor;
            this.Canvas.stroke();
          }
        } else
      if (data.Open > data.Close) //阴线
        {
          if (dataWidth >= this.MinBarWidth)
          {
            this.Canvas.strokeStyle = downColor;
            if (data.High > data.Close) //上影线
              {
                this.Canvas.beginPath();
                if (isHScreen)
                {
                  this.Canvas.moveTo(ToFixedPoint(y), ToFixedPoint(x));
                  this.Canvas.lineTo(ToFixedPoint(yOpen), ToFixedPoint(x));
                } else

                {
                  this.Canvas.moveTo(ToFixedPoint(x), ToFixedPoint(y));
                  this.Canvas.lineTo(ToFixedPoint(x), ToFixedPoint(yOpen));
                }
                this.Canvas.stroke();
                y = yOpen;
              } else

            {
              y = yOpen;
            }

            this.Canvas.fillStyle = downColor;
            if (isHScreen)
            {
              if (Math.abs(yClose - y) < 1)
              {
                this.Canvas.fillRect(ToFixedRect(y), ToFixedRect(left), 1, ToFixedRect(dataWidth)); //高度小于1,统一使用高度1
              } else

              {
                //宽度是负数竟然不会画, h5就可以
                this.Canvas.fillRect(ToFixedRect(Math.min(yClose, y)), ToFixedRect(left), ToFixedRect(Math.abs(yClose - y)), ToFixedRect(dataWidth));
              }
            } else

            {
              if (Math.abs(yClose - y) < 1) this.Canvas.fillRect(ToFixedRect(left), ToFixedRect(y), ToFixedRect(dataWidth), 1); //高度小于1,统一使用高度1
              else this.Canvas.fillRect(ToFixedRect(left), ToFixedRect(y), ToFixedRect(dataWidth), ToFixedRect(yClose - y));
            }

            if (data.Open > data.Low) //下影线
              {
                this.Canvas.beginPath();
                if (isHScreen)
                {
                  this.Canvas.moveTo(ToFixedPoint(y), ToFixedPoint(x));
                  this.Canvas.lineTo(ToFixedPoint(yLow), ToFixedPoint(x));
                } else

                {
                  this.Canvas.moveTo(ToFixedPoint(x), ToFixedPoint(y));
                  this.Canvas.lineTo(ToFixedPoint(x), ToFixedPoint(yLow));
                }
                this.Canvas.stroke();
              }
          } else

          {
            this.Canvas.beginPath();
            if (isHScreen)
            {
              this.Canvas.moveTo(yHigh, ToFixedPoint(x));
              this.Canvas.lineTo(yLow, ToFixedPoint(x));
            } else

            {
              this.Canvas.moveTo(ToFixedPoint(x), yHigh);
              this.Canvas.lineTo(ToFixedPoint(x), yLow);
            }
            this.Canvas.strokeStyle = downColor;
            this.Canvas.stroke();
          }
        } else
        // 平线
        {
          if (dataWidth >= this.MinBarWidth)
          {
            this.Canvas.strokeStyle = unchagneColor;
            this.Canvas.beginPath();
            if (data.High > data.Close) //上影线
              {
                if (isHScreen)
                {
                  this.Canvas.moveTo(y, ToFixedPoint(x));
                  this.Canvas.lineTo(yOpen, ToFixedPoint(x));
                } else

                {
                  this.Canvas.moveTo(ToFixedPoint(x), y);
                  this.Canvas.lineTo(ToFixedPoint(x), yOpen);
                }
                y = yOpen;
              } else

            {
              y = yOpen;
            }

            if (isHScreen)
            {
              this.Canvas.moveTo(ToFixedPoint(y), ToFixedPoint(left));
              this.Canvas.lineTo(ToFixedPoint(y), ToFixedPoint(right));
            } else

            {
              this.Canvas.moveTo(ToFixedPoint(left), ToFixedPoint(y));
              this.Canvas.lineTo(ToFixedPoint(right), ToFixedPoint(y));
            }

            if (data.Open > data.Low) //下影线
              {
                if (isHScreen)
                {
                  this.Canvas.moveTo(ToFixedPoint(y), ToFixedPoint(x));
                  this.Canvas.lineTo(ToFixedPoint(yLow), ToFixedPoint(x));
                } else

                {
                  this.Canvas.moveTo(ToFixedPoint(x), ToFixedPoint(y));
                  this.Canvas.lineTo(ToFixedPoint(x), ToFixedPoint(yLow));
                }
              }

            this.Canvas.stroke();
          } else

          {
            this.Canvas.beginPath();
            if (isHScreen)
            {
              this.Canvas.moveTo(yHigh, ToFixedPoint(x));
              this.Canvas.lineTo(yLow, ToFixedPoint(x));
            } else

            {
              this.Canvas.moveTo(ToFixedPoint(x), yHigh);
              this.Canvas.lineTo(ToFixedPoint(x), yLow);
            }
            this.Canvas.strokeStyle = unchagneColor;
            this.Canvas.stroke();
          }
        }

      if (this.Data.DataType == 0 && _umychartDataWechat.JSCommon_ChartData.IsDayPeriod(this.Data.Period, true)) //信息地雷
        {
          var infoItem = { X: x, Xleft: left, XRight: right, YMax: yHigh, YMin: yLow, DayData: data, Index: j };
          this.DrawInfoDiv(infoItem);
        }
    }

    this.PtMax = ptMax;
    this.PtMin = ptMin;
  };

  this.DrawTrade = function () //交易系统
  {
    if (!this.TradeData) return;

    var isHScreen = this.ChartFrame.IsHScreen === true;
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var xOffset = this.ChartBorder.GetLeft() + distanceWidth / 2.0 + 2.0;
    var chartright = this.ChartBorder.GetRight();
    var xPointCount = this.ChartFrame.XPointCount;

    if (isHScreen) {
      xOffset = this.ChartBorder.GetTop() + distanceWidth / 2.0 + 2.0;
      chartright = this.ChartBorder.GetBottom();
    }

    var sellData = this.TradeData.Sell;
    var buyData = this.TradeData.Buy;
    var arrowWidth = dataWidth;
    if (arrowWidth > 10) arrowWidth = 10;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth) {
      var data = this.Data.Data[i];
      if (data.Open == null || data.High == null || data.Low == null || data.Close == null) continue;

      var buy = false,sell = false;
      if (sellData && i < sellData.length) sell = sellData[i] > 0;
      if (buyData && i < buyData.length) buy = buyData[i] > 0;
      if (!sell && !buy) continue;

      var left = xOffset;
      var right = xOffset + dataWidth;
      if (right > chartright) break;
      var x = left + (right - left) / 2;
      var yLow = this.ChartFrame.GetYFromData(data.Low);
      var yHigh = this.ChartFrame.GetYFromData(data.High);
      var yOpen = this.ChartFrame.GetYFromData(data.Open);
      var yClose = this.ChartFrame.GetYFromData(data.Close);
      var y = yHigh;

      if (buy) {
        this.Canvas.fillStyle = this.UpColor;
        this.Canvas.strokeStyle = this.UnchagneColor;
        this.Canvas.beginPath();
        if (isHScreen) {
          this.Canvas.moveTo(yLow - 1, x);
          this.Canvas.lineTo(yLow - arrowWidth - 1, x - arrowWidth / 2);
          this.Canvas.lineTo(yLow - arrowWidth - 1, x + arrowWidth / 2);
        } else
        {
          this.Canvas.moveTo(x, yLow + 1);
          this.Canvas.lineTo(x - arrowWidth / 2, yLow + arrowWidth + 1);
          this.Canvas.lineTo(x + arrowWidth / 2, yLow + arrowWidth + 1);
        }
        this.Canvas.closePath();
        this.Canvas.fill();
        this.Canvas.stroke();
      }

      if (sell) {
        this.Canvas.fillStyle = this.DownColor;
        this.Canvas.strokeStyle = this.UnchagneColor;
        this.Canvas.beginPath();
        if (isHScreen) {
          this.Canvas.moveTo(yHigh + 1, x);
          this.Canvas.lineTo(yHigh + arrowWidth + 1, x - arrowWidth / 2);
          this.Canvas.lineTo(yHigh + arrowWidth + 1, x + arrowWidth / 2);
        } else
        {
          this.Canvas.moveTo(x, yHigh - 1);
          this.Canvas.lineTo(x - arrowWidth / 2, yHigh - arrowWidth - 1);
          this.Canvas.lineTo(x + arrowWidth / 2, yHigh - arrowWidth - 1);
        }
        this.Canvas.closePath();
        this.Canvas.fill();
        this.Canvas.stroke();
      }
    }
  };

  this.Draw = function () {
    this.PtMax = { X: null, Y: null, Value: null, Align: 'left' }; //清空最大
    this.PtMin = { X: null, Y: null, Value: null, Align: 'left' }; //清空最小
    this.ChartFrame.ChartKLine = { Max: null, Min: null }; //保存K线上 显示最大最小值坐标

    if (this.IsShow == false) return;

    if (this.DrawType == 1) {
      this.DrawCloseLine();
      return;
    } else
    if (this.DrawType == 2) {
      this.DrawAKLine();
    } else
    if (this.DrawType == 4) {
      this.DrawCloseArea();
    } else
    {
      this.DrawKBar();
    }

    this.DrawTrade();

    if (this.IsShowMaxMinPrice) //标注最大值最小值
      {
        if (this.ChartFrame.IsHScreen === true) this.HScreenDrawMaxMinPrice(this.PtMax, this.PtMin);else
        this.DrawMaxMinPrice(this.PtMax, this.PtMin);
      }
  };

  this.DrawMaxMinPrice = function (ptMax, ptMin) {
    if (ptMax.X == null || ptMax.Y == null || ptMax.Value == null) return;
    if (ptMin.X == null || ptMin.Y == null || ptMin.Value == null) return;

    var defaultfloatPrecision = _umychartCoordinatedataWechat.JSCommonCoordinateData.GetfloatPrecision(this.Symbol);
    this.Canvas.font = this.TextFont;
    this.Canvas.fillStyle = this.TextColor;
    this.Canvas.textAlign = ptMax.Align;
    this.Canvas.textBaseline = 'bottom';
    var left = ptMax.X;
    var text = ptMax.Value.toFixed(defaultfloatPrecision);
    if (ptMax.Align == 'left') text = '←' + text;else
    text = text + '→';
    this.Canvas.fillText(text, left, ptMax.Y);
    this.ChartFrame.ChartKLine.Max = { X: left, Y: ptMax.Y, Text: { BaseLine: 'bottom' } };

    this.Canvas.textAlign = ptMin.Align;
    this.Canvas.textBaseline = 'top';
    var left = ptMin.X;
    text = ptMin.Value.toFixed(defaultfloatPrecision);
    if (ptMin.Align == 'left') text = '←' + text;else
    text = text + '→';
    this.Canvas.fillText(text, left, ptMin.Y);
    this.ChartFrame.ChartKLine.Min = { X: left, Y: ptMin.Y, Text: { BaseLine: 'top' } };
  };

  this.HScreenDrawMaxMinPrice = function (ptMax, ptMin) //横屏模式下显示最大最小值
  {
    if (ptMax.X == null || ptMax.Y == null || ptMax.Value == null) return;
    if (ptMin.X == null || ptMin.Y == null || ptMin.Value == null) return;

    var defaultfloatPrecision = _umychartCoordinatedataWechat.JSCommonCoordinateData.GetfloatPrecision(this.Symbol);
    var xText = ptMax.Y;
    var yText = ptMax.X;
    this.Canvas.save();
    this.Canvas.translate(xText, yText);
    this.Canvas.rotate(90 * Math.PI / 180);

    this.Canvas.font = this.TextFont;
    this.Canvas.fillStyle = this.TextColor;
    this.Canvas.textAlign = ptMax.Align;
    this.Canvas.textBaseline = 'bottom';
    var text = ptMax.Value.toFixed(defaultfloatPrecision);
    if (ptMax.Align == 'left') text = '←' + text;else
    text = text + '→';
    this.Canvas.fillText(text, 0, 0);
    this.Canvas.restore();


    var xText = ptMin.Y;
    var yText = ptMin.X;
    this.Canvas.save();
    this.Canvas.translate(xText, yText);
    this.Canvas.rotate(90 * Math.PI / 180);

    this.Canvas.font = this.TextFont;
    this.Canvas.fillStyle = this.TextColor;
    this.Canvas.textAlign = ptMin.Align;
    this.Canvas.textBaseline = 'top';
    var text = ptMin.Value.toFixed(defaultfloatPrecision);
    if (ptMin.Align == 'left') text = '←' + text;else
    text = text + '→';
    this.Canvas.fillText(text, 0, 0);
    this.Canvas.restore();
  };

  //画某一天的信息地雷 画在底部
  this.DrawInfoDiv = function (item) {
    if (!this.InfoData || this.InfoData.length <= 0) return;

    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;

    var infoData = this.InfoData.get(item.DayData.Date.toString());
    if (!infoData || infoData.Data.length <= 0) return;
    var bHScreen = this.ChartFrame.IsHScreen === true;
    if (this.InfoDrawType === 1) {
      this.Canvas.font = this.GetDynamicFont(dataWidth);
      this.Canvas.fillStyle = this.InfoPointColor2;
      this.Canvas.textAlign = 'center';
      this.Canvas.textBaseline = 'top';
      if (bHScreen) {
        var xText = item.YMin;
        var yText = item.X;
        this.Canvas.save();
        this.Canvas.translate(xText, yText);
        this.Canvas.rotate(90 * Math.PI / 180);
        this.Canvas.fillText('▲', 0, 0);
        this.Canvas.restore();
      } else
      {
        var left = ToFixedPoint(item.X);
        this.Canvas.fillText('▲', left, item.YMin);
      }
    } else
    {
      var dataWidth = this.ChartFrame.DataWidth;
      var radius = dataWidth / 2;
      if (radius > 3) radius = 3;
      var x = item.X;
      var y = this.ChartFrame.ChartBorder.GetBottom() - 2 - radius;
      if (bHScreen) y = this.ChartFrame.ChartBorder.GetLeft() + 2 + radius;

      this.Canvas.fillStyle = this.InfoPointColor;
      this.Canvas.beginPath();
      if (bHScreen) this.Canvas.arc(y, x, radius, 0, Math.PI * 2, true);else
      this.Canvas.arc(ToFixedPoint(x), y, radius, 0, Math.PI * 2, true);
      this.Canvas.closePath();
      this.Canvas.fill();
    }
  };

  this.GetTooltipData = function (x, y, tooltip) {
    return false;
  };

  this.GetMaxMin = function () //计算当天显示数据的最大最小值
  {
    var xPointCount = this.ChartFrame.XPointCount;
    var range = {};
    range.Max = null;
    range.Min = null;

    if (this.IsShow == false) return range;

    if (this.DrawType == 1 || this.DrawType == 4) // 1=收盘价线 4=收盘价面积图
      {
        for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j)
        {
          var data = this.Data.Data[i];
          if (!_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(data.Close)) continue;

          if (range.Max == null) range.Max = data.Close;
          if (range.Min == null) range.Min = data.Close;

          if (range.Max < data.Close) range.Max = data.Close;
          if (range.Min > data.Close) range.Min = data.Close;
        }
      } else

    {
      for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j)
      {
        var data = this.Data.Data[i];
        if (data.Open == null || data.High == null || data.Low == null || data.Close == null) continue;

        if (range.Max == null) range.Max = data.High;
        if (range.Min == null) range.Min = data.Low;

        if (range.Max < data.High) range.Max = data.High;
        if (range.Min > data.Low) range.Min = data.Low;
      }

    }

    return range;
  };
}



/*
      文字输出 支持横屏
      数组不为null的数据中输出 this.Text文本
  */
function ChartSingleText()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.Color = "rgb(255,193,37)"; //线段颜色
  this.TextFont = "14px 微软雅黑"; //字体
  this.Text;
  this.TextAlign = 'left';
  this.Direction = 0; //0=middle 1=bottom 2=top
  this.YOffset = 0;
  this.Position; //指定输出位置

  this.TextSize =
  {
    Max: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DRAWICON.Text.MaxSize, Min: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DRAWICON.Text.MinSize, //字体的最大最小值
    Zoom: { Type: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DRAWICON.Text.Zoom.Type, Value: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DRAWICON.Text.Zoom.Value }, //放大倍数
    FontName: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DRAWICON.Text.FontName };


  this.ReloadResource = function (resource)
  {
    if (this.Name == "DRAWTEXT")
    {
      this.TextSize =
      {
        Max: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DRAWTEXT.MaxSize, Min: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DRAWTEXT.MinSize, //字体的最大最小值
        Zoom: { Type: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DRAWTEXT.Zoom.Type, Value: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DRAWTEXT.Zoom.Value }, //放大倍数
        FontName: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DRAWTEXT.FontName };

    } else
    if (this.Name == "DRAWNUMBER")
    {
      this.TextSize =
      {
        Max: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DRAWNUMBER.MaxSize, Min: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DRAWNUMBER.MinSize, //字体的最大最小值
        Zoom: { Type: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DRAWNUMBER.Zoom.Type, Value: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DRAWNUMBER.Zoom.Value }, //放大倍数
        FontName: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DRAWNUMBER.FontName };

    }
  };

  this.Draw = function ()
  {
    if (!this.IsShow) return;

    if (this.NotSupportMessage)
    {
      this.DrawNotSupportmessage();
      return;
    }

    if (this.Position)
    {
      this.DrawPosition();
      return;
    }

    if (!this.Data || !this.Data.Data) return;

    var isHScreen = this.ChartFrame.IsHScreen === true;
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var chartright = this.ChartBorder.GetRight();
    var top = this.ChartBorder.GetTopEx();
    var bottom = this.ChartBorder.GetBottomEx();
    if (isHScreen)
    {
      chartright = this.ChartBorder.GetBottom();
      top = this.ChartBorder.GetRightEx();
      bottom = this.ChartBorder.GetLeftEx();
    }
    var xPointCount = this.ChartFrame.XPointCount;

    var isArrayText = Array.isArray(this.Text);
    var text;
    if (this.Direction == 1) this.Canvas.textBaseline = 'bottom';else
    if (this.Direction == 2) this.Canvas.textBaseline = 'top';else
    this.Canvas.textBaseline = 'middle';
    this.TextFont = this.GetDynamicFontEx(dataWidth, distanceWidth, this.TextSize.Max, this.TextSize.Min, this.TextSize.Zoom, this.TextSize.FontName);
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j)
    {
      var value = this.Data.Data[i];
      if (value == null) continue;
      var x = this.ChartFrame.GetXFromIndex(j);
      var y = this.ChartFrame.GetYFromData(value);

      if (x > chartright) break;

      this.Canvas.textAlign = this.TextAlign;
      this.Canvas.fillStyle = this.Color;
      this.Canvas.font = this.TextFont;

      if (this.YOffset > 0 && this.Direction > 0)
      {
        var yPrice = y;

        this.Canvas.save();
        this.Canvas.setLineDash([5, 10]);
        this.Canvas.strokeStyle = this.Color;
        this.Canvas.beginPath();
        if (isHScreen)
        {
          if (this.Direction == 1)
          {
            y = top - this.YOffset;
            yPrice += 5;
          } else

          {
            y = bottom + this.YOffset;
            yPrice -= 5;
          }
          this.Canvas.moveTo(ToFixedPoint(yPrice), ToFixedPoint(x));
          this.Canvas.lineTo(ToFixedPoint(y), ToFixedPoint(x));
        } else

        {
          if (this.Direction == 1)
          {
            y = top + this.YOffset;
            yPrice += 5;
          } else

          {
            y = bottom - this.YOffset;
            yPrice -= 5;
          }
          this.Canvas.moveTo(ToFixedPoint(x), ToFixedPoint(yPrice));
          this.Canvas.lineTo(ToFixedPoint(x), ToFixedPoint(y));
        }

        this.Canvas.stroke();
        this.Canvas.restore();
      }

      if (isArrayText)
      {
        text = this.Text[i];
        if (!text) continue;
        if (isHScreen)
        {
          if (this.Name == 'DRAWNUMBER')
          {
            if (this.Direction == 1) y += _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DRAWABOVE.YOffset;else
            if (this.Direction == 2) y -= 4;
          }
        } else

        {
          if (this.Name == 'DRAWNUMBER')
          {
            if (this.Direction == 1) y -= _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DRAWABOVE.YOffset;else
            if (this.Direction == 2) y += 4;
          }
        }

        this.DrawText(text, x, y, isHScreen);
      } else

      {
        this.DrawText(this.Text, x, y, isHScreen);
      }
    }
  };

  this.DrawPosition = function () //绘制在指定位置上
  {
    if (!this.Text) return;
    var isHScreen = this.ChartFrame.IsHScreen === true;
    if (isHScreen)
    {
      var y = this.ChartBorder.GetRightEx() - this.ChartBorder.GetWidthEx() * this.Position.Y;
      var x = this.ChartBorder.GetTop() + this.ChartBorder.GetHeight() * this.Position.X;
    } else

    {
      var x = this.ChartBorder.GetLeft() + this.ChartBorder.GetWidth() * this.Position.X;
      var y = this.ChartBorder.GetTopEx() + this.ChartBorder.GetHeight() * this.Position.Y;
    }

    this.Canvas.fillStyle = this.Color;

    //TYPE:0为左对齐,1为右对齐.
    if (this.Position.Type == 0) this.Canvas.textAlign = 'left';else
    if (this.Position.Type == 1) this.Canvas.textAlign = 'right';else
    this.Canvas.textAlign = 'center';

    if (this.Direction == 1) this.Canvas.textBaseline = 'bottom';else
    if (this.Direction == 2) this.Canvas.textBaseline = 'top';else
    this.Canvas.textBaseline = 'middle';

    this.DrawText(this.Text, x, y, isHScreen);
  };

  this.DrawText = function (text, x, y, isHScreen)
  {
    if (isHScreen)
    {
      this.Canvas.save();
      this.Canvas.translate(y, x);
      this.Canvas.rotate(90 * Math.PI / 180);
      this.Canvas.fillText(text, 0, 0);
      this.Canvas.restore();
    } else

    {
      this.Canvas.fillText(text, x, y);
    }
  };
}


//线段
function ChartLine()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = 'ChartLine';
  this.Color = "rgb(255,193,37)"; //线段颜色
  this.LineWidth; //线段宽度
  this.DrawType = 0; //画图方式  0=无效数平滑  1=无效数不画断开
  this.IsDotLine = false; //虚线

  this.Draw = function ()
  {
    if (!this.IsShow) return;
    if (this.NotSupportMessage)
    {
      this.DrawNotSupportmessage();
      return;
    }

    if (!this.Data || !this.Data.Data) return;

    switch (this.DrawType) {

      case 0:
        return this.DrawLine();
      case 1:
        return this.DrawStraightLine();}

  };

  this.DrawLine = function ()
  {
    var bHScreen = this.ChartFrame.IsHScreen === true;
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var chartright = this.ChartBorder.GetRight();
    if (bHScreen) chartright = this.ChartBorder.GetBottom();
    var xPointCount = this.ChartFrame.XPointCount;

    this.Canvas.save();
    if (this.LineWidth > 0) this.Canvas.lineWidth = this.LineWidth;
    var bFirstPoint = true;
    var drawCount = 0;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j)
    {
      var value = this.Data.Data[i];
      if (value == null) continue;

      var x = this.ChartFrame.GetXFromIndex(j);
      var y = this.GetYFromData(value);

      if (x > chartright) break;

      if (bFirstPoint)
      {
        this.Canvas.strokeStyle = this.Color;
        this.Canvas.beginPath();
        if (bHScreen) this.Canvas.moveTo(y, x); //横屏坐标轴对调
        else this.Canvas.moveTo(x, y);
        bFirstPoint = false;
      } else

      {
        if (bHScreen) this.Canvas.lineTo(y, x);else
        this.Canvas.lineTo(x, y);
      }

      ++drawCount;
    }

    if (drawCount > 0) this.Canvas.stroke();
    this.Canvas.restore();
  };

  //无效数不画
  this.DrawStraightLine = function ()
  {
    var bHScreen = this.ChartFrame.IsHScreen === true;
    var isMinute = this.IsMinuteFrame();
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var xOffset = this.ChartBorder.GetLeft() + distanceWidth / 2.0 + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLeftMargin;
    var chartright = this.ChartBorder.GetRight();
    if (bHScreen) chartright = this.ChartBorder.GetBottom();
    if (bHScreen) xOffset = this.ChartBorder.GetTop() + distanceWidth / 2.0 + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLeftMargin;
    var xPointCount = this.ChartFrame.XPointCount;

    this.Canvas.save();
    if (this.LineWidth > 0) this.Canvas.lineWidth = this.LineWidth;
    this.Canvas.strokeStyle = this.Color;
    if (this.IsDotLine) this.Canvas.setLineDash([3, 5]); //画虚线

    var bFirstPoint = true;
    var drawCount = 0;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth)
    //for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j) 
    {
      var value = this.Data.Data[i];
      if (value == null)
      {
        if (drawCount > 0) this.Canvas.stroke();
        bFirstPoint = true;
        drawCount = 0;
        continue;
      }

      if (isMinute)
      {
        var x = this.ChartFrame.GetXFromIndex(j);
      } else

      {
        var left = xOffset;
        var right = xOffset + dataWidth;
        if (right > chartright) break;
        var x = left + (right - left) / 2;
      }


      var y = this.GetYFromData(value);

      if (x > chartright) break;

      if (bFirstPoint)
      {
        this.Canvas.beginPath();
        if (bHScreen) this.Canvas.moveTo(y, x); //横屏坐标轴对调
        else this.Canvas.moveTo(x, y);
        bFirstPoint = false;
      } else

      {
        if (bHScreen) this.Canvas.lineTo(y, x);else
        this.Canvas.lineTo(x, y);
      }

      ++drawCount;
    }

    if (drawCount > 0) this.Canvas.stroke();
    this.Canvas.restore();
  };

  this.GetYFromData = function (value)
  {
    return this.ChartFrame.GetYFromData(value);
  };
}

//子线段
function ChartSubLine()
{
  this.newMethod = ChartLine; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = 'ChartSubLine'; //类名
  this.Color = "rgb(255,193,37)"; //线段颜色
  this.LineWidth; //线段宽度
  this.DrawType = 0; //画图方式  0=无效数平滑  1=无效数不画断开
  this.IsDotLine = false; //虚线

  this.SubFrame = { Max: null, Min: null };

  this.Draw = function ()
  {
    if (!this.IsShow) return;
    if (!this.Data || !this.Data.Data) return;

    this.CalculateDataMaxMin();

    switch (this.DrawType) {

      case 0:
        return this.DrawLine();
      case 1:
        return this.DrawStraightLine();}

  };

  this.GetYFromData = function (value)
  {
    var bHScreen = this.ChartFrame.IsHScreen === true;

    if (bHScreen)
    {
      if (value <= this.SubFrame.Min) return this.ChartBorder.GetLeftEx();
      if (value >= this.SubFrame.Max) return this.ChartBorder.GetRightEx();

      var width = this.ChartBorder.GetWidthEx() * (value - this.SubFrame.Min) / (this.SubFrame.Max - this.SubFrame.Min);
      return this.ChartBorder.GetLeftEx() + width;
    } else

    {
      if (value <= this.SubFrame.Min) return this.ChartBorder.GetBottomEx();
      if (value >= this.SubFrame.Max) return this.ChartBorder.GetTopEx();

      var height = this.ChartBorder.GetHeightEx() * (value - this.SubFrame.Min) / (this.SubFrame.Max - this.SubFrame.Min);
      return this.ChartBorder.GetBottomEx() - height;
    }
  };

  this.CalculateDataMaxMin = function ()
  {
    this.SubFrame = { Max: null, Min: null };

    var bHScreen = this.ChartFrame.IsHScreen === true;
    var chartright = this.ChartBorder.GetRight();
    if (bHScreen) chartright = this.ChartBorder.GetBottom();
    var xPointCount = this.ChartFrame.XPointCount;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j)
    {
      var value = this.Data.Data[i];
      if (value == null) continue;

      var x = this.ChartFrame.GetXFromIndex(j);
      if (x > chartright) break;

      if (this.SubFrame.Min == null || this.SubFrame.Min > value) this.SubFrame.Min = value;
      if (this.SubFrame.Max == null || this.SubFrame.Max < value) this.SubFrame.Max = value;
    }
  };

  this.GetMaxMin = function () //数据不参与坐标轴最大最小值计算
  {
    var range = { Min: null, Max: null };
    return range;
  };
}

//POINTDOT 圆点 支持横屏
function ChartPointDot()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.Color = "rgb(255,193,37)"; //线段颜色
  this.Radius = 1; //点半径
  this.ClassName = 'ChartPointDot';

  this.Draw = function ()
  {
    if (!this.IsShow) return;

    if (this.NotSupportMessage)
    {
      this.DrawNotSupportmessage();
      return;
    }

    if (!this.Data || !this.Data.Data) return;

    var bHScreen = this.ChartFrame.IsHScreen === true;
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var chartright = this.ChartBorder.GetRight();
    if (bHScreen === true) chartright = this.ChartBorder.GetBottom();
    var xPointCount = this.ChartFrame.XPointCount;

    this.Canvas.save();
    this.Canvas.fillStyle = this.Color;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j)
    {
      var value = this.Data.Data[i];
      if (value == null) continue;

      var x = this.ChartFrame.GetXFromIndex(j);
      var y = this.ChartFrame.GetYFromData(value);

      if (x > chartright) break;

      this.Canvas.beginPath();
      if (bHScreen) this.Canvas.arc(y, x, this.Radius, 0, Math.PI * 2, true);else
      this.Canvas.arc(x, y, this.Radius, 0, Math.PI * 2, true);
      this.Canvas.closePath();
      this.Canvas.fill();
    }

    this.Canvas.restore();
  };
}

//通达信语法  STICK 支持横屏
function ChartStick()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.Color = "rgb(255,193,37)"; //线段颜色
  this.LineWidth; //线段宽度
  this.ClassName = 'ChartStick';

  this.DrawLine = function ()
  {
    if (!this.Data || !this.Data.Data) return;

    var isHScreen = this.ChartFrame.IsHScreen === true;
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var chartright = this.ChartBorder.GetRight();
    if (isHScreen === true) chartright = this.ChartBorder.GetBottom();
    var xPointCount = this.ChartFrame.XPointCount;

    this.Canvas.save();
    if (this.LineWidth > 0) this.Canvas.lineWidth = this.LineWidth;
    var bFirstPoint = true;
    var drawCount = 0;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j)
    {
      var value = this.Data.Data[i];
      if (value == null) continue;

      var x = this.ChartFrame.GetXFromIndex(j);
      var y = this.ChartFrame.GetYFromData(value);

      if (x > chartright) break;

      if (bFirstPoint)
      {
        this.Canvas.strokeStyle = this.Color;
        this.Canvas.beginPath();
        if (isHScreen) this.Canvas.moveTo(y, x);else
        this.Canvas.moveTo(x, y);
        bFirstPoint = false;
      } else

      {
        if (isHScreen) this.Canvas.lineTo(y, x);else
        this.Canvas.lineTo(x, y);
      }

      ++drawCount;
    }

    if (drawCount > 0) this.Canvas.stroke();
    this.Canvas.restore();
  };

  this.DrawStick = function ()
  {
    if (!this.Data || !this.Data.Data) return;
    var bHScreen = this.ChartFrame.IsHScreen === true;
    var chartright = this.ChartBorder.GetRight();
    if (bHScreen) chartright = this.ChartBorder.GetBottom();
    var xPointCount = this.ChartFrame.XPointCount;
    var yBottom = this.ChartBorder.GetBottom();
    var xLeft = this.ChartBorder.GetLeft();

    this.Canvas.save();
    this.Canvas.strokeStyle = this.Color;
    if (this.LineWidth) this.Canvas.lineWidth = this.LineWidth;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j)
    {
      var value = this.Data.Data[i];
      if (value == null) continue;

      var x = this.ChartFrame.GetXFromIndex(j);
      var y = this.ChartFrame.GetYFromData(value);

      if (x > chartright) break;

      this.Canvas.beginPath();
      if (bHScreen)
      {
        this.Canvas.moveTo(xLeft, x);
        this.Canvas.lineTo(y, x);
        this.Canvas.stroke();
      } else

      {
        var xFix = parseInt(x.toString()) + 0.5;
        this.Canvas.moveTo(xFix, y);
        this.Canvas.lineTo(xFix, yBottom);
      }
      this.Canvas.stroke();
    }
    this.Canvas.restore();
  };

  this.Draw = function ()
  {
    if (!this.IsShow) return;

    if (this.NotSupportMessage)
    {
      this.DrawNotSupportmessage();
      return;
    }

    this.DrawStick();
  };
}

//通达信语法 LINESTICK 支持横屏
function ChartLineStick()
{
  this.newMethod = ChartStick; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = 'ChartLineStick';

  this.Draw = function ()
  {
    if (!this.IsShow) return;

    if (this.NotSupportMessage)
    {
      this.DrawNotSupportmessage();
      return;
    }

    this.DrawStick();
    this.DrawLine();
  };
}

//柱子 支持横屏
function ChartStickLine()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = 'ChartStickLine';
  this.Color = "rgb(255,193,37)"; //线段颜色
  this.LineWidth = 2; //线段宽度
  this.BarType = 0; //柱子类型 0=实心 1=空心
  this.MinBarWidth = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.MinKLineBarWidth; //最小的柱子宽度

  this.Draw = function ()
  {
    if (this.NotSupportMessage)
    {
      this.DrawNotSupportmessage();
      return;
    }

    if (!this.Data || !this.Data.Data) return;

    var isHScreen = this.ChartFrame.IsHScreen === true;
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var chartright = this.ChartBorder.GetRight();
    if (isHScreen) chartright = this.ChartBorder.GetBottom();
    var xPointCount = this.ChartFrame.XPointCount;
    var xOffset = this.ChartBorder.GetLeft() + distanceWidth / 2.0 + 2.0;
    if (isHScreen) xOffset = this.ChartBorder.GetTop() + distanceWidth / 2.0 + 2.0;

    this.Canvas.save();
    var bFillBar = false;
    var bFillKLine = false;

    if (this.LineWidth == 50)
    {
      if (dataWidth >= this.MinBarWidth)
      {
        bFillKLine = true;
        this.Canvas.fillStyle = this.Color;
        this.Canvas.strokeStyle = this.Color;
      } else
        //太细了 画竖线
        {
          this.Canvas.lineWidth = 1;
          this.Canvas.strokeStyle = this.Color;
        }
    } else
    if (this.LineWidth < 100)
    {
      var LineWidth = this.LineWidth;
      if (dataWidth <= 4) LineWidth = 1;else
      if (dataWidth < LineWidth) LineWidth = parseInt(dataWidth);
      this.Canvas.lineWidth = LineWidth;
      this.Canvas.strokeStyle = this.Color;
    } else

    {
      bFillBar = true;
      this.Canvas.fillStyle = this.Color;
      var fixedWidth = 2;
    }

    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth)
    {
      var value = this.Data.Data[i];
      if (value == null) continue;

      var price = value.Value;
      var price2 = value.Value2;
      if (price2 == null) price2 = 0;

      var x = this.ChartFrame.GetXFromIndex(j);
      var y = this.ChartFrame.GetYFromData(price);
      var y2 = this.ChartFrame.GetYFromData(price2);

      if (x > chartright) break;

      if (bFillBar)
      {
        var left = xOffset - fixedWidth;
        if (isHScreen)
        {
          this.Canvas.fillRect(Math.min(y, y2), left, Math.abs(y - y2), dataWidth + distanceWidth + fixedWidth * 2);
        } else

        {
          var barWidth = dataWidth + distanceWidth + fixedWidth * 2;
          if (left + barWidth > chartright) barWidth = chartright - left; //不要超过右边框子
          this.Canvas.fillRect(left, ToFixedRect(Math.min(y, y2)), barWidth, ToFixedRect(Math.abs(y - y2)));
        }
      } else
      if (bFillKLine)
      {
        if (this.BarType == 1) //实心
          {
            if (isHScreen)
            {
              this.Canvas.beginPath();
              this.Canvas.fillRect(ToFixedRect(Math.min(y, y2)), ToFixedRect(xOffset), ToFixedRect(Math.abs(y - y2)), ToFixedRect(dataWidth));
              this.Canvas.stroke();
            } else

            {
              this.Canvas.beginPath();
              this.Canvas.rect(ToFixedRect(xOffset), ToFixedRect(Math.min(y, y2)), ToFixedRect(dataWidth), ToFixedRect(Math.abs(y - y2)));
              this.Canvas.stroke();
            }
          } else

        {
          if (isHScreen)
          this.Canvas.fillRect(ToFixedRect(Math.min(y, y2)), ToFixedRect(xOffset), ToFixedRect(Math.abs(y - y2)), ToFixedRect(dataWidth));else

          this.Canvas.fillRect(ToFixedRect(xOffset), ToFixedRect(Math.min(y, y2)), ToFixedRect(dataWidth), ToFixedRect(Math.abs(y - y2)));
        }
      } else

      {
        if (isHScreen)
        {
          this.Canvas.beginPath();
          this.Canvas.moveTo(y, ToFixedPoint(x));
          this.Canvas.lineTo(y2, ToFixedPoint(x));
          this.Canvas.stroke();
        } else

        {
          var xFix = parseInt(x.toString()) + 0.5;
          this.Canvas.beginPath();
          this.Canvas.moveTo(xFix, y);
          this.Canvas.lineTo(xFix, y2);
          this.Canvas.stroke();
        }
      }
    }

    this.Canvas.restore();
  };

  this.GetMaxMin = function ()
  {
    var xPointCount = this.ChartFrame.XPointCount;
    var range = {};
    range.Min = null;
    range.Max = null;

    if (!this.Data || !this.Data.Data) return range;

    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j)
    {
      var data = this.Data.Data[i];
      if (data == null) continue;
      var value2 = data.Value2;
      if (value2 == null) value2 = 0;
      if (data == null || isNaN(data.Value) || isNaN(value2)) continue;

      var valueMax = Math.max(data.Value, value2);
      var valueMin = Math.min(data.Value, value2);

      if (range.Max == null) range.Max = valueMax;
      if (range.Min == null) range.Min = valueMin;

      if (range.Max < valueMax) range.Max = valueMax;
      if (range.Min > valueMin) range.Min = valueMin;
    }

    return range;
  };
}

//画矩形
function ChartRectangle()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = 'ChartRectangle';
  this.Color = [];
  this.Rect;
  this.BorderColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameBorderPen;

  this.Draw = function ()
  {
    if (!this.IsShow) return;
    if (!this.Color || !this.Rect) return;
    if (this.Color.length <= 0) return;

    this.Canvas.strokeStyle = this.BorderColor;
    var bFill = false;
    if (this.Color.length == 2)
    {
      /*  TODO 渐变下次做吧
      if (this.ColorAngle==0)
      {
          var ptStart={ X:this.ChartBorder.GetLeft(), Y:this.ChartBorder.GetTopEx() };
          var ptEnd={ X:this.ChartBorder.GetLeft(), Y:this.ChartBorder.GetBottomEx() };
      }
      else
      {
          var ptStart={ X:this.ChartBorder.GetLeft(), Y:this.ChartBorder.GetTopEx() };
          var ptEnd={ X:this.ChartBorder.GetRight(), Y:this.ChartBorder.GetTopEx() };
      }
        let gradient = this.Canvas.createLinearGradient(ptStart.X,ptStart.Y, ptEnd.X,ptEnd.Y);
      gradient.addColorStop(0, this.Color[0]);
      gradient.addColorStop(1, this.Color[1]);
      this.Canvas.fillStyle=gradient;
      */


      this.Canvas.fillStyle = this.Color[0];
      bFill = true;
    } else
    if (this.Color.length == 1)
    {
      if (this.Color[0])
      {
        this.Canvas.fillStyle = this.Color[0];
        bFill = true;
      }
    } else

    {
      return;
    }

    var chartWidth = this.ChartBorder.GetWidth();
    var chartHeight = this.ChartBorder.GetHeightEx();
    var left = this.Rect.Left / 1000 * chartWidth;
    var top = this.Rect.Top / 1000 * chartHeight;
    var right = this.Rect.Right / 1000 * chartWidth;
    var bottom = this.Rect.Bottom / 1000 * chartHeight;

    left = this.ChartBorder.GetLeft() + left;
    top = this.ChartBorder.GetTopEx() + top;
    right = this.ChartBorder.GetLeft() + right;
    bottom = this.ChartBorder.GetTopEx() + bottom;
    var width = Math.abs(left - right);
    var height = Math.abs(top - bottom);
    if (bFill) this.Canvas.fillRect(left, top, width, height);
    this.Canvas.rect(ToFixedPoint(left), ToFixedPoint(top), ToFixedRect(width), ToFixedRect(height));
    this.Canvas.stroke();
  };
}

//K线叠加
function ChartOverlayKLine()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.Color = "rgb(65,105,225)";
  this.MainData; //主图K线数据
  this.SourceData; //叠加的原始数据
  this.Name = "ChartOverlayKLine";
  this.Title;
  this.DrawType = 0;
  this.ClassName = 'ChartOverlayKLine';
  this.CustomDrawType = null; //图形类型

  this.SetOption = function (option)
  {
    if (!option) return;
    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(option.DrawType)) this.CustomDrawType = option.DrawType;
  };

  this.DrawKBar = function (firstOpen) //firstOpen 当前屏第1个显示数据
  {
    var isHScreen = this.ChartFrame.IsHScreen === true;
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var xOffset = this.ChartBorder.GetLeft() + distanceWidth / 2.0 + 2.0;
    if (isHScreen) xOffset = this.ChartBorder.GetTop() + distanceWidth / 2.0 + 2.0;
    var chartright = this.ChartBorder.GetRight();
    if (isHScreen) chartright = this.ChartBorder.GetBottom();
    var xPointCount = this.ChartFrame.XPointCount;

    var isFristDraw = true;
    var firstOverlayOpen = null;

    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth)
    {
      var data = this.Data.Data[i];
      if (!data || data.Open == null || data.High == null || data.Low == null || data.Close == null) continue;

      if (firstOverlayOpen == null) firstOverlayOpen = data.Open;

      if (isFristDraw)
      {
        this.Canvas.strokeStyle = this.Color;
        this.Canvas.fillStyle = this.Color;
        this.Canvas.beginPath();
        isFristDraw = false;
      }

      var left = xOffset;
      var right = xOffset + dataWidth;
      if (right > chartright) break;
      var x = left + (right - left) / 2;
      var yLow = this.ChartFrame.GetYFromData(data.Low / firstOverlayOpen * firstOpen);
      var yHigh = this.ChartFrame.GetYFromData(data.High / firstOverlayOpen * firstOpen);
      var yOpen = this.ChartFrame.GetYFromData(data.Open / firstOverlayOpen * firstOpen);
      var yClose = this.ChartFrame.GetYFromData(data.Close / firstOverlayOpen * firstOpen);
      var y = yHigh;

      if (data.Open < data.Close) //阳线
        {
          if (dataWidth >= 4)
          {
            if (data.High > data.Close) //上影线
              {
                if (isHScreen)
                {
                  this.Canvas.moveTo(ToFixedPoint(y), ToFixedPoint(x));
                  this.Canvas.lineTo(ToFixedPoint(this.DrawType == 3 ? Math.max(yClose, yOpen) : yClose), ToFixedPoint(x));
                } else

                {
                  this.Canvas.moveTo(ToFixedPoint(x), ToFixedPoint(y));
                  this.Canvas.lineTo(ToFixedPoint(x), ToFixedPoint(this.DrawType == 3 ? Math.min(yClose, yOpen) : yClose));
                }
                y = yClose;
              } else

            {
              y = yClose;
            }

            if (isHScreen) {
              if (Math.abs(yOpen - y) < 1)
              {
                this.Canvas.fillRect(ToFixedRect(y), ToFixedRect(left), 1, ToFixedRect(dataWidth)); //高度小于1,统一使用高度1
              } else

              {
                if (this.DrawType == 3) this.Canvas.rect(ToFixedPoint(y), ToFixedPoint(left), ToFixedRect(yOpen - y), ToFixedRect(dataWidth)); //空心柱
                else this.Canvas.fillRect(ToFixedRect(y), ToFixedRect(left), ToFixedRect(yOpen - y), ToFixedRect(dataWidth));
              }
            } else

            {
              if (Math.abs(yOpen - y) < 1)
              {
                this.Canvas.fillRect(ToFixedRect(left), ToFixedRect(y), ToFixedRect(dataWidth), 1); //高度小于1,统一使用高度1
              } else

              {
                if (this.DrawType == 3) this.Canvas.rect(ToFixedPoint(left), ToFixedPoint(y), ToFixedRect(dataWidth), ToFixedRect(yOpen - y)); //空心柱
                else this.Canvas.fillRect(ToFixedRect(left), ToFixedRect(y), ToFixedRect(dataWidth), ToFixedRect(yOpen - y));
              }
            }

            if (data.Open > data.Low)
            {
              if (isHScreen)
              {
                this.Canvas.moveTo(ToFixedPoint(this.DrawType == 3 ? Math.min(yClose, yOpen) : y), ToFixedPoint(x));
                this.Canvas.lineTo(ToFixedPoint(yLow), ToFixedPoint(x));
              } else

              {
                this.Canvas.moveTo(ToFixedPoint(x), ToFixedPoint(this.DrawType == 3 ? Math.max(yClose, yOpen) : y));
                this.Canvas.lineTo(ToFixedPoint(x), ToFixedPoint(yLow));
              }
            }
          } else

          {
            if (isHScreen)
            {
              this.Canvas.moveTo(yHigh, ToFixedPoint(x));
              this.Canvas.lineTo(yLow, ToFixedPoint(x));
            } else

            {
              this.Canvas.moveTo(ToFixedPoint(x), yHigh);
              this.Canvas.lineTo(ToFixedPoint(x), yLow);
            }
          }
        } else
      if (data.Open > data.Close) //阴线
        {
          if (dataWidth >= 4)
          {
            if (data.High > data.Close) //上影线
              {
                if (isHScreen)
                {
                  this.Canvas.moveTo(ToFixedPoint(y), ToFixedPoint(x));
                  this.Canvas.lineTo(ToFixedPoint(yOpen), ToFixedPoint(x));
                } else

                {
                  this.Canvas.moveTo(ToFixedPoint(x), ToFixedPoint(y));
                  this.Canvas.lineTo(ToFixedPoint(x), ToFixedPoint(yOpen));
                }
                y = yOpen;
              } else

            {
              y = yOpen;
            }

            if (isHScreen)
            {
              if (Math.abs(yClose - y) < 1) this.Canvas.fillRect(ToFixedRect(y), ToFixedRect(left), 1, ToFixedRect(dataWidth)); //高度小于1,统一使用高度1
              else this.Canvas.fillRect(ToFixedRect(y), ToFixedRect(left), ToFixedRect(yClose - y), ToFixedRect(dataWidth));
            } else

            {
              if (Math.abs(yClose - y) < 1) this.Canvas.fillRect(ToFixedRect(left), ToFixedRect(y), ToFixedRect(dataWidth), 1); //高度小于1,统一使用高度1
              else this.Canvas.fillRect(ToFixedRect(left), ToFixedRect(y), ToFixedRect(dataWidth), ToFixedRect(yClose - y));
            }

            if (data.Open > data.Low) //下影线
              {
                if (isHScreen)
                {
                  this.Canvas.moveTo(ToFixedPoint(y), ToFixedPoint(x));
                  this.Canvas.lineTo(ToFixedPoint(yLow), ToFixedPoint(x));
                } else

                {
                  this.Canvas.moveTo(ToFixedPoint(x), ToFixedPoint(y));
                  this.Canvas.lineTo(ToFixedPoint(x), ToFixedPoint(yLow));
                }
              }
          } else

          {
            if (isHScreen)
            {
              this.Canvas.moveTo(yHigh, ToFixedPoint(x));
              this.Canvas.lineTo(yLow, ToFixedPoint(x));
            } else

            {
              this.Canvas.moveTo(ToFixedPoint(x), yHigh);
              this.Canvas.lineTo(ToFixedPoint(x), yLow);
            }
          }
        } else
        // 平线
        {
          if (dataWidth >= 4)
          {
            if (data.High > data.Close) //上影线
              {
                if (isHScreen)
                {
                  this.Canvas.moveTo(y, ToFixedPoint(x));
                  this.Canvas.lineTo(yOpen, ToFixedPoint(x));
                } else

                {
                  this.Canvas.moveTo(ToFixedPoint(x), y);
                  this.Canvas.lineTo(ToFixedPoint(x), yOpen);
                }

                y = yOpen;
              } else

            {
              y = yOpen;
            }

            if (isHScreen)
            {
              this.Canvas.moveTo(ToFixedPoint(y), ToFixedPoint(left));
              this.Canvas.lineTo(ToFixedPoint(y), ToFixedPoint(right));
            } else

            {
              this.Canvas.moveTo(ToFixedPoint(left), ToFixedPoint(y));
              this.Canvas.lineTo(ToFixedPoint(right), ToFixedPoint(y));
            }

            if (data.Open > data.Low) //下影线
              {
                if (isHScreen)
                {
                  this.Canvas.moveTo(ToFixedPoint(y), ToFixedPoint(x));
                  this.Canvas.lineTo(ToFixedPoint(yLow), ToFixedPoint(x));
                } else

                {
                  this.Canvas.moveTo(ToFixedPoint(x), ToFixedPoint(y));
                  this.Canvas.lineTo(ToFixedPoint(x), ToFixedPoint(yLow));
                }
              }
          } else

          {
            if (isHScreen)
            {
              this.Canvas.moveTo(yHigh, ToFixedPoint(x));
              this.Canvas.lineTo(yLow, ToFixedPoint(x));
            } else

            {
              this.Canvas.moveTo(ToFixedPoint(x), yHigh);
              this.Canvas.lineTo(ToFixedPoint(x), yLow);
            }
          }
        }

    }

    if (isFristDraw == false) this.Canvas.stroke();
  };

  this.DrawAKLine = function (firstOpen) //美国线
  {
    var isHScreen = this.ChartFrame.IsHScreen === true;
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var xOffset = this.ChartBorder.GetLeft() + distanceWidth / 2.0 + 2.0;
    if (isHScreen) xOffset = this.ChartBorder.GetTop() + distanceWidth / 2.0 + 2.0;
    var chartright = this.ChartBorder.GetRight();
    if (isHScreen) chartright = this.ChartBorder.GetBottom();
    var xPointCount = this.ChartFrame.XPointCount;

    var firstOverlayOpen = null;
    this.Canvas.strokeStyle = this.Color;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth)
    {
      var data = this.Data.Data[i];
      if (data.Open == null || data.High == null || data.Low == null || data.Close == null) continue;

      if (firstOverlayOpen == null) firstOverlayOpen = data.Open;
      var left = xOffset;
      var right = xOffset + dataWidth;
      if (right > chartright) break;
      var x = left + (right - left) / 2;
      var yLow = this.ChartFrame.GetYFromData(data.Low / firstOverlayOpen * firstOpen);
      var yHigh = this.ChartFrame.GetYFromData(data.High / firstOverlayOpen * firstOpen);
      var yOpen = this.ChartFrame.GetYFromData(data.Open / firstOverlayOpen * firstOpen);
      var yClose = this.ChartFrame.GetYFromData(data.Close / firstOverlayOpen * firstOpen);

      this.Canvas.beginPath(); //最高-最低
      if (isHScreen)
      {
        this.Canvas.moveTo(yHigh, ToFixedPoint(x));
        this.Canvas.lineTo(yLow, ToFixedPoint(x));
      } else

      {
        this.Canvas.moveTo(ToFixedPoint(x), yHigh);
        this.Canvas.lineTo(ToFixedPoint(x), yLow);
      }

      this.Canvas.stroke();

      if (dataWidth >= 4)
      {
        this.Canvas.beginPath(); //开盘
        if (isHScreen)
        {
          this.Canvas.moveTo(ToFixedPoint(yOpen), left);
          this.Canvas.lineTo(ToFixedPoint(yOpen), x);
        } else

        {
          this.Canvas.moveTo(left, ToFixedPoint(yOpen));
          this.Canvas.lineTo(x, ToFixedPoint(yOpen));
        }
        this.Canvas.stroke();

        this.Canvas.beginPath(); //收盘
        if (isHScreen)
        {
          this.Canvas.moveTo(ToFixedPoint(yClose), right);
          this.Canvas.lineTo(ToFixedPoint(yClose), x);
        } else

        {
          this.Canvas.moveTo(right, ToFixedPoint(yClose));
          this.Canvas.lineTo(x, ToFixedPoint(yClose));
        }
        this.Canvas.stroke();
      }
    }

  };

  this.DrawCloseLine = function (firstOpen) //收盘价线
  {
    var isHScreen = this.ChartFrame.IsHScreen === true;
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var xOffset = this.ChartBorder.GetLeft() + distanceWidth / 2.0 + 2.0;
    if (isHScreen) xOffset = this.ChartBorder.GetTop() + distanceWidth / 2.0 + 2.0;
    var chartright = this.ChartBorder.GetRight();
    if (isHScreen) chartright = this.ChartBorder.GetBottom();
    var xPointCount = this.ChartFrame.XPointCount;

    var firstOverlayOpen = null;
    var bFirstPoint = true;
    this.Canvas.strokeStyle = this.Color;
    this.Canvas.beginPath();
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth)
    {
      var data = this.Data.Data[i];
      if (data.Open == null || data.High == null || data.Low == null || data.Close == null) continue;

      if (firstOverlayOpen == null) firstOverlayOpen = data.Open;
      var left = xOffset;
      var right = xOffset + dataWidth;
      if (right > chartright) break;
      var x = left + (right - left) / 2;
      var yClose = this.ChartFrame.GetYFromData(data.Close / firstOverlayOpen * firstOpen);

      if (bFirstPoint)
      {
        if (isHScreen) this.Canvas.moveTo(yClose, x);else
        this.Canvas.moveTo(x, yClose);
        bFirstPoint = false;
      } else

      {
        if (isHScreen) this.Canvas.lineTo(yClose, x);else
        this.Canvas.lineTo(x, yClose);
      }
    }

    if (bFirstPoint == false) this.Canvas.stroke();
  };

  this.Draw = function ()
  {
    this.TooltipRect = [];
    if (!this.MainData || !this.Data) return;

    var xPointCount = this.ChartFrame.XPointCount;
    var firstOpen = null; //主线数据第1个开盘价
    for (var i = this.Data.DataOffset, j = 0; i < this.MainData.Data.length && j < xPointCount; ++i, ++j)
    {
      var data = this.MainData.Data[i];
      if (data.Open == null || data.High == null || data.Low == null || data.Close == null) continue;
      firstOpen = data.Open;
      break;
    }

    if (firstOpen == null) return;

    var drawTypeBackup = this.DrawType; //备份下线段类型
    if (this.CustomDrawType != null) this.DrawType = this.CustomDrawType;

    if (this.DrawType == 1) this.DrawCloseLine(firstOpen);else
    if (this.DrawType == 2) this.DrawAKLine(firstOpen);else
    this.DrawKBar(firstOpen);

    this.DrawType = drawTypeBackup; //还原线段类型
  };

  this.GetMaxMin = function ()
  {
    var xPointCount = this.ChartFrame.XPointCount;
    var range = {};
    range.Max = null;
    range.Min = null;

    if (!this.MainData || !this.Data) return range;

    var firstOpen = null; //主线数据第1个收盘价
    for (var i = this.Data.DataOffset, j = 0; i < this.MainData.Data.length && j < xPointCount; ++i, ++j)
    {
      var data = this.MainData.Data[i];
      if (data.Open == null || data.High == null || data.Low == null || data.Close == null) continue;
      firstOpen = data.Close;
      break;
    }

    if (firstOpen == null) return range;

    var firstOverlayOpen = null;
    var high, low;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j)
    {
      var data = this.Data.Data[i];
      if (!data || data.Open == null || data.High == null || data.Low == null || data.Close == null) continue;
      if (firstOverlayOpen == null) firstOverlayOpen = data.Open;

      high = data.High / firstOverlayOpen * firstOpen;
      low = data.Low / firstOverlayOpen * firstOpen;
      if (range.Max == null) range.Max = high;
      if (range.Min == null) range.Min = low;

      if (range.Max < high) range.Max = high;
      if (range.Min > low) range.Min = low;
    }

    return range;
  };
}

// 多文本集合  支持横屏
function ChartMultiText()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = 'ChartMultiText';
  this.Texts = []; //[ {Index:, Value:, Text:, Color:, Font: , Baseline:, Line:{ Color:, Dash:[虚线点], KData:"H/L", Offset:[5,10], Width:线粗细 } } ]
  this.Font = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DefaultTextFont;
  this.Color = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DefaultTextColor;
  this.IsHScreen = false; //是否横屏

  this.Draw = function ()
  {
    if (!this.IsShow) return;
    if (!this.Data || this.Data.length <= 0) return;
    if (!this.Texts) return;

    this.IsHScreen = this.ChartFrame.IsHScreen === true;
    var xPointCount = this.ChartFrame.XPointCount;
    var offset = this.Data.DataOffset;
    var left = this.ChartBorder.GetLeft();
    var right = this.ChartBorder.GetRight();

    if (this.IsHScreen)
    {
      left = this.ChartBorder.GetTop();
      right = this.ChartBorder.GetBottom();
    }

    for (var i in this.Texts)
    {
      var item = this.Texts[i];
      if (!item.Text) continue;
      if (!_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Index)) continue;

      var index = item.Index - offset;
      if (index >= 0 && index < xPointCount)
      {
        var x = this.ChartFrame.GetXFromIndex(index);
        var y = this.ChartFrame.GetYFromData(item.Value);

        if (item.Color) this.Canvas.fillStyle = item.Color;else
        this.Canvas.fillStyle = this.Color;
        if (item.Font) this.Canvas.font = item.Font;else
        this.Canvas.font = this.Font;

        var textWidth = this.Canvas.measureText(item.Text).width;
        this.Canvas.textAlign = 'center';
        if (x + textWidth / 2 >= right)
        {
          this.Canvas.textAlign = 'right';
          x = right;
        } else
        if (x - textWidth / 2 < left)
        {
          this.Canvas.textAlign = 'left';
          x = left;
        }
        if (item.Baseline == 1) this.Canvas.textBaseline = 'top';else
        if (item.Baseline == 2) this.Canvas.textBaseline = 'bottom';else
        this.Canvas.textBaseline = 'middle';
        if (this.IsHScreen) //横屏旋转
          {
            this.Canvas.save();
            this.Canvas.translate(y, x);
            this.Canvas.rotate(90 * Math.PI / 180);
            this.Canvas.fillText(item.Text, 0, 0);
            this.Canvas.restore();
          } else

        {
          this.Canvas.fillText(item.Text, x, y);
        }

        if (item.Line)
        {
          var kItem = this.Data.Data[item.Index];
          var price = item.Line.KData == "H" ? kItem.High : kItem.Low;
          var yPrice = this.ChartFrame.GetYFromData(price);
          var yText = y;
          if (Array.isArray(item.Line.Offset) && item.Line.Offset.length == 2)
          {
            if (yText > yPrice) //文字在下方
              {
                yText -= item.Line.Offset[1];
                yPrice += item.Line.Offset[0];
              } else
            if (yText < yPrice)
            {
              yText += item.Line.Offset[1];
              yPrice -= item.Line.Offset[0];
            }
          }
          this.Canvas.save();
          if (item.Line.Dash) this.Canvas.setLineDash(item.Line.Dash); //虚线
          if (item.Line.Width > 0) this.Canvas.lineWidth = item.Line.Width; //线宽
          this.Canvas.strokeStyle = item.Line.Color;
          this.Canvas.beginPath();
          if (this.IsHScreen)
          {
            this.Canvas.moveTo(yText, ToFixedPoint(x));
            this.Canvas.lineTo(yPrice, ToFixedPoint(x));
          } else

          {
            this.Canvas.moveTo(ToFixedPoint(x), yText);
            this.Canvas.lineTo(ToFixedPoint(x), yPrice);
          }
          this.Canvas.stroke();
          this.Canvas.restore();
        }
      }
    }
  };

  this.GetMaxMin = function ()
  {
    var range = { Min: null, Max: null };
    if (!this.Texts) return range;

    var xPointCount = this.ChartFrame.XPointCount;
    var start = this.Data.DataOffset;
    var end = start + xPointCount;

    for (var i in this.Texts)
    {
      var item = this.Texts[i];
      if (item.Index >= start && item.Index < end)
      {
        if (range.Max == null) range.Max = item.Value;else
        if (range.Max < item.Value) range.Max = item.Value;
        if (range.Min == null) range.Min = item.Value;else
        if (range.Min > item.Value) range.Min = item.Value;
      }
    }

    return range;
  };
}

// 多dom节点
function ChartMultiHtmlDom()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = "ChartMultiHtmlDom";
  this.Texts = []; //[ {Index:, Value:, Text: ] Text=dom内容
  this.IsHScreen = false; //是否横屏
  this.DrawCallback; //function(op, obj)  op:1=开始 2=结束 3=绘制单个数据
  this.DrawItem = [];

  this.Draw = function ()
  {
    this.DrawItem = [];
    if (this.DrawCallback) this.DrawCallback(1, { Self: this });

    this.DrawDom();

    if (this.DrawCallback) this.DrawCallback(2, { Self: this, Draw: this.DrawItem });
  };

  this.DrawDom = function ()
  {
    if (!this.IsShow) return;
    if (!this.Data || this.Data.length <= 0) return;

    this.IsHScreen = this.ChartFrame.IsHScreen === true;
    var xPointCount = this.ChartFrame.XPointCount;
    var offset = this.Data.DataOffset;

    for (var i in this.Texts)
    {
      var item = this.Texts[i];

      if (!item.Text) continue;
      if (!_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Index)) continue;

      var index = item.Index - offset;
      var kItem = this.Data.Data[item.Index]; //K线数据
      var obj = { KData: kItem, Item: item, IsShow: false, Self: this };
      if (index >= 0 && index < xPointCount)
      {
        var x = this.ChartFrame.GetXFromIndex(index);
        var y = this.ChartFrame.GetYFromData(item.Value);

        obj.X = x;
        obj.Y = y;
        obj.IsShow = true;
      }

      this.DrawItem.push(obj);

      if (this.DrawCallback) this.DrawCallback(3, obj);
    }
  };

  this.GetMaxMin = function ()
  {
    var range = { Min: null, Max: null };
    var xPointCount = this.ChartFrame.XPointCount;
    var start = this.Data.DataOffset;
    var end = start + xPointCount;

    for (var i in this.Texts)
    {
      var item = this.Texts[i];
      if (!_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Index)) continue;
      if (item.Index >= start && item.Index < end)
      {
        if (range.Max == null) range.Max = item.Value;else
        if (range.Max < item.Value) range.Max = item.Value;
        if (range.Min == null) range.Min = item.Value;else
        if (range.Min > item.Value) range.Min = item.Value;
      }
    }

    return range;
  };
}

// 线段集合  支持横屏
function ChartMultiLine()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.Lines = []; // [ {Point:[ {Index, Value }, ], Color: }, ] 
  this.IsHScreen = false;

  this.Draw = function ()
  {
    if (!this.IsShow) return;
    if (!this.Data || this.Data.length <= 0) return;

    this.IsHScreen = this.ChartFrame.IsHScreen === true;
    var xPointCount = this.ChartFrame.XPointCount;
    var offset = this.Data.DataOffset;

    var drawLines = [];
    for (var i in this.Lines)
    {
      var line = this.Lines[i];
      var drawPoints = { Point: [], Color: line.Color };
      for (var j in line.Point)
      {
        var point = line.Point[j];
        if (!_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(point.Index)) continue;

        var index = point.Index - offset;
        if (index >= 0 && index < xPointCount)
        {
          var x = this.ChartFrame.GetXFromIndex(index);
          var y = this.ChartFrame.GetYFromData(point.Value);
          drawPoints.Point.push({ X: x, Y: y });
        }
      }

      if (drawPoints.Point.length >= 2) drawLines.push(drawPoints);
    }

    for (var i in drawLines)
    {
      var item = drawLines[i];
      this.DrawLine(item);
    }
  };

  this.DrawLine = function (line)
  {
    this.Canvas.strokeStyle = line.Color;
    for (var i in line.Point)
    {
      var item = line.Point[i];
      if (i == 0)
      {
        this.Canvas.beginPath();
        if (this.IsHScreen) this.Canvas.moveTo(item.Y, item.X);else
        this.Canvas.moveTo(item.X, item.Y);
      } else

      {
        if (this.IsHScreen) this.Canvas.lineTo(item.Y, item.X);else
        this.Canvas.lineTo(item.X, item.Y);
      }
    }
    this.Canvas.stroke();
  };

  this.GetMaxMin = function ()
  {
    var range = { Min: null, Max: null };
    var xPointCount = this.ChartFrame.XPointCount;
    var start = this.Data.DataOffset;
    var end = start + xPointCount;

    for (var i in this.Lines)
    {
      var line = this.Lines[i];
      for (var j in line.Point)
      {
        var point = line.Point[j];
        if (point.Index >= start && point.Index < end)
        {
          if (range.Max == null) range.Max = point.Value;else
          if (range.Max < point.Value) range.Max = point.Value;
          if (range.Min == null) range.Min = point.Value;else
          if (range.Min > point.Value) range.Min = point.Value;
        }
      }
    }

    return range;
  };
}

// 柱子集合  支持横屏
function ChartMultiBar()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.Bars = []; // [ {Point:[ {Index, Value, Value2 }, ], Color:, Width: , Type: 0 实心 1 空心 }, ] 
  this.IsHScreen = false;

  this.Draw = function ()
  {
    if (!this.IsShow) return;
    if (!this.Data || this.Data.length <= 0) return;

    this.IsHScreen = this.ChartFrame.IsHScreen === true;
    var xPointCount = this.ChartFrame.XPointCount;
    var offset = this.Data.DataOffset;
    var dataWidth = this.ChartFrame.DataWidth;

    var drawBars = [];
    for (var i in this.Bars)
    {
      var item = this.Bars[i];
      var drawPoints = { Point: [], Color: item.Color, Width: dataWidth, Type: 0 };
      if (item.Type > 0) drawPoints.Type = item.Type;
      if (item.Width > 0)
      {
        drawPoints.Width = item.Width;
        if (drawPoints.Width > dataWidth) drawPoints.Width = dataWidth;
      } else

      {
        if (drawPoints.Width < 4) drawPoints.Width = 1;
      }

      for (var j in item.Point)
      {
        var point = item.Point[j];
        if (!_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(point.Index)) continue;

        var index = point.Index - offset;
        if (index >= 0 && index < xPointCount)
        {
          var x = this.ChartFrame.GetXFromIndex(index);
          var y = this.ChartFrame.GetYFromData(point.Value);
          var y2 = this.ChartFrame.GetYFromData(point.Value2);
          drawPoints.Point.push({ X: x, Y: y, Y2: y2 });
        }
      }

      if (drawPoints.Point.length > 0) drawBars.push(drawPoints);
    }

    for (var i in drawBars)
    {
      var item = drawBars[i];
      if (item.Width >= 4)
      {
        if (item.Type == 1) this.DrawHollowBar(item);else
        this.DrawFillBar(item);
      } else

      {
        this.DrawLineBar(item);
      }
    }
  };

  this.DrawLineBar = function (bar)
  {
    this.Canvas.strokeStyle = bar.Color;
    var backupLineWidth = this.Canvas.lineWidth;
    this.Canvas.lineWidth = bar.Width;
    for (var i in bar.Point)
    {
      var item = bar.Point[i];

      this.Canvas.beginPath();
      if (this.IsHScreen)
      {
        this.Canvas.moveTo(ToFixedPoint(item.Y), ToFixedPoint(item.X));
        this.Canvas.lineTo(ToFixedPoint(item.Y2), ToFixedPoint(item.X));
      } else

      {
        this.Canvas.moveTo(ToFixedPoint(item.X), ToFixedPoint(item.Y));
        this.Canvas.lineTo(ToFixedPoint(item.X), ToFixedPoint(item.Y2));
      }

      this.Canvas.stroke();
    }

    this.Canvas.lineWidth = backupLineWidth;
  };

  this.DrawFillBar = function (bar)
  {
    this.Canvas.fillStyle = bar.Color;
    for (var i in bar.Point)
    {
      var item = bar.Point[i];
      var x = item.X - bar.Width / 2;
      var y = Math.min(item.Y, item.Y2);
      var barWidth = bar.Width;
      var barHeight = Math.abs(item.Y - item.Y2);
      if (this.IsHScreen)
      this.Canvas.fillRect(ToFixedRect(y), ToFixedRect(x), ToFixedRect(barHeight), ToFixedRect(barWidth));else

      this.Canvas.fillRect(ToFixedRect(x), ToFixedRect(y), ToFixedRect(barWidth), ToFixedRect(barHeight));
    }
  };

  this.DrawHollowBar = function (bar) //空心柱子
  {
    this.Canvas.strokeStyle = bar.Color;
    var backupLineWidth = 1;
    for (var i in bar.Point)
    {
      var item = bar.Point[i];
      var x = item.X - bar.Width / 2;
      var y = Math.min(item.Y, item.Y2);
      var barWidth = bar.Width;
      var barHeight = Math.abs(item.Y - item.Y2);
      this.Canvas.beginPath();
      if (this.IsHScreen)
      this.Canvas.rect(ToFixedPoint(y), ToFixedPoint(x), ToFixedRect(barHeight), ToFixedRect(barWidth));else

      this.Canvas.rect(ToFixedPoint(x), ToFixedPoint(y), ToFixedRect(barWidth), ToFixedRect(barHeight));

      this.Canvas.stroke();
    }

    this.Canvas.lineWidth = backupLineWidth;
  };

  this.GetMaxMin = function ()
  {
    var range = { Min: null, Max: null };
    var xPointCount = this.ChartFrame.XPointCount;
    var start = this.Data.DataOffset;
    var end = start + xPointCount;
    for (var i in this.Bars)
    {
      var item = this.Bars[i];
      for (var j in item.Point)
      {
        var point = item.Point[j];
        if (point.Index >= start && point.Index < end)
        {
          var minValue = Math.min(point.Value, point.Value2);
          var maxValue = Math.max(point.Value, point.Value2);
          if (range.Max == null) range.Max = maxValue;else
          if (range.Max < maxValue) range.Max = maxValue;
          if (range.Min == null) range.Min = minValue;else
          if (range.Min > minValue) range.Min = minValue;
        }
      }
    }

    return range;
  };
}

//分钟信息地雷 支持横屏
function ChartMinuteInfo()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = "ChartMinuteInfo";
  this.Data = new Map(); //Map key=date-time, value=[{Date, Time, Title, Type, ID:}]
  this.SourceData;
  this.ChartMinutePrice;
  this.YClose;

  this.TextColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.MinuteInfo.TextColor;
  this.Font = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.MinuteInfo.Font;
  this.PointColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.MinuteInfo.PointColor;
  this.LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.MinuteInfo.LineColor;
  this.TextBGColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.MinuteInfo.TextBGColor;
  this.TextHeight = 18;

  this.TextRectCache = [];
  this.InfoDrawCache = [];
  this.FrameBottom;
  this.FrameTop;
  this.FrameLeft;
  this.FrameRight;
  this.YOffset = 5;
  this.IsHScreen = false;

  this.SetOption = function (option)
  {
    if (option.TextColor) this.TextColor = option.TextColor;
    if (option.TextBGColor) this.TextBGColor = option.TextBGColor;
    if (option.Font) this.Font = option.Font;
    if (option.PointColor) this.PointColor = option.PointColor;
    if (option.LineColor) this.LineColor = option.LineColor;
    if (option.TextHeight > 0) this.TextHeight = option.TextHeight;
  };

  this.Draw = function ()
  {
    if (!this.ChartMinutePrice) return;
    if (!this.Data || this.Data.size <= 0) return;

    this.TextRectCache = [];
    this.InfoDrawCache = [];
    this.IsHScreen = this.ChartFrame.IsHScreen === true;

    var xPointCount = this.ChartFrame.XPointCount;
    var minuteCount = this.ChartFrame.MinuteCount;

    this.FrameBottom = this.ChartBorder.GetBottom();
    this.FrameTop = this.ChartBorder.GetTop();
    this.FrameLeft = this.ChartBorder.GetLeft();
    this.FrameRight = this.ChartBorder.GetRight();
    if (this.IsHScreen)
    {
      this.FrameRight = this.ChartBorder.GetBottom();
      this.FrameLeft = this.ChartBorder.GetTop();
      this.FrameBottom = this.ChartBorder.GetLeft();
      this.FrameTop = this.ChartBorder.GetRight();
    }

    this.YClose = this.ChartMinutePrice.YClose;

    var data = this.ChartMinutePrice.Data;
    var isBeforeData = false;
    if (this.ChartMinutePrice.SourceData)
    {
      data = this.ChartMinutePrice.SourceData;
      isBeforeData = true;
    }

    this.Canvas.font = this.Font;
    for (var i = data.DataOffset, j = 0; i < data.Data.length && j < xPointCount; ++i, ++j)
    {
      var item = this.SourceData.Data[i];
      if (isBeforeData && item.Before) continue;
      if (!item) continue;

      var dateTime = item.DateTime;
      if (!this.Data.has(dateTime)) continue;
      if (this.IsHScreen)
      this.CalcuateInfoHScreenPosition(this.Data.get(dateTime), j, item);else

      this.CalcuateInfoPosition(this.Data.get(dateTime), j, item);
    }

    for (var i in this.InfoDrawCache)
    {
      var item = this.InfoDrawCache[i];
      this.DrawInfoLines(item);
    }

    for (var i in this.InfoDrawCache)
    {
      var item = this.InfoDrawCache[i];
      this.DrawInfoText(item);
    }

    this.TextRectCache = [];
    this.InfoDrawCache = [];
  };

  this.CalcuateInfoPosition = function (infoItem, index, minuteItem)
  {
    if (!infoItem || !infoItem.Data || infoItem.Data.length <= 0) return;

    var showItem = infoItem.Data[0];
    var textWidth = this.Canvas.measureText(showItem.Title).width + 4;
    var textHeight = this.TextHeight;

    var x = this.ChartFrame.GetXFromIndex(index);
    var y = this.ChartFrame.GetYFromData(minuteItem.Close);
    x = ToFixedPoint(x);

    var isDrawLeft = x < this.FrameLeft + Math.abs(this.FrameLeft - this.FrameRight) / 2;

    var ARRAY_OFFSET = [2, 4, 3, 2, 3, 3, 2];
    var offset = textHeight + ARRAY_OFFSET[index % ARRAY_OFFSET.length];
    var yData =
    {
      Y:
      [
      { Value: y + (textHeight + this.YOffset), Offset: offset },
      { Value: y - (2 * textHeight + this.YOffset), Offset: -offset }] };



    if (minuteItem.Close < this.YClose)
    yData.Y = yData.Y.reverse();

    var rtBorder = { X: x, Y: null, Width: textWidth, Height: textHeight };
    if (!isDrawLeft) rtBorder.X -= rtBorder.Width;

    this.FixTextRect(rtBorder, yData);
    var InfoDrawItem = { Border: rtBorder, Start: { X: x, Y: y }, IsLeft: isDrawLeft, Title: showItem.Title };

    this.InfoDrawCache.push(InfoDrawItem);
    this.TextRectCache.push(rtBorder);
  };

  this.CalcuateInfoHScreenPosition = function (infoItem, index, minuteItem)
  {
    if (!infoItem || !infoItem.Data || infoItem.Data.length <= 0) return;

    var showItem = infoItem.Data[0];
    var textHeight = this.Canvas.measureText(showItem.Title).width + 4;
    var textWidth = this.TextHeight;

    var y = this.ChartFrame.GetXFromIndex(index);
    var x = this.ChartFrame.GetYFromData(minuteItem.Close);
    y = ToFixedPoint(y);

    var isDrawLeft = y < this.FrameLeft + Math.abs(this.FrameLeft - this.FrameRight) / 2;

    var ARRAY_OFFSET = [2, 4, 3, 2, 3, 3, 2];
    var offset = textWidth + ARRAY_OFFSET[index % ARRAY_OFFSET.length];
    var xData =
    {
      X:
      [
      { Value: x + (textWidth + this.YOffset), Offset: offset },
      { Value: x - (2 * textWidth + this.YOffset), Offset: -offset }] };



    if (minuteItem.Close > this.YClose)
    xData.X = xData.X.reverse();

    var rtBorder = { X: null, Y: y, Width: textWidth, Height: textHeight };
    if (!isDrawLeft) rtBorder.Y -= rtBorder.Height;

    this.FixHScreenTextRect(rtBorder, xData);
    var InfoDrawItem = { Border: rtBorder, Start: { X: x, Y: y }, IsLeft: isDrawLeft, Title: showItem.Title };

    this.InfoDrawCache.push(InfoDrawItem);
    this.TextRectCache.push(rtBorder);
  };

  this.DrawInfoLines = function (item)
  {
    var rtBorder = item.Border;
    var isDrawLeft = item.IsLeft;
    this.Canvas.strokeStyle = this.LineColor;
    this.Canvas.beginPath();
    this.Canvas.moveTo(item.Start.X, item.Start.Y);
    if (isDrawLeft)
    {
      this.Canvas.lineTo(rtBorder.X, rtBorder.Y);
    } else

    {
      if (this.IsHScreen) this.Canvas.lineTo(rtBorder.X, rtBorder.Y + rtBorder.Height);else
      this.Canvas.lineTo(rtBorder.X + rtBorder.Width, rtBorder.Y);
    }
    this.Canvas.stroke();

    this.Canvas.fillStyle = this.PointColor;
    this.Canvas.beginPath();
    this.Canvas.arc(item.Start.X, item.Start.Y, 5, 0, 2 * Math.PI);
    this.Canvas.closePath();
    this.Canvas.fill();
  };

  this.DrawInfoText = function (item)
  {
    var rtBorder = item.Border;
    var x = rtBorder.X,y = rtBorder.Y;
    this.Canvas.fillStyle = this.TextBGColor;
    this.Canvas.fillRect(x, y, rtBorder.Width, rtBorder.Height);

    this.Canvas.strokeStyle = this.LineColor;
    this.Canvas.beginPath();
    this.Canvas.rect(x, y, rtBorder.Width, rtBorder.Height);
    this.Canvas.stroke();

    if (this.IsHScreen)
    {
      this.Canvas.save();
      this.Canvas.translate(rtBorder.X, rtBorder.Y);
      this.Canvas.rotate(90 * Math.PI / 180);
      x = 0;y = 0;
    }

    this.Canvas.textAlign = 'left';
    this.Canvas.textBaseline = 'middle';
    this.Canvas.fillStyle = this.TextColor;
    this.Canvas.font = this.Font;
    if (this.IsHScreen) this.Canvas.fillText(item.Title, x + 2, y - rtBorder.Width / 2);else
    this.Canvas.fillText(item.Title, x + 2, y + rtBorder.Height / 2);

    if (this.IsHScreen) this.Canvas.restore();
  };

  this.FixTextRect = function (rect, yData)
  {
    for (var k in yData.Y)
    {
      var yItem = yData.Y[k];
      rect.Y = yItem.Value;

      var y;
      for (var j = 0; j < 10; ++j)
      {
        var isOverlap = false;
        for (var i in this.TextRectCache)
        {
          var item = this.TextRectCache[i];
          if (this.IsOverlap(item, rect))
          {
            isOverlap = true;
            break;
          }
        }

        if (isOverlap == false) return;

        y = rect.Y;
        y += yItem.Offset;
        if (y + rect.Height > this.FrameBottom || y < this.FrameTop) break;

        rect.Y = y;
      }
    }
  };

  this.FixHScreenTextRect = function (rect, xData)
  {
    for (var k in xData.X)
    {
      var xItem = xData.X[k];
      rect.X = xItem.Value;

      var x;
      for (var j = 0; j < 10; ++j)
      {
        var isOverlap = false;
        for (var i in this.TextRectCache)
        {
          var item = this.TextRectCache[i];
          if (this.IsOverlap(item, rect))
          {
            isOverlap = true;
            break;
          }
        }

        if (isOverlap == false) return;

        x = rect.X;
        x += xItem.Offset;
        if (x + rect.Width < this.FrameBottom || x > this.FrameTop) break;

        rect.X = x;
      }
    }
  };

  this.IsOverlap = function (rc1, rc2)
  {
    if (rc1.X + rc1.Width > rc2.X && rc2.X + rc2.Width > rc1.X && rc1.Y + rc1.Height > rc2.Y && rc2.Y + rc2.Height > rc1.Y)
    return true;else

    return false;
  };

  this.GetMaxMin = function ()
  {
    var range = { Min: null, Max: null };
    return range;
  };
}

//买卖盘
function ChartBuySell()
{
  this.newMethod = ChartSingleText; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = "ChartBuySell";
  this.TextFont = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.KLineTrain.Font; //"bold 14px arial";           //买卖信息字体
  this.LastDataIcon = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.KLineTrain.LastDataIcon; //{Color:'rgb(0,0,205)',Text:'↓'};
  this.BuyIcon = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.KLineTrain.BuyIcon; //{Color:'rgb(0,0,205)',Text:'B'};
  this.SellIcon = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.KLineTrain.SellIcon; //{Color:'rgb(0,0,205)',Text:'S'};
  this.BuySellData = new Map(); //Key=数据索引index Value:Data:[ { Op: 买/卖 0=buy 1=sell, Date:, Time, Price: Vol:}, ] 

  this.AddTradeItem = function (tradeItem)
  {
    if (this.BuySellData.has(tradeItem.Key))
    {
      var Trade = this.BuySellData.get(tradeItem.Key);
      Trade.Data.push(tradeItem);
    } else

    {
      this.BuySellData.set(tradeItem.Key, { Data: [tradeItem] });
    }
  };

  this.ClearTradeData = function ()
  {
    this.BuySellData = new Map();
  };

  this.Draw = function ()
  {
    if (!this.Data || !this.Data.Data) return;

    var isHScreen = this.ChartFrame.IsHScreen === true;
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var chartright = this.ChartBorder.GetRight();
    if (isHScreen === true) chartright = this.ChartBorder.GetBottom();
    var xPointCount = this.ChartFrame.XPointCount;

    var bottom = this.ChartBorder.GetBottomEx();
    var top = this.ChartBorder.GetTopEx();
    var height = this.ChartBorder.GetHeightEx();
    if (isHScreen)
    {
      top = this.ChartBorder.GetRightEx();
      bottom = this.ChartBorder.GetLeftEx();
      height = this.ChartBorder.GetWidthEx();
    }

    this.Canvas.font = this.TextFont;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j)
    {
      var value = this.Data.Data[i];
      if (value == null) continue;
      if (x > chartright) break;

      if (i == this.Data.Data.length - 1)
      {
        var x = this.ChartFrame.GetXFromIndex(j);
        var yHigh = this.ChartFrame.GetYFromData(value.High);
        if (this.LastDataIcon.Text)
        {
          this.Canvas.textAlign = 'center';
          this.Canvas.textBaseline = 'bottom';
          this.Canvas.fillStyle = this.LastDataIcon.Color;
          this.Canvas.font = this.TextFont;
          this.DrawText(this.LastDataIcon.Text, x, yHigh, isHScreen);
        } else

        {
          var obj =
          {
            X: x, Top: top, Bottom: bottom, Height: height,
            DataWidth: dataWidth, Color: this.LastDataIcon.Color, IsHScreen: isHScreen };

          this.DrawLastData(obj);
        }
      }

      var key = i;
      if (!this.BuySellData.has(key)) continue;

      var trade = this.BuySellData.get(key);
      var x = this.ChartFrame.GetXFromIndex(j);
      var yHigh = this.ChartFrame.GetYFromData(value.High);
      var yLow = this.ChartFrame.GetYFromData(value.Low);
      var drawInfo = [false, false]; //0=buy 1=sell
      for (var k in trade.Data)
      {
        if (drawInfo[0] == true && drawInfo[1] == true) break; //买卖图标只画一次

        var bsItem = trade.Data[k];
        if (bsItem.Op == 0 && drawInfo[0] == false) //买 标识在最低价上
          {
            this.Canvas.textAlign = 'center';
            this.Canvas.textBaseline = 'top';
            this.Canvas.fillStyle = this.BuyIcon.Color;
            this.DrawText(this.BuyIcon.Text, x, yLow, isHScreen);
            drawInfo[0] = true;
          } else
        if (bsItem.Op == 1 && drawInfo[1] == false) //卖 标识在最高价上
          {
            this.Canvas.textAlign = 'center';
            this.Canvas.textBaseline = 'bottom';
            this.Canvas.fillStyle = this.SellIcon.Color;
            this.DrawText(this.SellIcon.Text, x, yHigh, isHScreen);
            drawInfo[1] = true;
          }
      }
    }
  };

  this.DrawLastData = function (obj)
  {
    this.Canvas.fillStyle = obj.Color;

    var width = obj.DataWidth;
    if (this.LastDataIcon.Width >= 2 && this.LastDataIcon.Width < obj.DataWidth)
    width = this.LastDataIcon.Width;
    var left = obj.X - width / 2;

    if (obj.IsHScreen)
    {
      this.Canvas.fillRect(ToFixedRect(obj.Bottom), ToFixedRect(left), ToFixedRect(obj.Height), ToFixedRect(width));
    } else

    {
      var left = obj.X - width / 2;
      this.Canvas.fillRect(ToFixedRect(left), ToFixedRect(obj.Top), ToFixedRect(width), ToFixedRect(obj.Height));
    }
  };
}

//分钟成交量
function ChartMinuteVolumBar()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.UpColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.UpBarColor;
  this.DownColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DownBarColor;
  this.CustomColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Minute.VolBarColor;
  this.YClose; //前收盘

  this.Draw = function ()
  {
    var isHScreen = this.ChartFrame.IsHScreen === true;
    var chartright = this.ChartBorder.GetRight();
    if (isHScreen) chartright = this.ChartBorder.GetBottom();
    var xPointCount = this.ChartFrame.XPointCount;
    var yBottom = this.ChartFrame.GetYFromData(0);
    var yPrice = this.YClose; //上一分钟的价格

    if (this.CustomColor) this.Canvas.strokeStyle = this.CustomColor;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j)
    {
      var item = this.Data.Data[i];
      if (!item || !item.Vol) continue;

      var y = this.ChartFrame.GetYFromData(item.Vol);
      var x = this.ChartFrame.GetXFromIndex(i);
      if (x > chartright) break;
      //价格>=上一分钟价格 红色 否则绿色
      if (!this.CustomColor) this.Canvas.strokeStyle = item.Close >= yPrice ? this.UpColor : this.DownColor;
      this.Canvas.beginPath();
      if (isHScreen)
      {
        this.Canvas.moveTo(y, ToFixedPoint(x));
        this.Canvas.lineTo(yBottom, ToFixedPoint(x));
      } else

      {
        this.Canvas.moveTo(ToFixedPoint(x), y);
        this.Canvas.lineTo(ToFixedPoint(x), yBottom);
      }
      this.Canvas.stroke();
      yPrice = item.Close;
    }
  };

  this.GetMaxMin = function ()
  {
    var xPointCount = this.ChartFrame.XPointCount;
    var range = {};
    range.Min = 0;
    range.Max = null;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j)
    {
      var item = this.Data.Data[i];
      if (!item || !item.Vol) continue;
      if (range.Max == null) range.Max = item.Vol;
      if (range.Max < item.Vol) range.Max = item.Vol;
    }

    return range;
  };
}

//MACD森林线 支持横屏
function ChartMACD()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = 'ChartMACD';
  this.UpColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.UpBarColor;
  this.DownColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DownBarColor;
  this.LineWidth = 1;

  this.Draw = function ()
  {
    if (this.NotSupportMessage)
    {
      this.DrawNotSupportmessage();
      return;
    }

    if (this.ChartFrame.IsHScreen === true)
    {
      this.HScreenDraw();
      return;
    }

    var isMinute = this.IsMinuteFrame();
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var xOffset = this.ChartBorder.GetLeft() + distanceWidth / 2.0 + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLeftMargin;
    var chartright = this.ChartBorder.GetRight();
    var xPointCount = this.ChartFrame.XPointCount;

    var lineWidth = this.LineWidth;
    if (this.LineWidth == 50) lineWidth = dataWidth;else
    if (lineWidth > dataWidth) lineWidth = dataWidth;

    this.Canvas.save();
    this.Canvas.lineWidth = lineWidth;

    var bFirstPoint = true;
    var drawCount = 0;
    var yBottom = this.ChartFrame.GetYFromData(0);
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth)
    //for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j) 
    {
      var value = this.Data.Data[i];
      if (value == null) continue;

      if (isMinute)
      {
        var x = this.ChartFrame.GetXFromIndex(j);
      } else

      {
        var left = xOffset;
        var right = xOffset + dataWidth;
        if (right > chartright) break;
        var x = left + (right - left) / 2;
      }
      var y = this.ChartFrame.GetYFromData(value);

      if (x > chartright) break;

      var xFix = parseInt(x.toString()) + 0.5; //毛边修正
      this.Canvas.beginPath();
      this.Canvas.moveTo(xFix, yBottom);
      this.Canvas.lineTo(xFix, y);

      if (value >= 0) this.Canvas.strokeStyle = this.UpColor;else
      this.Canvas.strokeStyle = this.DownColor;
      this.Canvas.stroke();
      this.Canvas.closePath();
    }

    this.Canvas.restore();
  };

  this.HScreenDraw = function ()
  {
    var isMinute = this.IsMinuteFrame();
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var xOffset = this.ChartBorder.GetTop() + distanceWidth / 2.0 + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLeftMargin;
    var chartright = this.ChartBorder.GetBottom();
    var xPointCount = this.ChartFrame.XPointCount;
    var yBottom = this.ChartFrame.GetYFromData(0);

    var lineWidth = this.LineWidth;
    if (this.LineWidth == 50) lineWidth = dataWidth;else
    if (lineWidth > dataWidth) lineWidth = dataWidth;

    this.Canvas.save();
    this.Canvas.lineWidth = lineWidth;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth)
    //for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j) 
    {
      var value = this.Data.Data[i];
      if (value == null) continue;

      if (isMinute)
      {
        var x = this.ChartFrame.GetXFromIndex(j);
      } else

      {
        var left = xOffset;
        var right = xOffset + dataWidth;
        if (right > chartright) break;
        var x = left + (right - left) / 2;
      }
      var y = this.ChartFrame.GetYFromData(value);

      if (x > chartright) break;

      this.Canvas.beginPath();
      this.Canvas.moveTo(yBottom, ToFixedPoint(x));
      this.Canvas.lineTo(y, ToFixedPoint(x));

      if (value >= 0) this.Canvas.strokeStyle = this.UpColor;else
      this.Canvas.strokeStyle = this.DownColor;
      this.Canvas.stroke();
      this.Canvas.closePath();
    }

    this.Canvas.restore();
  };
}

////////////////////////////////////////////////////////////////////////////////
// 等待提示
function ChartSplashPaint()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.Font = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DefaultTextFont; //字体
  this.TextColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DefaultTextColor; //文本颜色
  this.IsEnableSplash = false;
  this.SplashTitle = '数据加载中.....';
  this.HQChart;

  this.EnableSplash = function (bEnable)
  {
    this.IsEnableSplash = bEnable;
    if (this.HQChart)
    {
      var event = this.HQChart.GetEnableSplashEvent();
      if (event)
      {
        var data = { Enable: bEnable };
        event.Callback(event, data, this);
      }
    }
  };

  this.SetTitle = function (title)
  {
    this.SplashTitle = title;
  };

  this.Draw = function ()
  {
    if (!this.IsEnableSplash) return;

    if (this.Frame.IsHScreen === true)
    {
      this.HScreenDraw();
      return;
    }

    var xCenter = (this.Frame.ChartBorder.GetLeft() + this.Frame.ChartBorder.GetRight()) / 2;
    var yCenter = (this.Frame.ChartBorder.GetTop() + this.Frame.ChartBorder.GetBottom()) / 2;
    this.Canvas.textAlign = 'center';
    this.Canvas.textBaseline = 'middle';
    this.Canvas.fillStyle = this.TextColor;
    this.Canvas.font = this.Font;
    this.Canvas.fillText(this.SplashTitle, xCenter, yCenter);
  };

  this.HScreenDraw = function () //横屏
  {
    var xCenter = (this.Frame.ChartBorder.GetLeft() + this.Frame.ChartBorder.GetRight()) / 2;
    var yCenter = (this.Frame.ChartBorder.GetTop() + this.Frame.ChartBorder.GetBottom()) / 2;

    this.Canvas.save();
    this.Canvas.translate(xCenter, yCenter);
    this.Canvas.rotate(90 * Math.PI / 180); //数据和框子旋转180度

    this.Canvas.textAlign = 'center';
    this.Canvas.textBaseline = 'middle';
    this.Canvas.fillStyle = this.TextColor;
    this.Canvas.font = this.Font;
    this.Canvas.fillText(this.SplashTitle, 0, 0);

    this.Canvas.restore();
  };
}

//填充背景 支持横屏
function ChartBackground()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = "ChartBackground";
  this.Color = null;
  this.ColorAngle = 0; //0 竖向 1 横向
  this.IsDrawFirst = true; //面积图在K线前面画,否则回挡住K线的
  this.IsHScreen = false;

  this.Draw = function ()
  {
    if (!this.IsShow) return;
    if (!this.Color) return;
    if (this.Color.length <= 0) return;
    this.IsHScreen = this.ChartFrame.IsHScreen === true;

    if (this.Color.length == 2)
    {
      if (this.IsHScreen)
      {
        if (this.ColorAngle == 0)
        {
          var ptStart = { X: this.ChartBorder.GetRight(), Y: this.ChartBorder.GetTopEx() };
          var ptEnd = { X: this.ChartBorder.GetLeft(), Y: this.ChartBorder.GetTopEx() };
        } else

        {
          var ptStart = { X: this.ChartBorder.GetLeft(), Y: this.ChartBorder.GetTopEx() };
          var ptEnd = { X: this.ChartBorder.GetLeft(), Y: this.ChartBorder.GetBottomEx() };
        }
      } else

      {
        if (this.ColorAngle == 0)
        {
          var ptStart = { X: this.ChartBorder.GetLeft(), Y: this.ChartBorder.GetTopEx() };
          var ptEnd = { X: this.ChartBorder.GetLeft(), Y: this.ChartBorder.GetBottomEx() };
        } else

        {
          var ptStart = { X: this.ChartBorder.GetLeft(), Y: this.ChartBorder.GetTopEx() };
          var ptEnd = { X: this.ChartBorder.GetRight(), Y: this.ChartBorder.GetTopEx() };
        }
      }

      var gradient = this.Canvas.createLinearGradient(ptStart.X, ptStart.Y, ptEnd.X, ptEnd.Y);
      gradient.addColorStop(0, this.Color[0]);
      gradient.addColorStop(1, this.Color[1]);
      this.Canvas.fillStyle = gradient;
    } else
    if (this.Color.length == 1)
    {
      this.Canvas.fillStyle = this.Color[0];
    } else

    {
      return;
    }

    if (this.Name == "DRAWGBK2" || this.Name == "KLINE_BG")
    {
      this.DrawRegion();
      return;
    }

    if (this.IsHScreen)
    {
      var left = this.ChartBorder.GetLeftEx();
      var top = this.ChartBorder.GetTop();
      var width = this.ChartBorder.GetWidthEx();
      var height = this.ChartBorder.GetHeight();
    } else

    {
      var left = this.ChartBorder.GetLeft();
      var top = this.ChartBorder.GetTopEx();
      var width = this.ChartBorder.GetWidth();
      var height = this.ChartBorder.GetHeightEx();
    }
    this.Canvas.fillRect(left, top, width, height);
  };

  this.DrawRegion = function ()
  {
    var xPointCount = this.ChartFrame.XPointCount;
    var xOffset = this.ChartBorder.GetLeft() + distanceWidth / 2.0 + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLeftMargin;
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var top = this.ChartBorder.GetTopEx();
    var bottom = this.ChartBorder.GetBottomEx();
    if (this.IsHScreen)
    {
      top = this.ChartBorder.GetRightEx();
      bottom = this.ChartBorder.GetLeftEx();
    }

    var aryPoint = []; //点坐标
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth)
    {
      var value = this.Data.Data[i];
      aryPoint[i] = null;
      if (!_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(value) || value <= 0) continue;

      var x = this.ChartFrame.GetXFromIndex(j);
      var y = this.ChartFrame.GetYFromData(value.Value);

      if (this.IsHScreen)
      aryPoint[i] = { Line: { X: bottom, Y: x }, Line2: { X: top, Y: x } };else

      aryPoint[i] = { Line: { X: x, Y: top }, Line2: { X: x, Y: bottom } };
    }

    this.DrawBG(aryPoint);
  };

  this.DrawBG = function (aryPoint)
  {
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var halfWidth = (distanceWidth + dataWidth) / 2;
    var firstPoint = true;
    var pointCount = 0;
    var aryLine2 = [];
    var color = null;
    for (var i in aryPoint)
    {
      var item = aryPoint[i];
      if (!item || color && item.Color != color)
      {
        if (pointCount > 0)
        {
          for (var j = aryLine2.length - 1; j >= 0; --j)
          {
            var item2 = aryLine2[j];
            if (this.IsHScreen)
            {
              this.Canvas.lineTo(item2.Line2.X, item2.Line2.Y + halfWidth);
              this.Canvas.lineTo(item2.Line2.X, item2.Line2.Y - halfWidth);
            } else

            {
              this.Canvas.lineTo(item2.Line2.X + halfWidth, item2.Line2.Y);
              this.Canvas.lineTo(item2.Line2.X - halfWidth, item2.Line2.Y);
            }
          }
          this.Canvas.closePath();
          this.Canvas.fill();
        }

        firstPoint = true;
        pointCount = 0;
        aryLine2 = [];
        color = null;
      }

      if (!item) continue;

      if (firstPoint)
      {
        this.Canvas.beginPath();
        if (this.IsHScreen)
        {
          this.Canvas.moveTo(item.Line.X, item.Line.Y - halfWidth);
          this.Canvas.lineTo(item.Line.X, item.Line.Y + halfWidth);
        } else

        {
          this.Canvas.moveTo(item.Line.X - halfWidth, item.Line.Y);
          this.Canvas.lineTo(item.Line.X + halfWidth, item.Line.Y);
        }
        firstPoint = false;
        color = item.Color;
      } else

      {
        if (this.IsHScreen)
        {
          this.Canvas.lineTo(item.Line.X, item.Line.Y - halfWidth);
          this.Canvas.lineTo(item.Line.X, item.Line.Y + halfWidth);
        } else

        {
          this.Canvas.lineTo(item.Line.X - halfWidth, item.Line.Y);
          this.Canvas.lineTo(item.Line.X + halfWidth, item.Line.Y);
        }
      }

      aryLine2.push(item);
      ++pointCount;
    }

    if (pointCount > 0)
    {
      for (var j = aryLine2.length - 1; j >= 0; --j)
      {
        var item2 = aryLine2[j];
        if (this.IsHScreen)
        {
          this.Canvas.lineTo(item2.Line2.X, item2.Line2.Y + halfWidth);
          this.Canvas.lineTo(item2.Line2.X, item2.Line2.Y - halfWidth);
        } else

        {
          this.Canvas.lineTo(item2.Line2.X + halfWidth, item2.Line2.Y);
          this.Canvas.lineTo(item2.Line2.X - halfWidth, item2.Line2.Y);
        }

      }
      this.Canvas.closePath();
      this.Canvas.fill();
    }
  };

  this.GetMaxMin = function ()
  {
    return { Min: null, Max: null };
  };
}

//锁  支持横屏
function ChartLock()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;
  this.WidthDiv = 0.2; // 框子宽度占比
  this.LockCount = 10; // 锁最新的几个数据
  this.BGColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.LockBGColor;
  this.TextColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.LockTextColor;
  this.Font = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DefaultTextFont;
  this.Title = '🔒开通权限';
  this.LockRect = null; //上锁区域
  this.LockID; //锁ID
  this.Callback; //回调
  this.IndexName; //指标名字

  this.Draw = function ()
  {
    this.LockRect = null;

    if (this.NotSupportMessage)
    {
      this.DrawNotSupportmessage();
      return;
    }

    if (this.ChartFrame.IsHScreen === true)
    {
      this.HScreenDraw();
      return;
    }

    var xOffset = this.ChartBorder.GetRight();
    var lOffsetWidth = 0;
    if (this.ChartFrame.Data != null)
    {
      var dataWidth = this.ChartFrame.DataWidth;
      var distanceWidth = this.ChartFrame.DistanceWidth;
      xOffset = this.ChartBorder.GetLeft() + distanceWidth / 2.0 + 2.0;
      var chartright = this.ChartBorder.GetRight();
      var xPointCount = this.ChartFrame.XPointCount;
      for (var i = this.ChartFrame.Data.DataOffset, j = 0; i < this.ChartFrame.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth)
      {
        var data = this.ChartFrame.Data.Data[i];
        if (data.Open == null || data.High == null || data.Low == null || data.Close == null) continue;

        var left = xOffset;
        var right = xOffset + dataWidth;
        if (right > chartright) break;
      }
      lOffsetWidth = (dataWidth + distanceWidth) * this.LockCount;
    }
    if (lOffsetWidth == 0)
    {
      lOffsetWidth = (xOffset - this.ChartBorder.GetLeft()) * this.WidthDiv;
    }
    var lLeft = xOffset - lOffsetWidth;
    if (lLeft < this.ChartBorder.GetLeft())
    lLeft = this.ChartBorder.GetLeft();
    var lHeight = this.ChartBorder.GetBottom() - this.ChartBorder.GetTop();
    var lWidth = this.ChartBorder.GetRight() - lLeft;
    this.Canvas.fillStyle = this.BGColor;
    this.Canvas.fillRect(lLeft, this.ChartBorder.GetTop(), lWidth, lHeight);
    var xCenter = lLeft + lWidth / 2;
    var yCenter = this.ChartBorder.GetTop() + lHeight / 2;
    this.Canvas.textAlign = 'center';
    this.Canvas.textBaseline = 'middle';
    this.Canvas.fillStyle = this.TextColor;
    this.Canvas.font = this.Font;
    this.Canvas.fillText(this.Title, xCenter, yCenter);

    this.LockRect = { Left: lLeft, Top: this.ChartBorder.GetTop(), Width: lWidth, Heigh: lHeight }; //保存上锁区域
  };

  this.HScreenDraw = function ()
  {
    var xOffset = this.ChartBorder.GetBottom();

    var lOffsetWidth = 0;

    if (this.ChartFrame.Data != null)
    {
      var dataWidth = this.ChartFrame.DataWidth;
      var distanceWidth = this.ChartFrame.DistanceWidth;
      xOffset = this.ChartBorder.GetTop() + distanceWidth / 2.0 + 2.0;
      var chartright = this.ChartBorder.GetBottom();
      var xPointCount = this.ChartFrame.XPointCount;
      //求最后1个数据的位置
      for (var i = this.ChartFrame.Data.DataOffset, j = 0; i < this.ChartFrame.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth)
      {
        var data = this.ChartFrame.Data.Data[i];
        if (data.Open == null || data.High == null || data.Low == null || data.Close == null) continue;

        var left = xOffset;
        var right = xOffset + dataWidth;
        if (right > chartright) break;
      }
      lOffsetWidth = (dataWidth + distanceWidth) * this.LockCount;
    }
    if (lOffsetWidth == 0)
    {
      lOffsetWidth = (xOffset - this.ChartBorder.GetTop()) * this.WidthDiv;
    }

    var lLeft = xOffset - lOffsetWidth;
    if (lLeft < this.ChartBorder.GetTop()) lLeft = this.ChartBorder.GetTop();
    var lHeight = this.ChartBorder.GetRight() - this.ChartBorder.GetLeft();
    var lWidth = this.ChartBorder.GetBottom() - lLeft;
    this.Canvas.fillStyle = this.BGColor;
    this.Canvas.fillRect(this.ChartBorder.GetLeft(), lLeft, lHeight, lWidth);

    var xCenter = this.ChartBorder.GetLeft() + lHeight / 2;
    var yCenter = lLeft + lWidth / 2;
    this.Canvas.save();
    this.Canvas.translate(xCenter, yCenter);
    this.Canvas.rotate(90 * Math.PI / 180);
    this.Canvas.textAlign = 'center';
    this.Canvas.textBaseline = 'middle';
    this.Canvas.fillStyle = this.TextColor;
    this.Canvas.font = this.Font;
    this.Canvas.fillText(this.Title, 0, 0);
    this.Canvas.restore();

    this.LockRect = { Left: this.ChartBorder.GetLeft(), Top: lLeft, Width: lHeight, Heigh: lWidth }; //保存上锁区域
  };

  //x,y是否在上锁区域
  this.GetTooltipData = function (x, y, tooltip)
  {
    if (this.LockRect == null) return false;

    if (this.IsPointInRect(x, y, this.LockRect.Left, this.LockRect.Top, this.LockRect.Width, this.LockRect.Heigh))
    {
      tooltip.Data = { ID: this.LockID, Callback: this.Callback, IndexName: this.IndexName };
      tooltip.ChartPaint = this;
      return true;
    }

    return false;
  };

  this.IsPointInRect = function (x, y, left, top, width, heigh)
  {
    if (x > left && x < left + width && y > top && y < top + heigh) return true;
    return false;
  };
}

//通达信语法 VOLSTICK 支持横屏
function ChartVolStick()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.UpColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.UpBarColor;
  this.DownColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DownBarColor;
  this.HistoryData; //历史数据
  this.KLineDrawType = 0;
  this.ClassName = 'ChartVolStick';
  this.MinBarWidth = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.MinKLineBarWidth; //最小的柱子宽度

  this.Draw = function ()
  {
    if (this.ChartFrame.IsHScreen === true)
    {
      this.HScreenDraw();
      return;
    }

    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var xOffset = this.ChartBorder.GetLeft() + distanceWidth / 2.0 + 2.0;
    var chartright = this.ChartBorder.GetRight();
    var xPointCount = this.ChartFrame.XPointCount;

    var yBottom = this.ChartFrame.GetYFromData(0);

    if (dataWidth >= this.MinBarWidth)
    {
      yBottom = ToFixedRect(yBottom);
      for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth)
      {
        var value = this.Data.Data[i];
        var kItem = this.HistoryData.Data[i];
        if (value == null || kItem == null) continue;

        var left = xOffset;
        var right = xOffset + dataWidth;
        if (right > chartright) break;

        var y = this.ChartFrame.GetYFromData(value);
        var bUp = false;
        if (kItem.Close >= kItem.Open)
        {
          this.Canvas.fillStyle = this.UpColor;
          bUp = true;
        } else

        {
          this.Canvas.fillStyle = this.DownColor;
        }

        //高度调整为整数
        var height = ToFixedRect(Math.abs(yBottom - y) >= 1 ? yBottom - y : 1);
        y = yBottom - height;
        if (bUp && (this.KLineDrawType == 1 || this.KLineDrawType == 2 || this.KLineDrawType == 3)) //空心柱子
          {
            this.Canvas.strokeStyle = this.UpColor;
            this.Canvas.beginPath();
            this.Canvas.rect(ToFixedPoint(left), ToFixedPoint(y), ToFixedRect(dataWidth), height);
            this.Canvas.stroke();
          } else

        {
          this.Canvas.fillRect(ToFixedRect(left), y, ToFixedRect(dataWidth), height);
        }
      }
    } else
      //太细了直接话线
      {
        for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth)
        {
          var value = this.Data.Data[i];
          var kItem = this.HistoryData.Data[i];
          if (value == null || kItem == null) continue;

          var y = this.ChartFrame.GetYFromData(value);
          var x = this.ChartFrame.GetXFromIndex(j);
          if (x > chartright) break;

          if (kItem.Close > kItem.Open)
          this.Canvas.strokeStyle = this.UpColor;else

          this.Canvas.strokeStyle = this.DownColor;

          var x = this.ChartFrame.GetXFromIndex(j);
          this.Canvas.beginPath();
          this.Canvas.moveTo(ToFixedPoint(x), y);
          this.Canvas.lineTo(ToFixedPoint(x), yBottom);
          this.Canvas.stroke();
        }
      }
  };

  this.HScreenDraw = function () //横屏画法
  {
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var xOffset = this.ChartBorder.GetTop() + distanceWidth / 2.0 + 2.0;
    var chartBottom = this.ChartBorder.GetBottom();
    var xPointCount = this.ChartFrame.XPointCount;

    var yBottom = this.ChartFrame.GetYFromData(0);

    if (dataWidth >= this.MinBarWidth)
    {
      yBottom = ToFixedRect(yBottom);
      for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth)
      {
        var value = this.Data.Data[i];
        var kItem = this.HistoryData.Data[i];
        if (value == null || kItem == null) continue;

        var left = xOffset;
        var right = xOffset + dataWidth;
        if (right > chartBottom) break;

        var y = this.ChartFrame.GetYFromData(value);
        var bUp = false;

        if (kItem.Close >= kItem.Open)
        {
          bUp = true;
          this.Canvas.fillStyle = this.UpColor;
        } else

        {
          this.Canvas.fillStyle = this.DownColor;
        }

        //高度调整为整数
        var height = ToFixedRect(y - yBottom);
        if (bUp && (this.KLineDrawType == 1 || this.KLineDrawType == 2 || this.KLineDrawType == 3)) //空心柱子
          {
            this.Canvas.strokeStyle = this.UpColor;
            this.Canvas.beginPath();
            this.Canvas.rect(ToFixedPoint(yBottom), ToFixedPoint(left), height, ToFixedRect(dataWidth));
            this.Canvas.stroke();
          } else

        {
          this.Canvas.fillRect(yBottom, ToFixedRect(left), height, ToFixedRect(dataWidth));
        }
      }
    } else
      //太细了直接话线
      {
        for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth)
        {
          var value = this.Data.Data[i];
          var kItem = this.HistoryData.Data[i];
          if (value == null || kItem == null) continue;

          var y = this.ChartFrame.GetYFromData(value);
          var x = this.ChartFrame.GetXFromIndex(j);
          if (x > chartBottom) break;

          if (kItem.Close > kItem.Open)
          this.Canvas.strokeStyle = this.UpColor;else

          this.Canvas.strokeStyle = this.DownColor;

          var x = this.ChartFrame.GetXFromIndex(j);
          this.Canvas.beginPath();
          this.Canvas.moveTo(y, ToFixedPoint(x));
          this.Canvas.lineTo(yBottom, ToFixedPoint(x));
          this.Canvas.stroke();
        }
      }
  };

  this.GetMaxMin = function ()
  {
    var xPointCount = this.ChartFrame.XPointCount;
    var range = {};
    range.Min = 0;
    range.Max = null;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j)
    {
      var value = this.Data.Data[i];
      if (range.Max == null) range.Max = value;

      if (range.Max < value) range.Max = value;
    }

    return range;
  };
}

function ChartText()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.TextFont = "14px 微软雅黑";

  this.Draw = function ()
  {
    if (this.NotSupportMessage)
    {
      this.DrawNotSupportmessage();
      return;
    }

    if (!this.Data || !this.Data.Data) return;

    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var chartright = this.ChartBorder.GetRight();
    var xPointCount = this.ChartFrame.XPointCount;

    for (var i in this.Data.Data)
    {
      var value = this.Data.Data[i];
      if (value == null) continue;

      var price = value.Value;
      var position = value.Position;

      if (position == 'Left') {
        var x = this.ChartFrame.GetXFromIndex(0);
        var y = this.ChartFrame.GetYFromData(price);

        if (x > chartright) continue;

        this.Canvas.textAlign = 'left';
        this.Canvas.textBaseline = 'middle';
        this.Canvas.fillStyle = value.Color;
        this.Canvas.font = this.TextFont;
        this.Canvas.fillText(value.Message, x, y);
      }
    }
  };

  this.GetMaxMin = function ()
  {
    var xPointCount = this.ChartFrame.XPointCount;
    var range = {};
    range.Min = null;
    range.Max = null;

    if (!this.Data || !this.Data.Data) return range;

    for (var i in this.Data.Data)
    {
      var data = this.Data.Data[i];
      if (data == null || isNaN(data.Value)) continue;

      var value = data.Value;

      if (range.Max == null) range.Max = value;
      if (range.Min == null) range.Min = value;

      if (range.Max < value) range.Max = value;
      if (range.Min > value) range.Min = value;
    }

    return range;
  };
}

/*  水平面积 只有1个数据
      Data 数据结构 
      Value, Value2  区间最大最小值
      Color=面积的颜色
      Title=标题 TitleColor=标题颜色
      支持横屏
  */
function ChartStraightArea()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.Color = "rgb(255,193,37)"; //线段颜色
  this.Font = '11px 微软雅黑';

  this.Draw = function ()
  {
    if (this.NotSupportMessage)
    {
      this.DrawNotSupportmessage();
      return;
    }

    if (!this.Data || !this.Data.Data) return;

    if (this.ChartFrame.IsHScreen === true)
    {
      this.HScreenDraw();
      return;
    }

    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var chartright = this.ChartBorder.GetRight();
    var bottom = this.ChartBorder.GetBottom();
    var left = this.ChartBorder.GetLeft();
    var xPointCount = this.ChartFrame.XPointCount;

    var xRight = this.ChartFrame.GetXFromIndex(xPointCount - 1);

    //画背景
    for (var i in this.Data.Data)
    {
      var item = this.Data.Data[i];
      if (item == null || isNaN(item.Value) || isNaN(item.Value2)) continue;
      if (item.Color == null) continue;

      var valueMax = Math.max(item.Value, item.Value2);
      var valueMin = Math.min(item.Value, item.Value2);

      var yTop = this.ChartFrame.GetYFromData(valueMax);
      var yBottom = this.ChartFrame.GetYFromData(valueMin);

      this.Canvas.fillStyle = item.Color;
      this.Canvas.fillRect(ToFixedRect(left), ToFixedRect(yTop), ToFixedRect(xRight - left), ToFixedRect(yBottom - yTop));
    }

    for (var _i in this.Data.Data)
    {
      var _item = this.Data.Data[_i];
      if (_item == null || isNaN(_item.Value) || isNaN(_item.Value2)) continue;
      if (_item.Color == null) continue;

      var _valueMax = Math.max(_item.Value, _item.Value2);
      var _valueMin = Math.min(_item.Value, _item.Value2);

      var _yTop = this.ChartFrame.GetYFromData(_valueMax);
      var _yBottom = this.ChartFrame.GetYFromData(_valueMin);

      if (_item.Title && _item.TitleColor)
      {
        var x = xRight;
        if (_item.Align == 'left')
        {
          this.Canvas.textAlign = 'left';
          x = left;
        } else

        {
          this.Canvas.textAlign = 'right';
          x = xRight;
        }

        this.Canvas.textBaseline = 'middle';
        this.Canvas.fillStyle = _item.TitleColor;
        this.Canvas.font = this.Font;
        var y = _yTop + (_yBottom - _yTop) / 2;
        this.Canvas.fillText(_item.Title, x, y);
      }
    }
  };

  this.HScreenDraw = function ()
  {
    var bottom = this.ChartBorder.GetBottom();
    var top = this.ChartBorder.GetTop();
    var height = this.ChartBorder.GetHeight();

    for (var i in this.Data.Data)
    {
      var item = this.Data.Data[i];
      if (item == null || isNaN(item.Value) || isNaN(item.Value2)) continue;
      if (item.Color == null) continue;

      var valueMax = Math.max(item.Value, item.Value2);
      var valueMin = Math.min(item.Value, item.Value2);

      var yTop = this.ChartFrame.GetYFromData(valueMax);
      var yBottom = this.ChartFrame.GetYFromData(valueMin);

      this.Canvas.fillStyle = item.Color;
      this.Canvas.fillRect(ToFixedRect(yBottom), ToFixedRect(top), ToFixedRect(yTop - yBottom), ToFixedRect(height));

      if (item.Title && item.TitleColor)
      {
        var xText = yTop + (yBottom - yTop) / 2;
        var yText = bottom;
        this.Canvas.save();
        this.Canvas.translate(xText, yText);
        this.Canvas.rotate(90 * Math.PI / 180);

        this.Canvas.textAlign = 'right';
        this.Canvas.textBaseline = 'middle';
        this.Canvas.fillStyle = item.TitleColor;
        this.Canvas.font = this.Font;
        this.Canvas.fillText(item.Title, 0, -2);

        this.Canvas.restore();
      }
    }
  };

  this.GetMaxMin = function ()
  {
    var xPointCount = this.ChartFrame.XPointCount;
    var range = {};
    range.Min = null;
    range.Max = null;

    if (!this.Data || !this.Data.Data) return range;

    for (var i in this.Data.Data)
    {
      var item = this.Data.Data[i];
      if (item == null || isNaN(item.Value) || isNaN(item.Value2)) continue;

      var valueMax = Math.max(item.Value, item.Value2);
      var valueMin = Math.min(item.Value, item.Value2);

      if (range.Max == null) range.Max = valueMax;
      if (range.Min == null) range.Min = valueMin;

      if (range.Max < valueMax) range.Max = valueMax;
      if (range.Min > valueMin) range.Min = valueMin;
    }
    return range;
  };
}

// 面积图
function ChartBand() {
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;
  this.IsDrawFirst = true;

  this.FirstColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.LineColor[0];
  this.SecondColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.LineColor[1];

  this.Draw = function () {
    if (this.NotSupportMessage) {
      this.DrawNotSupportmessage();
      return;
    }

    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var xPointCount = this.ChartFrame.XPointCount;
    var xOffset = this.ChartBorder.GetLeft() + distanceWidth / 2.0 + 2.0;
    var x = 0;
    var y = 0;
    var y2 = 0;
    var firstlinePoints = [];
    var secondlinePoints = [];
    var lIndex = 0;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth) {
      var value = this.Data.Data[i];
      if (value == null || value.Value == null || value.Value2 == null) continue;
      x = this.ChartFrame.GetXFromIndex(j);
      y = this.ChartFrame.GetYFromData(value.Value);
      y2 = this.ChartFrame.GetYFromData(value.Value2);
      firstlinePoints[lIndex] = { x: x, y: y };
      secondlinePoints[lIndex] = { x: x, y: y2 };
      lIndex++;
    }
    if (firstlinePoints.length > 1) {
      this.Canvas.save();
      this.Canvas.beginPath();
      for (var i = 0; i < firstlinePoints.length; ++i) {
        if (i == 0)
        this.Canvas.moveTo(firstlinePoints[i].x, firstlinePoints[i].y);else

        this.Canvas.lineTo(firstlinePoints[i].x, firstlinePoints[i].y);
      }
      for (var j = secondlinePoints.length - 1; j >= 0; --j) {
        this.Canvas.lineTo(secondlinePoints[j].x, secondlinePoints[j].y);
      }
      this.Canvas.closePath();
      this.Canvas.strokeStyle = "rgba(255,255,255,0)";
      this.Canvas.stroke();
      this.Canvas.clip();
      this.Canvas.beginPath();
      this.Canvas.moveTo(firstlinePoints[0].x, this.ChartBorder.GetBottom());
      for (var i = 0; i < firstlinePoints.length; ++i) {
        this.Canvas.lineTo(firstlinePoints[i].x, firstlinePoints[i].y);
      }
      this.Canvas.lineTo(firstlinePoints[firstlinePoints.length - 1].x, this.ChartBorder.GetBottom());
      this.Canvas.closePath();
      this.Canvas.fillStyle = this.FirstColor;
      this.Canvas.fill();
      this.Canvas.beginPath();
      this.Canvas.moveTo(secondlinePoints[0].x, this.ChartBorder.GetBottom());
      for (var i = 0; i < secondlinePoints.length; ++i) {
        this.Canvas.lineTo(secondlinePoints[i].x, secondlinePoints[i].y);
      }
      this.Canvas.lineTo(secondlinePoints[secondlinePoints.length - 1].x, this.ChartBorder.GetBottom());
      this.Canvas.closePath();
      this.Canvas.fillStyle = this.SecondColor;
      this.Canvas.fill();
      this.Canvas.restore();
    }
  };
  this.GetMaxMin = function () {
    var xPointCount = this.ChartFrame.XPointCount;
    var range = {};
    range.Min = null;
    range.Max = null;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j) {
      var value = this.Data.Data[i];
      if (value == null || value.Value == null || value.Value2 == null) continue;
      var maxData = value.Value > value.Value2 ? value.Value : value.Value2;
      var minData = value.Value < value.Value2 ? value.Value : value.Value2;
      if (range.Max == null)
      range.Max = maxData;else
      if (range.Max < maxData)
      range.Max = maxData;

      if (range.Min == null)
      range.Min = minData;else
      if (range.Min > minData)
      range.Min = minData;
    }

    return range;
  };
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// 其他图形
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////

/*
    饼图
*/
function ChartPie()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.Draw = function ()
  {
    if (!this.Data || !this.Data.Data || !(this.Data.Data.length > 0)) return this.DrawEmptyData();

    var left = this.ChartBorder.GetLeft();
    var right = this.ChartBorder.GetRight();
    var top = this.ChartBorder.GetTop();
    var bottom = this.ChartBorder.GetBottom();
    var width = this.ChartBorder.GetWidth();
    var height = this.ChartBorder.GetHeight();

    //圆半径
    var radius = width / 4 * 0.8;
    this.Canvas.save();
    this.Canvas.translate(left + radius, top + height / 2);

    var totalValue = 0; //求和
    for (var i in this.Data.Data) {
      totalValue += this.Data.Data[i].Value;
    }

    var startAngle = Math.PI * 1.5;
    var start = startAngle;
    var end = startAngle;
    //画饼图
    for (var _i2 in this.Data.Data)
    {
      var item = this.Data.Data[_i2];
      var rate = item.Value / totalValue; //占比

      // 绘制扇形
      this.Canvas.beginPath();
      this.Canvas.moveTo(0, 0);

      end += rate * 2 * Math.PI; //终止角度
      this.Canvas.strokeStyle = "white";
      this.Canvas.fillStyle = item.Color;
      this.Canvas.arc(0, 0, radius, start, end);
      this.Canvas.fill();
      this.Canvas.closePath();
      this.Canvas.stroke();

      start += rate * 2 * Math.PI; //起始角度
    }

    //画文字
    this.Canvas.restore();
    var textLeft = left + width / 2 + 5;
    // let textTop = top + height / 2 + 20;
    var textTop = top;
    this.Canvas.textBaseline = "bottom";
    this.Canvas.font = "12px 微软雅黑";

    for (var _i3 = 0, j = 0; _i3 < this.Data.Data.length; ++_i3)
    {
      var _item2 = this.Data.Data[_i3];
      if (!_item2.Text) continue;

      this.Canvas.fillStyle = _item2.Color;
      this.Canvas.fillRect(textLeft, textTop - 15, 13, 13);

      this.Canvas.fillStyle = 'rgb(102,102,102)';
      this.Canvas.fillText(_item2.Text, textLeft + 16, textTop);
      // textTop += 20;
      textTop += 17;
      if (textTop > top + height / 2 + radius) {
        ++j;
        if (j >= 2) break;

        // textTop = top + height / 2 + 20;
        textTop = top;
        textLeft = right - width / 4 + 5;
      }
    }
  };

  //空数据
  this.DrawEmptyData = function ()
  {
    console.log('[ChartPie::DrawEmptyData]');

    var left = this.ChartBorder.GetLeft();
    var right = this.ChartBorder.GetRight();
    var top = this.ChartBorder.GetTop();
    var bottom = this.ChartBorder.GetBottom();
    var width = this.ChartBorder.GetWidth();
    var height = this.ChartBorder.GetHeight();

    //圆半径
    var radius = width / 4 * 0.8;
    this.Canvas.save();
    this.Canvas.translate(left + radius, top + height / 2);

    this.Canvas.beginPath();
    this.Canvas.fillStyle = 'rgb(211,211,211)';
    this.Canvas.strokeStyle = "white";
    this.Canvas.arc(0, 0, radius * 0.8, 0, 2 * Math.PI);
    this.Canvas.fill();
    this.Canvas.closePath();
    this.Canvas.stroke();

    this.Canvas.restore();
  };
}


/*
      圆环
  */
function ChartCircle()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.BGColor = 'white'; //背景色
  this.TextHeight = 25;

  //空数据
  this.DrawEmptyData = function ()
  {
    console.log('[ChartCircle::DrawEmptyData]');
  };

  this.Draw = function ()
  {
    if (!this.Data || !this.Data.Data || !(this.Data.Data.length > 0)) return this.DrawEmptyData();

    var left = this.ChartBorder.GetLeft();
    var right = this.ChartBorder.GetRight();
    var top = this.ChartBorder.GetTop();
    var bottom = this.ChartBorder.GetBottom();
    var width = this.ChartBorder.GetWidth();
    var height = this.ChartBorder.GetHeight();

    //圆半径
    var lTextHeight = this.TextHeight;
    var size = width - lTextHeight;
    if (size > height - lTextHeight) size = height - lTextHeight;
    var radius = (size - lTextHeight) / 2;
    this.Canvas.save();
    this.Canvas.translate(left + width / 2, top + height / 2 - lTextHeight / 2);

    var totalValue = 0; //求和
    for (var i in this.Data.Data)
    {
      totalValue += this.Data.Data[i].Value;
    }

    var startAngle = Math.PI * 1.5;
    var start = startAngle;
    var end = startAngle;
    //画饼图
    for (var _i4 in this.Data.Data)
    {
      var item = this.Data.Data[_i4];
      var rate = item.Value / totalValue; //占比
      //console.log('[ChartPie::Draw]', i, rate, item);

      // 绘制扇形
      this.Canvas.beginPath();
      this.Canvas.moveTo(0, 0);

      end += rate * 2 * Math.PI; //终止角度
      this.Canvas.strokeStyle = "white";
      this.Canvas.fillStyle = item.Color;
      this.Canvas.arc(0, 0, radius, start, end);
      this.Canvas.fill();
      this.Canvas.closePath();
      this.Canvas.stroke();

      start += rate * 2 * Math.PI; //起始角度
    }

    //中心画一个背景色的圆
    this.Canvas.beginPath();
    this.Canvas.fillStyle = this.BGColor;
    this.Canvas.arc(0, 0, radius * 0.5, 0, 2 * Math.PI);
    this.Canvas.fill();
    this.Canvas.closePath();
    this.Canvas.stroke();

    this.Canvas.restore();

    //画文字
    this.Canvas.restore();
    var textLeft = left;
    var textTop = top + height / 2 - lTextHeight / 2 + radius + 5 + 20;
    this.Canvas.textBaseline = "bottom";
    this.Canvas.textAlign = 'left';
    this.Canvas.font = "14px 微软雅黑";
    var textWidth = 0;
    //以圆心左右显示
    for (var _i5 = 0, j = 0; _i5 < this.Data.Data.length; ++_i5)
    {
      var _item3 = this.Data.Data[_i5];
      if (!_item3.Text) continue;

      this.Canvas.fillStyle = _item3.Color;

      if (j % 2 == 0)
      {
        textLeft = left + width / 2 - 10;
        textWidth = this.Canvas.measureText(_item3.Text).width;
        textLeft = textLeft - textWidth - 16;
        this.Canvas.fillRect(textLeft, textTop - 15, 13, 13);
        this.Canvas.fillStyle = 'rgb(102,102,102)';
        this.Canvas.fillText(_item3.Text, textLeft + 16, textTop);
      } else

      {
        textLeft = left + width / 2 + 10 + 10;
        this.Canvas.fillRect(textLeft, textTop - 15, 13, 13);
        this.Canvas.fillStyle = 'rgb(102,102,102)';
        this.Canvas.fillText(_item3.Text, textLeft + 16, textTop);
        textTop += 20;
      }

      if (textTop > bottom) break;

      ++j;
    }
  };
}



//  中国地图
function ChartChinaMap()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.ImageData = null;
  this.Left;
  this.Top;
  this.Width;
  this.Height;
  this.ImageWidth;
  this.ImageHeight;

  this.DefaultColor = [217, 222, 239];

  this.Color =
  [
  { Name: '海南', Color: 'rgb(217,222,223)' },
  { Name: '内蒙古', Color: 'rgb(217,222,225)' },
  { Name: '新疆', Color: 'rgb(217,222,226)' },
  { Name: '青海', Color: 'rgb(217,222,227)' },
  { Name: '西藏', Color: 'rgb(217,222,228)' },
  { Name: '云南', Color: 'rgb(217,222,229)' },
  { Name: '黑龙江', Color: 'rgb(217,222,230)' },
  { Name: '吉林', Color: 'rgb(217,222,231)' },
  { Name: '辽宁', Color: 'rgb(217,222,232)' },
  { Name: '河北', Color: 'rgb(217,222,233)' },
  { Name: '山东', Color: 'rgb(217,222,234)' },
  { Name: '江苏', Color: 'rgb(217,222,235)' },
  { Name: '浙江', Color: 'rgb(217,222,236)' },
  { Name: '福建', Color: 'rgb(217,222,237)' },
  { Name: '广东', Color: 'rgb(217,222,238)' },
  { Name: '广西', Color: 'rgb(217,222,239)' },
  { Name: '贵州', Color: 'rgb(217,222,240)' },
  { Name: '湖南', Color: 'rgb(217,222,241)' },
  { Name: '江西', Color: 'rgb(217,222,242)' },
  { Name: '安徽', Color: 'rgb(217,222,243)' },
  { Name: '湖北', Color: 'rgb(217,222,244)' },
  { Name: '重庆', Color: 'rgb(217,222,245)' },
  { Name: '四川', Color: 'rgb(217,222,246)' },
  { Name: '甘肃', Color: 'rgb(217,222,247)' },
  { Name: '陕西', Color: 'rgb(217,222,248)' },
  { Name: '山西', Color: 'rgb(217,222,249)' },
  { Name: '河南', Color: 'rgb(217,222,250)' }];


  this.Draw = function ()
  {
    var left = this.ChartBorder.GetLeft() + 1;
    var right = this.ChartBorder.GetRight() - 1;
    var top = this.ChartBorder.GetTop() + 1;
    var bottom = this.ChartBorder.GetBottom() - 1;
    var width = this.ChartBorder.GetWidth() - 2;
    var height = this.ChartBorder.GetHeight() - 2;

    var imageWidth = CHINA_MAP_IMAGE.width;
    var imageHeight = CHINA_MAP_IMAGE.height;

    var drawImageWidth = imageWidth;
    var drawImageHeight = imageHeight;

    if (height < drawImageHeight || width < drawImageWidth)
    {
      this.ImageData = null;
      return;
    }

    if (this.Left != left || this.Top != top || this.Width != width || this.Height != height || this.ImageWidth != imageWidth || this.ImageHeight != imageHeight)
    {
      this.ImageData = null;

      this.ImageWidth = imageWidth;
      this.ImageHeight = imageHeight;
      this.Left = left;
      this.Top = top;
      this.Width = width;
      this.Height = height;

      console.log(imageWidth, imageHeight);
    }

    if (this.ImageData == null)
    {
      this.Canvas.drawImage(CHINA_MAP_IMAGE, 0, 0, imageWidth, imageHeight, left, top, drawImageWidth, drawImageHeight);
      this.ImageData = this.Canvas.getImageData(left, top, drawImageWidth, drawImageHeight);

      var defaultColorSet = new Set(); //默认颜色填充的色块
      var colorMap = new Map(); //定义颜色填充的色块

      var nameMap = new Map();
      if (this.Data.length > 0)
      {
        for (var i in this.Data)
        {
          var item = this.Data[i];
          nameMap.set(item.Name, item.Color);
        }
      }

      console.log(this.Data);
      for (var _i6 in this.Color)
      {
        var _item4 = this.Color[_i6];
        if (nameMap.has(_item4.Name))
        {
          colorMap.set(_item4.Color, nameMap.get(_item4.Name));
        } else

        {
          defaultColorSet.add(_item4.Color);
        }
      }

      var color;
      for (var _i7 = 0; _i7 < this.ImageData.data.length; _i7 += 4)
      {
        color = 'rgb(' + this.ImageData.data[_i7] + ',' + this.ImageData.data[_i7 + 1] + ',' + this.ImageData.data[_i7 + 2] + ')';

        if (defaultColorSet.has(color))
        {
          this.ImageData.data[_i7] = this.DefaultColor[0];
          this.ImageData.data[_i7 + 1] = this.DefaultColor[1];
          this.ImageData.data[_i7 + 2] = this.DefaultColor[2];
        } else
        if (colorMap.has(color))
        {
          var colorValue = colorMap.get(color);
          this.ImageData.data[_i7] = colorValue[0];
          this.ImageData.data[_i7 + 1] = colorValue[1];
          this.ImageData.data[_i7 + 2] = colorValue[2];
        }
      }
      this.Canvas.clearRect(left, top, drawImageWidth, drawImageHeight);
      this.Canvas.putImageData(this.ImageData, left, top, 0, 0, drawImageWidth, drawImageHeight);
    } else

    {
      this.Canvas.putImageData(this.ImageData, left, top, 0, 0, drawImageWidth, drawImageHeight);
    }
  };
}


//  雷达图
function ChartRadar()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.BorderPoint = []; //边框点
  this.DataPoint = []; //数据点
  this.CenterPoint = {};
  this.StartAngle = 0;
  this.Color = 'rgb(198,198,198)';
  this.AreaColor = 'rgba(242,154,118,0.4)'; //面积图颜色
  this.AreaLineColor = 'rgb(242,154,118)';
  this.TitleFont = '24px 微软雅黑';
  this.TitleColor = 'rgb(102,102,102)';
  this.BGColor = ['rgb(255,255,255)', 'rgb(224,224,224)']; //背景色

  this.DrawBorder = function () //画边框
  {
    if (this.BorderPoint.length <= 0) return;

    this.Canvas.font = this.TitleFont;
    this.Canvas.strokeStyle = this.Color;

    var aryBorder = [1, 0.8, 0.6, 0.4, 0.2];
    for (var j in aryBorder)
    {
      var rate = aryBorder[j];
      var isFirstDraw = true;
      for (var i in this.BorderPoint)
      {
        var item = this.BorderPoint[i];
        item.X = this.CenterPoint.X + item.Radius * Math.cos(item.Angle * Math.PI / 180) * rate;
        item.Y = this.CenterPoint.Y + item.Radius * Math.sin(item.Angle * Math.PI / 180) * rate;
        if (isFirstDraw)
        {
          this.Canvas.beginPath();
          this.Canvas.moveTo(item.X, item.Y);
          isFirstDraw = false;
        } else

        {
          this.Canvas.lineTo(item.X, item.Y);
        }

        if (j == 0) this.DrawText(item);
      }

      this.Canvas.closePath();
      this.Canvas.stroke();
      this.Canvas.fillStyle = this.BGColor[j % 2 == 0 ? 0 : 1];
      this.Canvas.fill();
    }

    this.Canvas.beginPath();
    for (var _i8 in this.BorderPoint)
    {
      var item = this.BorderPoint[_i8];
      item.X = this.CenterPoint.X + item.Radius * Math.cos(item.Angle * Math.PI / 180);
      item.Y = this.CenterPoint.Y + item.Radius * Math.sin(item.Angle * Math.PI / 180);
      this.Canvas.moveTo(this.CenterPoint.X, this.CenterPoint.Y);
      this.Canvas.lineTo(item.X, item.Y);
    }
    this.Canvas.stroke();
  };

  this.DrawArea = function ()
  {
    if (!this.DataPoint || this.DataPoint.length <= 0) return;

    this.Canvas.fillStyle = this.AreaColor;
    this.Canvas.strokeStyle = this.AreaLineColor;
    this.Canvas.beginPath();
    var isFirstDraw = true;
    for (var i in this.DataPoint)
    {
      var item = this.DataPoint[i];
      if (isFirstDraw)
      {
        this.Canvas.beginPath();
        this.Canvas.moveTo(item.X, item.Y);
        isFirstDraw = false;
      } else

      {
        this.Canvas.lineTo(item.X, item.Y);
      }
    }

    this.Canvas.closePath();
    this.Canvas.fill();
    this.Canvas.stroke();
  };

  this.DrawText = function (item)
  {
    if (!item.Text) return;

    //console.log(item.Text, item.Angle);
    this.Canvas.fillStyle = this.TitleColor;
    var xText = item.X,yText = item.Y;

    //显示每个角度的位置
    if (item.Angle > 0 && item.Angle < 45)
    {
      this.Canvas.textAlign = 'left';
      this.Canvas.textBaseline = 'middle';
      xText += 2;
    } else
    if (item.Angle >= 0 && item.Angle < 90) {
      this.Canvas.textAlign = 'left';
      this.Canvas.textBaseline = 'top';
      xText += 2;
    } else
    if (item.Angle >= 90 && item.Angle < 135)
    {
      this.Canvas.textAlign = 'right';
      this.Canvas.textBaseline = 'top';
      xText -= 2;
    } else
    if (item.Angle >= 135 && item.Angle < 180)
    {
      this.Canvas.textAlign = 'right';
      this.Canvas.textBaseline = 'top';
      xText -= 2;
    } else
    if (item.Angle >= 180 && item.Angle < 225) {
      this.Canvas.textAlign = 'right';
      this.Canvas.textBaseline = 'middle';
      xText -= 2;
    } else
    if (item.Angle >= 225 && item.Angle <= 270) {
      this.Canvas.textAlign = 'center';
      this.Canvas.textBaseline = 'bottom';
    } else
    if (item.Angle > 270 && item.Angle < 315)
    {
      this.Canvas.textAlign = 'left';
      this.Canvas.textBaseline = 'bottom';
      xText += 2;
    } else

    {
      this.Canvas.textAlign = 'left';
      this.Canvas.textBaseline = 'middle';
      xText += 2;
    }

    this.Canvas.fillText(item.Text, xText, yText);
  };

  this.Draw = function ()
  {
    this.BorderPoint = [];
    this.DataPoint = [];
    this.InternalBorderPoint = [];
    this.CenterPoint = {};
    if (!this.Data || !this.Data.Data || !(this.Data.Data.length > 0))
    this.CalculatePoints(null);else

    this.CalculatePoints(this.Data.Data);

    this.DrawBorder();
    this.DrawArea();
  };

  this.CalculatePoints = function (data)
  {
    var left = this.ChartBorder.GetLeft();
    var right = this.ChartBorder.GetRight();
    var top = this.ChartBorder.GetTop();
    var bottom = this.ChartBorder.GetBottom();
    var width = this.ChartBorder.GetWidth();
    var height = this.ChartBorder.GetHeight();

    var ptCenter = { X: left + width / 2, Y: top + height / 2 }; //中心点
    var radius = Math.min(width / 2, height / 2) - 2; //半径
    var count = Math.max(5, data ? data.length : 0);
    var averageAngle = 360 / count;
    for (var i = 0; i < count; ++i)
    {
      var ptBorder = { Index: i, Radius: radius, Angle: i * averageAngle + this.StartAngle };
      var angle = ptBorder.Angle;

      if (data && i < data.length)
      {
        var item = data[i];
        var ptData = { Index: i, Text: item.Text };
        ptBorder.Text = item.Name;
        if (!item.Value)
        {
          ptData.X = ptCenter.X;
          ptData.Y = ptCenter.Y;
        } else

        {
          var value = item.Value;
          if (value >= 1) value = 1;
          var dataRadius = radius * value;
          ptData.X = ptCenter.X + dataRadius * Math.cos(angle * Math.PI / 180);
          ptData.Y = ptCenter.Y + dataRadius * Math.sin(angle * Math.PI / 180);
        }

        this.DataPoint.push(ptData);
      }

      this.BorderPoint.push(ptBorder);
    }
    this.CenterPoint = ptCenter;
  };
}


///////////////////////////////////////////////////////////////////////////////////////////////////
//十字光标
function ChartCorssCursor()
{
  this.Frame;
  this.Canvas; //画布

  this.HPenColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.CorssCursorHPenColor; //水平线颜色
  this.HPenType = 0; //水平线样式 0=虚线 1=实线

  this.VPenColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.CorssCursorVPenColor; //垂直线颜色
  this.VPenType = 0; //垂直线颜色 0=虚线 1=实线 2=K线宽度

  this.Font = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.CorssCursorTextFont; //字体
  this.TextColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.CorssCursorTextColor; //文本颜色
  this.TextBGColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.CorssCursorBGColor; //文本背景色
  this.TextHeight = 15; //文本字体高度
  this.LastPoint;
  this.CursorIndex; //当前数据的位置

  this.PointX;
  this.PointY;

  this.StringFormatX;
  this.StringFormatY;

  this.IsShow = true; //是否显示
  this.ShowTextMode = { Left: 1, Right: 1, Bottom: 1 }; //0=不显示  1=显示在框架外 2=显示在框架内
  this.IsShowCorss = true; //是否显示十字光标
  this.IsShowClose = false; //Y轴始终显示收盘价
  this.IsFixXLastTime = false; //是否修正X轴,超出当前时间的,X轴调整到当前最后的时间.

  //内部使用
  this.Close = null; //收盘价格

  this.GetCloseYPoint = function (index)
  {
    this.Close = null;
    if (!this.StringFormatX.Data) return null;
    var data = this.StringFormatX.Data;
    if (!data.Data || data.Data.length <= 0) return null;
    var dataIndex = data.DataOffset + index;
    if (dataIndex >= data.Data.length) dataIndex = data.Data.length - 1;
    if (dataIndex < 0) return null;

    var klineData = data.Data[dataIndex];
    if (!klineData) return null;
    this.Close = klineData.Close;
    var yPoint = this.Frame.GetYFromData(this.Close);
    return yPoint;
  };

  this.FixMinuteLastTimeXPoint = function (index)
  {
    if (!_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(index)) return null;
    index = parseInt(index);
    if (!this.StringFormatX.Data) return null;
    var data = this.StringFormatX.Data;
    if (!data.Data || data.Data.length <= 0) return null;
    var dataIndex = data.DataOffset + index;
    if (dataIndex < data.Data.length) return null;

    dataIndex = data.Data.length - 1;
    dataIndex -= data.DataOffset;
    var xPoint = this.Frame.GetXFromIndex(dataIndex);

    return { X: xPoint, Index: dataIndex };
  };

  this.Draw = function ()
  {
    if (!this.LastPoint) return;

    var x = this.LastPoint.X;
    var y = this.LastPoint.Y;

    var isInClient = false;
    var rtClient = new _umychartDataWechat.JSCommon_Rect(this.Frame.ChartBorder.GetLeft(), this.Frame.ChartBorder.GetTop(), this.Frame.ChartBorder.GetWidth(), this.Frame.ChartBorder.GetHeight());
    isInClient = rtClient.IsPointIn(x, y);
    this.PointY = null;
    this.PointY == null;

    if (!isInClient) return;

    if (this.Frame.IsHScreen === true)
    {
      this.HScreenDraw();
      return;
    }

    var left = this.Frame.ChartBorder.GetLeft();
    var right = this.Frame.ChartBorder.GetRight();
    var top = this.Frame.ChartBorder.GetTopTitle();
    var bottom = this.Frame.ChartBorder.GetBottom();
    var rightWidth = this.Frame.ChartBorder.Right;
    var chartRight = this.Frame.ChartBorder.GetChartWidth();
    x = this.Frame.GetXFromIndex(this.CursorIndex); //手机端 十字只能画在K线上
    if (this.IsShowClose)
    {
      var yPoint = this.GetCloseYPoint(this.CursorIndex);
      if (yPoint != null) y = yPoint;
    }

    if (this.IsFixXLastTime)
    {
      var value = this.FixMinuteLastTimeXPoint(this.CursorIndex);
      if (value)
      {
        x = value.X;
        this.CursorIndex = value.Index;
      }
    }

    this.PointY = [[left, y], [right, y]];
    this.PointX = [[x, top], [x, bottom]];

    if (this.IsShowCorss) //十字线
      {
        if (this.HPenType == 1 || this.HPenType == 0)
        {
          this.Canvas.strokeStyle = this.HPenColor;
          if (this.HPenType == 0) this.Canvas.setLineDash([3, 2]); //虚线
          //this.Canvas.lineWidth=0.5
          this.Canvas.beginPath();
          this.Canvas.moveTo(left, ToFixedPoint(y));
          this.Canvas.lineTo(right, ToFixedPoint(y));
          this.Canvas.stroke();
          this.Canvas.setLineDash([]);
        }

        this.Canvas.save();
        this.Canvas.strokeStyle = this.VPenColor;
        if (this.VPenType == 0)
        {
          this.Canvas.setLineDash([3, 2]); //虚线
        } else
        if (this.VPenType == 2)
        {
          var barWidth = this.Frame.SubFrame[0].Frame.DataWidth; //和K线一样宽度
          if (barWidth > 2) this.Canvas.lineWidth = barWidth;
        }

        this.Canvas.beginPath();
        if (this.Frame.SubFrame.length > 0)
        {
          for (var i in this.Frame.SubFrame)
          {
            var frame = this.Frame.SubFrame[i].Frame;
            top = frame.ChartBorder.GetTopTitle();
            bottom = frame.ChartBorder.GetBottom();
            this.Canvas.moveTo(ToFixedPoint(x), top);
            this.Canvas.lineTo(ToFixedPoint(x), bottom);
          }
        } else

        {
          this.Canvas.moveTo(ToFixedPoint(x), top);
          this.Canvas.lineTo(ToFixedPoint(x), bottom);
        }

        this.Canvas.stroke();
        this.Canvas.restore();
      }

    var xValue = this.Frame.GetXData(x);
    var yValueExtend = {};
    var yValue = this.Frame.GetYData(y, yValueExtend);
    this.StringFormatY.RValue = yValueExtend.RightYValue; //右侧子坐标
    if (this.IsShowClose && this.Close != null) yValue = this.Close;

    this.StringFormatX.Value = this.CursorIndex;
    this.StringFormatY.Value = yValue;
    this.StringFormatY.FrameID = yValueExtend.FrameID;

    if ((this.ShowTextMode.Left == 1 && this.Frame.ChartBorder.Left >= 30 || this.ShowTextMode.Left == 2 ||
    this.ShowTextMode.Right == 1 && this.Frame.ChartBorder.Right >= 30 || this.ShowTextMode.Right == 2) && this.StringFormatY.Operator())
    {
      var text = this.StringFormatY.Text;
      this.Canvas.font = this.Font;
      var textWidth = this.Canvas.measureText(text).width + 4; //前后各空2个像素

      if (this.Frame.ChartBorder.Left >= 30 && this.ShowTextMode.Left == 1)
      {
        this.Canvas.fillStyle = this.TextBGColor;
        if (left < textWidth) //左边空白的地方太少了画布下
          {
            this.Canvas.fillRect(2, y - this.TextHeight / 2, textWidth, this.TextHeight);
            this.Canvas.textAlign = "left";
            this.Canvas.textBaseline = "middle";
            this.Canvas.fillStyle = this.TextColor;
            this.Canvas.fillText(text, 2 + 2, y, textWidth);
          } else

        {
          this.Canvas.fillRect(left - 2, y - this.TextHeight / 2, -textWidth, this.TextHeight);
          this.Canvas.textAlign = "right";
          this.Canvas.textBaseline = "middle";
          this.Canvas.fillStyle = this.TextColor;
          this.Canvas.fillText(text, left - 4, y, textWidth);
        }
      } else
      if (this.ShowTextMode.Left == 2)
      {
        this.Canvas.fillStyle = this.TextBGColor;
        this.Canvas.fillRect(left, y - this.TextHeight / 2, textWidth, this.TextHeight);
        this.Canvas.textAlign = "left";
        this.Canvas.textBaseline = "middle";
        this.Canvas.fillStyle = this.TextColor;
        this.Canvas.fillText(text, left + 2, y, textWidth);
      }

      if (this.StringFormatY.RText)
      {
        text = this.StringFormatY.RText;
        var textWidth = this.Canvas.measureText(text).width + 4; //前后各空2个像素
      }

      if (this.Frame.ChartBorder.Right >= 30 && this.ShowTextMode.Right == 1)
      {
        this.Canvas.fillStyle = this.TextBGColor;
        if (rightWidth > textWidth) //右边不够就不画
          {
            this.Canvas.fillRect(right + 2, y - this.TextHeight / 2, textWidth, this.TextHeight);
            this.Canvas.textAlign = "left";
            this.Canvas.textBaseline = "middle";
            this.Canvas.fillStyle = this.TextColor;
            this.Canvas.fillText(text, right + 4, y, textWidth);
          } else

        {
          this.Canvas.fillRect(chartRight - 2 - textWidth, y - this.TextHeight / 2, textWidth, this.TextHeight);
          this.Canvas.textAlign = "right";
          this.Canvas.textBaseline = "middle";
          this.Canvas.fillStyle = this.TextColor;
          this.Canvas.fillText(text, chartRight - 4, y, textWidth);
        }
      } else
      if (this.ShowTextMode.Right == 2)
      {
        this.Canvas.fillStyle = this.TextBGColor;
        var showLeft = right - textWidth;
        this.Canvas.fillRect(showLeft, y - this.TextHeight / 2, textWidth, this.TextHeight);
        this.Canvas.textAlign = "left";
        this.Canvas.textBaseline = "middle";
        this.Canvas.fillStyle = this.TextColor;
        this.Canvas.fillText(text, showLeft + 2, y, textWidth);
      }
    }

    if (this.ShowTextMode.Bottom == 1 && this.StringFormatX.Operator())
    {
      var text = this.StringFormatX.Text;
      this.Canvas.font = this.Font;

      this.Canvas.fillStyle = this.TextBGColor;
      var textWidth = this.Canvas.measureText(text).width + 4; //前后各空2个像素
      if (x - textWidth / 2 < 3) //左边位置不够了, 顶着左边画
        {
          this.Canvas.fillRect(x - 1, bottom + 2, textWidth, this.TextHeight);
          this.Canvas.textAlign = "left";
          this.Canvas.textBaseline = "top";
          this.Canvas.fillStyle = this.TextColor;
          this.Canvas.fillText(text, x + 1, bottom + 2, textWidth);
        } else
      if (right - left - x < textWidth)
      {//右边位置不够用，顶着右边画
        this.Canvas.fillRect(x - textWidth, bottom + 2, textWidth, this.TextHeight);
        this.Canvas.textAlign = "right";
        this.Canvas.textBaseline = "top";
        this.Canvas.fillStyle = this.TextColor;
        this.Canvas.fillText(text, x - 1, bottom + 2, textWidth);
      } else

      {
        this.Canvas.fillRect(x - textWidth / 2, bottom + 2, textWidth, this.TextHeight);
        this.Canvas.textAlign = "center";
        this.Canvas.textBaseline = "top";
        this.Canvas.fillStyle = this.TextColor;
        this.Canvas.fillText(text, x, bottom + 2, textWidth);
      }
    }
  };

  this.HScreenDraw = function ()
  {
    var x = this.LastPoint.X;
    var y = this.LastPoint.Y;

    y = this.Frame.GetXFromIndex(this.CursorIndex); //手机端 十字只能画在K线上

    var left = this.Frame.ChartBorder.GetLeft();
    var right = this.Frame.ChartBorder.GetRightEx();
    var top = this.Frame.ChartBorder.GetTop();
    var bottom = this.Frame.ChartBorder.GetBottom();
    var bottomWidth = this.Frame.ChartBorder.Bottom;

    this.PointY = [[left, y], [right, y]];
    this.PointX = [[x, top], [x, bottom]];

    if (this.IsShowCorss) //十字线
      {
        this.Canvas.save();
        this.Canvas.strokeStyle = this.HPenColor;
        if (this.HPenType == 0) this.Canvas.setLineDash([3, 2]); //虚线

        //画竖线
        this.Canvas.beginPath();
        this.Canvas.moveTo(ToFixedPoint(x), top);
        this.Canvas.lineTo(ToFixedPoint(x), bottom);
        this.Canvas.stroke();
        this.Canvas.restore();

        this.Canvas.save();
        this.Canvas.strokeStyle = this.VPenColor;
        if (this.VPenType == 0)
        {
          this.Canvas.setLineDash([3, 2]); //虚线
        } else
        if (this.VPenType == 2)
        {
          var barWidth = this.Frame.SubFrame[0].Frame.DataWidth; //和K线一样宽度
          if (barWidth > 2) this.Canvas.lineWidth = barWidth;
        }
        this.Canvas.beginPath();
        //画横线
        if (this.Frame.SubFrame.length > 0)
        {
          for (var i in this.Frame.SubFrame)
          {
            var frame = this.Frame.SubFrame[i].Frame;
            this.Canvas.moveTo(frame.ChartBorder.GetLeft(), ToFixedPoint(y));
            this.Canvas.lineTo(frame.ChartBorder.GetRightTitle(), ToFixedPoint(y));
          }
        } else

        {
          this.Canvas.moveTo(left, ToFixedPoint(y));
          this.Canvas.lineTo(right, ToFixedPoint(y));
        }

        this.Canvas.stroke();
        this.Canvas.restore();
      }

    var xValue = this.Frame.GetXData(y);
    var yValueExtend = {};
    var yValue = this.Frame.GetYData(x, yValueExtend);

    this.StringFormatX.Value = xValue;
    this.StringFormatY.Value = yValue;
    this.StringFormatY.FrameID = yValueExtend.FrameID;

    if ((this.ShowTextMode.Left == 1 && this.Frame.ChartBorder.Top >= 30 || this.ShowTextMode.Left == 2 ||
    this.ShowTextMode.Right == 1 && this.Frame.ChartBorder.Bottom >= 30 || this.ShowTextMode.Right == 2) && this.StringFormatY.Operator()) {
      var text = this.StringFormatY.Text;
      this.Canvas.font = this.Font;
      var textWidth = this.Canvas.measureText(text).width + 4; //前后各空2个像素

      if (this.Frame.ChartBorder.Top >= 30 && this.ShowTextMode.Left == 1) {
        var xText = x,yText = top;
        this.Canvas.save();
        this.Canvas.translate(xText, yText);
        this.Canvas.rotate(90 * Math.PI / 180); //数据和框子旋转180度
        this.Canvas.fillStyle = this.TextBGColor;

        if (top >= textWidth) {
          this.Canvas.fillRect(-textWidth, -(this.TextHeight / 2), textWidth, this.TextHeight);
          this.Canvas.textAlign = "right";
          this.Canvas.textBaseline = "middle";
          this.Canvas.fillStyle = this.TextColor;
          this.Canvas.fillText(text, -2, 0, textWidth);
        } else
        {
          this.Canvas.fillRect(textWidth - top, -(this.TextHeight / 2), -textWidth, this.TextHeight);
          this.Canvas.textAlign = "right";
          this.Canvas.textBaseline = "middle";
          this.Canvas.fillStyle = this.TextColor;
          this.Canvas.fillText(text, textWidth - top - 2, 0, textWidth);
        }
        this.Canvas.restore();
      } else
      if (this.ShowTextMode.Left == 2) {
        var xText = x;
        var yText = top;
        this.Canvas.save();
        this.Canvas.translate(xText, yText);
        this.Canvas.rotate(90 * Math.PI / 180); //数据和框子旋转180度

        this.Canvas.fillStyle = this.TextBGColor;
        this.Canvas.fillRect(0, -(this.TextHeight / 2), textWidth, this.TextHeight);
        this.Canvas.textAlign = "left";
        this.Canvas.textBaseline = "middle";
        this.Canvas.fillStyle = this.TextColor;
        this.Canvas.fillText(text, 2, 0, textWidth);

        this.Canvas.restore();
      }

      if (this.Frame.ChartBorder.Bottom >= 30 && this.ShowTextMode.Right == 1) {
        var xText = x,yText = bottom;
        this.Canvas.save();
        this.Canvas.translate(xText, yText);
        this.Canvas.rotate(90 * Math.PI / 180); //数据和框子旋转180度
        this.Canvas.fillStyle = this.TextBGColor;

        if (bottomWidth > textWidth) {
          this.Canvas.fillRect(0, -(this.TextHeight / 2), textWidth, this.TextHeight);
          this.Canvas.textAlign = "left";
          this.Canvas.textBaseline = "middle";
          this.Canvas.fillStyle = this.TextColor;
          this.Canvas.fillText(text, 2, 0, textWidth);
        } else
        {
          this.Canvas.fillRect(bottomWidth - textWidth, -(this.TextHeight / 2), textWidth, this.TextHeight);
          this.Canvas.textAlign = "left";
          this.Canvas.textBaseline = "middle";
          this.Canvas.fillStyle = this.TextColor;
          this.Canvas.fillText(text, bottomWidth - textWidth + 2, 0, textWidth);
        }
        this.Canvas.restore();
      } else
      if (this.ShowTextMode.Right == 2) {
        var xText = x;
        var yText = bottom;
        this.Canvas.save();
        this.Canvas.translate(xText, yText);
        this.Canvas.rotate(90 * Math.PI / 180); //数据和框子旋转180度

        this.Canvas.fillStyle = this.TextBGColor;
        this.Canvas.fillRect(0, -(this.TextHeight / 2), -textWidth, this.TextHeight);
        this.Canvas.textAlign = "right";
        this.Canvas.textBaseline = "middle";
        this.Canvas.fillStyle = this.TextColor;
        this.Canvas.fillText(text, -2, 0, textWidth);

        this.Canvas.restore();
      }
    }

    if (this.ShowTextMode.Bottom === 1 && this.StringFormatX.Operator()) {
      var text = this.StringFormatX.Text;
      this.Canvas.font = this.Font;

      this.Canvas.fillStyle = this.TextBGColor;
      var textWidth = this.Canvas.measureText(text).width + 4; //前后各空2个像素
      if (y - textWidth / 2 < 3) //左边位置不够了, 顶着左边画
        {
          var xText = left;
          var yText = y;
          this.Canvas.save();
          this.Canvas.translate(xText, yText);
          this.Canvas.rotate(90 * Math.PI / 180); //数据和框子旋转180度

          this.Canvas.fillRect(0, 0, textWidth, this.TextHeight);
          this.Canvas.textAlign = "center";
          this.Canvas.textBaseline = "top";
          this.Canvas.fillStyle = this.TextColor;
          this.Canvas.fillText(text, 0, 0, textWidth);

          this.Canvas.restore();
        } else
      {
        var xText = left;
        var yText = y;

        this.Canvas.save();
        this.Canvas.translate(xText, yText);
        this.Canvas.rotate(90 * Math.PI / 180); //数据和框子旋转180度

        this.Canvas.fillRect(-(textWidth / 2), 0, textWidth, this.TextHeight);
        this.Canvas.textAlign = "center";
        this.Canvas.textBaseline = "top";
        this.Canvas.fillStyle = this.TextColor;
        this.Canvas.fillText(text, 0, 0, textWidth);

        this.Canvas.restore();
      }
    }
  };
}

//分钟线
function ChartMinutePriceLine()
{
  this.newMethod = ChartLine; //派生
  this.newMethod();
  delete this.newMethod;

  this.YClose;
  this.IsDrawArea = true; //是否画价格面积图
  this.AreaColor = 'rgba(0,191,255,0.1)';

  this.Draw = function ()
  {
    if (this.NotSupportMessage)
    {
      this.DrawNotSupportmessage();
      return;
    }

    if (!this.IsShow) return;
    if (!this.Data) return;

    var isHScreen = this.ChartFrame.IsHScreen === true;
    var dataWidth = this.ChartFrame.DataWidth;
    var distanceWidth = this.ChartFrame.DistanceWidth;
    var chartright = this.ChartBorder.GetRight();
    if (isHScreen === true) chartright = this.ChartBorder.GetBottom();
    var xPointCount = this.ChartFrame.XPointCount;
    var minuteCount = this.ChartFrame.MinuteCount;
    var bottom = this.ChartBorder.GetBottomEx();
    var left = this.ChartBorder.GetLeftEx();

    var bFirstPoint = true;
    var ptFirst = {}; //第1个点
    var drawCount = 0;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j)
    {
      var value = this.Data.Data[i];
      if (value == null) continue;

      var x = this.ChartFrame.GetXFromIndex(j);
      var y = this.ChartFrame.GetYFromData(value);

      if (bFirstPoint)
      {
        this.Canvas.strokeStyle = this.Color;
        this.Canvas.beginPath();
        if (isHScreen) this.Canvas.moveTo(y, x);else
        this.Canvas.moveTo(x, y);
        bFirstPoint = false;
        ptFirst = { X: x, Y: y };
      } else

      {
        if (isHScreen) this.Canvas.lineTo(y, x);else
        this.Canvas.lineTo(x, y);
      }

      ++drawCount;

      if (drawCount >= minuteCount) //上一天的数据和这天地数据线段要断开
        {
          bFirstPoint = true;
          this.Canvas.stroke();
          if (this.IsDrawArea) //画面积
            {
              if (isHScreen)
              {
                this.Canvas.lineTo(left, x);
                this.Canvas.lineTo(left, ptFirst.X);
                this.SetFillStyle(this.AreaColor, this.ChartBorder.GetRightEx(), bottom, this.ChartBorder.GetLeftEx(), bottom);
              } else

              {
                this.Canvas.lineTo(x, bottom);
                this.Canvas.lineTo(ptFirst.X, bottom);
                this.SetFillStyle(this.AreaColor, left, this.ChartBorder.GetTopEx(), left, bottom);
              }
              this.Canvas.fill();
            }
          drawCount = 0;
        }
    }

    if (drawCount > 0)
    {
      this.Canvas.stroke();
      if (this.IsDrawArea) //画面积
        {
          if (isHScreen)
          {
            this.Canvas.lineTo(left, x);
            this.Canvas.lineTo(left, ptFirst.X);
            this.SetFillStyle(this.AreaColor, this.ChartBorder.GetRightEx(), bottom, this.ChartBorder.GetLeftEx(), bottom);
          } else

          {
            this.Canvas.lineTo(x, bottom);
            this.Canvas.lineTo(ptFirst.X, bottom);
            this.SetFillStyle(this.AreaColor, left, this.ChartBorder.GetTopEx(), left, bottom);
          }
          this.Canvas.fill();
        }
    }
  };

  this.GetMaxMin = function ()
  {
    var xPointCount = this.ChartFrame.XPointCount;
    var range = {};
    if (this.YClose == null) return range;

    range.Min = this.YClose;
    range.Max = this.YClose;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j)
    {
      var value = this.Data.Data[i];
      if (!value) continue;

      if (range.Max == null) range.Max = value;
      if (range.Min == null) range.Min = value;

      if (range.Max < value) range.Max = value;
      if (range.Min > value) range.Min = value;
    }

    if (range.Max == this.YClose && range.Min == this.YClose)
    {
      range.Max = this.YClose + this.YClose * 0.1;
      range.Min = this.YClose - this.YClose * 0.1;
      return range;
    }

    var distance = Math.max(Math.abs(this.YClose - range.Max), Math.abs(this.YClose - range.Min));
    range.Max = this.YClose + distance;
    range.Min = this.YClose - distance;

    return range;
  };
}

////////////////////////////////////////////////////////////////////////////////
//深度图十字光标
function DepthChartCorssCursor()
{
  this.Frame;
  this.Canvas; //画布
  this.Data;
  this.Symbol;
  this.HQChart;

  this.HPenType = 0; //水平线样式 0=虚线 1=实线
  this.VPenType = 0; //垂直线颜色 0=虚线 1=实线
  this.LineDash = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DepthCorss.LineDash;

  this.AskColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DepthCorss.AskColor.Line; //卖
  this.BidColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DepthCorss.BidColor.Line; //买
  this.LineWidth = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DepthCorss.LineWidth;

  this.IsShowTooltip = true;
  this.Tooltip =
  {
    LineHeight: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DepthCorss.Tooltip.LineHeight,
    Border:
    {
      Top: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DepthCorss.Tooltip.Border.Top,
      Left: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DepthCorss.Tooltip.Border.Left,
      Bottom: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DepthCorss.Tooltip.Border.Bottom,
      Center: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DepthCorss.Tooltip.Border.Center },

    Font: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DepthCorss.Tooltip.Font,
    TextColor: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DepthCorss.Tooltip.TextColor,
    BGColor: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DepthCorss.Tooltip.BGColor };
  // Width: Height:

  this.Font = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.CorssCursorTextFont; //字体
  this.TextColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.CorssCursorTextColor; //文本颜色
  this.TextBGColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.CorssCursorBGColor; //文本背景色
  this.TextHeight = 20; //文本字体高度
  this.LastPoint;

  this.PointX;
  this.PointY;

  this.StringFormatX;
  this.StringFormatY;

  this.IsShowCorss = true; //是否显示十字光标
  this.IsShow = true;

  this.GetVol = function (price, isAsk)
  {
    if (!this.Data) return null;
    var aryData = isAsk ? this.Data.Asks : this.Data.Bids;
    if (!aryData || !Array.isArray(aryData) || aryData.length <= 0) return null;

    for (var i in aryData)
    {
      var item = aryData[i];
      if (item.Price == price) return item.Vol;
    }

    return null;
  };

  this.Draw = function ()
  {
    this.Status = 0;
    if (!this.LastPoint) return;
    if (!this.Data) return;
    if (!this.IsShow) return;

    var x = this.LastPoint.X;
    var y = this.LastPoint.Y;

    var isInClient = false;
    var rtClient = new _umychartDataWechat.JSCommon_Rect(this.Frame.ChartBorder.GetLeft(), this.Frame.ChartBorder.GetTop(), this.Frame.ChartBorder.GetWidth(), this.Frame.ChartBorder.GetHeight());
    isInClient = rtClient.IsPointIn(x, y);

    this.PointY = null;
    this.PointY == null;

    if (!isInClient) return;

    if (this.Frame.IsHScreen === true)
    {
      return;
    }

    var left = this.Frame.ChartBorder.GetLeft();
    var right = this.Frame.ChartBorder.GetRight();
    var top = this.Frame.ChartBorder.GetTopTitle();
    var bottom = this.Frame.ChartBorder.GetBottom();
    var rightWidth = this.Frame.ChartBorder.Right;
    var chartRight = this.Frame.ChartBorder.GetChartWidth();

    var xValue = this.Frame.GetXData(x);
    var xInfo = this.Frame.GetXFromPrice(xValue); //调整价格到有数据的点上

    if (!xInfo) return;

    var yVol = this.GetVol(xInfo.Price, xInfo.IsAsk);
    y = this.Frame.GetYFromData(yVol); //调整Y轴, 让它在线段上

    xInfo.Vol = yVol;
    xInfo.Y = y;

    this.PointY = [[left, y], [right, y]];
    this.PointX = [[x, top], [x, bottom]];

    if (this.IsShowCorss)
    {
      if (xInfo.IsAsk) this.Canvas.strokeStyle = this.AskColor;else
      this.Canvas.strokeStyle = this.BidColor;
      this.Canvas.save();
      this.Canvas.lineWidth = this.LineWidth;
      var lineWidth = this.Canvas.lineWidth;

      if (this.HPenType == 1 || this.HPenType == 0) //0=实线 1=虚线
        {
          if (this.HPenType == 0) this.Canvas.setLineDash(this.LineDash); //虚线
          var yFix = ToFixedPoint(y);
          this.Canvas.beginPath();
          this.Canvas.moveTo(left, yFix);
          this.Canvas.lineTo(right, yFix);
          this.Canvas.stroke();
          if (this.HPenType == 0) this.Canvas.setLineDash([]);
        }

      if (this.VPenType == 0) this.Canvas.setLineDash(this.LineDash); //虚线
      var xFix = ToFixedPoint(xInfo.X);
      this.Canvas.beginPath();
      this.Canvas.moveTo(xFix, top);
      this.Canvas.lineTo(xFix, bottom);
      this.Canvas.stroke();
      if (this.VPenType == 0) this.Canvas.setLineDash([]);

      this.Canvas.restore();
    }

    if (this.HQChart)
    {
      //JSCHART_EVENT_ID.ON_DRAW_DEPTH_TOOLTIP
      var event = this.HQChart.GetEvent(25);
      if (event)
      {
        event.Callback(event, xInfo, this);
      }
    }

    if (this.IsShowTooltip) this.DrawTooltip(xInfo);
  };

  this.DrawTooltip = function (data)
  {
    var price = data.Price;
    var vol = data.Vol;
    var border = this.Tooltip.Border;
    this.Canvas.font = this.Tooltip.Font;
    var floatPrecision = 2;
    if (this.Symbol) floatPrecision = _umychartCoordinatedataWechat.JSCommonCoordinateData.GetfloatPrecision(this.Symbol); //价格小数位数
    var maxText = '擎擎: 9999.99亿 ';
    if (floatPrecision >= 5) maxText = "\u64CE\u64CE: ".concat(99.99.toFixed(floatPrecision), " "); //小数位数太多了
    this.Tooltip.Width = this.Canvas.measureText(maxText).width + border.Left;
    this.Tooltip.Height = this.Tooltip.LineHeight * 4 + border.Top + border.Bottom + border.Center;

    var chartRight = this.Frame.ChartBorder.GetRight();
    var chartTop = this.Frame.ChartBorder.GetTop();

    var left = data.X + 2;
    var top = data.Y - this.Tooltip.Height - 2;
    if (left + this.Tooltip.Width >= chartRight) left = data.X - this.Tooltip.Width - 2;
    if (top < chartTop) top = data.Y + 2;

    this.Canvas.fillStyle = this.Tooltip.BGColor;
    this.Canvas.fillRect(left, top, this.Tooltip.Width, this.Tooltip.Height);

    var x = border.Left + left;
    var y = border.Top + top;

    this.Canvas.textBaseline = "top";
    this.Canvas.textAlign = "left";
    this.Canvas.fillStyle = this.Tooltip.TextColor;
    this.Canvas.fillText("委托价", x, y);
    y += this.Tooltip.LineHeight;
    this.Canvas.fillText(data.Price.toFixed(floatPrecision), x, y);
    y += this.Tooltip.LineHeight;
    y += border.Center;

    this.Canvas.fillText("累计", x, y);
    y += this.Tooltip.LineHeight;
    this.Canvas.fillText(data.Vol.toFixed(4), x, y);
  };
}

//深度图
function ChartOrderbookDepth()
{
  this.newMethod = IChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = "ChartOrderbookDepth";
  this.Data = null;

  this.AskColor = { Line: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DepthChart.AskColor.Line, Area: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DepthChart.AskColor.Area }; //卖
  this.BidColor = { Line: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DepthChart.BidColor.Line, Area: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DepthChart.BidColor.Area }; //买
  this.LineWidth = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DepthChart.LineWidth;

  this.Draw = function ()
  {
    if (!this.Data) return;

    this.Canvas.save();
    this.Canvas.lineWidth = this.LineWidth;
    this.DrawArea(this.Data.Bids, this.BidColor.Line, this.BidColor.Area, true);
    this.DrawArea(this.Data.Asks, this.AskColor.Line, this.AskColor.Area, false);
    this.Canvas.restore();
  };

  this.DrawArea = function (aryData, colorLine, colorArea, isLeft)
  {
    var xRange = this.ChartFrame.VerticalRange;
    var aryPoint = [];
    for (var i in aryData)
    {
      var item = aryData[i];
      if (isLeft)
      {
        if (item.Price < xRange.Min) break;
      } else

      {
        if (item.Price > xRange.Max) break;
      }

      var x = this.ChartFrame.GetXFromIndex(item.Price);
      var y = this.ChartFrame.GetYFromData(item.Vol);
      aryPoint.push({ X: x, Y: y });
    }
    if (aryPoint.length <= 1) return;

    var left = this.ChartBorder.GetLeft();
    var bottom = this.ChartBorder.GetBottom();
    var right = this.ChartBorder.GetRight();

    this.Canvas.beginPath();
    this.Canvas.moveTo(aryPoint[0].X, bottom);
    for (var i in aryPoint)
    {
      var item = aryPoint[i];
      this.Canvas.lineTo(item.X, item.Y);
    }

    this.Canvas.lineTo(isLeft ? left : right, aryPoint[aryPoint.length - 1].Y);
    this.Canvas.lineTo(isLeft ? left : right, bottom);
    this.Canvas.lineTo(aryPoint[0].X, bottom);
    this.Canvas.closePath();
    this.Canvas.fillStyle = colorArea;
    this.Canvas.fill();

    this.Canvas.beginPath();
    this.Canvas.moveTo(aryPoint[0].X, bottom);
    for (var i in aryPoint)
    {
      var item = aryPoint[i];
      this.Canvas.lineTo(item.X, item.Y);
    }
    this.Canvas.lineTo(isLeft ? left : right, aryPoint[aryPoint.length - 1].Y);
    this.Canvas.strokeStyle = colorLine;
    this.Canvas.stroke();
  };

  this.GetMaxMin = function ()
  {
    var range = { Min: null, Max: null, XMin: null, XMax: null };
    var xRange = this.ChartFrame.VerticalRange;

    for (var i in this.Data.Asks)
    {
      var item = this.Data.Asks[i];
      if (item.Price > xRange.Max) break;

      if (range.XMin == null || range.XMin > item.Price) range.XMin = item.Price;
      if (range.XMax == null || range.XMax < item.Price) range.XMax = item.Price;
      if (range.Min == null || range.Min > item.Vol) range.Min = item.Vol;
      if (range.Max == null || range.Max < item.Vol) range.Max = item.Vol;
    }

    for (var i in this.Data.Bids)
    {
      var item = this.Data.Bids[i];
      if (item.Price < xRange.Min) break;

      if (range.XMin == null || range.XMin > item.Price) range.XMin = item.Price;
      if (range.XMax == null || range.XMax < item.Price) range.XMax = item.Price;
      if (range.Min == null || range.Min > item.Vol) range.Min = item.Vol;
      if (range.Max == null || range.Max < item.Vol) range.Max = item.Vol;
    }

    return range;
  };
}

///////////////////////////////////////////////////////////////////////////////////////
// 公共函数

//修正线段有毛刺
function ToFixedPoint(value)
{
  //return value;
  return parseInt(value) + 0.5;
}

function ToFixedRect(value)
{
  var rounded;
  return rounded = 0.5 + value << 0;
}

//导出统一使用JSCommon命名空间名
module.exports =
{
  JSCommonChartPaint:
  {
    IChartPaintin: IChartPainting,
    ChartKLine: ChartKLine,
    ChartLine: ChartLine,
    ChartSubLine: ChartSubLine,
    ChartSingleText: ChartSingleText,
    ChartPointDot: ChartPointDot,
    ChartStick: ChartStick,
    ChartLineStick: ChartLineStick,
    ChartStickLine: ChartStickLine,
    ChartOverlayKLine: ChartOverlayKLine,
    ChartMinuteInfo: ChartMinuteInfo,
    ChartRectangle: ChartRectangle,
    ChartMultiText: ChartMultiText,
    ChartMultiHtmlDom: ChartMultiHtmlDom,
    ChartMultiLine: ChartMultiLine,
    ChartBackground: ChartBackground,
    ChartBuySell: ChartBuySell,
    ChartMultiBar: ChartMultiBar,
    ChartMACD: ChartMACD,
    ChartMinutePriceLine: ChartMinutePriceLine,
    ChartLock: ChartLock,
    ChartVolStick: ChartVolStick,
    ChartBand: ChartBand,
    ChartMinuteVolumBar: ChartMinuteVolumBar,
    ChartText: ChartText,
    ChartStraightArea: ChartStraightArea,
    ChartSplashPaint: ChartSplashPaint,
    ChartPie: ChartPie,
    ChartCircle: ChartCircle,
    ChartChinaMap: ChartChinaMap,
    ChartRadar: ChartRadar,

    ChartCorssCursor: ChartCorssCursor, //十字光标 
    DepthChartCorssCursor: DepthChartCorssCursor,
    ChartOrderbookDepth: ChartOrderbookDepth },


  //单个类导出
  JSCommonChartPaint_IChartPainting: IChartPainting,
  JSCommonChartPaint_ChartKLine: ChartKLine,
  JSCommonChartPaint_ChartLine: ChartLine,
  JSCommonChartPaint_ChartSubLine: ChartSubLine,
  JSCommonChartPaint_ChartSingleText: ChartSingleText,
  JSCommonChartPaint_ChartPointDot: ChartPointDot,
  JSCommonChartPaint_ChartStick: ChartStick,
  JSCommonChartPaint_ChartLineStick: ChartLineStick,
  JSCommonChartPaint_ChartStickLine: ChartStickLine,
  JSCommonChartPaint_ChartBackground: ChartBackground,
  JSCommonChartPaint_ChartMinuteVolumBar: ChartMinuteVolumBar,
  JSCommonChartPaint_ChartOverlayKLine: ChartOverlayKLine,
  JSCommonChartPaint_ChartLock: ChartLock,
  JSCommonChartPaint_ChartVolStick: ChartVolStick,
  JSCommonChartPaint_ChartBand: ChartBand,
  JSCommonChartPaint_ChartMinutePriceLine: ChartMinutePriceLine,
  JSCommonChartPaint_ChartPie: ChartPie,
  JSCommonChartPaint_ChartCircle: ChartCircle,
  JSCommonChartPaint_ChartChinaMap: ChartChinaMap,
  JSCommonChartPaint_ChartRadar: ChartRadar,
  JSCommonChartPaint_ChartMinuteInfo: ChartMinuteInfo,
  JSCommonChartPaint_ChartRectangle: ChartRectangle,
  JSCommonChartPaint_ChartMultiText: ChartMultiText,
  JSCommonChartPaint_ChartMultiLine: ChartMultiLine,
  JSCommonChartPaint_ChartMultiHtmlDom: ChartMultiHtmlDom,
  JSCommonChartPaint_ChartMultiBar: ChartMultiBar,
  JSCommonChartPaint_ChartBuySell: ChartBuySell,
  JSCommonChartPaint_ChartMACD: ChartMACD,
  JSCommonChartPaint_ChartText: ChartText,
  JSCommonChartPaint_ChartStraightArea: ChartStraightArea,
  JSCommonChartPaint_ChartCorssCursor: ChartCorssCursor,
  JSCommonChartPaint_DepthChartCorssCursor: DepthChartCorssCursor,
  JSCommonChartPaint_ChartOrderbookDepth: ChartOrderbookDepth,
  JSCommonChartPaint_ChartSplashPaint: ChartSplashPaint };

/***/ }),
/* 111 */
/*!**********************************************************************!*\
  !*** I:/out-project/FCoinEx/static/js/umychart.framesplit.wechat.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";












var _umychartResourceWechat = __webpack_require__(/*! ./umychart.resource.wechat.js */ 106);





var _umychartDataWechat = __webpack_require__(/*! ./umychart.data.wechat.js */ 103);





var _umychartCoordinatedataWechat = __webpack_require__(/*! ./umychart.coordinatedata.wechat.js */ 104); /*
                                                                                        copyright (c) 2018 jones
                                                                                    
                                                                                        http://www.apache.org/licenses/LICENSE-2.0
                                                                                    
                                                                                        开源项目 https://github.com/jones2000/HQChart
                                                                                    
                                                                                        jones_2000@163.com
                                                                                    
                                                                                        坐标轴相关算法
                                                                                    */var MARKET_SUFFIX_NAME = _umychartCoordinatedataWechat.JSCommonCoordinateData.MARKET_SUFFIX_NAME; //坐标信息
function CoordinateInfo() {this.Value; //坐标数据
  this.Message = new Array(); //坐标输出文字信息
  this.TextColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameSplitTextColor; //文字颜色
  this.Font = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameSplitTextFont; //字体
  this.LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameSplitPen; //线段颜色
  this.LineType = 1; //线段类型 -1 不画线段
} /////////////////////////////////////////////////////////////////////////////////////////////////////
//坐标分割
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function IFrameSplitOperator() {this.ChartBorder; //边框信息
  this.Frame; //框架信息
  this.FrameSplitData; //坐标轴分割方法
  this.SplitCount = 5; //刻度个数
  this.StringFormat = 0; //刻度字符串格式 -1 刻度文字全部不显示 -2 刻度文字右边不显示
  this.IsShowLeftText = true; //显示左边刻度 
  this.IsShowRightText = true; //显示右边刻度
  this.LanguageID = _umychartResourceWechat.JSCommonResource_JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID;this.GetEventCallback; //事件回调

  //////////////////////
  // data.Min data.Max data.Interval data.Count
  //
  this.IntegerCoordinateSplit = function (data)
  {
    var splitItem = this.FrameSplitData.Find(data.Interval);
    if (!splitItem) return false;
    if (data.Interval == splitItem.Interval) return true;

    var fixMax = data.Max,fixMin = data.Min;
    var maxValue = data.Max / splitItem.FixInterval;
    var minValue = data.Min / splitItem.FixInterval;
    //调整到整数倍数,不能整除的 +1
    if (IFrameSplitOperator.IsFloat(maxValue)) fixMax = parseInt((maxValue + 0.5).toFixed(0)) * splitItem.FixInterval;
    if (IFrameSplitOperator.IsFloat(minValue)) fixMin = parseInt((minValue - 0.5).toFixed(0)) * splitItem.FixInterval;
    if (data.Min == 0) fixMin = 0; //最小值是0 不用调整了.
    if (fixMin < 0 && data.Min > 0) fixMin = 0; //都是正数的, 最小值最小调整为0

    var count = 0;
    for (var i = fixMin; i - fixMax < 0.00000001; i += splitItem.FixInterval)
    {
      ++count;
    }

    data.Interval = splitItem.FixInterval;
    data.Max = fixMax;
    data.Min = fixMin;
    data.Count = count;

    return true;
  };

  this.Filter = function (aryInfo, keepZero) //keepZero 保留0轴
  {
    if (this.SplitCount <= 0 || aryInfo.length <= 0 || aryInfo.length <= this.SplitCount) return aryInfo;

    //分割线比预设的多, 过掉一些
    var filter = parseInt(aryInfo.length / this.SplitCount);
    if (filter <= 1) filter = 2;
    var data = [];

    for (var i = 0; i < aryInfo.length; i += filter)
    {
      if (i + filter >= aryInfo.length && i != aryInfo.length - 1) //最后一个数据放进去
        {
          data.push(aryInfo[aryInfo.length - 1]);
        } else
      {
        data.push(aryInfo[i]);
      }
    }

    if (this.SplitCount == 2 && data.length > 2) //之显示第1个和最后一个刻度
      {
        for (var i = 1; i < data.length - 1; ++i)
        {
          var item = data[i];
          item.Message[0] = null;
          item.Message[1] = null;
        }
      }

    if (keepZero) //如果不存在0轴,增加一个0轴,刻度信息部显示
      {
        var bExsitZero = false;
        for (var i = 0; i < data; ++i)
        {
          var item = data[i];
          if (Math.abs(item.Value) < 0.00000001)
          {
            bExsitZero = true;
            break;
          }
        }

        if (bExsitZero == false)
        {
          var zeroCoordinate = new CoordinateInfo();
          zeroCoordinate.Value = 0;
          zeroCoordinate.Message[0] = null;
          zeroCoordinate.Message[1] = null;
          data.push(zeroCoordinate);
        }
      }

    return data;
  };

  this.RemoveZero = function (aryInfo) //移除小数后面多余的0
  {
    //所有的数字小数点后面都0,才会去掉
    var isAllZero = [true, true];
    for (var i in aryInfo) {
      var item = aryInfo[i];
      var message = item.Message[0];
      if (!this.IsDecimalZeroEnd(message)) isAllZero[0] = false;

      var message = item.Message[1];
      if (!this.IsDecimalZeroEnd(message)) isAllZero[1] = false;
    }

    if (isAllZero[0] == false && isAllZero[1] == false) return;
    for (var i in aryInfo)
    {
      var item = aryInfo[i];
      if (isAllZero[0])
      {
        var message = item.Message[0];
        if (message != null)
        {
          if (typeof message == 'number') message = message.toString();
          item.Message[0] = message.replace(/[.][0]+/g, '');
        }
      }

      if (isAllZero[1])
      {
        var message = item.Message[1];
        if (message != null)
        {
          if (typeof message == 'number') message = message.toString();
          item.Message[1] = message.replace(/[.][0]+/g, '');
        }
      }
    }
  };

  this.IsDecimalZeroEnd = function (text) //是否是0结尾的小数
  {
    if (text == null) return true;
    if (text == '0') return true;
    if (typeof text == 'number') text = text.toString();

    var pos = text.search(/[.]/);
    if (pos < 0) return false;

    for (var i = pos + 1; i < text.length; ++i)
    {
      var char = text.charAt(i);
      if (char >= '1' && char <= '9') return false;
    }

    return true;
  };
}

//字符串格式化 千分位分割
IFrameSplitOperator.FormatValueThousandsString = function (value, floatPrecision)
{
  if (value == null || isNaN(value))
  {
    if (floatPrecision > 0)
    {
      var nullText = '-.';
      for (var i = 0; i < floatPrecision; ++i) {
        nullText += '-';}
      return nullText;
    }

    return '--';
  }

  var result = '';
  var num = value.toFixed(floatPrecision);
  if (floatPrecision > 0) {
    var numFloat = num.split('.')[1];
    var numM = num.split('.')[0];
    while (numM.length > 3)
    {
      result = ',' + numM.slice(-3) + result;
      numM = numM.slice(0, numM.length - 3);
    }
    if (numM) {result = numM + result + '.' + numFloat;}
  } else {
    while (num.length > 3)
    {
      result = ',' + num.slice(-3) + result;
      num = num.slice(0, num.length - 3);
    }
    if (num) {result = num + result;}
  }

  return result;
};

//数据输出格式化 floatPrecision=小数位数
IFrameSplitOperator.FormatValueString = function (value, floatPrecision, languageID)
{
  if (value == null || isNaN(value))
  {
    if (floatPrecision > 0)
    {
      var nullText = '-.';
      for (var i = 0; i < floatPrecision; ++i) {
        nullText += '-';}
      return nullText;
    }

    return '--';
  }

  if (value < 0.00000000001 && value > -0.00000000001)
  {
    return "0";
  }

  var absValue = Math.abs(value);
  if (languageID === _umychartResourceWechat.JSCommonResource_JSCHART_LANGUAGE_ID.LANGUAGE_ENGLISH_ID)
  {
    if (absValue < 10000)
    return value.toFixed(floatPrecision);else
    if (absValue < 1000000)
    return (value / 1000).toFixed(floatPrecision) + "K";else
    if (absValue < 1000000000)
    return (value / 1000000).toFixed(floatPrecision) + "M";else
    if (absValue < 1000000000000)
    return (value / 1000000000).toFixed(floatPrecision) + "B";else

    return (value / 1000000000000).toFixed(floatPrecision) + "T";
  } else

  {
    if (absValue < 10000)
    return value.toFixed(floatPrecision);else
    if (absValue < 100000000)
    return (value / 10000).toFixed(floatPrecision) + "万";else
    if (absValue < 1000000000000)
    return (value / 100000000).toFixed(floatPrecision) + "亿";else

    return (value / 1000000000000).toFixed(floatPrecision) + "万亿";
  }

  return '';
};

//整形输出格式化 floatPrecision=小数位数
IFrameSplitOperator.FromatIntegerString = function (value, floatPrecision, languageID)
{
  if (value < 10000 && IFrameSplitOperator.IsInteger(value)) floatPrecision = 0; //<10000的整形 去掉小数位数
  return IFrameSplitOperator.FormatValueString(value, floatPrecision, languageID);
};

IFrameSplitOperator.NumberToString = function (value)
{
  if (value < 10) return '0' + value.toString();
  return value.toString();
};

IFrameSplitOperator.FormatDateString = function (value, format)
{
  var year = parseInt(value / 10000);
  var month = parseInt(value / 100) % 100;
  var day = value % 100;

  switch (format) {

    case 'MM-DD':
      return IFrameSplitOperator.NumberToString(month) + '-' + IFrameSplitOperator.NumberToString(day);
    default:
      return year.toString() + '-' + IFrameSplitOperator.NumberToString(month) + '-' + IFrameSplitOperator.NumberToString(day);}

};

IFrameSplitOperator.FormatTimeString = function (value, format) //format hh:mm:ss
{
  if (format == 'HH:MM:SS')
  {
    var hour = parseInt(value / 10000);
    var minute = parseInt(value % 10000 / 100);
    var second = value % 100;
    return IFrameSplitOperator.NumberToString(hour) + ':' + IFrameSplitOperator.NumberToString(minute) + ':' + IFrameSplitOperator.NumberToString(second);
  } else
  if (format == 'HH:MM')
  {
    var hour = parseInt(value / 100);
    var minute = value % 100;
    return IFrameSplitOperator.NumberToString(hour) + ':' + IFrameSplitOperator.NumberToString(minute);
  } else

  {
    if (value < 10000)
    {
      var hour = parseInt(value / 100);
      var minute = value % 100;
      return IFrameSplitOperator.NumberToString(hour) + ':' + IFrameSplitOperator.NumberToString(minute);
    } else

    {
      var hour = parseInt(value / 10000);
      var minute = parseInt(value % 10000 / 100);
      var second = value % 100;
      return IFrameSplitOperator.NumberToString(hour) + ':' + IFrameSplitOperator.NumberToString(minute) + ':' + IFrameSplitOperator.NumberToString(second);
    }

  }
};

//报告格式化
IFrameSplitOperator.FormatReportDateString = function (value)
{
  var year = parseInt(value / 10000);
  var month = parseInt(value / 100) % 100;
  var monthText;
  switch (month) {

    case 3:
      monthText = "一季度报";
      break;
    case 6:
      monthText = "半年报";
      break;
    case 9:
      monthText = "三季度报";
      break;
    case 12:
      monthText = "年报";
      break;}


  return year.toString() + monthText;
};

IFrameSplitOperator.FormatDateTimeString = function (value, isShowDate)
{
  var aryValue = value.split(' ');
  if (aryValue.length < 2) return "";
  var time = parseInt(aryValue[1]);
  var minute = time % 100;
  var hour = parseInt(time / 100);
  var text = (hour < 10 ? '0' + hour.toString() : hour.toString()) + ':' + (minute < 10 ? '0' + minute.toString() : minute.toString());

  if (isShowDate == true)
  {
    var date = parseInt(aryValue[0]);
    var year = parseInt(date / 10000);
    var month = parseInt(date % 10000 / 100);
    var day = date % 100;
    text = year.toString() + '-' + (month < 10 ? '0' + month.toString() : month.toString()) + '-' + (day < 10 ? '0' + day.toString() : day.toString()) + " " + text;
  }

  return text;
};

//字段颜色格式化
IFrameSplitOperator.FormatValueColor = function (value, value2)
{
  if (value != null && value2 == null) //只传一个值的 就判断value正负
    {
      if (value == 0) return 'PriceNull';else
      if (value > 0) return 'PriceUp';else
      return 'PriceDown';
    }

  //2个数值对比 返回颜色
  if (value == null || value2 == null) return 'PriceNull';
  if (value == value2) return 'PriceNull';else
  if (value > value2) return 'PriceUp';else
  return 'PriceDown';
};

IFrameSplitOperator.IsNumber = function (value)
{
  if (value == null) return false;
  if (isNaN(value)) return false;

  return true;
};

//判断是否是正数
IFrameSplitOperator.IsPlusNumber = function (value)
{
  if (value == null) return false;
  if (isNaN(value)) return false;

  return value > 0;
};

//是否是整形
IFrameSplitOperator.IsInteger = function (x)
{
  return typeof x === 'number' && x % 1 === 0;
};

//判断字段是否存在
IFrameSplitOperator.IsObjectExist = function (obj)
{
  if (obj === undefined) return false;
  if (obj == null) return false;

  return true;
};

//是否时bool
IFrameSplitOperator.IsBool = function (value)
{
  if (value === true || value === false) return true;
  return false;
};

IFrameSplitOperator.IsString = function (value)
{
  if (value && typeof value == 'string') return true;
  return false;
};

IFrameSplitOperator.IsFloat = function (value)
{
  if (value === undefined) return false;
  if (value == null) return false;
  if (isNaN(value)) return false;

  return value != parseInt(value);
};

//是否是非空的数组
IFrameSplitOperator.IsNonEmptyArray = function (ary)
{
  if (!ary) return;
  if (!Array.isArray(ary)) return;

  return ary.length > 0;
};

//K线Y轴分割
function FrameSplitKLinePriceY()
{
  this.newMethod = IFrameSplitOperator; //派生
  this.newMethod();
  delete this.newMethod;

  this.CoordinateType = 0; //坐标类型 0=普通坐标  1=百分比坐标 (右边坐标刻度)
  this.Symbol;
  this.Data; //K线数据 (计算百分比坐标)
  this.FrameSplitData2; //坐标轴分割方法(计算百分比刻度)
  this.FloatPrecision = null; //小数位数 (设置了就使用这个位数,否则使用品种对应的小数位数)

  this.Custom = []; //[{Type:0}];   定制刻度 0=显示最后的价格刻度
  this.SplitType = 0; //0=自动分割  1=固定分割

  this.Operator = function ()
  {
    var splitData = {};
    splitData.Max = this.Frame.HorizontalMax;
    splitData.Min = this.Frame.HorizontalMin;
    splitData.Count = this.SplitCount;
    if (splitData.Max == splitData.Min) //如果一样上下扩大下
      {
        splitData.Max += splitData.Max * 0.01;
        splitData.Min -= splitData.Min * 0.01;
      }
    splitData.Interval = (splitData.Max - splitData.Min) / (splitData.Count - 1);

    var defaultfloatPrecision = _umychartCoordinatedataWechat.JSCommonCoordinateData.GetfloatPrecision(this.Symbol);
    if (_umychartCoordinatedataWechat.JSCommonCoordinateData.MARKET_SUFFIX_NAME.IsSHSZIndex(this.Symbol)) defaultfloatPrecision = 0; //手机端指数不显示小数位数
    if (this.FloatPrecision != null) defaultfloatPrecision = this.FloatPrecision;

    var bFilter = true;
    if (FrameSplitKLinePriceY.SplitCustom)
    {
      FrameSplitKLinePriceY.SplitCustom(this, splitData, defaultfloatPrecision); //自定义分割
      bFilter = false;
    } else

    {
      switch (this.CoordinateType) {

        case 1:
          this.SplitPercentage(splitData, defaultfloatPrecision);
          break;
        default:
          if (this.SplitType == 1) this.SplitFixed(splitData, defaultfloatPrecision);else
          this.SplitDefault(splitData, defaultfloatPrecision);
          this.CustomCoordinate(defaultfloatPrecision);
          break;}

    }

    if (bFilter) this.Frame.HorizontalInfo = this.Filter(this.Frame.HorizontalInfo, false);
    this.Frame.HorizontalMax = splitData.Max;
    this.Frame.HorizontalMin = splitData.Min;

    if (this.GetEventCallback)
    {
      var event = this.GetEventCallback(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.ON_SPLIT_YCOORDINATE);
      if (event && event.Callback)
      {
        var data = { ID: this.Frame.Identify, Frame: this.Frame };
        event.Callback(event, data, this);
      }
    }
  };

  this.SplitDefault = function (splitData, floatPrecision) //默认坐标
  {
    this.IntegerCoordinateSplit(splitData);

    this.Frame.HorizontalInfo = [];
    for (var i = 0, value = splitData.Min; i < splitData.Count; ++i, value += splitData.Interval)
    {
      this.Frame.HorizontalInfo[i] = new CoordinateInfo();
      this.Frame.HorizontalInfo[i].Value = value;
      if (this.IsShowLeftText) this.Frame.HorizontalInfo[i].Message[0] = value.toFixed(floatPrecision);
      if (this.IsShowRightText) this.Frame.HorizontalInfo[i].Message[1] = value.toFixed(floatPrecision);
    }
  };

  this.SplitPercentage = function (splitData, floatPrecision) //百分比坐标
  {
    var firstOpenPrice = this.GetFirstOpenPrice();
    splitData.Max = (splitData.Max - firstOpenPrice) / firstOpenPrice;
    splitData.Min = (splitData.Min - firstOpenPrice) / firstOpenPrice;
    splitData.Interval = (splitData.Max - splitData.Min) / (splitData.Count - 1);
    this.IntegerCoordinateSplit2(splitData);

    this.Frame.HorizontalInfo = [];
    for (var i = 0, value = splitData.Min; i < splitData.Count; ++i, value += splitData.Interval)
    {
      var price = (value + 1) * firstOpenPrice;
      this.Frame.HorizontalInfo[i] = new CoordinateInfo();
      this.Frame.HorizontalInfo[i].Value = price;
      if (this.IsShowLeftText) this.Frame.HorizontalInfo[i].Message[0] = price.toFixed(floatPrecision); //左边价格坐标      
      if (this.IsShowRightText) this.Frame.HorizontalInfo[i].Message[1] = (value * 100).toFixed(2) + '%'; //右边百分比
    }

    splitData.Min = (1 + splitData.Min) * firstOpenPrice; //最大最小值调整
    splitData.Max = (1 + splitData.Max) * firstOpenPrice;
  };

  this.SplitFixed = function (splitData, floatPrecision) //固定分割坐标
  {
    this.Frame.HorizontalInfo = [];
    for (var i = 0, value = splitData.Min; i < splitData.Count; ++i, value += splitData.Interval) {
      this.Frame.HorizontalInfo[i] = new CoordinateInfo();
      this.Frame.HorizontalInfo[i].Value = value;
      if (this.IsShowLeftText) this.Frame.HorizontalInfo[i].Message[0] = value.toFixed(floatPrecision);
      if (this.IsShowRightText) this.Frame.HorizontalInfo[i].Message[1] = value.toFixed(floatPrecision);
    }
  };

  this.CustomCoordinate = function (floatPrecision)
  {
    this.Frame.CustomHorizontalInfo = [];
    for (var i in this.Custom)
    {
      var item = this.Custom[i];
      if (item.Type == 0) //最新价格刻度
        {
          var dec = floatPrecision;
          //外部设置小数位数
          if (IFrameSplitOperator.IsNumber(item.FloatPrecision) && item.FloatPrecision >= 0) dec = item.FloatPrecision;
          var latestItem = this.GetLatestPrice(dec, item);
          if (latestItem) this.Frame.CustomHorizontalInfo.push(latestItem);
        } else
      if (item.Type == 1) //固定价格刻度
        {
          this.CustomFixedCoordinate(item);
        }
    }
  };

  this.GetLatestPrice = function (floatPrecision, option)
  {
    if (!this.Data || !this.Data.Data) return null;
    if (this.Data.Data.length <= 0) return null;
    var latestItem = this.Data.Data[this.Data.Data.length - 1];
    var info = new CoordinateInfo();
    info.Type = 0;
    info.Value = latestItem.Close;
    info.TextColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLatestPrice.TextColor;
    info.LineType = 2; //虚线
    latestItem.Close = parseFloat(latestItem.Close);
    if (option.Position == 'left') info.Message[0] = latestItem.Close.toFixed(floatPrecision);else
    info.Message[1] = latestItem.Close.toFixed(floatPrecision);
    if (latestItem.Close > latestItem.Open) info.LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLatestPrice.UpBarColor;else
    if (latestItem.Close < latestItem.Open) info.LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLatestPrice.DownBarColor;else
    info.LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLatestPrice.UnchagneBarColor;

    if (IFrameSplitOperator.IsNumber(option.LineType)) info.LineType = option.LineType;
    if (option.IsShowLine == false) info.LineType = -1;

    return info;
  };

  this.GetFirstOpenPrice = function () //获取显示第1个数据的开盘价
  {
    if (!this.Data) return null;
    var xPointCount = this.Frame.XPointCount;
    for (var i = this.Data.DataOffset, j = 0; i < this.Data.Data.length && j < xPointCount; ++i, ++j)
    {
      var data = this.Data.Data[i];
      if (data.Open == null || data.High == null || data.Low == null || data.Close == null) continue;

      return data.Open;
    }
    return null;
  };

  this.CustomFixedCoordinate = function (option) //固定坐标刻度
  {
    var defaultfloatPrecision = _umychartCoordinatedataWechat.JSCommonCoordinateData.GetfloatPrecision(this.Symbol);
    for (var i in option.Data)
    {
      var item = option.Data[i];
      var info = new CoordinateInfo();
      info.Type = 1;
      info.TextColor = item.TextColor;
      info.LineColor = item.Color;
      info.LineType = 2; //虚线
      if (IFrameSplitOperator.IsNumber(option.LineType)) info.LineType = option.LineType;
      if (option.IsShowLine == false) info.LineType = -1;

      info.Value = item.Value;
      var text;
      if (item.Text) text = item.Text;else
      text = info.Value.toFixed(defaultfloatPrecision);
      if (option.Position == 'left') info.Message[0] = text;else
      info.Message[1] = text;

      this.Frame.CustomHorizontalInfo.push(info);
    }
  };


  //////////////////////
  // data.Min data.Max data.Interval data.Count
  //
  this.IntegerCoordinateSplit2 = function (data)
  {
    var splitItem = this.FrameSplitData2.Find(data.Interval);
    if (!splitItem) return false;
    if (data.Interval == splitItem.FixInterval) return true;

    var fixMax = data.Max,fixMin = data.Min;
    var maxValue = data.Max / splitItem.FixInterval;
    var minValue = data.Min / splitItem.FixInterval;
    //调整到整数倍数,不能整除的 +1
    if (IFrameSplitOperator.IsFloat(maxValue)) fixMax = parseInt((maxValue + 0.5).toFixed(0)) * splitItem.FixInterval;
    if (IFrameSplitOperator.IsFloat(minValue)) fixMin = parseInt((minValue - 0.5).toFixed(0)) * splitItem.FixInterval;
    if (data.Min == 0) fixMin = 0; //最小值是0 不用调整了.
    if (fixMin < 0 && data.Min > 0) fixMin = 0; //都是正数的, 最小值最小调整为0

    var count = 0;
    for (var i = fixMin; i - fixMax < 0.00000001; i += splitItem.FixInterval)
    {
      ++count;
    }

    data.Interval = splitItem.FixInterval;
    data.Max = fixMax;
    data.Min = fixMin;
    data.Count = count;

    return true;
  };

}

//一般的Y轴分割
function FrameSplitY()
{
  this.newMethod = IFrameSplitOperator; //派生
  this.newMethod();
  delete this.newMethod;
  this.SplitType = 0; //0=自动分割  1=固定分割
  this.FloatPrecision = 2; //坐标小数位数(默认2)
  this.FLOATPRECISION_RANGE = [1, 0.1, 0.01, 0.001, 0.0001];
  this.IgnoreYValue = null; //在这个数组里的数字不显示在刻度上 
  this.LineType = null; //线段样式

  this.IsShowYZero = true;
  this.IntegerSplitData = null;

  this.Operator = function ()
  {
    var splitData = {};
    splitData.Max = this.Frame.HorizontalMax;
    splitData.Min = this.Frame.HorizontalMin;
    if (this.Frame.YSpecificMaxMin)
    {
      splitData.Count = this.Frame.YSpecificMaxMin.Count;
      splitData.Interval = (splitData.Max - splitData.Min) / (splitData.Count - 1);
    } else
    if (this.SplitType == 1)
    {
      splitData.Count = this.SplitCount;
      splitData.Interval = (splitData.Max - splitData.Min) / (splitData.Count - 1);
    } else

    {
      splitData.Count = this.SplitCount * 2; //放大两倍
      if (this.FloatPrecision == 0) //页面配置了纵坐标小数位数FloatPrecision=0时执行
        {
          splitData.Interval = (splitData.Max - splitData.Min) / (splitData.Count - 1);
          this.IntegerCoordinateSplit2(splitData);
        } else
      {
        splitData.Interval = (splitData.Max - splitData.Min) / (splitData.Count - 1);
        this.IntegerCoordinateSplit(splitData);
      }
    }

    this.Frame.HorizontalInfo = [];
    if (this.Frame.YSplitScale)
    {
      for (var i in this.Frame.YSplitScale)
      {
        var value = this.Frame.YSplitScale[i];
        var coordinate = new CoordinateInfo();
        coordinate.Value = value;
        if (IFrameSplitOperator.IsNumber(this.LineType)) coordinate.LineType = this.LineType;

        var absValue = Math.abs(value);
        var floatPrecision = this.FloatPrecision; //数据比小数位数还小, 调整小数位数
        if (absValue < 0.0000000001)
        coordinate.Message[1] = 0;else
        if (absValue < this.FLOATPRECISION_RANGE[this.FLOATPRECISION_RANGE.length - 1])
        coordinate.Message[1] = value.toExponential(2).toString();else

        {
          if (floatPrecision < this.FLOATPRECISION_RANGE.length && absValue < this.FLOATPRECISION_RANGE[floatPrecision]) ++floatPrecision;
          if (floatPrecision < this.FLOATPRECISION_RANGE.length && absValue < this.FLOATPRECISION_RANGE[floatPrecision]) ++floatPrecision;
          if (floatPrecision < this.FLOATPRECISION_RANGE.length && absValue < this.FLOATPRECISION_RANGE[floatPrecision]) ++floatPrecision;
          coordinate.Message[1] = IFrameSplitOperator.FormatValueString(value, floatPrecision, this.LanguageID);
        }
        coordinate.Message[0] = coordinate.Message[1];

        if (this.StringFormat == -2) coordinate.Message[1] = null; //刻度右边不显示
        else if (this.StringFormat == -3) coordinate.Message[0] = null; //刻度左边不显示
          else if (this.StringFormat == -1) coordinate.Message[0] = coordinate.Message[1] = null; //刻度左右都不显示

        this.Frame.HorizontalInfo.push(coordinate);
      }
    } else

    {
      for (var i = 0, value = splitData.Min; i < splitData.Count; ++i, value += splitData.Interval)
      {
        var coordinate = new CoordinateInfo();
        this.Frame.HorizontalInfo[i] = coordinate;
        coordinate.Value = value;
        if (IFrameSplitOperator.IsNumber(this.LineType)) coordinate.LineType = this.LineType;

        if (this.StringFormat == 1) //手机端格式 如果有万,亿单位了 去掉小数
          {
            var floatPrecision = this.FloatPrecision;
            if (!isNaN(value) && Math.abs(value) > 1000) floatPrecision = 0;
            this.Frame.HorizontalInfo[i].Message[1] = IFrameSplitOperator.FormatValueString(value, floatPrecision, this.LanguageID);
          } else
        if (this.StringFormat == -1) //刻度不显示
          {

          } else

        {
          var absValue = Math.abs(value);
          var floatPrecision = this.FloatPrecision; //数据比小数位数还小, 调整小数位数
          if (absValue < 0.0000000001)
          this.Frame.HorizontalInfo[i].Message[1] = 0;else
          if (absValue < this.FLOATPRECISION_RANGE[this.FLOATPRECISION_RANGE.length - 1])
          this.Frame.HorizontalInfo[i].Message[1] = value.toExponential(2).toString();else
          {
            if (floatPrecision < this.FLOATPRECISION_RANGE.length && absValue < this.FLOATPRECISION_RANGE[floatPrecision]) ++floatPrecision;
            if (floatPrecision < this.FLOATPRECISION_RANGE.length && absValue < this.FLOATPRECISION_RANGE[floatPrecision]) ++floatPrecision;
            if (floatPrecision < this.FLOATPRECISION_RANGE.length && absValue < this.FLOATPRECISION_RANGE[floatPrecision]) ++floatPrecision;
            this.Frame.HorizontalInfo[i].Message[1] = IFrameSplitOperator.FormatValueString(value, floatPrecision, this.LanguageID);
          }
        }

        this.Frame.HorizontalInfo[i].Message[0] = this.Frame.HorizontalInfo[i].Message[1];

        if (this.StringFormat == -2) this.Frame.HorizontalInfo[i].Message[1] = null; //刻度右边不显示
        else if (this.StringFormat == -3) this.Frame.HorizontalInfo[i].Message[0] = null; //刻度左边不显示
      }
    }

    this.FilterIgnoreYValue();
    this.Frame.HorizontalInfo = this.Filter(this.Frame.HorizontalInfo, splitData.Max > 0 && splitData.Min < 0 && this.IsShowYZero);
    this.RemoveZero(this.Frame.HorizontalInfo);
    this.Frame.HorizontalMax = splitData.Max;
    this.Frame.HorizontalMin = splitData.Min;

    if (this.GetEventCallback)
    {
      var event = this.GetEventCallback(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.ON_SPLIT_YCOORDINATE);
      if (event && event.Callback)
      {
        var data = { ID: this.Frame.Identify, Frame: this.Frame };
        event.Callback(event, data, this);
      }
    }
  };

  this.FilterIgnoreYValue = function ()
  {
    if (!this.IgnoreYValue || this.IgnoreYValue.length <= 0) return;

    var setValue = new Set(this.IgnoreYValue);
    this.Frame.HorizontalInfo = this.Frame.HorizontalInfo.filter(function (item) {return !setValue.has(item.Value);});
    this.IsShowYZero = !setValue.has(0); //是否显示0刻度
  };

  this.IntegerCoordinateSplit2 = function (data) //整数分割
  {
    if (this.IntegerSplitData == null) this.IntegerSplitData = new IntegerSplitData();
    //最大最小调整为整数
    if (data.Max > 0) data.Max = parseInt(data.Max + 0.5);else
    if (data.Max < 0) data.Max = parseInt(data.Max - 0.5);
    if (data.Min > 0) data.Min = parseInt(data.Min - 0.5);else
    if (data.Min < 0) data.Min = parseInt(data.Min + 0.5);

    data.Interval = (data.Max - data.Min) / (data.Count - 1);
    var splitItem = this.IntegerSplitData.Find(data.Interval);
    if (!splitItem) return false;

    if (data.Interval == splitItem.Interval) return true;

    var fixMax = parseInt((data.Max / splitItem.FixInterval + 0.5).toFixed(0)) * splitItem.FixInterval + 0.5;
    var fixMin = parseInt((data.Min / splitItem.FixInterval - 0.5).toFixed(0)) * splitItem.FixInterval;
    if (data.Min == 0) fixMin = 0;
    if (fixMin < 0 && data.Min > 0) fixMin = 0;
    var count = 0;
    for (var i = fixMin; i - fixMax < 0.00000001; i += splitItem.FixInterval)
    {
      ++count;
    }
    data.Interval = splitItem.FixInterval;
    data.Max = fixMax;
    data.Min = fixMin;
    data.Count = count;

    return true;
  };
}

function FrameSplitKLineX()
{
  this.newMethod = IFrameSplitOperator; //派生
  this.newMethod();
  delete this.newMethod;

  this.ShowText = true; //是否显示坐标信息
  this.MinDistance = 12; //刻度间隔
  this.Period; //周期
  this.Symbol; //股票代码
  this.MinTextDistance = 50;

  this.SplitDateTime = function () //根据时间分割
  {
    this.Frame.VerticalInfo = [];
    var itemWidth = this.Frame.DistanceWidth + this.Frame.DataWidth;
    var xOffset = this.Frame.Data.DataOffset;
    var xPointCount = this.Frame.XPointCount;
    var lastYear = null,lastMonth = null;
    var textDistance = 0;

    for (var i = 0, index = xOffset; i < xPointCount && index < this.Frame.Data.Data.length; ++i, ++index)
    {
      textDistance += itemWidth;
      var infoData = null;
      if (i == 0)
      {
        var date = IFrameSplitOperator.FormatDateString(this.Frame.Data.Data[index].Date, 'MM-DD');
        infoData = { Value: index - xOffset, Text: date };
      } else
      if (textDistance > this.MinTextDistance)
      {
        var time = IFrameSplitOperator.FormatTimeString(this.Frame.Data.Data[index].Time);
        infoData = { Value: index - xOffset, Text: time };
      }

      if (infoData)
      {
        var info = new CoordinateInfo();
        info.Value = infoData.Value;
        if (this.ShowText) info.Message[0] = infoData.Text;
        this.Frame.VerticalInfo.push(info);
        textDistance = 0;
        if (i == 0) textDistance = -(this.MinTextDistance / 2);
      }
    }
  };

  this.SplitSecond = function () //根据时间分割
  {
    this.Frame.VerticalInfo = [];
    var itemWidth = this.Frame.DistanceWidth + this.Frame.DataWidth;
    var xOffset = this.Frame.Data.DataOffset;
    var xPointCount = this.Frame.XPointCount;
    var lastYear = null,lastMonth = null;
    var textDistance = 0;

    for (var i = 0, index = xOffset; i < xPointCount && index < this.Frame.Data.Data.length; ++i, ++index)
    {
      textDistance += itemWidth;
      var infoData = null;
      if (i == 0)
      {
        var date = IFrameSplitOperator.FormatDateString(this.Frame.Data.Data[index].Date, 'MM-DD');
        infoData = { Value: index - xOffset, Text: date };
      } else
      if (textDistance > this.MinTextDistance)
      {
        var time = IFrameSplitOperator.FormatTimeString(this.Frame.Data.Data[index].Time, "HH:MM:SS");
        infoData = { Value: index - xOffset, Text: time };
      }

      if (infoData)
      {
        var info = new CoordinateInfo();
        info.Value = infoData.Value;
        if (this.ShowText) info.Message[0] = infoData.Text;
        this.Frame.VerticalInfo.push(info);
        textDistance = 0;
        if (i == 0) textDistance = -(this.MinTextDistance / 2);
      }
    }
  };

  this.SplitDate = function () //根据日期分割
  {
    this.Frame.VerticalInfo = [];
    var xOffset = this.Frame.Data.DataOffset;
    var xPointCount = this.Frame.XPointCount;
    var lastYear = null,lastMonth = null;
    var monthCount = 0;

    for (var i = 0, index = xOffset, distance = this.MinDistance; i < xPointCount && index < this.Frame.Data.Data.length; ++i, ++index)
    {
      var year = parseInt(this.Frame.Data.Data[index].Date / 10000);
      var month = parseInt(this.Frame.Data.Data[index].Date / 100) % 100;
      if (lastMonth != month) ++monthCount;

      if (distance < this.MinDistance && lastYear == year ||
      lastYear != null && lastYear == year && lastMonth != null && lastMonth == month)
      {
        lastMonth = month;
        ++distance;
        continue;
      }

      var info = new CoordinateInfo();
      info.Value = index - xOffset;
      //info.TextColor = "rgb(51,51,51)";
      var text;
      if (lastYear == null || lastYear != year)
      {
        text = year.toString();
      } else
      if (lastMonth == null || lastMonth != month)
      {
        text = month.toString() + "月";
      }

      lastYear = year;
      lastMonth = month;

      if (this.ShowText)
      {
        info.Message[0] = text;
      }

      this.Frame.VerticalInfo.push(info);
      distance = 0;
    }

    if (this.Period == 0 && monthCount <= 2)
    this.SplitShortDate();
  };

  //分隔在2个月一下的格式
  this.SplitShortDate = function ()
  {
    this.Frame.VerticalInfo = [];
    var xOffset = this.Frame.Data.DataOffset;
    var xPointCount = this.Frame.XPointCount;
    var minDistance = 12;
    var isFirstYear = true;
    for (var i = 0, index = xOffset, distance = minDistance; i < xPointCount && index < this.Frame.Data.Data.length; ++i, ++index) {
      var year = parseInt(this.Frame.Data.Data[index].Date / 10000);
      //var month=parseInt(this.Frame.Data.Data[index].Date/100)%100;
      //var day=parseInt(this.Frame.Data.Data[index].Date%100);

      if (distance < minDistance)
      {
        ++distance;
        continue;
      }

      var info = new CoordinateInfo();
      info.Value = index - xOffset;
      var text;
      if (isFirstYear)
      {
        text = year.toString();
        isFirstYear = false;
      } else

      {
        text = IFrameSplitOperator.FormatDateString(this.Frame.Data.Data[index].Date, 'MM-DD');
      }

      if (this.ShowText)
      {
        info.Message[0] = text;
      }

      this.Frame.VerticalInfo.push(info);
      distance = 0;
    }
  };

  this.Operator = function ()
  {
    if (this.Frame.Data == null) return;
    if (FrameSplitKLineX.SplitCustom) FrameSplitKLineX.SplitCustom(this); //自定义分割
    else if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(this.Period, true)) this.SplitDateTime();else
      if (_umychartDataWechat.JSCommon_ChartData.IsSecondPeriod(this.Period)) this.SplitSecond();else
      this.SplitDate();
  };

  this.CreateCoordinateInfo = function ()
  {
    return new CoordinateInfo(); //创建一个节点坐标
  };
}

//FrameSplitKLineX.SplitCustom=function(split) { }

function FrameSplitMinutePriceY()
{
  this.newMethod = IFrameSplitOperator; //派生
  this.newMethod();
  delete this.newMethod;

  this.High = null; //最高最低价
  this.Low = null;

  this.YClose; //昨收
  this.Data; //分钟数据
  this.AverageData; //分钟均线数据
  this.OverlayChartPaint;
  this.SplitCount = 7;
  this.Symbol;
  this.Custom;

  this.Operator = function ()
  {
    this.Frame.HorizontalInfo = [];
    this.Frame.CustomHorizontalInfo = [];
    if (!this.Data) return;

    var range = this.GetMaxMin();

    this.DefaultSplit(range);
    this.CustomCoordinate();

    if (this.GetEventCallback)
    {
      var event = this.GetEventCallback(_umychartDataWechat.JSCommon_JSCHART_EVENT_ID.ON_SPLIT_YCOORDINATE);
      if (event && event.Callback)
      {
        var data = { ID: this.Frame.Identify, Frame: this.Frame };
        event.Callback(event, data, this);
      }
    }
  };

  this.GetMaxMin = function () //计算图中所有的数据的最大最小值
  {
    var max = this.YClose;
    var min = this.YClose;

    for (var i in this.Data.Data)
    {
      if (!this.Data.Data[i]) continue; //价格必须大于0
      if (max < this.Data.Data[i]) max = this.Data.Data[i];
      if (min > this.Data.Data[i]) min = this.Data.Data[i];
    }

    if (this.AverageData)
    {
      for (var i in this.AverageData.Data)
      {
        if (!this.AverageData.Data[i]) continue; //价格必须大于0
        if (max < this.AverageData.Data[i]) max = this.AverageData.Data[i];
        if (min > this.AverageData.Data[i]) min = this.AverageData.Data[i];
      }
    }

    if (this.OverlayChartPaint && this.OverlayChartPaint.length > 0 && this.OverlayChartPaint[0] && this.OverlayChartPaint[0].Symbol)
    {
      var range = this.OverlayChartPaint[0].GetMaxMin();
      if (range.Max && range.Max > max) max = range.Max;
      if (range.Min && range.Min < min) min = range.Min;
    }

    if (IFrameSplitOperator.IsNumber(this.High) && IFrameSplitOperator.IsNumber(this.Low))
    {
      if (max < this.High) max = this.High;
      if (min > this.Low) min = this.Low;
    }

    return { Max: max, Min: min };
  };

  this.DefaultSplit = function (range)
  {
    var max = range.Max;
    var min = range.Min;

    if (this.YClose == max && this.YClose == min)
    {
      max = this.YClose + this.YClose * 0.1;
      min = this.YClose - this.YClose * 0.1;
    } else

    {
      var distanceValue = Math.max(Math.abs(this.YClose - max), Math.abs(this.YClose - min));
      max = this.YClose + distanceValue;
      min = this.YClose - distanceValue;
      if (min < 0) min = range.Min;
    }

    var showCount = this.SplitCount;
    var distance = (max - min) / (showCount - 1);
    var minDistance = [1, 0.1, 0.01, 0.001, 0.0001];
    var defaultfloatPrecision = _umychartCoordinatedataWechat.JSCommonCoordinateData.GetfloatPrecision(this.Symbol);; //默认小数位数
    if (_umychartCoordinatedataWechat.JSCommonCoordinateData.MARKET_SUFFIX_NAME.IsSHSZIndex(this.Symbol)) defaultfloatPrecision = 0; //手机端指数不显示小数位数,太长了

    if (distance < minDistance[defaultfloatPrecision])
    {
      distance = minDistance[defaultfloatPrecision];
      max = this.YClose + distance * (showCount - 1) / 2;
      min = this.YClose - distance * (showCount - 1) / 2;
    }

    for (var i = 0; i < showCount; ++i)
    {
      var price = min + distance * i;
      this.Frame.HorizontalInfo[i] = new CoordinateInfo();
      this.Frame.HorizontalInfo[i].Value = price;

      this.Frame.HorizontalInfo[i].Message[0] = price.toFixed(defaultfloatPrecision);

      if (this.YClose)
      {
        var per = (price / this.YClose - 1) * 100;
        if (per > 0) this.Frame.HorizontalInfo[i].TextColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.UpTextColor;else
        if (per < 0) this.Frame.HorizontalInfo[i].TextColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DownTextColor;
        this.Frame.HorizontalInfo[i].Message[1] = IFrameSplitOperator.FormatValueString(per, 2) + '%'; //百分比
      }
    }

    this.Frame.HorizontalMax = max;
    this.Frame.HorizontalMin = min;
  };

  this.CustomCoordinate = function () //自定义刻度
  {
    if (!this.Custom) return;

    for (var i in this.Custom)
    {
      var item = this.Custom[i];
      if (item.Type == 1)
      this.CustomFixedCoordinate(item);else
      if (item.Type == 0)
      {
        var defaultfloatPrecision = _umychartCoordinatedataWechat.JSCommonCoordinateData.GetfloatPrecision(this.Symbol);
        var latestItem = this.GetLatestPrice(defaultfloatPrecision, item);
        if (latestItem) this.Frame.CustomHorizontalInfo.push(latestItem);
      }
    }
  };

  this.GetLatestPrice = function (floatPrecision, option)
  {
    if (!this.Data || !this.Data.Data) return null;
    if (this.Data.Data.length <= 0) return null;
    var price = this.Data.Data[this.Data.Data.length - 1];
    if (!IFrameSplitOperator.IsNumber(price) || !IFrameSplitOperator.IsNumber(this.YClose)) return null;

    var info = new CoordinateInfo();
    info.Type = 0;
    info.Value = price;
    info.TextColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLatestPrice.TextColor;
    info.LineType = 2; //虚线
    if (option.Position == 'left') info.Message[0] = price.toFixed(floatPrecision);else
    info.Message[1] = price.toFixed(floatPrecision);
    if (price > this.YClose) info.LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLatestPrice.UpBarColor;else
    if (price < this.YClose) info.LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLatestPrice.DownBarColor;else
    info.LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLatestPrice.UnchagneBarColor;

    if (IFrameSplitOperator.IsNumber(option.LineType)) info.LineType = option.LineType;
    if (option.IsShowLine == false) info.LineType = -1;

    return info;
  };

  this.CustomFixedCoordinate = function (option) //固定坐标刻度
  {
    var defaultfloatPrecision = _umychartCoordinatedataWechat.JSCommonCoordinateData.GetfloatPrecision(this.Symbol);
    for (var i in option.Data)
    {
      var item = option.Data[i];
      var info = new CoordinateInfo();
      info.Type = 1;
      info.TextColor = item.TextColor;
      info.LineColor = item.Color;
      info.LineType = 2; //虚线
      if (IFrameSplitOperator.IsNumber(option.LineType)) info.LineType = option.LineType;
      if (option.IsShowLine == false) info.LineType = -1;

      if (IFrameSplitOperator.IsNumber(item.Increase)) //涨幅计算价格
        {
          if (!IFrameSplitOperator.IsNumber(this.YClose)) conintue;
          info.Value = this.YClose * (1 + item.Increase);
        } else

      {
        info.Value = item.Value;
      }

      var text;
      if (item.Text) text = item.Text;else
      text = info.Value.toFixed(defaultfloatPrecision);
      if (option.Position == 'left') info.Message[0] = text;else
      info.Message[1] = text;

      this.Frame.CustomHorizontalInfo.push(info);
    }
  };

}

function FrameSplitMinuteX()
{
  this.newMethod = IFrameSplitOperator; //派生
  this.newMethod();
  delete this.newMethod;

  this.ShowText = true; //是否显示坐标信息
  this.Symbol = null; //股票代码 x轴刻度根据股票类型来调整
  this.DayCount = 1;
  this.DayData;

  this.Operator = function ()
  {
    this.Frame.VerticalInfo = [];
    var xPointCount = this.Frame.XPointCount;
    var width = this.Frame.ChartBorder.GetWidth();
    var isHScreen = this.Frame.IsHScreen === true;
    if (isHScreen) width = this.Frame.ChartBorder.GetHeight();

    var minuteCoordinate = _umychartCoordinatedataWechat.JSCommonCoordinateData.MinuteCoordinateData;
    var xcoordinateData = minuteCoordinate.GetCoordinateData(this.Symbol, width);
    var minuteCount = xcoordinateData.Count;
    var minuteMiddleCount = xcoordinateData.MiddleCount > 0 ? xcoordinateData.MiddleCount : parseInt(minuteCount / 2);;

    var xcoordinate = xcoordinateData.Data;
    this.Frame.XPointCount = 243;

    this.Frame.XPointCount = minuteCount * this.DayCount;
    this.Frame.MinuteCount = minuteCount;
    this.Frame.VerticalInfo = [];

    if (this.DayCount <= 1)
    {
      for (var i in xcoordinate)
      {
        var info = new CoordinateInfo();
        //info.TextColor = "rgb(51,51,51)";
        info.Value = xcoordinate[i][0];
        if (this.ShowText)
        info.Message[0] = xcoordinate[i][3];
        this.Frame.VerticalInfo[i] = info;
      }
    } else

    {
      for (var i = this.DayData.length - 1, j = 0; i >= 0; --i, ++j)
      {
        var info = new CoordinateInfo();
        info.Value = j * minuteCount + minuteMiddleCount;
        info.LineType = -1;
        if (this.ShowText) info.Message[0] = IFrameSplitOperator.FormatDateString(this.DayData[i].Date, 'MM-DD');
        this.Frame.VerticalInfo.push(info);

        var info = new CoordinateInfo();
        info.Value = (j + 1) * minuteCount;
        this.Frame.VerticalInfo.push(info);
      }
    }
  };
}

function FrameSplitXData()
{
  this.newMethod = IFrameSplitOperator; //派生
  this.newMethod();
  delete this.newMethod;

  this.ShowText = true; //是否显示坐标信息

  this.Operator = function ()
  {
    if (this.Frame.Data == null || this.Frame.XData == null) return;
    this.Frame.VerticalInfo = [];
    var xOffset = this.Frame.Data.DataOffset;
    var xPointCount = this.Frame.XPointCount;

    for (var i = 0, index = xOffset; i < xPointCount && index < this.Frame.Data.Data.length; ++i, ++index)
    {
      var info = new CoordinateInfo();
      info.Value = index - xOffset;

      if (this.ShowText)
      info.Message[0] = this.Frame.XData[i];

      this.Frame.VerticalInfo.push(info);
    }
  };
}

//深度图X轴价格信息
function FrameSplitXDepth()
{
  this.newMethod = IFrameSplitOperator; //派生
  this.newMethod();
  delete this.newMethod;

  this.ShowText = true; //是否显示坐标信息
  this.SplitCount = 3;
  this.Symbol;
  this.LineType = 3;

  this.Operator = function ()
  {
    var xRange = this.Frame.VerticalRange;
    if (!xRange) return;
    this.Frame.VerticalInfo = [];

    var floatPrecision = 2;
    if (this.Symbol) floatPrecision = _umychartCoordinatedataWechat.JSCommonCoordinateData.GetfloatPrecision(this.Symbol);
    var xMax = xRange.Max;
    var xMin = xRange.Min;
    if (xRange.Bid)
    {
      var interval = (xRange.Bid.Max - xMin) / this.SplitCount;
      for (var i = 0; i < this.SplitCount; ++i)
      {
        var info = new CoordinateInfo();
        info.Value = xMin + interval * i;
        if (info.Value <= 0) continue;
        if (IFrameSplitOperator.IsNumber(this.LineType)) info.LineType = this.LineType;
        if (this.ShowText) info.Message[0] = info.Value.toFixed(floatPrecision);
        this.Frame.VerticalInfo.push(info);
      }
    }

    var info = new CoordinateInfo();
    info.Value = xRange.Center;
    this.Frame.VerticalInfo.push(info);

    if (xRange.Ask)
    {
      var interval = (xMax - xRange.Ask.Min) / this.SplitCount;
      for (var i = 1; i <= this.SplitCount; ++i)
      {
        var info = new CoordinateInfo();
        info.Value = xRange.Ask.Min + interval * i;
        if (IFrameSplitOperator.IsNumber(this.LineType)) info.LineType = this.LineType;
        if (this.ShowText) info.Message[0] = info.Value.toFixed(floatPrecision);
        this.Frame.VerticalInfo.push(info);
      }
    }
  };
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//  数据分割
//  [0]=Start起始 [1]=End结束 [2]=FixInterval修正的间隔 [3]=Increase
//
function SplitData() {
  this.Data = [
  [0.000001, 0.000002, 0.000001, 0.0000001],
  [0.000002, 0.000004, 0.000002, 0.0000002],
  [0.000004, 0.000005, 0.000004, 0.0000001],
  [0.000005, 0.00001, 0.000005, 0.0000005],

  [0.00001, 0.00002, 0.00001, 0.000001],
  [0.00002, 0.00004, 0.00002, 0.000002],
  [0.00004, 0.00005, 0.00004, 0.000001],
  [0.00005, 0.0001, 0.00005, 0.000005],

  [0.0001, 0.0002, 0.0001, 0.00001],
  [0.0002, 0.0004, 0.0002, 0.00002],
  [0.0004, 0.0005, 0.0004, 0.00001],
  [0.0005, 0.001, 0.0005, 0.00005],

  [0.001, 0.002, 0.001, 0.0001],
  [0.002, 0.004, 0.002, 0.0002],
  [0.004, 0.005, 0.004, 0.0001],
  [0.005, 0.01, 0.005, 0.0005],

  [0.01, 0.02, 0.01, 0.001],
  [0.02, 0.04, 0.02, 0.002],
  [0.04, 0.05, 0.04, 0.001],
  [0.05, 0.1, 0.05, 0.005],

  [0.1, 0.2, 0.1, 0.01],
  [0.2, 0.4, 0.2, 0.02],
  [0.4, 0.5, 0.4, 0.01],
  [0.5, 1, 0.5, 0.05],

  [1, 2, 1, 0.05],
  [2, 4, 2, 0.05],
  [4, 5, 4, 0.05],
  [5, 10, 5, 0.05],

  [10, 20, 10, 2],
  [20, 40, 20, 5],
  [40, 50, 40, 2],
  [50, 100, 50, 10],

  [100, 200, 100, 10],
  [200, 400, 200, 20],
  [400, 500, 400, 10],
  [500, 1000, 500, 50],

  [1000, 2000, 1000, 50],
  [2000, 4000, 2000, 50],
  [4000, 5000, 4000, 50],
  [5000, 10000, 5000, 100],

  [10000, 20000, 10000, 1000],
  [20000, 40000, 20000, 2000],
  [40000, 50000, 40000, 1000],
  [50000, 100000, 50000, 5000],

  [100000, 200000, 100000, 10000],
  [200000, 400000, 200000, 20000],
  [400000, 500000, 400000, 10000],
  [500000, 1000000, 500000, 50000],

  [1000000, 2000000, 1000000, 100000],
  [2000000, 4000000, 2000000, 200000],
  [4000000, 5000000, 4000000, 100000],
  [5000000, 10000000, 5000000, 500000],

  [10000000, 20000000, 10000000, 1000000],
  [20000000, 40000000, 20000000, 2000000],
  [40000000, 50000000, 40000000, 1000000],
  [50000000, 100000000, 50000000, 5000000],

  [100000000, 200000000, 100000000, 10000000],
  [200000000, 400000000, 100000000, 10000000],
  [400000000, 500000000, 100000000, 10000000],
  [500000000, 1000000000, 100000000, 10000000],

  [1000000000, 2000000000, 1000000000, 100000000],
  [2000000000, 4000000000, 2000000000, 200000000],
  [4000000000, 5000000000, 4000000000, 100000000],
  [5000000000, 10000000000, 5000000000, 500000000]];


  this.Find = function (interval) {
    for (var i in this.Data) {
      var item = this.Data[i];
      if (interval > item[0] && interval <= item[1]) {
        var result = {};
        result.FixInterval = item[2];
        result.Increase = item[3];
        return result;
      }
    }

    return null;
  };
}

function PriceSplitData() {
  this.newMethod = SplitData; //派生
  this.newMethod();
  delete this.newMethod;

  this.Data = [
  [0.000001, 0.000002, 0.000001, 0.0000001],
  [0.000002, 0.000004, 0.000002, 0.0000002],
  [0.000004, 0.000005, 0.000004, 0.0000001],
  [0.000005, 0.00001, 0.000005, 0.0000005],

  [0.00001, 0.00002, 0.00001, 0.000001],
  [0.00002, 0.00004, 0.00002, 0.000002],
  [0.00004, 0.00005, 0.00004, 0.000001],
  [0.00005, 0.0001, 0.00005, 0.000005],

  [0.0001, 0.0002, 0.0001, 0.00001],
  [0.0002, 0.0004, 0.0002, 0.00002],
  [0.0004, 0.0005, 0.0004, 0.00001],
  [0.0005, 0.001, 0.0005, 0.00005],

  [0.001, 0.002, 0.001, 0.0001],
  [0.002, 0.004, 0.002, 0.0002],
  [0.004, 0.005, 0.004, 0.0001],
  [0.005, 0.01, 0.005, 0.0005],

  [0.01, 0.02, 0.01, 0.001],
  [0.02, 0.04, 0.02, 0.002],
  [0.04, 0.05, 0.04, 0.001],
  [0.05, 0.1, 0.05, 0.005],

  [0.1, 0.2, 0.1, 0.01],
  [0.2, 0.4, 0.2, 0.02],
  [0.4, 0.5, 0.2, 0.01],
  [0.5, 0.8, 0.2, 0.05],
  [0.8, 1, 0.5, 0.05],

  [1, 2, 0.5, 0.05],
  [2, 4, 0.5, 0.05],
  [4, 5, 0.5, 0.05],
  [5, 10, 0.5, 0.05],

  [10, 12, 10, 2],
  [20, 40, 20, 5],
  [40, 50, 40, 2],
  [50, 100, 50, 10],

  [100, 200, 100, 10],
  [200, 400, 200, 20],
  [400, 500, 400, 10],
  [500, 1000, 500, 50],

  [1000, 2000, 1000, 50],
  [2000, 4000, 2000, 50],
  [4000, 5000, 4000, 50],
  [5000, 10000, 5000, 100],

  [10000, 20000, 10000, 1000],
  [20000, 40000, 20000, 2000],
  [40000, 50000, 40000, 1000],
  [50000, 100000, 50000, 5000],

  [100000, 200000, 100000, 10000],
  [200000, 400000, 200000, 20000],
  [400000, 500000, 400000, 10000],
  [500000, 1000000, 500000, 50000],

  [1000000, 2000000, 1000000, 100000],
  [2000000, 4000000, 2000000, 200000],
  [4000000, 5000000, 4000000, 100000],
  [5000000, 10000000, 5000000, 500000],

  [10000000, 20000000, 10000000, 1000000],
  [20000000, 40000000, 20000000, 2000000],
  [40000000, 50000000, 40000000, 1000000],
  [50000000, 100000000, 50000000, 5000000],

  [100000000, 200000000, 100000000, 10000000],
  [200000000, 400000000, 200000000, 20000000],
  [400000000, 500000000, 400000000, 10000000],
  [500000000, 1000000000, 500000000, 50000000],

  [1000000000, 2000000000, 1000000000, 100000000],
  [2000000000, 4000000000, 2000000000, 200000000],
  [4000000000, 5000000000, 4000000000, 100000000],
  [5000000000, 10000000000, 5000000000, 500000000]];

}

//整数分割
function IntegerSplitData() {
  this.newMethod = SplitData; //派生
  this.newMethod();
  delete this.newMethod;

  this.Data =
  [
  [0.000001, 0.000002, 0.000001, 0.0000001],
  [0.000002, 0.000004, 0.000002, 0.0000002],
  [0.000004, 0.000005, 0.000004, 0.0000001],
  [0.000005, 0.00001, 0.000005, 0.0000005],

  [0.00001, 0.00002, 0.00001, 0.000001],
  [0.00002, 0.00004, 0.00002, 0.000002],
  [0.00004, 0.00005, 0.00004, 0.000001],
  [0.00005, 0.0001, 0.00005, 0.000005],

  [0.0001, 0.0002, 0.0001, 0.00001],
  [0.0002, 0.0004, 0.0002, 0.00002],
  [0.0004, 0.0005, 0.0004, 0.00001],
  [0.0005, 0.001, 0.0005, 0.00005],

  [0.001, 0.002, 0.001, 0.0001],
  [0.002, 0.004, 0.002, 0.0002],
  [0.004, 0.005, 0.004, 0.0001],
  [0.005, 0.01, 0.005, 0.0005],

  [0.01, 0.02, 0.01, 0.001],
  [0.02, 0.04, 0.02, 0.002],
  [0.04, 0.05, 0.04, 0.001],
  [0.05, 0.1, 0.05, 0.005],

  [0.1, 0.2, 1, 1],
  [0.2, 0.4, 1, 1],
  [0.4, 0.5, 1, 1],
  [0.5, 0.8, 1, 1],
  [0.8, 1, 1, 1],

  [1, 2, 1, 1],
  [2, 4, 2, 1],
  [4, 5, 4, 1],
  [5, 10, 5, 1],

  [10, 12, 10, 2],
  [20, 40, 20, 5],
  [40, 50, 40, 2],
  [50, 100, 50, 10],

  [100, 200, 100, 10],
  [200, 400, 200, 20],
  [400, 500, 400, 10],
  [500, 1000, 500, 50],

  [1000, 2000, 1000, 50],
  [2000, 4000, 2000, 50],
  [4000, 5000, 4000, 50],
  [5000, 10000, 5000, 100],

  [10000, 20000, 10000, 1000],
  [20000, 40000, 20000, 2000],
  [40000, 50000, 40000, 1000],
  [50000, 100000, 50000, 5000],

  [100000, 200000, 100000, 10000],
  [200000, 400000, 200000, 20000],
  [400000, 500000, 400000, 10000],
  [500000, 1000000, 500000, 50000],

  [1000000, 2000000, 1000000, 100000],
  [2000000, 4000000, 2000000, 200000],
  [4000000, 5000000, 4000000, 100000],
  [5000000, 10000000, 5000000, 500000],

  [10000000, 20000000, 10000000, 1000000],
  [20000000, 40000000, 20000000, 2000000],
  [40000000, 50000000, 40000000, 1000000],
  [50000000, 100000000, 50000000, 5000000],

  [100000000, 200000000, 100000000, 10000000],
  [200000000, 400000000, 200000000, 20000000],
  [400000000, 500000000, 400000000, 10000000],
  [500000000, 1000000000, 500000000, 50000000],

  [1000000000, 2000000000, 1000000000, 100000000],
  [2000000000, 4000000000, 2000000000, 200000000],
  [4000000000, 5000000000, 4000000000, 100000000],
  [5000000000, 10000000000, 5000000000, 500000000]];

}


//导出统一使用JSCommon命名空间名
module.exports =
{
  JSCommonSplit:
  {
    CoordinateInfo: CoordinateInfo,
    IFrameSplitOperator: IFrameSplitOperator,
    FrameSplitKLinePriceY: FrameSplitKLinePriceY,
    FrameSplitY: FrameSplitY,
    FrameSplitKLineX: FrameSplitKLineX,
    FrameSplitMinutePriceY: FrameSplitMinutePriceY,
    FrameSplitMinuteX: FrameSplitMinuteX,
    FrameSplitXData: FrameSplitXData,
    SplitData: SplitData,
    PriceSplitData: PriceSplitData,
    FrameSplitXDepth: FrameSplitXDepth },


  JSCommonSplit_CoordinateInfo: CoordinateInfo,
  JSCommonSplit_IFrameSplitOperator: IFrameSplitOperator,
  JSCommonSplit_FrameSplitKLinePriceY: FrameSplitKLinePriceY,
  JSCommonSplit_FrameSplitY: FrameSplitY,
  JSCommonSplit_FrameSplitKLineX: FrameSplitKLineX,
  JSCommonSplit_FrameSplitMinutePriceY: FrameSplitMinutePriceY,
  JSCommonSplit_FrameSplitMinuteX: FrameSplitMinuteX,
  JSCommonSplit_FrameSplitXData: FrameSplitXData,
  JSCommonSplit_SplitData: SplitData,
  JSCommonSplit_PriceSplitData: PriceSplitData,
  JSCommonSplit_FrameSplitXDepth: FrameSplitXDepth };

/***/ }),
/* 112 */
/*!***********************************************************************!*\
  !*** I:/out-project/FCoinEx/static/js/umychart.extendchart.wechat.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";












var _umychartConsoleWechat = __webpack_require__(/*! ./umychart.console.wechat.js */ 102);


var _umychartDataWechat = __webpack_require__(/*! ./umychart.data.wechat.js */ 103);








var _umychartCoordinatedataWechat = __webpack_require__(/*! ./umychart.coordinatedata.wechat.js */ 104);





var _umychartResourceWechat = __webpack_require__(/*! ./umychart.resource.wechat.js */ 106);






var _umychartFramesplitWechat = __webpack_require__(/*! ./umychart.framesplit.wechat.js */ 111);function _createForOfIteratorHelper(o, allowArrayLike) {var it;if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = o[Symbol.iterator]();}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}




function IExtendChartPainting()
{
  this.Canvas; //画布
  this.ChartBorder; //边框信息
  this.ChartFrame; //框架画法
  this.Name; //名称
  this.Data; // = new ChartData();        //数据区
  this.ClassName = 'IExtendChartPainting';
  this.IsDynamic = false;
  this.IsEraseBG = false; //是否每次画的时候需要擦除K线图背景
  this.IsAnimation = false;
  this.DrawAfterTitle = false; //是否在动态标题画完以后再画,防止动态标题覆盖

  //上下左右间距
  this.Left = 5;
  this.Right = 5;
  this.Top = 5;
  this.Bottom = 5;

  this.Draw = function () {}; //画图接口
  this.SetOption = function (option) {}; //设置参数接口
}

//K线Tooltip, 显示在左边或右边
function KLineTooltipPaint()
{
  this.newMethod = IExtendChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.IsDynamic = true;
  this.IsEraseBG = true;
  this.DrawAfterTitle = true;
  this.ClassName = 'KLineTooltipPaint';
  this.LatestPoint; //手势位置
  this.ShowPosition = 0; //显示位置 0=左 1=右

  this.BorderColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.TooltipPaint.BorderColor; //边框颜色
  this.BGColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.TooltipPaint.BGColor; //背景色
  this.TitleColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.TooltipPaint.TitleColor; //标题颜色
  this.Font = [_umychartResourceWechat.JSCommonResource_Global_JSChartResource.TooltipPaint.TitleFont];

  this.Width = 50;
  this.Height = 100;
  this.LineHeight = 15; //行高

  this.Left = 1;
  this.Top = 0;

  this.HQChart;
  this.KLineTitlePaint;
  this.IsHScreen = false; //是否横屏
  this.LanguageID = _umychartResourceWechat.JSCommonResource_JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID;

  this.GetLeft = function ()
  {
    if (this.IsHScreen)
    {
      return this.ChartBorder.GetRightEx() - this.Height - this.Top;
    } else

    {
      if (this.ShowPosition == 0)
      return this.ChartBorder.GetLeft() + this.Left;else

      return this.ChartBorder.GetRight() - this.Width - this.Left;
    }
  };

  this.GetTop = function ()
  {
    if (this.IsHScreen)
    {
      if (this.ShowPosition == 0)
      return this.ChartBorder.GetTop() + this.Left;else

      return this.ChartBorder.GetBottom() - this.Width - this.Left;
    } else

    {
      return this.ChartBorder.GetTopEx() + this.Top;
    }
  };

  this.Draw = function ()
  {
    if (!this.HQChart || !this.HQChart.TitlePaint || !this.HQChart.TitlePaint[0]) return;
    if (!this.HQChart.IsOnTouch) return;

    this.KLineTitlePaint = this.HQChart.TitlePaint[0];
    var klineData = this.KLineTitlePaint.GetCurrentKLineData();
    if (!klineData) return;

    var upperSymbol;
    if (this.HQChart.Symbol) upperSymbol = this.HQChart.Symbol.toUpperCase();
    var isFutures = _umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsChinaFutures(upperSymbol) ? true : false;

    var lineCount = 8; //显示函数
    if (this.ClassName === 'MinuteTooltipPaint')
    {
      lineCount = 7;
      if (isFutures && _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(klineData.Position)) ++lineCount; //期货多一个持仓量
    } else

    {
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(klineData.Time)) ++lineCount; //分钟K线多一列时间
      if (isFutures && _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(klineData.Position)) ++lineCount; //持仓量
    }

    this.IsHScreen = this.ChartFrame.IsHScreen === true;
    this.Canvas.font = this.Font[0];
    var defaultfloatPrecision = _umychartCoordinatedataWechat.JSCommonCoordinateData.GetfloatPrecision(this.HQChart.Symbol); //价格小数位数
    var maxText = ' 擎: 9999.99亿 ';
    if (defaultfloatPrecision >= 5) maxText = " \u64CE: ".concat(99.99.toFixed(defaultfloatPrecision), " "); //小数位数太多了
    this.Width = this.Canvas.measureText(maxText).width;
    this.Height = this.LineHeight * lineCount + 2 * 2;
    if (klineData && klineData.High > 0)
    {
      maxText = " \u64CE: ".concat(klineData.High.toFixed(defaultfloatPrecision), " ");
      var textWidth = this.Canvas.measureText(maxText).width;
      if (textWidth > this.Width) this.Width = textWidth;
    }

    this.CalculateShowPosition();
    this.DrawBG();
    this.DrawTooltipData(klineData);
    this.DrawBorder();
  };

  //判断显示位置
  this.CalculateShowPosition = function ()
  {
    this.ShowPosition = 0;
    if (!this.LatestPoint) return;

    if (this.IsHScreen)
    {
      var top = this.ChartBorder.GetTop();
      var height = this.ChartBorder.GetHeight();
      var yCenter = top + height / 2;
      if (this.LatestPoint.Y < yCenter) this.ShowPosition = 1;
    } else

    {
      var left = this.ChartBorder.GetLeft();
      var width = this.ChartBorder.GetWidth();
      var xCenter = left + width / 2;
      if (this.LatestPoint.X < xCenter) this.ShowPosition = 1;
    }
  };

  this.DrawBorder = function ()
  {
    var isHScreen = this.ChartFrame.IsHScreen === true;
    var left = this.GetLeft();
    var top = this.GetTop();
    this.Canvas.strokeStyle = this.BorderColor;
    if (isHScreen)
    {
      this.Canvas.strokeRect(this.HQChart.ToFixedPoint(left), this.HQChart.ToFixedPoint(top),
      this.HQChart.ToFixedRect(this.Height), this.HQChart.ToFixedRect(this.Width));
    } else

    {
      this.Canvas.strokeRect(this.HQChart.ToFixedPoint(left), this.HQChart.ToFixedPoint(top),
      this.HQChart.ToFixedRect(this.Width), this.HQChart.ToFixedRect(this.Height));
    }
  };

  this.DrawBG = function ()
  {
    var isHScreen = this.ChartFrame.IsHScreen === true;
    var left = this.GetLeft();
    var top = this.GetTop();
    this.Canvas.fillStyle = this.BGColor;
    if (isHScreen) this.Canvas.fillRect(left, top, this.Height, this.Width);else
    this.Canvas.fillRect(left, top, this.Width, this.Height);
  };

  this.DrawTooltipData = function (item)
  {
    //console.log('[KLineTooltipPaint::DrawKLineData] ', item);

    var defaultfloatPrecision = _umychartCoordinatedataWechat.JSCommonCoordinateData.GetfloatPrecision(this.HQChart.Symbol); //价格小数位数
    var left = this.GetLeft() + 2;
    var top = this.GetTop() + 3;

    if (this.IsHScreen)
    {
      this.Canvas.save();
      var x = this.GetLeft() + this.Height,y = this.GetTop();

      this.Canvas.translate(x, y);
      this.Canvas.rotate(90 * Math.PI / 180);

      //x, y 作为原点
      left = 2;
      top = 3;
    }

    this.Canvas.textBaseline = "top";
    this.Canvas.textAlign = "left";
    this.Canvas.font = this.Font[0];
    var labelWidth = this.Canvas.measureText('擎: ').width;

    var text = this.HQChart.FormatDateString(item.Date);
    this.Canvas.fillStyle = this.TitleColor;
    this.Canvas.fillText(text, left, top);
    var period = this.HQChart.Period;
    if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(period, true) && _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Time))
    {
      top += this.LineHeight;
      text = this.HQChart.FormatTimeString(item.Time);
      this.Canvas.fillText(text, left, top);
    } else
    if (_umychartDataWechat.JSCommon_ChartData.IsSecondPeriod(period) && _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Time))
    {
      top += this.LineHeight;
      text = this.HQChart.FormatTimeString(item.Time, "HH:MM:SS");
      this.Canvas.fillText(text, left, top);
    }

    top += this.LineHeight;
    this.Canvas.fillStyle = this.TitleColor;
    text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Open', this.LanguageID);
    this.Canvas.fillText(text, left, top);
    var color = this.KLineTitlePaint.GetColor(item.Open, item.YClose);
    text = item.Open.toFixed(defaultfloatPrecision);
    this.Canvas.fillStyle = color;
    this.Canvas.fillText(text, left + labelWidth, top);

    top += this.LineHeight;
    this.Canvas.fillStyle = this.TitleColor;
    text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-High', this.LanguageID);
    this.Canvas.fillText(text, left, top);
    var color = this.KLineTitlePaint.GetColor(item.High, item.YClose);
    var text = item.High.toFixed(defaultfloatPrecision);
    this.Canvas.fillStyle = color;
    this.Canvas.fillText(text, left + labelWidth, top);

    top += this.LineHeight;
    this.Canvas.fillStyle = this.TitleColor;
    text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Low', this.LanguageID);
    this.Canvas.fillText(text, left, top);
    var color = this.KLineTitlePaint.GetColor(item.Low, item.YClose);
    var text = item.Low.toFixed(defaultfloatPrecision);
    this.Canvas.fillStyle = color;
    this.Canvas.fillText(text, left + labelWidth, top);

    top += this.LineHeight;
    this.Canvas.fillStyle = this.TitleColor;
    text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Close', this.LanguageID);
    this.Canvas.fillText(text, left, top);
    var color = this.KLineTitlePaint.GetColor(item.Close, item.YClose);
    var text = item.Close.toFixed(defaultfloatPrecision);
    this.Canvas.fillStyle = color;
    this.Canvas.fillText(text, left + labelWidth, top);

    top += this.LineHeight;
    this.Canvas.fillStyle = this.TitleColor;
    text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Increase', this.LanguageID);
    this.Canvas.fillText(text, left, top);
    if (item.YClose > 0)
    {
      var value = (item.Close - item.YClose) / item.YClose * 100;
      var color = this.KLineTitlePaint.GetColor(value, 0);
      var text = value.toFixed(2) + '%';
    } else

    {
      var text = '--.--';
      var color = this.KLineTitlePaint.GetColor(0, 0);
    }
    this.Canvas.fillStyle = color;
    this.Canvas.fillText(text, left + labelWidth, top);

    this.Canvas.fillStyle = this.TitleColor;

    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Vol))
    {
      top += this.LineHeight;
      text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Vol', this.LanguageID);
      this.Canvas.fillText(text, left, top);
      var text = this.HQChart.FormatValueString(item.Vol, 2, this.LanguageID);
      this.Canvas.fillText(text, left + labelWidth, top);
    }

    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Amount))
    {
      top += this.LineHeight;
      text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Amount', this.LanguageID);
      this.Canvas.fillText(text, left, top);
      var text = this.HQChart.FormatValueString(item.Amount, 2, this.LanguageID);
      this.Canvas.fillText(text, left + labelWidth, top);
    }

    //持仓量
    var upperSymbol;
    if (this.HQChart.Symbol) upperSymbol = this.HQChart.Symbol.toUpperCase();
    if (_umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsChinaFutures(upperSymbol) && _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Position))
    {
      this.Canvas.fillStyle = this.TitleColor;
      top += this.LineHeight;
      text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Position', this.LanguageID);
      this.Canvas.fillText(text, left, top);
      var text = _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatValueString(item.Position, 2, this.LanguageID);
      this.Canvas.fillText(text, left + labelWidth, top);
    }

    if (this.IsHScreen) this.Canvas.restore();
  };

  //设置参数接口
  this.SetOption = function (option)
  {
    if (option.LineHeight > 0) this.LineHeight = option.LineHeight;
    if (option.BGColor) this.BGColor = option.BGColor;
    if (option.LanguageID > 0) this.LanguageID = option.LanguageID;
  };
}

function MinuteTooltipPaint()
{
  this.newMethod = KLineTooltipPaint; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = 'MinuteTooltipPaint';
  this.IsShowAveragePrice = true;

  this.GetTop = function ()
  {
    if (this.IsHScreen)
    {
      if (this.ShowPosition == 0)
      return this.ChartBorder.GetTop() + this.Left;else

      return this.ChartBorder.GetBottom() - this.Width - this.Left;
    } else

    {
      return this.ChartBorder.GetTop() + this.Top;
    }
  };

  this.GetLeft = function ()
  {
    if (this.IsHScreen)
    {
      return this.ChartBorder.GetRight() - this.Height - this.Top;
    } else

    {
      if (this.ShowPosition == 0)
      return this.ChartBorder.GetLeft() + this.Left;else

      return this.ChartBorder.GetRight() - this.Width - this.Left;
    }
  };

  this.DrawTooltipData = function (item)
  {
    //console.log('[KLineTooltipPaint::DrawKLineData] ', item);
    var defaultfloatPrecision = _umychartCoordinatedataWechat.JSCommonCoordinateData.GetfloatPrecision(this.HQChart.Symbol); //价格小数位数
    var left = this.GetLeft() + 2;
    var top = this.GetTop() + 3;
    this.YClose = this.KLineTitlePaint.YClose;

    if (this.IsHScreen)
    {
      this.Canvas.save();
      var x = this.GetLeft() + this.Height,y = this.GetTop();

      this.Canvas.translate(x, y);
      this.Canvas.rotate(90 * Math.PI / 180);

      //x, y 作为原点
      left = 2;
      top = 3;
    }

    this.Canvas.textBaseline = "top";
    this.Canvas.textAlign = "left";
    this.Canvas.font = this.Font[0];
    var labelWidth = this.Canvas.measureText('擎: ').width;

    var aryDateTime = item.DateTime.split(' ');
    if (aryDateTime && aryDateTime.length == 2)
    {
      var text = this.HQChart.FormatDateString(aryDateTime[0]);
      this.Canvas.fillStyle = this.TitleColor;
      this.Canvas.fillText(text, left, top);

      top += this.LineHeight;
      text = this.HQChart.FormatTimeString(aryDateTime[1]);
      this.Canvas.fillText(text, left, top);
    }

    top += this.LineHeight;
    this.Canvas.fillStyle = this.TitleColor;
    text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Price', this.LanguageID);
    this.Canvas.fillText(text, left, top);
    var color = this.KLineTitlePaint.GetColor(item.Close, this.YClose);
    text = item.Close.toFixed(defaultfloatPrecision);
    this.Canvas.fillStyle = color;
    this.Canvas.fillText(text, left + labelWidth, top);

    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.AvPrice) && this.IsShowAveragePrice == true)
    {
      top += this.LineHeight;
      this.Canvas.fillStyle = this.TitleColor;
      text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-AvPrice', this.LanguageID);
      this.Canvas.fillText(text, left, top);
      var color = this.KLineTitlePaint.GetColor(item.AvPrice, this.YClose);
      var text = item.AvPrice.toFixed(defaultfloatPrecision);
      this.Canvas.fillStyle = color;
      this.Canvas.fillText(text, left + labelWidth, top);
    }

    top += this.LineHeight;
    this.Canvas.fillStyle = this.TitleColor;
    text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Increase', this.LanguageID);
    this.Canvas.fillText(text, left, top);
    var value = (item.Close - this.YClose) / this.YClose * 100;
    var color = this.KLineTitlePaint.GetColor(value, 0);
    var text = value.toFixed(2) + '%';
    this.Canvas.fillStyle = color;
    this.Canvas.fillText(text, left + labelWidth, top);

    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Vol))
    {
      this.Canvas.fillStyle = this.TitleColor;
      top += this.LineHeight;
      text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Vol', this.LanguageID);
      this.Canvas.fillText(text, left, top);
      var text = this.HQChart.FormatValueString(item.Vol, 2, this.LanguageID);
      this.Canvas.fillText(text, left + labelWidth, top);
    }

    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Amount))
    {
      top += this.LineHeight;
      text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Amount', this.LanguageID);
      this.Canvas.fillText(text, left, top);
      var text = this.HQChart.FormatValueString(item.Amount, 2, this.LanguageID);
      this.Canvas.fillText(text, left + labelWidth, top);
    }

    //持仓量
    var upperSymbol;
    if (this.HQChart.Symbol) upperSymbol = this.HQChart.Symbol.toUpperCase();
    if (_umychartCoordinatedataWechat.JSCommonCoordinateData_MARKET_SUFFIX_NAME.IsChinaFutures(upperSymbol) && _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Position))
    {
      this.Canvas.fillStyle = this.TitleColor;
      top += this.LineHeight;
      text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Position', this.LanguageID);
      this.Canvas.fillText(text, left, top);
      var text = _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatValueString(item.Position, 2, this.LanguageID);
      this.Canvas.fillText(text, left + labelWidth, top);
    }


    if (this.IsHScreen) this.Canvas.restore();
  };
}


//////////////////////////////////////////////////////////////////////////////
// 弹幕
//弹幕数据 { X:X偏移, Y:Y偏移, Text:内容, Color:颜色 }
function BarrageList()
{
  this.PlayList = []; //正在播放队列
  this.Cache = []; //没有播放的弹幕数据
  this.MinLineHeight = 40;
  this.Height; //高度
  this.Step = 1;

  //{Canves:画布, Right:右边坐标, Left:左边坐标, Font:默认字体 }
  this.GetPlayList = function (obj)
  {
    var canves = obj.Canves;
    var right = obj.Right;
    var left = obj.Left;
    var width = right - left;
    var isMoveStep = obj.IsMoveStep;

    var list = [];
    var yOffset = 0;
    for (var i = 0; i < this.PlayList.length; ++i)
    {
      var ary = this.PlayList[i];
      var lineHeight = this.MinLineHeight;
      if (ary.Height > this.MinLineHeight) lineHeight = ary.Height;

      var bAddNewItem = true; //是否需要加入新弹幕
      var bRemoveFirst = false; //是否删除第1个数据
      for (var j = 0; j < ary.Data.length; ++j)
      {
        var item = ary.Data[j];
        var playItem = { X: item.X, Y: yOffset, Text: item.Text, Color: item.Color, Height: lineHeight, Font: item.Font, Info: item.Info };
        list.push(playItem);

        if (!isMoveStep) continue;

        if (j == ary.Data.length - 1 && this.Cache.length > 0) //最后一个数据了 判断是否需要增加弹幕
          {
            bAddNewItem = false;
            if (!item.TextWidth)
            {
              if (item.Font && item.Font.Name) canves.font = item.Font.Name;else
              canves.font = obj.Font;
              item.TextWidth = canves.measureText(playItem.Text + '擎擎').width;
            }

            if (item.X >= item.TextWidth)
            bAddNewItem = true;
          } else
        if (j == 0)
        {
          bRemoveFirst = false;
          if (!item.TextWidth)
          {
            if (item.Font && item.Font.Name) canves.font = item.Font.Name;else
            canves.font = obj.Font;
            item.TextWidth = canves.measureText(playItem.Text + '擎擎').width;
          }

          if (item.X > width + item.TextWidth) bRemoveFirst = true;
        }

        item.X += this.Step;
      }

      if (isMoveStep && bAddNewItem && this.Cache.length > 0) //最后一个数据了 判断是否需要增加弹幕
        {
          var cacheItem = this.Cache.shift();
          var newItem = { X: 0, Text: cacheItem.Text, Color: cacheItem.Color, Font: cacheItem.Font, Info: cacheItem.Info };
          ary.Data.push(newItem);
        }

      if (isMoveStep && bRemoveFirst && ary.Data.length > 0)
      {
        var removeItem = ary.Data.shift();
        this.OnItemPlayEnd(obj.HQChart, removeItem);
      }

      yOffset += lineHeight;
    }

    return list;
  };

  //根据高度计算播放队列个数
  this.CacluatePlayLine = function (height)
  {
    this.Height = height;
    var lineCount = parseInt(height / this.MinLineHeight);
    if (this.PlayList.length < lineCount)
    {
      var addCount = lineCount - this.PlayList.length;
      for (var i = 0; i < addCount; ++i)
      {
        this.PlayList.push({ Data: [] });
      }
    } else
    if (this.PlayList.length > lineCount)
    {
      var removeCount = this.PlayList.length - lineCount;
      for (var i = 0; i < removeCount; ++i)
      {
        var ary = this.PlayList.pop();
        for (var j = 0; j < ary.Data.length; ++j)
        {
          var item = ary.Data[j];
          var cacheItem = { Text: item.Text, Color: item.Color, Font: item.Font, Info: item.Info };
          this.Cache.unshift(cacheItem);
        }
      }
    }

    _umychartConsoleWechat.JSConsole.Chart.Log("[BarrageList::CacluatePlayLine] LineCount=".concat(this.PlayList.length, " Height=").concat(this.Height));
  };

  //添加弹幕
  this.AddBarrage = function (barrageData)
  {
    for (var i in barrageData) {
      var item = barrageData[i];
      this.Cache.push(item);
    }
  };

  this.OnItemPlayEnd = function (hqChart, item) //单挑弹幕播放完毕
  {
    //监听事件
    var event = hqChart.GetBarrageEvent();
    if (!event || !event.Callback) return;

    event.Callback(event, item, this);
  };

  this.Count = function () {return this.Cache.length;}; //未播放的弹幕个数
}

//背景图 支持横屏
function BackgroundPaint()
{
  this.newMethod = IExtendChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = 'BackgroundPaint';

  this.IsDynamic = false;
  this.IsCallbackDraw = true; //在回调函数里绘制, 不在Draw()中绘制

  this.FrameID = 0;
  this.Data; //背景数据 { Start:, End:, Color:[] }
  this.ID = (0, _umychartDataWechat.JSCommon_Guid)(); //唯一的ID

  /*
  this.Data=
  [ 
      { Start:{ Date:20181201 }, End:{ Date:20181230 }, Color:'rgb(44,55,44)' } , 
      { Start:{ Date:20190308 }, End:{ Date:20190404 }, Color:['rgb(44,55,255)','rgb(200,55,255)'] } 
  ]
  */

  this.ChartSubFrame;
  this.ChartBorder;
  this.KData;
  this.Period;
  this.XPointCount = 0;

  this.SetOption = function (option) //设置
  {
    if (option.FrameID > 0) this.FrameID = option.FrameID;
    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsObjectExist(option.ID)) this.ID = option.ID;
  };

  this.Draw = function ()
  {
    if (!this.Data || !this.HQChart) return;
    if (!this.ChartFrame || !this.ChartFrame.SubFrame || this.ChartFrame.SubFrame.length <= this.FrameID) return;
    var klineChart = this.HQChart.ChartPaint[0];
    if (!klineChart || !klineChart.Data) return;

    this.ChartSubFrame = this.ChartFrame.SubFrame[this.FrameID].Frame;
    this.ChartBorder = this.ChartSubFrame.ChartBorder;
    this.KData = klineChart.Data;
    this.Period = this.HQChart.Period;
    if (!this.KData || this.KData.Data.length <= 0) return;

    var isHScreen = this.ChartSubFrame.IsHScreen === true;
    this.XPointCount = this.ChartSubFrame.XPointCount;
    var xPointCount = this.ChartSubFrame.XPointCount;

    var firstKItem = this.KData.Data[this.KData.DataOffset];
    var endIndex = this.KData.DataOffset + xPointCount - 1;
    if (endIndex >= this.KData.Data.length) endIndex = this.KData.Data.length - 1;
    var endKItem = this.KData.Data[endIndex];
    var showData = this.GetShowData(firstKItem, endKItem);
    if (!showData || showData.length <= 0) return;

    var kLineMap = this.BuildKLineMap();
    var bottom = this.ChartBorder.GetBottomEx();
    var top = this.ChartBorder.GetTopEx();
    var height = this.ChartBorder.GetHeightEx();
    if (isHScreen)
    {
      top = this.ChartBorder.GetRightEx();
      bottom = this.ChartBorder.GetLeftEx();
      height = this.ChartBorder.GetWidthEx();
    }

    for (var i in showData)
    {
      var item = showData[i];
      var rt = this.GetBGCoordinate(item, kLineMap);
      if (!rt) continue;

      if (Array.isArray(item.Color))
      {
        var gradient;
        if (isHScreen) gradient = this.Canvas.createLinearGradient(bottom, rt.Left, top, rt.Left);else
        gradient = this.Canvas.createLinearGradient(rt.Left, top, rt.Left, bottom);
        var offset = 1 / item.Color.length;
        for (var i in item.Color)
        {
          gradient.addColorStop(i * offset, item.Color[i]);
        }
        this.Canvas.fillStyle = gradient;
      } else

      {
        this.Canvas.fillStyle = item.Color;
      }

      if (isHScreen) this.Canvas.fillRect((0, _umychartDataWechat.JSCommon_ToFixedRect)(bottom), (0, _umychartDataWechat.JSCommon_ToFixedRect)(rt.Left), (0, _umychartDataWechat.JSCommon_ToFixedRect)(height), (0, _umychartDataWechat.JSCommon_ToFixedRect)(rt.Width));else
      this.Canvas.fillRect((0, _umychartDataWechat.JSCommon_ToFixedRect)(rt.Left), (0, _umychartDataWechat.JSCommon_ToFixedRect)(top), (0, _umychartDataWechat.JSCommon_ToFixedRect)(rt.Width), (0, _umychartDataWechat.JSCommon_ToFixedRect)(height));
    }
  };

  this.GetShowData = function (first, end)
  {
    var aryData = [];
    for (var i in this.Data) {
      var item = this.Data[i];
      var showItem = {};
      if (item.Start.Date >= first.Date && item.Start.Date <= end.Date) showItem.Start = item.Start;
      if (item.End.Date >= first.Date && item.End.Date <= end.Date) showItem.End = item.End;
      if (showItem.Start || showItem.End)
      {
        showItem.Color = item.Color;
        aryData.push(showItem);
      }
    }

    return aryData;
  };

  this.BuildKLineMap = function ()
  {
    var isHScreen = this.ChartSubFrame.IsHScreen === true;
    var dataWidth = this.ChartSubFrame.DataWidth;
    var distanceWidth = this.ChartSubFrame.DistanceWidth;
    var xOffset = this.ChartBorder.GetLeft() + distanceWidth / 2.0 + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLeftMargin;
    if (isHScreen) xOffset = this.ChartBorder.GetTop() + distanceWidth / 2.0 + _umychartResourceWechat.JSCommonResource_Global_JSChartResource.FrameLeftMargin;
    var chartright = this.ChartBorder.GetRight();
    if (isHScreen) chartright = this.ChartBorder.GetBottom();

    var mapKLine = { Data: new Map() }; //Key: date / date time, Value:索引
    for (var i = this.KData.DataOffset, j = 0; i < this.KData.Data.length && j < this.XPointCount; ++i, ++j, xOffset += dataWidth + distanceWidth)
    {
      var kItem = this.KData.Data[i];
      var left = xOffset;
      var right = xOffset + dataWidth;
      if (right > chartright) break;
      var x = left + (right - left) / 2;

      if (j == 0) mapKLine.XLeft = left;
      mapKLine.XRight = right;

      var value = { Index: i, ShowIndex: j, X: x, Right: right, Left: left, Date: kItem.Date };
      if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(this.Period, true))
      {
        var key = "Date:".concat(kItem.Date, " Time:").concat(kItem.Time);
        value.Time = kItem.Time;
      } else

      {
        var key = "Date:".concat(kItem.Date);
      }

      mapKLine.Data.set(key, value);
    }

    return mapKLine;
  };

  this.GetBGCoordinate = function (item, kLineMap)
  {
    var xLeft = null,xRight = null;
    if (item.Start)
    {
      if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(this.Period, true))
      var key = "Date:".concat(item.Start.Date, " Time:").concat(item.Start.Time);else

      var key = "Date:".concat(item.Start.Date);

      if (kLineMap.Data.has(key))
      {
        var findItem = kLineMap.Data.get(key);
        xLeft = findItem.Left;
      } else

      {var _iterator = _createForOfIteratorHelper(
        kLineMap.Data),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;)
          {var kItem = _step.value;
            var value = kItem[1];
            if (value.Date > item.Start.Date)
            {
              xLeft = value.Left;
              break;
            }
          }} catch (err) {_iterator.e(err);} finally {_iterator.f();}
      }
    } else

    {
      xLeft = kLineMap.XLeft;
    }

    if (item.End)
    {
      if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(this.Period, true))
      var key = "Date:".concat(item.End.Date, " Time:").concat(item.End.Time);else

      var key = "Date:".concat(item.End.Date);

      if (kLineMap.Data.has(key))
      {
        var findItem = kLineMap.Data.get(key);
        xRight = findItem.Right;
      } else

      {
        var previousX = null;var _iterator2 = _createForOfIteratorHelper(
        kLineMap.Data),_step2;try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;)
          {var kItem = _step2.value;
            var value = kItem[1];
            if (value.Date > item.End.Date)
            {
              xRight = previousX;
              break;
            }
            previousX = value.Right;
          }} catch (err) {_iterator2.e(err);} finally {_iterator2.f();}
      }
    } else

    {
      xRight = kLineMap.XRight;
    }

    if (xLeft == null || xRight == null) return null;

    return { Left: xLeft, Right: xRight, Width: xRight - xLeft };
  };
}


//弹幕
function BarragePaint()
{
  this.newMethod = IExtendChartPainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = 'BarragePaint';
  this.IsAnimation = true;
  this.IsEraseBG = true;
  this.HQChart;

  this.Font = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Barrage.Font;
  this.TextColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Barrage.Color;
  this.FontHeight = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Barrage.Height;

  this.BarrageList = new BarrageList(); //字幕列表
  this.IsMoveStep = false;


  this.SetOption = function (option) //设置参数接口
  {
    if (option)
    {
      if (option.Step > 0) this.BarrageList.Step = option.Step;
      if (option.MinLineHeight) this.Barrage.MinLineHeight = option.MinLineHeight;
    }
  };

  this.DrawHScreen = function ()
  {
    var height = this.ChartBorder.GetWidth();
    var left = this.ChartBorder.GetTop();
    var right = this.ChartBorder.GetBottom();
    var top = this.ChartBorder.GetRightEx();
    var wdith = this.ChartBorder.GetChartWidth();

    if (height != this.BarrageList.Height)
    this.BarrageList.CacluatePlayLine(height);

    this.Canvas.textBaseline = "middle";
    this.Canvas.textAlign = "left";

    var play = this.BarrageList.GetPlayList({ Canves: this.Canvas, Right: right, Left: left, Font: this.Font, IsMoveStep: this.IsMoveStep, HQChart: this.HQChart });
    this.IsMoveStep = false;
    if (!play) return;

    this.Canvas.save();
    this.Canvas.translate(this.ChartBorder.GetChartHeight(), 0);
    this.Canvas.rotate(90 * Math.PI / 180);

    for (var i = 0; i < play.length; ++i)
    {
      var item = play[i];
      if (item.Color) this.Canvas.fillStyle = item.Color;else
      this.Canvas.fillStyle = this.TextColor;
      if (item.Font) this.Canvas.font = item.Font.Name;else
      this.Canvas.font = this.Font;

      var fontHeight = this.FontHeight;
      if (item.Font && item.Font.Height > 0) fontHeight = item.Font.Height;
      var yOffset = item.Y + parseInt((item.Height - fontHeight) / 2);

      this.Canvas.fillText(item.Text, right - item.X, top + yOffset);
    }

    this.Canvas.restore();
  };

  this.Draw = function ()
  {
    if (this.ChartFrame.IsHScreen)
    {
      this.DrawHScreen();
      return;
    }

    var left = this.ChartBorder.GetLeft();
    var right = this.ChartBorder.GetRight();
    var top = this.ChartBorder.GetTopEx();
    var height = this.ChartBorder.GetHeight();

    if (height != this.BarrageList.Height)
    this.BarrageList.CacluatePlayLine(height);

    this.Canvas.textBaseline = "middle";
    this.Canvas.textAlign = "left";

    var play = this.BarrageList.GetPlayList({ Canves: this.Canvas, Right: right, Left: left, Font: this.Font, IsMoveStep: this.IsMoveStep, HQChart: this.HQChart });
    this.IsMoveStep = false;
    if (!play) return;

    for (var i = 0; i < play.length; ++i)
    {
      var item = play[i];
      if (item.Color) this.Canvas.fillStyle = item.Color;else
      this.Canvas.fillStyle = this.TextColor;
      if (item.Font) this.Canvas.font = item.Font.Name;else
      this.Canvas.font = this.Font;

      var fontHeight = this.FontHeight;
      if (item.Font && item.Font.Height > 0) fontHeight = item.Font.Height;
      var yOffset = item.Y + parseInt((item.Height - fontHeight) / 2);

      this.Canvas.fillText(item.Text, right - item.X, top + yOffset);
    }
  };
}

//导出统一使用JSCommon命名空间名
module.exports =
{
  JSCommonExtendChartPaint:
  {
    IExtendChartPainting: IExtendChartPainting,
    KLineTooltipPaint: KLineTooltipPaint,
    BarragePaint: BarragePaint,
    MinuteTooltipPaint: MinuteTooltipPaint,
    BackgroundPaint: BackgroundPaint },


  //单个类导出
  JSCommonExtendChartPaint_IExtendChartPainting: IExtendChartPainting,
  JSCommonExtendChartPaint_KLineTooltipPaint: KLineTooltipPaint,
  JSCommonExtendChartPaint_BarragePaint: BarragePaint,
  JSCommonExtendChartPaint_MinuteTooltipPaint: MinuteTooltipPaint,
  JSCommonExtendChartPaint_BackgroundPaint: BackgroundPaint };

/***/ }),
/* 113 */
/*!*****************************************************************!*\
  !*** I:/out-project/FCoinEx/static/js/umychart.index.wechat.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";












var _umychartResourceWechat = __webpack_require__(/*! ./umychart.resource.wechat.js */ 106);



var _umychartComplierWechat = __webpack_require__(/*! ./umychart.complier.wechat.js */ 107);


var _umychartChartpaintWechat = __webpack_require__(/*! ./umychart.chartpaint.wechat.js */ 110);































var _umychartFramesplitWechat = __webpack_require__(/*! ./umychart.framesplit.wechat.js */ 111);













var _umychartCharttitleWechat = __webpack_require__(/*! ./umychart.charttitle.wechat.js */ 114); /*
                                                                                copyright (c) 2018 jones
                                                                            
                                                                                http://www.apache.org/licenses/LICENSE-2.0
                                                                            
                                                                                开源项目 https://github.com/jones2000/HQChart
                                                                            
                                                                                jones_2000@163.com
                                                                            
                                                                                指标基类及定制指标
                                                                            */ //通达信编译器
//图形库
//////////////////////////////////////////////////////////
//
//  指标信息
//
function IndexInfo(name, param) {this.Name = name; //名字
  this.Param = param; //参数
  this.LineColor; //线段颜色
  this.ReqeustData = null; //数据请求
}
function BaseIndex(name)
{
  this.Index; //指标阐述
  this.Name = name; //指标名字
  this.UpdateUICallback; //数据到达回调

  //默认创建都是线段
  this.Create = function (hqChart, windowIndex)
  {
    for (var i in this.Index)
    {
      if (!this.Index[i].Name) continue;

      var maLine = new _umychartChartpaintWechat.JSCommonChartPaint_ChartLine();
      maLine.Canvas = hqChart.Canvas;
      maLine.Name = this.Name + '-' + i.toString();
      maLine.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
      maLine.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;
      maLine.Color = this.Index[i].LineColor;

      hqChart.ChartPaint.push(maLine);
    }
  };

  //指标不支持 周期/复权/股票等
  this.NotSupport = function (hqChart, windowIndex, message)
  {
    var paint = hqChart.GetChartPaint(windowIndex);
    for (var i in paint)
    {
      paint[i].Data.Data = []; //清空数据
      if (i == 0) paint[i].NotSupportMessage = message;
    }
  };

  //格式化指标名字+参数
  //格式:指标名(参数1,参数2,参数3,...)
  this.FormatIndexTitle = function ()
  {
    var title = this.Name;
    var param = null;

    for (var i in this.Index)
    {
      var item = this.Index[i];
      if (item.Param == null) continue;

      if (param) param += ',' + item.Param.toString();else
      param = item.Param.toString();
    }

    if (param) title += '(' + param + ')';

    return title;
  };

  this.InvokeUpdateUICallback = function (paint)
  {
    if (typeof this.UpdateUICallback != 'function') return;

    var indexData = new Array();
    for (var i in paint)
    {
      indexData.push({ Name: this.Index[i].Name, Data: paint[i].Data });
    }

    this.UpdateUICallback(indexData);
  };
}

//脚本指标
//name=指标名字 args=参数名字 参数值
function ScriptIndex(name, script, args, option)
{
  this.newMethod = BaseIndex; //派生
  this.newMethod(name);
  delete this.newMethod;

  this.Script = script;
  this.Arguments = [];
  this.OutVar = [];
  this.ID; //指标ID
  this.FloatPrecision = 2; //小数位数
  this.StringFormat;
  this.KLineType = null; //K线显示类型
  this.InstructionType; //五彩K线, 交易指标
  this.YSpecificMaxMin = null; //最大最小值
  this.YSplitScale = null; //固定刻度
  this.OutName = null; //动态输出指标名字

  //指标上锁配置信息
  this.IsLocked = false; //是否锁住指标
  this.LockCallback = null;
  this.LockID = null;
  this.LockBG = null; //锁背景色
  this.LockTextColor = null;
  this.LockText = null;
  this.LockFont = null;
  this.LockCount = 10;

  if (option)
  {
    if (option.FloatPrecision >= 0) this.FloatPrecision = option.FloatPrecision;
    if (option.StringFormat > 0) this.StringFormat = option.StringFormat;
    if (option.ID) this.ID = option.ID;
    if (option.KLineType) this.KLineType = option.KLineType;
    if (option.InstructionType) this.InstructionType = option.InstructionType;
    if (option.YSpecificMaxMin) this.YSpecificMaxMin = option.YSpecificMaxMin;
    if (option.YSplitScale) this.YSplitScale = option.YSplitScale;
    if (option.OutName) this.OutName = option.OutName;
  }

  if (option && option.Lock)
  {
    if (option.Lock.IsLocked == true) this.IsLocked = true; //指标上锁
    if (option.Lock.Callback) this.LockCallback = option.Lock.Callback; //锁回调
    if (option.Lock.ID) this.LockID = option.Lock.ID; //锁ID
    if (option.Lock.BG) this.LockBG = option.Lock.BG;
    if (option.Lock.TextColor) this.LockTextColor = option.Lock.TextColor;
    if (option.Lock.Text) this.LockText = option.Lock.Text;
    if (option.Lock.Font) this.LockFont = option.Lock.Font;
    if (option.Lock.Count) this.LockCount = option.Lock.Count;
  }

  if (args) this.Arguments = args;

  this.SetLock = function (lockData) {
    if (lockData.IsLocked == true) {
      this.IsLocked = true; //指标上锁
      if (lockData.Callback) this.LockCallback = lockData.Callback; //锁回调
      if (lockData.ID) this.LockID = lockData.ID; //锁ID
      if (lockData.BG) this.LockBG = lockData.BG;
      if (lockData.TextColor) this.LockTextColor = lockData.TextColor;
      if (lockData.Text) this.LockText = lockData.Text;
      if (lockData.Font) this.LockFont = lockData.Font;
      if (lockData.Count) this.LockCount = lockData.Count;
    } else
    {//清空锁配置信息
      this.IsLocked = false; //是否锁住指标
      this.LockCallback = null;
      this.LockID = null;
      this.LockBG = null; //锁背景色
      this.LockTextColor = null;
      this.LockText = null;
      this.LockFont = null;
      this.LockCount = 10;
    }
  };

  this.ExecuteScript = function (hqChart, windowIndex, hisData)
  {
    this.OutVar = [];
    var self = this;
    var param =
    {
      HQChart: hqChart,
      WindowIndex: windowIndex,
      HistoryData: hisData,
      Self: this };


    var hqDataType = 0; //默认K线
    if (hqChart.ClassName === 'MinuteChartContainer') hqDataType = 2; //分钟数据
    var option =
    {
      HQDataType: hqDataType,
      Symbol: hqChart.Symbol,
      Data: hisData,
      SourceData: hqChart.SourceData, //原始数据
      Callback: this.RecvResultData, CallbackParam: param,
      Async: true,
      MaxReqeustDataCount: hqChart.MaxReqeustDataCount,
      MaxRequestMinuteDayCount: hqChart.MaxRequestMinuteDayCount,
      Arguments: this.Arguments };


    if (hqChart.NetworkFilter) option.NetworkFilter = hqChart.NetworkFilter;

    var code = this.Script;
    var run = _umychartComplierWechat.JSCommonComplier.JSComplier.Execute(code, option, hqChart.ScriptErrorCallback);
  };

  this.RecvResultData = function (outVar, param)
  {
    var hqChart = param.HQChart;
    var windowIndex = param.WindowIndex;
    var hisData = param.HistoryData;
    param.Self.OutVar = outVar;
    param.Self.BindData(hqChart, windowIndex, hisData);

    if (param.Self.IsLocked == false) //不上锁
      {
        param.HQChart.Frame.SubFrame[windowIndex].Frame.SetLock(null);
      } else
      //上锁
      {
        var lockData =
        {
          IsLocked: true, Callback: param.Self.LockCallback, IndexName: param.Self.Name, ID: param.Self.LockID,
          BG: param.Self.LockBG, Text: param.Self.LockText, TextColor: param.Self.LockTextColor, Font: param.Self.LockFont,
          Count: param.Self.LockCount };

        param.HQChart.Frame.SubFrame[windowIndex].Frame.SetLock(lockData);
      }

    param.HQChart.UpdataDataoffset(); //更新数据偏移
    param.HQChart.UpdateFrameMaxMin(); //调整坐标最大 最小值
    param.HQChart.Draw();

    var event = hqChart.GetIndexEvent(); //指标计算完成回调
    if (event)
    {
      var self = param.Self;
      var data = {
        OutVar: self.OutVar, WindowIndex: windowIndex, Name: self.Name, Arguments: self.Arguments, HistoryData: hisData,
        Stock: { Symbol: hqChart.Symbol, Name: hqChart.Name } };

      event.Callback(event, data, self);
    }
  };

  this.CreateLine = function (hqChart, windowIndex, varItem, id)
  {
    var line = new _umychartChartpaintWechat.JSCommonChartPaint_ChartLine();
    line.Canvas = hqChart.Canvas;
    line.DrawType = 1; //无效数不画
    line.Name = varItem.Name;
    line.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    line.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;
    if (varItem.Color) line.Color = this.GetColor(varItem.Color);else
    line.Color = this.GetDefaultColor(id);
    if (varItem.IsShow == false) line.IsShow = false;
    if (varItem.LineWidth)
    {
      var width = parseInt(varItem.LineWidth.replace("LINETHICK", ""));
      if (!isNaN(width) && width > 0) line.LineWidth = width;
    }

    if (varItem.IsDotLine) line.IsDotLine = true; //虚线
    if (varItem.IsShow == false) line.IsShow = false;

    var titleIndex = windowIndex + 1;
    line.Data.Data = varItem.Data;
    if (varItem.IsShowTitle === false) //NOTEXT 不绘制标题
      {
      } else
    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsString(varItem.Name) && varItem.Name.indexOf("NOTEXT") == 0) //标题中包含NOTEXT不绘制标题
      {
      } else

    {
      hqChart.TitlePaint[titleIndex].Data[id] = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicTitleData(line.Data, varItem.NoneName == true ? null : varItem.Name, line.Color);
    }

    hqChart.ChartPaint.push(line);
  };

  this.CreateOverlayLine = function (hqChart, windowIndex, varItem, id)
  {
    var line = new _umychartChartpaintWechat.JSCommonChartPaint_ChartSubLine();
    line.Canvas = hqChart.Canvas;
    line.DrawType = 1; //无效数不画
    line.Name = varItem.Name;
    line.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    line.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;
    if (varItem.Color) line.Color = this.GetColor(varItem.Color);else
    line.Color = this.GetDefaultColor(id);

    if (varItem.LineWidth) {
      var width = parseInt(varItem.LineWidth.replace("LINETHICK", ""));
      if (!isNaN(width) && width > 0) line.LineWidth = width;
    }

    if (varItem.IsDotLine) line.IsDotLine = true; //虚线
    if (varItem.IsShow == false) line.IsShow = false;

    var titleIndex = windowIndex + 1;
    line.Data.Data = varItem.Data;
    hqChart.TitlePaint[titleIndex].Data[id] = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicTitleData(line.Data, varItem.Name, line.Color);

    hqChart.ChartPaint.push(line);
  };

  //创建柱子
  this.CreateBar = function (hqChart, windowIndex, varItem, id)
  {
    var bar = new _umychartChartpaintWechat.JSCommonChartPaint_ChartStickLine();
    bar.Canvas = hqChart.Canvas;
    if (varItem.Draw.Width > 0) bar.LineWidth = varItem.Draw.Width;else
    bar.LineWidth = 1;

    bar.Name = varItem.Name;
    bar.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    bar.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;
    if (varItem.Color) bar.Color = this.GetColor(varItem.Color);else
    bar.Color = this.GetDefaultColor(id);

    var titleIndex = windowIndex + 1;
    bar.Data.Data = varItem.Draw.DrawData;
    bar.BarType = varItem.Draw.Type;

    //hqChart.TitlePaint[titleIndex].Data[id]=new DynamicTitleData(bar.Data,varItem.Name,bar.Color);

    hqChart.ChartPaint.push(bar);
  };

  //创建文本
  this.CreateText = function (hqChart, windowIndex, varItem, id)
  {
    var chartText = new _umychartChartpaintWechat.JSCommonChartPaint_ChartSingleText();
    chartText.Canvas = hqChart.Canvas;
    chartText.TextAlign = 'left';

    chartText.Name = varItem.Name;
    chartText.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    chartText.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;
    chartText.ReloadResource();

    if (varItem.Color) chartText.Color = this.GetColor(varItem.Color);else
    chartText.Color = this.GetDefaultColor(id);

    var titleIndex = windowIndex + 1;
    if (varItem.Draw.Position) chartText.Position = varItem.Draw.Position; //赋值坐标
    if (varItem.Draw.DrawData) chartText.Data.Data = varItem.Draw.DrawData;
    chartText.Text = varItem.Draw.Text;
    if (varItem.Draw.Direction > 0) chartText.Direction = varItem.Draw.Direction;
    if (varItem.Draw.YOffset > 0) chartText.YOffset = varItem.Draw.YOffset;
    if (varItem.Draw.TextAlign) chartText.TextAlign = varItem.Draw.TextAlign;

    //hqChart.TitlePaint[titleIndex].Data[id]=new DynamicTitleData(bar.Data,varItem.Name,bar.Color);
    hqChart.ChartPaint.push(chartText);
  };

  //COLORSTICK 
  this.CreateMACD = function (hqChart, windowIndex, varItem, id)
  {
    var chartMACD = new _umychartChartpaintWechat.JSCommonChartPaint_ChartMACD();
    chartMACD.Canvas = hqChart.Canvas;

    chartMACD.Name = varItem.Name;
    chartMACD.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    chartMACD.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;
    if (varItem.LineWidth)
    {
      var width = parseInt(varItem.LineWidth.replace("LINETHICK", ""));
      if (!isNaN(width) && width > 0) chartMACD.LineWidth = width;
    }

    var titleIndex = windowIndex + 1;
    chartMACD.Data.Data = varItem.Data;
    var clrTitle = this.GetDefaultColor(id);
    if (varItem.Color) clrTitle = this.GetColor(varItem.Color);
    hqChart.TitlePaint[titleIndex].Data[id] = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicTitleData(chartMACD.Data, varItem.Name, clrTitle);

    hqChart.ChartPaint.push(chartMACD);
  };

  this.CreatePointDot = function (hqChart, windowIndex, varItem, id) {
    var pointDot = new _umychartChartpaintWechat.JSCommonChartPaint_ChartPointDot();
    pointDot.Canvas = hqChart.Canvas;
    pointDot.Name = varItem.Name;
    pointDot.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    pointDot.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;
    if (varItem.Color) pointDot.Color = this.GetColor(varItem.Color);else
    pointDot.Color = this.GetDefaultColor(id);

    if (varItem.Radius) pointDot.Radius = varItem.Radius;

    if (varItem.LineWidth) {
      var width = parseInt(varItem.LineWidth.replace("LINETHICK", ""));
      if (!isNaN(width) && width > 0) pointDot.Radius = width;
    }

    var titleIndex = windowIndex + 1;
    pointDot.Data.Data = varItem.Data;
    hqChart.TitlePaint[titleIndex].Data[id] = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicTitleData(pointDot.Data, varItem.Name, pointDot.Color);

    hqChart.ChartPaint.push(pointDot);
  };

  this.CreateStick = function (hqChart, windowIndex, varItem, id) {
    var chart = new _umychartChartpaintWechat.JSCommonChartPaint_ChartStick();
    chart.Canvas = hqChart.Canvas;
    chart.Name = varItem.Name;
    chart.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    chart.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;
    if (varItem.Color) chart.Color = this.GetColor(varItem.Color);else
    chart.Color = this.GetDefaultColor(id);

    if (varItem.LineWidth) {
      var width = parseInt(varItem.LineWidth.replace("LINETHICK", ""));
      if (!isNaN(width) && width > 0) chart.LineWidth = width;
    }

    var titleIndex = windowIndex + 1;
    chart.Data.Data = varItem.Data;
    hqChart.TitlePaint[titleIndex].Data[id] = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicTitleData(chart.Data, varItem.Name, chart.Color);

    hqChart.ChartPaint.push(chart);
  };

  this.CreateLineStick = function (hqChart, windowIndex, varItem, id) {
    var chart = new _umychartChartpaintWechat.JSCommonChartPaint_ChartLineStick();
    chart.Canvas = hqChart.Canvas;
    chart.Name = varItem.Name;
    chart.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    chart.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;
    if (varItem.Color) chart.Color = this.GetColor(varItem.Color);else
    chart.Color = this.GetDefaultColor(id);

    if (varItem.LineWidth) {
      var width = parseInt(varItem.LineWidth.replace("LINETHICK", ""));
      if (!isNaN(width) && width > 0) chart.LineWidth = width;
    }

    var titleIndex = windowIndex + 1;
    chart.Data.Data = varItem.Data;
    hqChart.TitlePaint[titleIndex].Data[id] = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicTitleData(chart.Data, varItem.Name, chart.Color);

    hqChart.ChartPaint.push(chart);
  };

  this.CreateStraightLine = function (hqChart, windowIndex, varItem, id) {
    var line = new _umychartChartpaintWechat.JSCommonChartPaint_ChartLine();
    line.DrawType = 1;
    line.Canvas = hqChart.Canvas;
    line.Name = varItem.Name;
    line.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    line.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;
    if (varItem.Color) line.Color = this.GetColor(varItem.Color);else
    line.Color = this.GetDefaultColor(id);

    if (varItem.LineWidth) {
      var width = parseInt(varItem.LineWidth.replace("LINETHICK", ""));
      if (!isNaN(width) && width > 0) line.LineWidth = width;
    }

    var titleIndex = windowIndex + 1;
    line.Data.Data = varItem.Draw.DrawData;
    //hqChart.TitlePaint[titleIndex].Data[id]=new DynamicTitleData(line.Data,varItem.Name,line.Color);

    hqChart.ChartPaint.push(line);
  };

  this.CreateVolStick = function (hqChart, windowIndex, varItem, id, hisData) {
    var chart = new _umychartChartpaintWechat.JSCommonChartPaint_ChartVolStick();
    chart.Canvas = hqChart.Canvas;
    chart.Name = varItem.Name;
    chart.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    chart.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;
    chart.KLineDrawType = hqChart.KLineDrawType; //设置K线显示类型
    if (varItem.Color) chart.Color = this.GetColor(varItem.Color);else
    chart.Color = this.GetDefaultColor(id);

    var titleIndex = windowIndex + 1;
    chart.Data.Data = varItem.Data;
    chart.HistoryData = hisData;
    hqChart.TitlePaint[titleIndex].Data[id] = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicTitleData(chart.Data, varItem.Name, chart.Color);

    hqChart.ChartPaint.push(chart);
  };

  this.CreateBand = function (hqChart, windowIndex, varItem, id) {
    var chart = new _umychartChartpaintWechat.JSCommonChartPaint_ChartBand();
    chart.Canvas = hqChart.Canvas;
    chart.Name = varItem.Name;
    chart.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    chart.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;

    chart.FirstColor = varItem.Draw.Color[0];
    chart.SecondColor = varItem.Draw.Color[1];
    chart.Data.Data = varItem.Draw.DrawData;

    hqChart.ChartPaint.push(chart);
  };

  this.CreatePolyLine = function (hqChart, windowIndex, varItem, id) {
    var line = new _umychartChartpaintWechat.JSCommonChartPaint_ChartLine();
    line.Canvas = hqChart.Canvas;
    line.Name = varItem.Name;
    line.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    line.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;
    if (varItem.Color) line.Color = this.GetColor(varItem.Color);else
    line.Color = this.GetDefaultColor(id);

    if (varItem.LineWidth) {
      var width = parseInt(varItem.LineWidth.replace("LINETHICK", ""));
      if (!isNaN(width) && width > 0) line.LineWidth = width;
    }

    var titleIndex = windowIndex + 1;
    line.Data.Data = varItem.Draw.DrawData;
    //hqChart.TitlePaint[titleIndex].Data[id] = new DynamicTitleData(line.Data, ' ', line.Color); //给一个空的标题

    hqChart.ChartPaint.push(line);
  };

  //创建K线图
  this.CreateKLine = function (hqChart, windowIndex, varItem, id) {
    var chart = new _umychartChartpaintWechat.JSCommonChartPaint_ChartKLine();
    chart.Canvas = hqChart.Canvas;
    chart.Name = varItem.Name;
    chart.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    chart.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;

    chart.Data.Data = varItem.Draw.DrawData;
    chart.IsShowMaxMinPrice = false;

    if (varItem.Color) //如果设置了颜色,使用外面设置的颜色
      chart.UnchagneColor = chart.DownColor = chart.UpColor = this.GetColor(varItem.Color);

    hqChart.ChartPaint.push(chart);
  };

  this.CreateNumberText = function (hqChart, windowIndex, varItem, id) {
    var chartText = new _umychartChartpaintWechat.JSCommonChartPaint_ChartSingleText();
    chartText.Canvas = hqChart.Canvas;

    chartText.Name = varItem.Name;
    chartText.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    chartText.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;
    chartText.ReloadResource();

    chartText.TextAlign = "center";
    if (varItem.Color) chartText.Color = this.GetColor(varItem.Color);else
    chartText.Color = this.GetDefaultColor(id);
    if (varItem.IsDrawAbove) chartText.Direction = 1;else
    chartText.Direction = 2;

    var titleIndex = windowIndex + 1;
    chartText.Data.Data = varItem.Draw.DrawData.Value;
    chartText.Text = varItem.Draw.DrawData.Text;

    //hqChart.TitlePaint[titleIndex].Data[id]=new DynamicTitleData(bar.Data,varItem.Name,bar.Color);
    hqChart.ChartPaint.push(chartText);
  };

  //创建图标
  this.CreateIcon = function (hqChart, windowIndex, varItem, id) {
    var chartText = new _umychartChartpaintWechat.JSCommonChartPaint_ChartSingleText();
    chartText.Canvas = hqChart.Canvas;
    chartText.TextAlign = 'center';

    chartText.Name = varItem.Name;
    chartText.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    chartText.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;

    var titleIndex = windowIndex + 1;
    chartText.Data.Data = varItem.Draw.DrawData;
    chartText.Text = varItem.Draw.Icon.Symbol;
    if (varItem.Color) chartText.Color = this.GetColor(varItem.Color);else
    if (varItem.Draw.Icon.Color) chartText.Color = varItem.Draw.Icon.Color;else
    chartText.Color = 'rgb(0,0,0)';

    //hqChart.TitlePaint[titleIndex].Data[id]=new DynamicTitleData(bar.Data,varItem.Name,bar.Color);

    hqChart.ChartPaint.push(chartText);
  };

  this.CreateRectangle = function (hqChart, windowIndex, varItem, i)
  {
    var chart = new _umychartChartpaintWechat.JSCommonChartPaint_ChartRectangle();
    chart.Canvas = hqChart.Canvas;
    chart.Name = varItem.Name;
    chart.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    chart.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;

    chart.Color = [varItem.Draw.DrawData.Color];
    chart.Rect = varItem.Draw.DrawData.Rect;
    if (varItem.Color) chart.BorderColor = this.GetColor(varItem.Color);
    hqChart.ChartPaint.push(chart);
  };

  this.CreateBackgroud = function (hqChart, windowIndex, varItem, id)
  {
    var chart = new _umychartChartpaintWechat.JSCommonChartPaint_ChartBackground();
    chart.Canvas = hqChart.Canvas;
    chart.Name = varItem.Name;
    chart.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    chart.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;
    if (varItem.Draw && varItem.Draw.DrawData)
    {
      var drawData = varItem.Draw.DrawData;
      chart.Color = drawData.Color;
      chart.ColorAngle = drawData.Angle;

      if (drawData.Data) chart.Data.Data = drawData.Data;
    }

    hqChart.ChartPaint.push(chart);
  };

  this.CreateMultiText = function (hqChart, windowIndex, varItem, i)
  {
    var chart = new _umychartChartpaintWechat.JSCommonChartPaint_ChartMultiText();
    chart.Canvas = hqChart.Canvas;
    chart.Name = varItem.Name;
    chart.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    chart.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;

    chart.Data = hqChart.ChartPaint[0].Data; //绑定K线
    chart.Texts = varItem.Draw.DrawData;
    hqChart.ChartPaint.push(chart);
  };

  this.CreateMulitHtmlDom = function (hqChart, windowIndex, varItem, i)
  {
    var chart = new _umychartChartpaintWechat.JSCommonChartPaint_ChartMultiHtmlDom();
    chart.Canvas = hqChart.Canvas;
    chart.Name = varItem.Name;
    chart.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    chart.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;

    chart.Data = hqChart.ChartPaint[0].Data; //绑定K线
    chart.Texts = varItem.Draw.DrawData;
    chart.DrawCallback = varItem.Draw.Callback;
    hqChart.ChartPaint.push(chart);
  };

  this.CreateMultiLine = function (hqChart, windowIndex, varItem, i)
  {
    var chart = new _umychartChartpaintWechat.JSCommonChartPaint_ChartMultiLine();
    chart.Canvas = hqChart.Canvas;
    chart.Name = varItem.Name;
    chart.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    chart.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;

    chart.Data = hqChart.ChartPaint[0].Data; //绑定K线
    chart.Lines = varItem.Draw.DrawData;
    hqChart.ChartPaint.push(chart);
  };

  this.CreateMultiBar = function (hqChart, windowIndex, varItem, i)
  {
    var chart = new _umychartChartpaintWechat.JSCommonChartPaint_ChartMultiBar();
    chart.Canvas = hqChart.Canvas;
    chart.Name = varItem.Name;
    chart.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    chart.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;

    chart.Data = hqChart.ChartPaint[0].Data; //绑定K线
    chart.Bars = varItem.Draw.DrawData;
    hqChart.ChartPaint.push(chart);
  };

  //创建K线背景
  this.CreateSelfKLine = function (hqChart, windowIndex, hisData)
  {
    var chart = new _umychartChartpaintWechat.JSCommonChartPaint_ChartKLine();
    chart.Canvas = hqChart.Canvas;
    chart.Name = "Self Kline";
    chart.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
    chart.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;

    chart.Data = hisData;
    chart.IsShowMaxMinPrice = false;
    chart.IsShowKTooltip = false;
    chart.DrawType = this.KLineType;

    hqChart.ChartPaint.push(chart);
  };

  this.BindInstructionData = function (hqChart, windowIndex, hisData) //绑定指示指标
  {
    if (this.OutVar == null || this.OutVar.length < 0) return;
    if (this.InstructionType == 2)
    {
      var varItem = this.OutVar[this.OutVar.length - 1]; //取最后一组数据作为指示数据
      hqChart.SetInstructionData(this.InstructionType, { Data: varItem.Data }); //设置指示数据
      return true;
    } else
    if (this.InstructionType == 1) //交易系统
      {
        var buyData, sellData;
        for (var i in this.OutVar)
        {
          var item = this.OutVar[i];
          if (item.Name == 'ENTERLONG') buyData = item.Data;else
          if (item.Name == 'EXITLONG') sellData = item.Data;
        }

        hqChart.SetInstructionData(this.InstructionType, { Buy: buyData, Sell: sellData }); //设置指示数据
        return true;
      }
  };


  this.BindData = function (hqChart, windowIndex, hisData)
  {
    if (windowIndex == 0 && this.InstructionType)
    {
      this.BindInstructionData(hqChart, windowIndex, hisData);
      return;
    }

    //清空指标图形
    hqChart.DeleteIndexPaint(windowIndex);
    if (windowIndex == 0) hqChart.ShowKLine(true);

    if (this.OutVar == null || this.OutVar.length < 0) return;

    //叠加一个K线背景
    if (this.KLineType != null)
    {
      if (this.KLineType === 0 || this.KLineType === 1 || this.KLineType === 2) this.CreateSelfKLine(hqChart, windowIndex, hisData);else
      if (this.KLineType === -1 && windowIndex == 0) hqChart.ShowKLine(false);
    }

    if (windowIndex >= 1 && hqChart.Frame)
    {
      hqChart.Frame.SubFrame[windowIndex].Frame.YSplitOperator.FloatPrecision = this.FloatPrecision;
      if (this.YSpecificMaxMin) hqChart.Frame.SubFrame[windowIndex].Frame.YSpecificMaxMin = this.YSpecificMaxMin; //最大最小值
      if (this.YSplitScale) hqChart.Frame.SubFrame[windowIndex].Frame.YSplitScale = this.YSplitScale; //固定刻度
    }

    for (var i in this.OutVar)
    {
      var item = this.OutVar[i];
      if (item.IsExData === true) continue; //扩展数据不显示图形

      if (item.Type == 0)
      {
        if (item.IsOverlayLine) this.CreateOverlayLine(hqChart, windowIndex, item, i);else
        this.CreateLine(hqChart, windowIndex, item, i);
      } else
      if (item.Type == 1)
      {
        switch (item.Draw.DrawType) {

          case 'STICKLINE':
            this.CreateBar(hqChart, windowIndex, item, i);
            break;
          case 'DRAWTEXT':
          case 'SUPERDRAWTEXT':
          case 'DRAWTEXT_FIX':
            this.CreateText(hqChart, windowIndex, item, i);
            break;
          case 'DRAWLINE':
            this.CreateStraightLine(hqChart, windowIndex, item, i);
            break;
          case 'DRAWBAND':
            this.CreateBand(hqChart, windowIndex, item, i);
            break;
          case 'DRAWKLINE':
            this.CreateKLine(hqChart, windowIndex, item, i);
            break;
          case 'DRAWKLINE_IF':
            this.CreateKLine(hqChart, windowIndex, item, i);
            break;
          case 'POLYLINE':
            this.CreatePolyLine(hqChart, windowIndex, item, i);
            break;
          case 'DRAWNUMBER':
            this.CreateNumberText(hqChart, windowIndex, item, i);
            break;
          case 'DRAWICON':
            this.CreateIcon(hqChart, windowIndex, item, i);
            break;
          case 'DRAWRECTREL':
            this.CreateRectangle(hqChart, windowIndex, item, i);
            break;
          case 'DRAWGBK':
          case "DRAWGBK2":
            this.CreateBackgroud(hqChart, windowIndex, item, i);
            break;

          //第3方指标定制
          case 'MULTI_TEXT':
            this.CreateMultiText(hqChart, windowIndex, item, i);
            break;
          case "MULTI_HTMLDOM":
            this.CreateMulitHtmlDom(hqChart, windowIndex, item, i);
            break;
          case 'MULTI_LINE':
            this.CreateMultiLine(hqChart, windowIndex, item, i);
            break;
          case 'MULTI_BAR':
            this.CreateMultiBar(hqChart, windowIndex, item, i);
            break;
          case "KLINE_BG":
            this.CreateBackgroud(hqChart, windowIndex, item, i);
            break;}

      } else
      if (item.Type == 2)
      {
        this.CreateMACD(hqChart, windowIndex, item, i);
      } else
      if (item.Type == 3)
      {
        this.CreatePointDot(hqChart, windowIndex, item, i);
      } else
      if (item.Type == 4)
      {
        this.CreateLineStick(hqChart, windowIndex, item, i);
      } else
      if (item.Type == 5)
      {
        this.CreateStick(hqChart, windowIndex, item, i);
      } else
      if (item.Type == 6)
      {
        this.CreateVolStick(hqChart, windowIndex, item, i, hisData);
      }

      var titlePaint = hqChart.TitlePaint[windowIndex + 1];
      if (titlePaint && titlePaint.Data && i < titlePaint.Data.length) //设置标题数值 小数位数和格式
        {
          if (this.StringFormat > 0) titlePaint.Data[i].StringFormat = this.StringFormat;
          if (this.FloatPrecision >= 0) titlePaint.Data[i].FloatPrecision = this.FloatPrecision;
          if (this.OutName && this.OutName.length > 0 && this.Arguments && this.Arguments.length > 0)
          {
            titlePaint.SetDynamicOutName(this.OutName, this.Arguments);
          }
        }
    }

    var titleIndex = windowIndex + 1;
    hqChart.TitlePaint[titleIndex].Title = this.Name;

    var indexParam = '';
    for (var _i in this.Arguments)
    {
      var _item = this.Arguments[_i];
      if (indexParam.length > 0) indexParam += ',';
      indexParam += _item.Value.toString();
    }

    if (indexParam.length > 0) hqChart.TitlePaint[titleIndex].Title = this.Name + '(' + indexParam + ')';

    if (hqChart.UpdateUICallback) hqChart.UpdateUICallback('ScriptIndex', this.OutVar,
    { WindowIndex: windowIndex, Name: this.Name, Arguments: this.Arguments, HistoryData: hisData }); //通知上层回调

    return true;
  };


  this.GetDefaultColor = function (id) //给一个默认的颜色
  {
    var COLOR_ARRAY = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.ColorArray;
    var number = parseInt(id);
    return COLOR_ARRAY[number % (COLOR_ARRAY.length - 1)];
  };


  this.GetColor = function (colorName) //获取颜色
  {
    var COLOR_MAP = new Map([
    ['COLORBLACK', 'rgb(0,0,0)'],
    ['COLORBLUE', 'rgb(18,95,216)'],
    ['COLORGREEN', 'rgb(25,158,0)'],
    ['COLORCYAN', 'rgb(0,255,198)'],
    ['COLORRED', 'rgb(238,21,21)'],
    ['COLORMAGENTA', 'rgb(255,0,222)'],
    ['COLORBROWN', 'rgb(149,94,15)'],
    ['COLORLIGRAY', 'rgb(218,218,218)'], //画淡灰色
    ['COLORGRAY', 'rgb(133,133,133)'], //画深灰色
    ['COLORLIBLUE', 'rgb(94,204,255)'], //淡蓝色
    ['COLORLIGREEN', 'rgb(183,255,190)'], //淡绿色
    ['COLORLICYAN', 'rgb(154,255,242)'], //淡青色
    ['COLORLIRED', 'rgb(255,172,172)'], //淡红色
    ['COLORLIMAGENTA', 'rgb(255,145,241)'], //淡洋红色
    ['COLORWHITE', 'rgb(255,255,255)'], //白色
    ['COLORYELLOW', 'rgb(255,198,0)']]);


    if (COLOR_MAP.has(colorName)) return COLOR_MAP.get(colorName);

    //COLOR 自定义色
    //格式为COLOR+“RRGGBB”：RR、GG、BB表示红色、绿色和蓝色的分量，每种颜色的取值范围是00-FF，采用了16进制。
    //例如：MA5：MA(CLOSE，5)，COLOR00FFFF　表示纯红色与纯绿色的混合色：COLOR808000表示淡蓝色和淡绿色的混合色。
    if (colorName.indexOf('COLOR') == 0) return '#' + colorName.substr(5);
    return 'rgb(30,144,255)';
  };
}





//市场多空
function MarketLongShortIndex()
{
  this.newMethod = BaseIndex; //派生
  this.newMethod('市场多空');
  delete this.newMethod;

  this.Index = new Array(
  new IndexInfo("多空指标", null),
  new IndexInfo("多头区域", null),
  new IndexInfo("空头区域", null));


  this.Index[0].LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.LineColor[0];
  this.Index[1].LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.UpBarColor;
  this.Index[2].LineColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DownBarColor;

  this.LongShortData; //多空数据

  this.Create = function (hqChart, windowIndex) {
    for (var i in this.Index) {
      var paint = null;
      if (i == 0)
      paint = new _umychartChartpaintWechat.JSCommonChartPaint_ChartLine();else

      paint = new ChartStraightLine();

      paint.Color = this.Index[i].LineColor;
      paint.Canvas = hqChart.Canvas;
      paint.Name = this.Name + "-" + i.toString();
      paint.ChartBorder = hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
      paint.ChartFrame = hqChart.Frame.SubFrame[windowIndex].Frame;

      hqChart.ChartPaint.push(paint);
    }
  };

  //请求数据
  this.RequestData = function (hqChart, windowIndex, hisData) {
    var self = this;
    var param =
    {
      HQChart: hqChart,
      WindowIndex: windowIndex,
      HistoryData: hisData };


    this.LongShortData = [];

    if (param.HQChart.Period > 0) //周期数据
      {
        this.NotSupport(param.HQChart, param.WindowIndex, "不支持周期切换");
        param.HQChart.Draw();
        return false;
      }

    //请求数据
    wx.request({
      url: _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Index.MarketLongShortApiUrl,
      data:
      {},


      method: 'POST',
      dataType: "json",
      async: true,
      success: function success(recvData) {
        self.RecvData(recvData, param);
      } });


    return true;
  };

  this.RecvData = function (recvData, param) {
    if (recvData.data.data.length <= 0) return;

    var aryData = new Array();
    for (var i in recvData.data.data) {
      var item = recvData.data.data[i];
      var indexData = new SingleData();
      indexData.Date = item[0];
      indexData.Value = item[1];
      aryData.push(indexData);
    }

    var aryFittingData = param.HistoryData.GetFittingData(aryData);

    var bindData = new ChartData();
    bindData.Data = aryFittingData;
    bindData.Period = param.HQChart.Period; //周期
    bindData.Right = param.HQChart.Right; //复权

    this.LongShortData = bindData.GetValue();
    this.BindData(param.HQChart, param.WindowIndex, param.HistoryData);

    param.HQChart.UpdataDataoffset(); //更新数据偏移
    param.HQChart.UpdateFrameMaxMin(); //调整坐标最大 最小值
    param.HQChart.Draw();

  };


  this.BindData = function (hqChart, windowIndex, hisData) {
    var paint = hqChart.GetChartPaint(windowIndex);

    if (paint.length != this.Index.length) return false;

    //paint[0].Data.Data=SWLData;
    paint[0].Data.Data = this.LongShortData;
    paint[0].NotSupportMessage = null;
    paint[1].Data.Data[0] = 8;
    paint[2].Data.Data[0] = 1;

    //指定[0,9]
    hqChart.Frame.SubFrame[windowIndex].Frame.YSpecificMaxMin = { Max: 9, Min: 0, Count: 3 };

    var titleIndex = windowIndex + 1;

    for (var i in paint) {
      hqChart.TitlePaint[titleIndex].Data[i] = new _umychartCharttitleWechat.JSCommonChartTitle_DynamicTitleData(paint[i].Data, this.Index[i].Name, this.Index[i].LineColor);
      if (i > 0) hqChart.TitlePaint[titleIndex].Data[i].DataType = "StraightLine";
    }

    hqChart.TitlePaint[titleIndex].Title = this.FormatIndexTitle();

    if (hqChart.UpdateUICallback) hqChart.UpdateUICallback('MarketLongShortIndex', paint, { WindowIndex: windowIndex, HistoryData: hisData }); //通知上层回调
    return true;
  };

}



module.exports =
{
  JSCommonIndex:
  {
    IndexInfo: IndexInfo,
    BaseIndex: BaseIndex,
    ScriptIndex: ScriptIndex },


  //单个类导出
  JSCommonIndex_IndexInfo: IndexInfo,
  JSCommonIndex_BaseIndex: BaseIndex,
  JSCommonIndex_ScriptIndex: ScriptIndex };

/***/ }),
/* 114 */
/*!**********************************************************************!*\
  !*** I:/out-project/FCoinEx/static/js/umychart.charttitle.wechat.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";












var _umychartResourceWechat = __webpack_require__(/*! ./umychart.resource.wechat.js */ 106);






var _umychartDataWechat = __webpack_require__(/*! ./umychart.data.wechat.js */ 103);











var _umychartCoordinatedataWechat = __webpack_require__(/*! ./umychart.coordinatedata.wechat.js */ 104);




var _umychartKlineinfoWechat = __webpack_require__(/*! ./umychart.klineinfo.wechat.js */ 105);




var _umychartFramesplitWechat = __webpack_require__(/*! ./umychart.framesplit.wechat.js */ 111); /*
                                                                                copyright (c) 2018 jones
                                                                            
                                                                                http://www.apache.org/licenses/LICENSE-2.0
                                                                            
                                                                                开源项目 https://github.com/jones2000/HQChart
                                                                            
                                                                                jones_2000@163.com
                                                                                
                                                                                标题画法
                                                                            */var MARKET_SUFFIX_NAME = _umychartCoordinatedataWechat.JSCommonCoordinateData.MARKET_SUFFIX_NAME; //标题画法基类
function IChartTitlePainting() {this.Frame;this.Data = new Array();
  this.Canvas; //画布
  this.IsDynamic = false; //是否是动态标题
  this.Position = 0; //标题显示位置 0 框架里的标题  1 框架上面
  this.CursorIndex; //数据索引
  this.Font = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DynamicTitleFont; //"12px 微软雅黑";
  this.Title; //固定标题(可以为空)
  this.TitleColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DefaultTextColor;
  this.LanguageID = _umychartResourceWechat.JSCommonResource_JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID;
  this.UpdateUICallback; //通知外面更新标题(老接口废弃)
  this.OnDrawEvent; //外部事件通知
}

var PERIOD_NAME = ["日线", "周线", "月线", "年线", "1分", "5分", "15分", "30分", "60分", "季线", "分笔", "2小时", "4小时", "", ""];
var RIGHT_NAME = ['不复权', '前复权', '后复权'];
//K线标题
function DynamicKLineTitlePainting()
{
  this.newMethod = IChartTitlePainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.ClassName = 'DynamicKLineTitlePainting';
  this.IsDynamic = true;
  this.IsShow = true; //是否显示
  this.LineCount = 1; //默认显示1行
  this.SpaceWidth = 1; //空格宽度  
  this.Period; //周期  

  this.UpColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.UpTextColor;
  this.DownColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.DownTextColor;
  this.UnchagneColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.UnchagneTextColor;

  this.VolColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Title.VolColor;
  this.AmountColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Title.AmountColor;
  this.DateTimeColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Title.DateTimeColor;
  this.NameColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Title.NameColor;
  this.SettingColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Title.SettingColor; //周期 复权
  this.PositionColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.Title.PositionColor; //持仓

  this.Symbol;
  this.UpperSymbol;
  this.Name;
  this.InfoData;
  this.InfoTextHeight = 15;
  this.InfoTextColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.KLine.Info.TextColor;
  this.InfoTextBGColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.KLine.Info.TextBGColor;

  this.IsShowName = true; //是否显示股票名称
  this.IsShowSettingInfo = true; //是否显示设置信息(周期 复权)

  this.GetCurrentKLineData = function () //获取当天鼠标位置所在的K线数据
  {
    if (this.CursorIndex == null || !this.Data) return null;
    if (this.Data.length <= 0) return null;

    var index = this.CursorIndex;
    index = parseInt(index.toFixed(0));
    var dataIndex = this.Data.DataOffset + index;
    if (dataIndex >= this.Data.Data.length) dataIndex = this.Data.Data.length - 1;
    if (dataIndex < 0) return null;

    var item = this.Data.Data[dataIndex];
    return item;
  };

  this.GetDataIndex = function ()
  {
    if (this.CursorIndex == null || !this.Data) return null;
    if (this.Data.length <= 0) return null;

    var index = this.CursorIndex;
    index = parseInt(index.toFixed(0));
    var dataIndex = this.Data.DataOffset + index;
    if (dataIndex >= this.Data.Data.length) dataIndex = this.Data.Data.length - 1;
    if (dataIndex < 0) return null;

    return dataIndex;
  };

  this.SendUpdateUIMessage = function (funcName) //通知外面 标题变了
  {
    if (!this.UpdateUICallback) return;

    var sendData = {
      TitleName: 'K线标题', CallFunction: funcName, Stock: { Name: this.Name, Symbol: this.Symbol },
      Rect:
      {
        Left: this.Frame.ChartBorder.GetLeft(), Right: this.Frame.ChartBorder.GetRight(),
        Top: 0, Bottom: this.Frame.ChartBorder.GetTop() } };



    //有数据
    if (this.Data && this.Data.Data && this.Data.Data.length > 0) {
      var index = this.Data.Data.length - 1; //默认最后一天的数据
      if (this.CursorIndex) {
        var cursorIndex = Math.abs(this.CursorIndex - 0.5);
        cursorIndex = parseInt(cursorIndex.toFixed(0));
        index = this.Data.DataOffset + cursorIndex;
        if (index >= this.Data.Data.length) index = this.Data.Data.length - 1;
      }

      if (index >= 0) {
        var item = this.Data.Data[index];
        sendData.Stock.Data =
        {
          Date: item.Date,
          YClose: item.YClose, Open: item.Open, High: item.High, Low: item.Low, Close: item.Close,
          Vol: item.Vol, Amount: item.Amount };

        if (item.Time) sendData.Stock.Time = item.Time; //分钟K线才有时间
      }

      if (this.Data.Period != null) sendData.Stock.PeriodName = this.GetPeriodName(this.Data.Period); //周期名字
      if (this.Data.Right != null) sendData.Stock.RightName = RIGHT_NAME[this.Data.Right]; //复权名字
    }

    //console.log('[DynamicKLineTitlePainting::SendUpdateUIMessage', sendData);
    this.UpdateUICallback(sendData);
  };

  this.GetPeriodName = function (period)
  {
    var name = '';
    if (period > _umychartDataWechat.JSCommon_CUSTOM_MINUTE_PERIOD_START && period <= _umychartDataWechat.JSCommon_CUSTOM_MINUTE_PERIOD_END)
    name = period - _umychartDataWechat.JSCommon_CUSTOM_MINUTE_PERIOD_START + _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('自定义分钟', this.LanguageID);else
    if (period > _umychartDataWechat.JSCommon_CUSTOM_DAY_PERIOD_START && period <= _umychartDataWechat.JSCommon_CUSTOM_DAY_PERIOD_END)
    name = period - _umychartDataWechat.JSCommon_CUSTOM_DAY_PERIOD_START + _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('自定义日线', this.LanguageID);else
    if (period > _umychartDataWechat.JSCommon_CUSTOM_SECOND_PERIOD_START && period <= _umychartDataWechat.JSCommon_CUSTOM_SECOND_PERIOD_END)
    name = period - _umychartDataWechat.JSCommon_CUSTOM_SECOND_PERIOD_START + _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('自定义秒', this.LanguageID);else

    name = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText(_umychartDataWechat.JSCommon_ChartData.GetPeriodName(period), this.LanguageID);
    return name;
  };

  this.GetRightName = function (rightID, periodID)
  {
    //分钟K线没有复权
    if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(periodID, true) || _umychartDataWechat.JSCommon_ChartData.IsSecondPeriod(periodID))
    return null;

    if (MARKET_SUFFIX_NAME.IsSHSZStockA(this.UpperSymbol)) //A股有复权
      {
        var rightName = RIGHT_NAME[rightID];
        return rightName;
      }

    return null;
  };

  this.FullDraw = function ()
  {
    if (!this.IsShow) return;
    this.UpperSymbol = this.Symbol ? this.Symbol.toUpperCase() : '';
    if (this.CursorIndex == null || !this.Data || this.Data.length <= 0)
    {
      this.OnDrawEventCallback(null, 'DynamicKLineTitlePainting::FullDraw');
      return;
    }

    this.SpaceWidth = this.Canvas.measureText(' ').width;
    var index = this.CursorIndex;
    index = parseInt(index.toFixed(0));
    var dataIndex = this.Data.DataOffset + index;
    if (dataIndex >= this.Data.Data.length) dataIndex = -1;
    if (dataIndex < 0)
    {
      this.OnDrawEventCallback(null, 'DynamicKLineTitlePainting::FullDraw');
      return;
    }

    var item = this.Data.Data[dataIndex];
    this.OnDrawEventCallback(item, 'DynamicKLineTitlePainting::FullDraw');

    if (this.Frame.IsHScreen === true)
    {
      this.Canvas.save();
      if (this.LineCount > 1) this.DrawMulitLine(item);else
      this.DrawSingleLine(item, true);
      this.Canvas.restore();
      if (!item.Time && item.Date && this.InfoData) this.HSCreenKLineInfoDraw(item.Date);
    } else

    {
      if (this.LineCount > 1) this.DrawMulitLine(item);else
      this.DrawSingleLine(item, true);
      if (!item.Time && item.Date && this.InfoData) this.KLineInfoDraw(item.Date);
    }
  };

  this.DrawTitle = function ()
  {
    this.UpperSymbol = this.Symbol ? this.Symbol.toUpperCase() : '';
    this.SendUpdateUIMessage('DrawTitle');
    this.OnDrawEventCallback(null, 'DynamicKLineTitlePainting::DrawTitle');

    if (!this.IsShow) return;
    if (!this.IsShowName && !this.IsShowSettingInfo) return;
    if (this.LineCount > 1) return;

    if (this.Frame.IsHScreen === true)
    {
      this.Canvas.save();
      this.HScreenDrawTitle();
      this.Canvas.restore();
      return;
    }

    var left = this.Frame.ChartBorder.GetLeft();
    var bottom = this.Frame.ChartBorder.GetTop();
    var right = this.Frame.ChartBorder.GetRight();
    if (bottom < 5) return;

    this.Canvas.textAlign = "left";
    this.Canvas.textBaseline = "bottom";
    this.Canvas.font = this.Font;
    var position = { Left: left, Bottom: bottom, IsHScreen: false };

    if (this.IsShowName && this.Name)
    {
      if (!this.DrawKLineText(this.Name, this.NameColor, position)) return;
    }

    if (this.IsShowSettingInfo && this.Data.Period != null && this.Data.Right != null)
    {
      var periodName = this.GetPeriodName(this.Data.Period);
      var rightName = this.GetRightName(this.Data.Right, this.Data.Period);
      var text = "(" + periodName + ")";
      if (rightName) text = "(" + periodName + " " + rightName + ")";
      if (!this.DrawKLineText(text, this.SettingColor, position)) return;
    }
  };

  this.HScreenDrawTitle = function ()
  {
    var xText = this.Frame.ChartBorder.GetRight();
    var yText = this.Frame.ChartBorder.GetTop();
    var right = this.Frame.ChartBorder.GetHeight();
    if (this.Frame.ChartBorder.Right < 10) return;

    this.Canvas.translate(xText, yText);
    this.Canvas.rotate(90 * Math.PI / 180);

    this.Canvas.textAlign = "left";
    this.Canvas.textBaseline = "bottom";
    this.Canvas.font = this.Font;

    var left = 2;
    var bottom = -2;
    var position = { Left: left, Bottom: bottom, IsHScreen: false };
    if (this.IsShowName && this.Name)
    {
      if (!this.DrawKLineText(this.Name, this.NameColor, position)) return;
    }

    if (this.IsShowSettingInfo && this.Data.Period != null && this.Data.Right != null)
    {
      var periodName = this.GetPeriodName(this.Data.Period);
      var rightName = this.GetRightName(this.Data.Right, this.Data.Period);
      var text = "(" + periodName + ")";
      if (rightName) text = "(" + periodName + " " + rightName + ")";
      if (!this.DrawKLineText(text, this.SettingColor, position)) return;
    }
  };

  this.DrawMulitLine = function (item) //画多行
  {
    var isHScreen = this.Frame.IsHScreen === true;
    var leftSpace = 1;
    var bottomSpace = 1;
    var left = this.Frame.ChartBorder.GetLeft() + leftSpace;;
    var width = this.Frame.ChartBorder.GetWidth();
    var height = this.Frame.ChartBorder.GetTop();
    var defaultfloatPrecision = _umychartCoordinatedataWechat.JSCommonCoordinateData.GetfloatPrecision(this.Symbol); //价格小数位数
    if (isHScreen)
    {
      var left = leftSpace;;
      var width = this.Frame.ChartBorder.GetHeight();
      var height = this.Frame.ChartBorder.Right;
      var xText = this.Frame.ChartBorder.GetChartWidth();
      var yText = this.Frame.ChartBorder.GetTop();

      this.Canvas.translate(xText, yText);
      this.Canvas.rotate(90 * Math.PI / 180);
    }

    var itemHeight = (height - bottomSpace) / this.LineCount;
    var itemWidth = (width - leftSpace) / 4;
    var bottom = itemHeight;

    this.Canvas.textAlign = "left";
    this.Canvas.textBaseline = "bottom";
    this.Canvas.font = this.Font;

    var text = _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatDateString(item.Date);
    this.Canvas.fillStyle = this.DateTimeColor;
    this.Canvas.fillText(text, left, bottom, itemWidth);
    left += itemWidth;

    this.Canvas.textAlign = "left";
    this.Canvas.fillStyle = this.GetColor(item.Open, item.YClose);
    var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Open', this.LanguageID) + item.Open.toFixed(defaultfloatPrecision);
    this.Canvas.fillText(text, left, bottom, itemWidth);
    left += itemWidth;

    this.Canvas.fillStyle = this.GetColor(item.High, item.YClose);
    var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-High', this.LanguageID) + item.High.toFixed(defaultfloatPrecision);
    this.Canvas.fillText(text, left, bottom, itemWidth);
    left += itemWidth;

    var value = (item.Close - item.YClose) / item.YClose * 100;
    this.Canvas.fillStyle = this.GetColor(value, 0);
    var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Increase', this.LanguageID) + value.toFixed(2) + '%';
    this.Canvas.fillText(text, left, bottom, itemWidth);
    left += itemWidth;

    bottom += itemHeight; //换行
    var left = this.Frame.ChartBorder.GetLeft() + leftSpace;
    if (isHScreen) left = leftSpace;
    if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(this.Period, true) && item.Time)
    {
      this.Canvas.fillStyle = this.DateTimeColor;
      var text = _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatTimeString(item.Time);
      this.Canvas.fillText(text, left, bottom, itemWidth);
    } else
    if (_umychartDataWechat.JSCommon_ChartData.IsSecondPeriod(this.Period) && item.Time)
    {
      this.Canvas.fillStyle = this.SettingColor;
      var text = _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatTimeString(item.Time, 'HH:MM:SS');
      this.Canvas.fillText(text, left, bottom, itemWidth);
    }
    left += itemWidth;

    this.Canvas.fillStyle = this.GetColor(item.Close, item.YClose);
    var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Close', this.LanguageID) + item.Close.toFixed(defaultfloatPrecision);
    this.Canvas.fillText(text, left, bottom, itemWidth);
    left += itemWidth;

    this.Canvas.fillStyle = this.GetColor(item.Low, item.YClose);
    var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Low', this.LanguageID) + item.Low.toFixed(defaultfloatPrecision);
    this.Canvas.fillText(text, left, bottom, itemWidth);
    left += itemWidth;

    this.Canvas.fillStyle = this.AmountColor;
    var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Amount', this.LanguageID) + _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatValueString(item.Amount, 2, this.LanguageID);
    this.Canvas.fillText(text, left, bottom, itemWidth);
    left += itemWidth;
  };

  this.DrawSingleLine = function (item, bDrawTitle) //画单行
  {
    var isHScreen = this.Frame.IsHScreen === true;
    var left = this.Frame.ChartBorder.GetLeft();
    //var bottom=this.Frame.ChartBorder.GetTop()-this.Frame.ChartBorder.Top/2;
    var bottom = this.Frame.ChartBorder.GetTop();
    var right = this.Frame.ChartBorder.GetRight();
    var defaultfloatPrecision = _umychartCoordinatedataWechat.JSCommonCoordinateData.GetfloatPrecision(this.Symbol); //价格小数位数

    if (isHScreen)
    {
      right = this.Frame.ChartBorder.GetHeight();
      if (this.Frame.ChartBorder.Right < 5) return;
      left = 2;
      bottom = -2;
      var xText = this.Frame.ChartBorder.GetRight();
      var yText = this.Frame.ChartBorder.GetTop();
      this.Canvas.translate(xText, yText);
      this.Canvas.rotate(90 * Math.PI / 180);
    } else

    {
      if (bottom < 5) return;
    }

    this.Canvas.textAlign = "left";
    this.Canvas.textBaseline = "bottom";
    this.Canvas.font = this.Font;

    var position = { Left: left, Bottom: bottom, IsHScreen: isHScreen };

    if (this.IsShowName) //名称
      {
        if (!this.DrawKLineText(this.Name, this.NameColor, position, bDrawTitle == true)) return;
      }

    if (this.IsShowSettingInfo) //周期 复权信息
      {
        var periodName = this.GetPeriodName(this.Data.Period);
        var rightName = this.GetRightName(this.Data.Right, this.Data.Period);
        var text = "(" + periodName + ")";
        if (rightName) text = "(" + periodName + " " + rightName + ")";
        if (!this.DrawKLineText(text, this.SettingColor, position, bDrawTitle == true)) return;
      }

    var text = _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatDateString(item.Date); //日期
    if (!this.DrawKLineText(text, this.DateTimeColor, position)) return;

    //时间
    if (_umychartDataWechat.JSCommon_ChartData.IsMinutePeriod(this.Period, true) && _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Time))
    {
      var text = _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatTimeString(item.Time);
      if (!this.DrawKLineText(text, this.DateTimeColor, position)) return;
    } else
    if (_umychartDataWechat.JSCommon_ChartData.IsSecondPeriod(this.Period) && _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Time))
    {
      var text = _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatTimeString(item.Time, "HH:MM:SS");
      if (!this.DrawKLineText(text, this.DateTimeColor, position)) return;
    }

    var color = this.GetColor(item.Open, item.YClose);
    var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('KTitle-Open', this.LanguageID) + item.Open.toFixed(defaultfloatPrecision);
    if (!this.DrawKLineText(text, color, position)) return;

    var color = this.GetColor(item.High, item.YClose);
    var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('KTitle-High', this.LanguageID) + item.High.toFixed(defaultfloatPrecision);
    if (!this.DrawKLineText(text, color, position)) return;

    var color = this.GetColor(item.Low, item.YClose);
    var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('KTitle-Low', this.LanguageID) + item.Low.toFixed(defaultfloatPrecision);
    if (!this.DrawKLineText(text, color, position)) return;

    var color = this.GetColor(item.Close, item.YClose);
    var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('KTitle-Close', this.LanguageID) + item.Close.toFixed(defaultfloatPrecision);
    if (!this.DrawKLineText(text, color, position)) return;

    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Vol))
    {
      var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('KTitle-Vol', this.LanguageID) + _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatValueString(item.Vol, 2);
      if (!this.DrawKLineText(text, this.VolColor, position)) return;
    }

    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Amount))
    {
      var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('KTitle-Amount', this.LanguageID) + _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatValueString(item.Amount, 2);
      if (!this.DrawKLineText(text, this.AmountColor, position)) return;
    }

    if (MARKET_SUFFIX_NAME.IsChinaFutures(this.UpperSymbol) && _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Position))
    {
      var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('KTitle-Position', this.LanguageID) + _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatValueString(item.Position, 2);
      if (!this.DrawKLineText(text, this.PositionColor, position)) return;
    }
  };

  this.OnDrawEventCallback = function (drawData, explain)
  {
    if (!this.OnDrawEvent || !this.OnDrawEvent.Callback) return;
    var data = { Draw: drawData, Name: this.ClassName, Explain: explain };
    if (this.Data && this.Data.Data)
    {
      if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(this.CursorIndex))
      {
        var index = this.CursorIndex;
        index = parseInt(index.toFixed(0));
        var dataIndex = this.Data.DataOffset + index;
      } else

      {
        dataIndex = this.Data.Data.length - 1;
      }

      var dataCount = this.Data.Data.length;
      data.DataIndex = dataIndex;
      data.DataCount = dataCount;
    }
    this.OnDrawEvent.Callback(this.OnDrawEvent, data, this);
  };

  this.Draw = function ()
  {
    this.UpperSymbol = this.Symbol ? this.Symbol.toUpperCase() : '';
    this.SendUpdateUIMessage('Draw');

    if (!this.IsShow) return;
    if (this.CursorIndex == null || !this.Data || this.Data.length <= 0)
    {
      this.OnDrawEventCallback(null, 'DynamicKLineTitlePainting::Draw');
      return;
    }

    this.SpaceWidth = this.Canvas.measureText(' ').width;
    var index = this.CursorIndex;
    index = parseInt(index.toFixed(0));
    var dataIndex = this.Data.DataOffset + index;
    if (dataIndex >= this.Data.Data.length) dataIndex = this.Data.Data.length - 1;
    if (dataIndex < 0)
    {
      this.OnDrawEventCallback(null, 'DynamicKLineTitlePainting::Draw');
      return;
    }

    var item = this.Data.Data[dataIndex];
    this.OnDrawEventCallback(item, 'DynamicKLineTitlePainting::Draw');

    if (this.Frame.IsHScreen === true)
    {
      this.Canvas.save();
      if (this.LineCount > 1) this.DrawMulitLine(item);else
      this.DrawSingleLine(item);
      this.Canvas.restore();
      if (!item.Time && item.Date && this.InfoData) this.HSCreenKLineInfoDraw(item.Date);
    } else

    {
      if (this.LineCount > 1) this.DrawMulitLine(item);else
      this.DrawSingleLine(item);

      if (!item.Time && item.Date && this.InfoData) this.KLineInfoDraw(item.Date);
    }
  };


  this.KLineInfoDraw = function (date) {
    var info = this.InfoData.get(date.toString());
    if (!info) return;
    var invesotrCount = 0; //互动易统计
    var researchCouunt = 0;
    var reportCount = 0;
    var blockTradeCount = 0; //大宗交易次数
    var tradeDetailCount = 0; //龙虎榜上榜次数
    var policyData = null;
    var reportTitle = null,pforecastTitle = null;
    //console.log(info);
    for (var i in info.Data) {
      var item = info.Data[i];
      switch (item.InfoType) {
        case _umychartKlineinfoWechat.JSCommon_KLINE_INFO_TYPE.INVESTOR:
          ++invesotrCount;
          break;
        case _umychartKlineinfoWechat.JSCommon_KLINE_INFO_TYPE.PFORECAST:
          pforecastTitle = item.Title;
          break;
        case _umychartKlineinfoWechat.JSCommon_KLINE_INFO_TYPE.ANNOUNCEMENT:
          ++reportCount;
          break;
        case _umychartKlineinfoWechat.JSCommon_KLINE_INFO_TYPE.ANNOUNCEMENT_QUARTER_1:
        case _umychartKlineinfoWechat.JSCommon_KLINE_INFO_TYPE.ANNOUNCEMENT_QUARTER_2:
        case _umychartKlineinfoWechat.JSCommon_KLINE_INFO_TYPE.ANNOUNCEMENT_QUARTER_3:
        case _umychartKlineinfoWechat.JSCommon_KLINE_INFO_TYPE.ANNOUNCEMENT_QUARTER_4:
          reportTitle = item.Title;
          break;
        case _umychartKlineinfoWechat.JSCommon_KLINE_INFO_TYPE.RESEARCH:
          ++researchCouunt;
          break;
        case _umychartKlineinfoWechat.JSCommon_KLINE_INFO_TYPE.BLOCKTRADING:
          ++blockTradeCount;
          break;
        case _umychartKlineinfoWechat.JSCommon_KLINE_INFO_TYPE.TRADEDETAIL:
          ++tradeDetailCount;
          break;
        case _umychartKlineinfoWechat.JSCommon_KLINE_INFO_TYPE.POLICY:
          policyData = item;
          break;}

    }

    var isHScreen = this.Frame.IsHScreen === true;
    var right = this.Frame.ChartBorder.GetRight() - 4;
    var top = this.Frame.ChartBorder.GetTopEx();
    if (isHScreen) {
      right = this.Frame.ChartBorder.GetBottom() - 4;
      top = this.Frame.ChartBorder.GetRightEx();
      this.Canvas.translate(top, right);
      this.Canvas.rotate(90 * Math.PI / 180);
      right = 0;top = 0;
    }

    this.Canvas.font = this.Font;

    var aryTitle = [];
    var position = { Top: top, Right: right, IsHScreen: isHScreen };

    aryTitle.push(_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatDateString(date));
    if (reportTitle) aryTitle.push(reportTitle); //季报
    if (pforecastTitle) aryTitle.push(pforecastTitle); //业绩预告  
    if (reportCount > 0) aryTitle.push('公告数量:' + reportCount);
    if (researchCouunt > 0) aryTitle.push('机构调研次数:' + researchCouunt);
    if (tradeDetailCount > 0) aryTitle.push('龙虎榜上榜次数:' + tradeDetailCount);
    if (invesotrCount > 0) aryTitle.push('互动易数量:' + invesotrCount);
    if (blockTradeCount > 0) aryTitle.push('大宗交易次数:' + blockTradeCount);
    if (policyData) //策略选股
      {
        for (var _i in policyData.ExtendData) //显示满足的策略
        {
          aryTitle.push(policyData.ExtendData[_i].Name);
        }
      }

    var maxWidth = 0,textBGHeight = 0;
    for (var _i2 in aryTitle) {
      var item = aryTitle[_i2];
      var textWidth = this.Canvas.measureText(item).width + 2; //后空2个像素
      if (maxWidth < textWidth) maxWidth = textWidth;
      textBGHeight += this.InfoTextHeight;
    }

    this.Canvas.fillStyle = this.InfoTextBGColor;
    if (isHScreen) this.Canvas.fillRect(position.Right - maxWidth, position.Top, maxWidth + 2, textBGHeight + 2);else
    this.Canvas.fillRect(position.Right - maxWidth, position.Top, maxWidth + 2, textBGHeight + 2);

    for (var _i3 in aryTitle) {
      var item = aryTitle[_i3];
      this.DrawInfoText(item, position);
    }
  };

  this.HSCreenKLineInfoDraw = function (date) {
    this.Canvas.save();
    this.KLineInfoDraw(date);
    this.Canvas.restore();
  };

  this.GetColor = function (price, yclse) {
    if (price > yclse) return this.UpColor;else
    if (price < yclse) return this.DownColor;else
    return this.UnchagneColor;
  };

  this.DrawInfoText = function (title, position) {
    if (!title) return true;

    this.Canvas.textAlign = "right";
    this.Canvas.textBaseline = "top";
    this.Canvas.fillStyle = this.InfoTextColor;
    this.Canvas.fillText(title, position.Right, position.Top);
    position.Top += this.InfoTextHeight;
    return true;
  };

  this.DrawKLineText = function (title, color, position, isShow)
  {
    if (!title) return true;

    var isHScreen = this.Frame.IsHScreen === true;
    var right = this.Frame.ChartBorder.GetRight();
    if (isHScreen) right = this.Frame.ChartBorder.GetHeight();

    this.Canvas.fillStyle = color;
    var textWidth = this.Canvas.measureText(title).width;
    if (position.Left + textWidth > right) return false;
    if (!(isShow === false)) this.Canvas.fillText(title, position.Left, position.Bottom, textWidth);

    position.Left += textWidth + this.SpaceWidth;
    return true;
  };

}

//分时图标题
function DynamicMinuteTitlePainting()
{
  this.newMethod = DynamicKLineTitlePainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.YClose;
  this.IsShowDate = false; //标题是否显示日期
  this.IsShowName = true; //标题是否显示股票名字
  this.Symbol;
  this.UpperSymbol;
  this.LastShowData; //保存最后显示的数据 给tooltip用
  this.ClassName = 'DynamicMinuteTitlePainting';
  this.SpaceWidth = 2;
  this.IsShowAveragePrice = true; //是否显示均线价格

  this.GetCurrentKLineData = function () //获取当天鼠标位置所在的K线数据
  {
    if (this.LastShowData) return this.LastShowData;
    if (this.CursorIndex == null || !this.Data) return null;
    if (this.Data.length <= 0) return null;

    var index = Math.abs(this.CursorIndex);
    index = parseInt(index.toFixed(0));
    var dataIndex = this.Data.DataOffset + index;
    if (dataIndex >= this.Data.Data.length) dataIndex = this.Data.Data.length - 1;
    if (dataIndex < 0) return null;

    var item = this.Data.Data[dataIndex];
    return item;
  };

  this.SendUpdateUIMessage = function (funcName) //通知外面 标题变了
  {
    if (!this.UpdateUICallback) return;

    var sendData =
    {
      TitleName: '分钟标题', CallFunction: funcName, Stock: { Name: this.Name, Symbol: this.Symbol },
      Rect:
      {
        Left: this.Frame.ChartBorder.GetLeft(), Right: this.Frame.ChartBorder.GetRight(),
        Top: 0, Bottom: this.Frame.ChartBorder.GetTop() } };



    //有数据
    if (this.Data && this.Data.Data && this.Data.Data.length > 0) {
      var index = this.Data.Data.length - 1; //默认最后1分钟的数据
      if (this.CursorIndex) {
        var cursorIndex = Math.abs(this.CursorIndex - 0.5);
        cursorIndex = parseInt(cursorIndex.toFixed(0));
        index = this.Data.DataOffset + cursorIndex;
        if (index >= this.Data.Data.length) index = this.Data.Data.length - 1;
      }

      if (index >= 0) {
        var item = this.Data.Data[index];
        this.LastShowData = item;
        sendData.Stock.Data =
        {
          Time: item.Time, Close: item.Close, AvPrice: item.AvPrice,
          Vol: item.Vol, Amount: item.Amount };

        if (item.Time) sendData.Stock.Time = item.Time; //分钟K线才有时间
      }
    }
    this.UpdateUICallback(sendData);
  };

  this.DrawTitle = function ()
  {
    this.UpperSymbol = this.Symbol ? this.Symbol.toUpperCase() : '';
    this.SendUpdateUIMessage('DrawTitle');
    this.OnDrawEventCallback(null, "DynamicMinuteTitlePainting::DrawTitle");
  };

  this.GetDecimal = function (symbol)
  {
    return _umychartCoordinatedataWechat.JSCommonCoordinateData.GetfloatPrecision(symbol); //价格小数位数
  };

  this.DrawMulitLine = function (item) //画多行
  {
    var leftSpace = 5;
    var bottomSpace = 2;
    var left = this.Frame.ChartBorder.GetLeft() + leftSpace;;
    var right = this.Frame.ChartBorder.GetRight();
    var width = this.Frame.ChartBorder.GetWidth();
    var height = this.Frame.ChartBorder.GetTop();

    var defaultfloatPrecision = this.GetDecimal(this.Symbol); //价格小数位数
    var itemHeight = (height - bottomSpace) / this.LineCount;
    var bottom = itemHeight;

    this.Canvas.textAlign = "left";
    this.Canvas.textBaseline = "bottom";
    this.Canvas.font = this.Font;
    this.Canvas.fillStyle = this.UnchagneColor;

    this.Canvas.fillStyle = this.UnchagneColor;
    var text = _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatDateTimeString(item.DateTime, this.IsShowDate ? 'YYYY-MM-DD' : 'HH-MM');
    var timeWidth = this.Canvas.measureText(text).width + 5; //后空5个像素
    this.Canvas.fillText(text, left, bottom, timeWidth);

    if (this.IsShowDate) {
      var text = _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatDateTimeString(item.DateTime, 'HH-MM');
      this.Canvas.fillText(text, left, bottom + itemHeight, timeWidth);
    }

    var itemWidth = (width - leftSpace - timeWidth) / 2;
    left += timeWidth;

    if (item.Close != null) {
      this.Canvas.fillStyle = this.GetColor(item.Close, this.YClose);
      var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Price', this.LanguageID) + item.Close.toFixed(defaultfloatPrecision);
      this.Canvas.fillText(text, left, bottom, itemWidth);
      left += itemWidth;
    }

    if (item.Increase != null) {
      this.Canvas.fillStyle = this.GetColor(item.Increase, 0);
      var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Increase', this.LanguageID) + item.Increase.toFixed(2) + '%';
      this.Canvas.fillText(text, left, bottom, itemWidth);
      left += itemWidth;
    }

    bottom += itemHeight; //换行
    var left = this.Frame.ChartBorder.GetLeft() + leftSpace + timeWidth;

    this.Canvas.fillStyle = this.VolColor;
    var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Vol', this.LanguageID) + _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatValueString(item.Vol, 2, this.LanguageID);
    this.Canvas.fillText(text, left, bottom, itemWidth);
    left += itemWidth;

    this.Canvas.fillStyle = this.AmountColor;
    var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('Tooltip-Amount', this.LanguageID) + _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatValueString(item.Amount, 2, this.LanguageID);
    this.Canvas.fillText(text, left, bottom, itemWidth);
    left += itemWidth;
  };

  this.DrawItem = function (item)
  {
    var isHScreen = this.Frame.IsHScreen === true;
    var left = this.Frame.ChartBorder.GetLeft();;
    var bottom = this.Frame.ChartBorder.GetTop() - this.Frame.ChartBorder.Top / 2;
    var right = this.Frame.ChartBorder.GetRight();
    var defaultfloatPrecision = this.GetDecimal(this.Symbol); //价格小数位数

    if (isHScreen)
    {
      if (this.Frame.ChartBorder.Right < 5) return;
      var left = 2;
      var bottom = this.Frame.ChartBorder.Right / 2; //上下居中显示
      var right = this.Frame.ChartBorder.GetHeight();
      var xText = this.Frame.ChartBorder.GetChartWidth();
      var yText = this.Frame.ChartBorder.GetTop();
      this.Canvas.translate(xText, yText);
      this.Canvas.rotate(90 * Math.PI / 180);
    } else

    {
      if (bottom < 5) return;
    }

    this.Canvas.textAlign = "left";
    this.Canvas.textBaseline = "middle";
    this.Canvas.font = this.Font;
    var position = { Left: left, Bottom: bottom, IsHScreen: isHScreen };

    if (this.IsShowName)
    {
      if (!this.DrawMinuteText(this.Name, this.NameColor, position, true)) return;
    }

    this.Canvas.fillStyle = this.UnchagneColor;
    var text = _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatDateTimeString(item.DateTime, this.IsShowDate ? 'YYYY-MM-DD HH-MM' : 'HH-MM');
    if (!this.DrawMinuteText(text, this.DateTimeColor, position)) return;

    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Close))
    {
      var color = this.GetColor(item.Close, this.YClose);
      var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('MTitle-Close', this.LanguageID) + item.Close.toFixed(defaultfloatPrecision);
      if (!this.DrawMinuteText(text, color, position)) return;
    }

    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Increase))
    {
      var color = this.GetColor(item.Increase, 0);
      var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('MTitle-Increase', this.LanguageID) + item.Increase.toFixed(2) + '%';
      if (!this.DrawMinuteText(text, color, position)) return;
    }

    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.AvPrice) && this.IsShowAveragePrice == true)
    {
      var color = this.GetColor(item.AvPrice, this.YClose);
      var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('MTitle-AvPrice', this.LanguageID) + item.AvPrice.toFixed(defaultfloatPrecision);
      if (!this.DrawMinuteText(text, color, position)) return;
    }

    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Vol))
    {
      var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('MTitle-Vol', this.LanguageID) + _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatValueString(item.Vol, 2, this.LanguageID);
      if (!this.DrawMinuteText(text, this.VolColor, position)) return;
    }

    if (_umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Amount))
    {
      var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('MTitle-Amount', this.LanguageID) + _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatValueString(item.Amount, 2, this.LanguageID);
      if (!this.DrawMinuteText(text, this.AmountColor, position)) return;
    }

    if (MARKET_SUFFIX_NAME.IsChinaFutures(this.UpperSymbol) && _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.IsNumber(item.Position))
    {
      var text = _umychartResourceWechat.JSCommonResource_Global_JSChartLocalization.GetText('MTitle-Position', this.LanguageID) + _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatValueString(item.Position, 2, this.LanguageID);
      if (!this.DrawMinuteText(text, this.VolColor, position)) return;
    }

  };

  this.FullDraw = function ()
  {
    this.Draw();
  };

  this.Draw = function ()
  {
    this.UpperSymbol = this.Symbol ? this.Symbol.toUpperCase() : '';
    this.LastShowData = null;
    this.SendUpdateUIMessage('Draw');
    if (!this.IsShow) return;
    if (this.CursorIndex == null || !this.Data || !this.Data.Data || this.Data.Data.length <= 0)
    {
      this.OnDrawEventCallback(null, "DynamicMinuteTitlePainting::Draw");
      return;
    }

    var index = this.CursorIndex;
    index = parseInt(index.toFixed(0));
    var dataIndex = index + this.Data.DataOffset;
    if (dataIndex >= this.Data.Data.length) dataIndex = this.Data.Data.length - 1;

    var item = this.Data.Data[dataIndex];
    this.LastShowData = item;
    this.OnDrawEventCallback(item, "DynamicMinuteTitlePainting::Draw");

    if (this.LineCount > 1 && !(this.Frame.IsHScreen === true))
    {
      this.DrawMulitLine(item);
      return;
    }

    this.Canvas.save();
    this.DrawItem(item);
    this.Canvas.restore();
  };

  this.DrawMinuteText = function (title, color, position, isShow)
  {
    if (!title) return true;

    var isHScreen = this.Frame.IsHScreen === true;
    var right = this.Frame.ChartBorder.GetRight();
    if (isHScreen) right = this.Frame.ChartBorder.GetHeight();

    this.Canvas.fillStyle = color;
    var textWidth = this.Canvas.measureText(title).width;
    if (position.Left + textWidth > right) return false;
    if (!(isShow === false)) this.Canvas.fillText(title, position.Left, position.Bottom, textWidth);

    position.Left += textWidth + this.SpaceWidth;
    return true;
  };
}

//字符串输出格式
var STRING_FORMAT_TYPE =
{
  DEFAULT: 1, //默认 2位小数 单位自动转化 (万 亿)
  ORIGINAL: 2, //原始数据
  THOUSANDS: 21 //千分位分割
};

function DynamicTitleData(data, name, color) //指标标题数据
{
  this.Data = data;
  this.Name = name;
  this.Color = color; //字体颜色
  this.DataType; //数据类型
  this.StringFormat = STRING_FORMAT_TYPE.DEFAULT; //字符串格式
  this.FloatPrecision = 2; //小数位数
  this.GetTextCallback; //自定义数据转文本回调
}

//指标标题
function DynamicChartTitlePainting()
{
  this.newMethod = IChartTitlePainting; //派生
  this.newMethod();
  delete this.newMethod;

  this.IsDynamic = true;
  this.Data = new Array();
  this.Explain;
  this.TitleBG; //标题背景色
  this.TitleBGHeight = 20; //标题背景色高度
  this.TitleAlign = 'middle'; //对其方式
  this.TitleBottomDistance = 1; //标题靠底部输出的时候 字体和底部的间距
  this.Text = new Array(); //副标题 Text:'文本', Color:'颜色'
  this.EraseRect;
  this.EraseColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.BGColor; //用来擦出的背景色

  this.TitleRect; //指标名字显示区域
  this.IsDrawTitleBG = false; //是否绘制指标名字背景色
  this.BGColor = _umychartResourceWechat.JSCommonResource_Global_JSChartResource.IndexTitleBGColor;

  this.IsShowIndexName = true; //是否显示指标名字
  this.ParamSpace = 2; //参数显示的间距
  this.OutName = null; //动态标题
  this.IsFullDraw = true; //手势离开屏幕以后是否显示最后的价格

  this.SetDynamicOutName = function (outName, args)
  {
    if (!this.OutName) this.OutName = new Map();else
    this.OutName.clear();

    var mapArgs = new Map();
    for (var i in args)
    {
      var item = args[i];
      mapArgs.set("{".concat(item.Name, "}"), item);
    }

    for (var i in outName)
    {
      var item = outName[i];
      var aryFond = item.DynamicName.match(/{\w*}/i);
      if (!aryFond || aryFond.length <= 0)
      {
        this.OutName.set(item.Name, item.DynamicName);
      } else

      {
        var dyName = item.DynamicName;
        var bFind = true;
        for (var j = 0; j < aryFond.length; ++j)
        {
          var findItem = aryFond[j];
          if (mapArgs.has(findItem))
          {
            var value = mapArgs.get(findItem).Value;
            dyName = dyName.replace(findItem, value.toString());
          } else

          {
            bFind = false;
            break;
          }
        }

        if (bFind) this.OutName.set(item.Name, dyName);
      }
    }
  };

  this.GetDynamicOutName = function (outName)
  {
    if (!this.OutName || this.OutName.size <= 0) return null;
    if (!this.OutName.has(outName)) return null;

    return this.OutName.get(outName);
  };

  this.IsClickTitle = function (x, y) //是否点击了指标标题
  {
    if (!this.TitleRect) return false;

    if (x > this.TitleRect.Left && x < this.TitleRect.Left + this.TitleRect.Width && y > this.TitleRect.Top && y < this.TitleRect.Top + this.TitleRect.Height)
    {
      return true;
    }

    return false;
  };

  this.FormatValue = function (value, item)
  {
    if (item.StringFormat == STRING_FORMAT_TYPE.DEFAULT)
    return _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatValueString(value, item.FloatPrecision, this.LanguageID);else
    if (item.StringFormat = STRING_FORMAT_TYPE.THOUSANDS)
    return _umychartFramesplitWechat.JSCommonSplit_IFrameSplitOperator.FormatValueThousandsString(value, item.FloatPrecision);else
    if (item.StringFormat == STRING_FORMAT_TYPE.ORIGINAL)
    return value.toFixed(item.FloatPrecision).toString();
  };

  this.FormatMultiReport = function (data, format)
  {
    var text = "";
    for (var i in data) {
      var item = data[i];
      var quarter = item.Quarter;
      var year = item.Year;
      var value = item.Value;

      if (text.length > 0) text += ',';

      text += year.toString();
      switch (quarter) {
        case 1:
          text += '一季报 ';
          break;
        case 2:
          text += '半年报 ';
          break;
        case 3:
          text += '三季报 ';
          break;
        case 4:
          text += '年报 ';
          break;}


      text += this.FormatValue(value, format);
    }

    return text;
  };

  this.SendUpdateUIMessage = function (funcName) //通知外面 标题变了
  {
    if (!this.UpdateUICallback) return;

    var sendData = {
      TitleName: '指标标题', CallFunction: funcName,
      TitleData: { Title: this.Title, Identify: this.Frame.Identify, Data: [] },
      Rect: //标题的位置
      {
        Top: this.Frame.ChartBorder.GetTop(), Left: this.Frame.ChartBorder.GetLeft(),
        Right: this.Frame.ChartBorder.GetRight(), Bottom: this.Frame.ChartBorder.GetBottom() } };



    for (var i in this.Data) {
      var item = this.Data[i];
      if (!item || !item.Data || !item.Data.Data) continue;
      if (item.Data.Data.length <= 0) continue;

      var titleItem = { Name: item.Name, Color: item.Color };
      if (item.DataType) titleItem.DataType = item.DataType;

      if (item.DataType == "StraightLine") //直线只有1个数据
        {
          titleItem.Value = item.Data.Data[0];
        } else
      {
        var index = item.Data.Data.length - 1;
        if (this.CursorIndex != null) {
          var cursorIndex = Math.abs(this.CursorIndex - 0.5);
          cursorIndex = parseInt(cursorIndex.toFixed(0));
          index = item.Data.DataOffset + cursorIndex;
        }
        if (index >= item.Data.Data.length) index = item.Data.Data.length - 1;

        titleItem.Value = item.Data.Data[index];
      }

      sendData.TitleData.Data.push(titleItem);
    }

    //console.log('[DynamicChartTitlePainting::SendUpdateUIMessage', sendData);
    this.UpdateUICallback(sendData);
  };

  this.FullDraw = function ()
  {
    this.EraseRect = null;
    this.TitleRect = null;
    this.IsDrawTitleBG = this.Frame.IsDrawTitleBG;
    if (this.Frame.ChartBorder.TitleHeight < 5) return;
    if (this.Frame.IsShowTitle == false) return;
    this.IsShowIndexName = this.Frame.IsShowIndexName;
    this.ParamSpace = this.Frame.IndexParamSpace;

    if (this.Frame.IsHScreen === true)
    {
      this.Canvas.save();
      this.DrawItem(true, true);
      this.Canvas.restore();
      return;
    }

    this.DrawItem(true, true);
  };

  this.DrawTitle = function ()
  {
    this.IsDrawTitleBG = this.Frame.IsDrawTitleBG;
    this.EraseRect = null;
    this.TitleRect = null;
    this.SendUpdateUIMessage('DrawTitle');
    if (this.Frame.ChartBorder.TitleHeight < 5) return;
    if (this.Frame.IsShowTitle == false) return;

    this.IsShowIndexName = this.Frame.IsShowIndexName;
    this.ParamSpace = this.Frame.IndexParamSpace;

    if (this.Frame.IsHScreen === true)
    {
      this.Canvas.save();
      this.DrawItem(true, false);
      this.Canvas.restore();
      return;
    }

    this.DrawItem(true, false);
  };

  this.EraseTitle = function ()
  {
    if (!this.EraseRect) return;
    this.Canvas.fillStyle = this.EraseColor;
    this.Canvas.fillRect(this.EraseRect.Left, this.EraseRect.Top, this.EraseRect.Width, this.EraseRect.Height);
  };

  this.Draw = function ()
  {
    this.TitleRect = null;
    this.SendUpdateUIMessage('Draw');

    if (this.CursorIndex == null) return;
    if (!this.Data) return;
    if (this.Frame.ChartBorder.TitleHeight < 5) return;
    if (this.Frame.IsShowTitle == false) return;

    this.IsShowIndexName = this.Frame.IsShowIndexName;
    this.ParamSpace = this.Frame.IndexParamSpace;

    if (this.Frame.IsHScreen === true)
    {
      this.Canvas.save();
      this.DrawItem(false, true);
      this.Canvas.restore();
      return;
    }

    this.DrawItem(false, true);
  };

  this.DrawItem = function (bDrawTitle, bDrawValue)
  {
    var isHScreen = this.Frame.IsHScreen === true;
    var left = this.Frame.ChartBorder.GetLeft() + 1;
    var bottom = this.Frame.ChartBorder.GetTop() + this.Frame.ChartBorder.TitleHeight / 2; //上下居中显示
    if (this.TitleAlign == 'bottom') bottom = this.Frame.ChartBorder.GetTopEx() - this.TitleBottomDistance;
    var right = this.Frame.ChartBorder.GetRight();
    var textWidth;

    if (isHScreen)
    {
      var xText = this.Frame.ChartBorder.GetRightTitle();
      var yText = this.Frame.ChartBorder.GetTop();
      this.Canvas.translate(xText, yText);
      this.Canvas.rotate(90 * Math.PI / 180);
      left = 1;
      bottom = -(this.Frame.ChartBorder.TitleHeight / 2); //上下居中显示
      if (this.TitleAlign == 'bottom') bottom = -this.TitleBottomDistance;
      right = this.Frame.ChartBorder.GetHeight();
    }

    this.EraseTitle();

    this.Canvas.textAlign = "left";
    this.Canvas.textBaseline = this.TitleAlign;
    this.Canvas.font = this.Font;

    if (this.TitleBG && this.Title) //指标名称
      {
        textWidth = this.Canvas.measureText(this.Title).width + 2;
        var height = this.Frame.ChartBorder.TitleHeight;
        var top = this.Frame.ChartBorder.GetTop();
        if (height > 20)
        {
          top += (height - 20) / 2 + (height - 45) / 2;
          height = 20;
        }

        if (this.TitleAlign == 'bottom') //底部输出文字
          {
            top = this.Frame.ChartBorder.GetTopEx() - 20;
            if (top < 0) top = 0;
          }
        if (bDrawTitle)
        {
          this.Canvas.fillStyle = this.TitleBG;
          this.Canvas.fillRect(left, top, textWidth, height);
        }
      }

    if (this.Title && this.IsShowIndexName) //指标参数
      {
        var metrics = this.Canvas.measureText(this.Title);
        textWidth = metrics.width + 2;
        if (bDrawTitle)
        {
          if (this.IsDrawTitleBG) //绘制指标名背景色
            {
              var spaceSize = 1;
              this.Canvas.fillStyle = this.BGColor;
              if (isHScreen)
              {
                this.TitleRect = { Left: this.Frame.ChartBorder.GetRightTitle(), Top: this.Frame.ChartBorder.GetTop(), Width: this.Frame.ChartBorder.TitleHeight, Height: textWidth }; //保存下标题的坐标
                var drawRect = { Left: left, Top: -this.Frame.ChartBorder.TitleHeight + spaceSize, Width: textWidth, Height: this.Frame.ChartBorder.TitleHeight - spaceSize * 2 };
                this.Canvas.fillRect(drawRect.Left, drawRect.Top, drawRect.Width, drawRect.Height);
              } else

              {
                this.TitleRect = { Left: left, Top: this.Frame.ChartBorder.GetTop() + spaceSize, Width: textWidth, Height: this.Frame.ChartBorder.TitleHeight - spaceSize * 2 }; //保存下标题的坐标
                this.Canvas.fillRect(this.TitleRect.Left, this.TitleRect.Top, this.TitleRect.Width, this.TitleRect.Height);
              }
            }
          this.Canvas.fillStyle = this.TitleColor;
          this.Canvas.fillText(this.Title, left, bottom, textWidth);
        }
        left += textWidth;
      }

    if (this.Text && this.Text.length > 0)
    {
      for (var _i4 in this.Text)
      {
        var _item = this.Text[_i4];
        this.Canvas.fillStyle = _item.Color;
        textWidth = this.Canvas.measureText(_item.Text).width + 2;
        this.Canvas.fillText(_item.Text, left, bottom, textWidth);
        left += textWidth;
      }
    }

    if (bDrawValue)
    {
      for (var i in this.Data)
      {
        var item = this.Data[i];
        if (!item || !item.Data || !item.Data.Data) continue;

        if (item.Data.Data.length <= 0) continue;

        var value = null;
        var valueText = null;
        if (item.DataType == "StraightLine") //直线只有1个数据
          {
            value = item.Data.Data[0];
            valueText = this.FormatValue(value, item);
          } else

        {
          var index = this.CursorIndex - 0.5;
          if (index < 0) index = 0;
          index = parseInt(index.toFixed(0));
          if (item.Data.DataOffset + index >= item.Data.Data.length) continue;

          value = item.Data.Data[item.Data.DataOffset + index];
          if (value == null) continue;

          if (item.DataType == "HistoryData-Vol")
          {
            value = value.Vol;
            valueText = this.FormatValue(value, item);
          } else
          if (item.DataType == "MultiReport")
          {
            valueText = this.FormatMultiReport(value, item);
          } else

          {
            if (item.GetTextCallback) valueText = item.GetTextCallback(value, item);else
            valueText = this.FormatValue(value, item);
          }
        }

        this.Canvas.fillStyle = item.Color;

        var text;
        if (item.Name)
        {
          var dyTitle = this.GetDynamicOutName(item.Name);
          if (dyTitle) text = dyTitle + ":" + valueText;else
          text = item.Name + ":" + valueText;
        } else

        {
          text = valueText;
        }
        textWidth = this.Canvas.measureText(text).width + this.ParamSpace; //后空2个像素
        this.Canvas.fillText(text, left, bottom, textWidth);
        left += textWidth;
      }
    } else

    {
      left += 4;
      var eraseRight = left,eraseLeft = left;
      for (var i in this.Data)
      {
        var item = this.Data[i];
        if (!item || !item.Data || !item.Data.Data) continue;
        if (item.Data.Data.length <= 0) continue;

        var indexName = '●' + item.Name;
        this.Canvas.fillStyle = item.Color;
        textWidth = this.Canvas.measureText(indexName).width + this.ParamSpace;
        if (left + textWidth >= right) break;
        this.Canvas.fillText(indexName, left, bottom, textWidth);
        left += textWidth;
        eraseRight = left;
      }

      if (eraseRight > eraseLeft)
      {
        if (isHScreen)
        {
          this.EraseRect =
          {
            Left: eraseLeft, Right: eraseRight, Top: -(this.Frame.ChartBorder.TitleHeight - 1),
            Width: eraseRight - eraseLeft, Height: this.Frame.ChartBorder.TitleHeight - 2 };

        } else

        {
          this.EraseRect =
          {
            Left: eraseLeft, Right: eraseRight, Top: this.Frame.ChartBorder.GetTop() + 1,
            Width: eraseRight - eraseLeft, Height: this.Frame.ChartBorder.TitleHeight - 2 };

        }
      }
    }
  };
}



//导出统一使用JSCommon命名空间名
module.exports =
{
  JSCommonChartTitle:
  {
    IChartTitlePainting: IChartTitlePainting,
    DynamicKLineTitlePainting: DynamicKLineTitlePainting,
    DynamicMinuteTitlePainting: DynamicMinuteTitlePainting,
    DynamicChartTitlePainting: DynamicChartTitlePainting,
    DynamicTitleData: DynamicTitleData,
    STRING_FORMAT_TYPE: STRING_FORMAT_TYPE },


  //单个类导出
  JSCommonChartTitle_IChartTitlePainting: IChartTitlePainting,
  JSCommonChartTitle_DynamicKLineTitlePainting: DynamicKLineTitlePainting,
  JSCommonChartTitle_DynamicMinuteTitlePainting: DynamicMinuteTitlePainting,
  JSCommonChartTitle_DynamicChartTitlePainting: DynamicChartTitlePainting,
  JSCommonChartTitle_DynamicTitleData: DynamicTitleData,
  JSCommonChartTitle_STRING_FORMAT_TYPE: STRING_FORMAT_TYPE };

/***/ }),
/* 115 */
/*!*************************************************************************!*\
  !*** I:/out-project/FCoinEx/static/js/umychart.uniapp.canvas.helper.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
copyright (c) 2018 jones

    http://www.apache.org/licenses/LICENSE-2.0

    开源项目 https://github.com/jones2000/HQChart

    jones_2000@163.com
    
    uniapp canvas 兼容方法
*/

function JSUniAppCanvasHelper() {}

JSUniAppCanvasHelper.MeasureText = function (text, canvas)
{
  var font = canvas.font;
  var fontSize = 12;
  var pos = font.search('px');
  if (pos > 0)
  {
    var strSize = font.substring(0, pos);
    fontSize = parseInt(strSize);
  }
  text = String(text);
  var text = text.split('');
  var width = 0;
  for (var i = 0; i < text.length; i++)
  {
    var item = text[i];
    if (/[a-zA-Z]/.test(item))
    {
      width += 7;
    } else if (/[0-9]/.test(item))
    {
      width += 5.5;
    } else if (/\./.test(item))
    {
      width += 2.7;
    } else if (/-/.test(item))
    {
      width += 3.25;
    } else if (/[\u4e00-\u9fa5]/.test(item))
    {
      width += 10;
    } else if (/\(|\)/.test(item))
    {
      width += 3.73;
    } else if (/\s/.test(item))
    {
      width += 2.5;
    } else if (/%/.test(item))
    {
      width += 8;
    } else
    {
      width += 10;
    }
  }
  return width * fontSize / 10;
};

//导出统一使用JSCommon命名空间名
module.exports =
{
  JSCommonUniApp:
  {
    JSUniAppCanvasHelper: JSUniAppCanvasHelper } };

/***/ }),
/* 116 */
/*!*****************************************************************!*\
  !*** I:/out-project/FCoinEx/static/js/umychart.style.wechat.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
    copyright (c) 2018 jones

    http://www.apache.org/licenses/LICENSE-2.0

    开源项目 https://github.com/jones2000/HQChart

    jones_2000@163.com

    不同风格行情配置文件 (微信小程序版本)
*/

var BLACK_STYLE = //黑色风格
{
  BGColor: 'rgb(0,0,0)',
  TooltipBGColor: "rgb(255, 255, 255)", //背景色
  TooltipAlpha: 0.92, //透明度

  SelectRectBGColor: "rgba(1,130,212,0.06)", //背景色
  //  SelectRectAlpha: 0.06;                  //透明度

  UpBarColor: "rgb(238,21,21)",
  DownBarColor: "rgb(25,158,0)",
  UnchagneBarColor: "rgb(199,199,199)",

  Minute: {
    VolBarColor: null,
    PriceColor: "rgb(25,180,231)",
    AvPriceColor: "rgb(255,236,0)" },



  DefaultTextColor: "rgb(101,104,112)",
  DefaultTextFont: '14px 微软雅黑',
  IndexTitleBGColor: 'rgb(211,211,211)',

  DynamicTitleFont: '12px 微软雅黑', //指标动态标题字体


  UpTextColor: "rgb(238,21,21)",
  DownTextColor: "rgb(25,158,0)",
  UnchagneTextColor: "rgb(101,104,112)",
  CloseLineColor: 'rgb(178,34,34)',

  Title:
  {
    TradeIndexColor: 'rgb(105,105,105)', //交易指标颜色
    ColorIndexColor: 'rgb(112,128,144)', //五彩K线颜色

    VolColor: "rgb(101,104,112)", //标题成交量
    AmountColor: "rgb(101,104,112)", //成交金额 
    DateTimeColor: "rgb(101,104,112)", //时间,日期  
    SettingColor: "rgb(101,104,112)", //周期,复权
    NameColor: "rgb(101,104,112)", //股票名称
    TurnoverRateColor: 'rgb(101,104,112)', //换手率
    PositionColor: "rgb(101,104,112)" //持仓
  },

  FrameBorderPen: "rgba(236,236,236,0.13)", //边框
  FrameSplitPen: "rgba(236,236,236,0.13)", //分割线
  FrameSplitTextColor: "rgb(101,104,112)", //刻度文字颜色
  FrameSplitTextFont: "12px 微软雅黑", //坐标刻度文字字体
  FrameTitleBGColor: "rgb(246,251,253)", //标题栏背景色
  Frame: { XBottomOffset: 0 }, //X轴文字向下偏移

  FrameLatestPrice: {
    TextColor: 'rgb(255,255,255)', //最新价格文字颜色
    UpBarColor: "rgb(238,21,21)", //上涨
    DownBarColor: "rgb(25,158,0)", //下跌
    UnchagneBarColor: "rgb(190,190,190)", //平盘
    BGAlpha: 0.6 },


  CorssCursorBGColor: "rgb(43,54,69)", //十字光标背景
  CorssCursorTextColor: "rgb(255,255,255)",
  CorssCursorTextFont: "12px 微软雅黑",
  CorssCursorHPenColor: "rgb(130,130,130)", //十字光标线段颜色
  CorssCursorVPenColor: "rgb(130,130,130)", //十字光标线段颜色

  KLine:
  {
    MaxMin: { Font: '12px 微软雅黑', Color: 'rgb(111,111,111)' }, //K线最大最小值显示
    Info: //信息地雷
    {
      Color: 'rgb(205,149,12)',
      TextColor: '#afc0da',
      TextBGColor: '#1a283e',
      Investor:
      {
        ApiUrl: '/API/NewsInteract' //互动易
      },
      Announcement: //公告
      {
        ApiUrl: '/API/ReportList' },

      Pforecast: //业绩预告
      {
        ApiUrl: '/API/StockHistoryDay' },

      Research: //调研
      {
        ApiUrl: '/API/InvestorRelationsList' },

      BlockTrading: //大宗交易
      {
        ApiUrl: '/API/StockHistoryDay' },

      TradeDetail: //龙虎榜
      {
        ApiUrl: '/API/StockHistoryDay' },

      Policy: //策略
      {
        ApiUrl: '/API/StockHistoryDay' } } },




  Index: { //指标线段颜色
    LineColor: [
    "rgb(255,189,09)",
    "rgb(22,198,255)",
    "rgb(174,35,161)",
    "rgb(236,105,65)",
    "rgb(68,114,196)",
    "rgb(229,0,79)",
    "rgb(0,128,255)",
    "rgb(252,96,154)",
    "rgb(42,230,215)",
    "rgb(24,71,178)"],


    NotSupport: { Font: "14px 微软雅黑", TextColor: "rgb(52,52,52)" } },


  ColorArray: //自定义指标默认颜色
  [
  "rgb(255,174,0)",
  "rgb(25,199,255)",
  "rgb(175,95,162)",
  "rgb(236,105,65)",
  "rgb(68,114,196)",
  "rgb(229,0,79)",
  "rgb(0,128,255)",
  "rgb(252,96,154)",
  "rgb(42,230,215)",
  "rgb(24,71,178)"],

  //画图工具
  DrawPicture:
  {
    LineColor: "rgb(30,144,255)",
    PointColor: "rgb(105,105,105)" },


  TooltipPaint: //Tooltip
  {
    BGColor: 'rgba(20,20,20,0.8)', //背景色
    BorderColor: 'rgb(210,210,210)', //边框颜色
    TitleColor: 'rgb(210,210,210)', //标题颜色
    TitleFont: '13px 微软雅黑' //字体
  },

  //深度图
  DepthChart:
  {
    BidColor: { Line: "rgb(82,176,123)", Area: "rgba(82,176,123,0.5)" }, //卖
    AskColor: { Line: "rgb(207,76,89)", Area: "rgba(207,76,89, 0.5)" }, //买
    LineWidth: 4 },


  DepthCorss:
  {
    BidColor: { Line: "rgb(82,176,123)" }, //卖
    AskColor: { Line: "rgb(207,76,89)" }, //买
    LineWidth: 2, //线段宽度
    LineDash: [3, 3],
    Tooltip:
    {
      BGColor: 'rgba(54,54,54, 0.8)', TextColor: "rgb(203,215,224)",
      Border: { Top: 5, Left: 20, Bottom: 5, Center: 5 },
      Font: "14px 微软雅黑",
      LineHeight: 16 //单行高度
    } } };




var WHITE_STYLE = //白色风格
{
  BGColor: 'rgb(255,255,255)',
  TooltipBGColor: "rgb(255, 255, 255)", //背景色
  TooltipAlpha: 0.92, //透明度

  SelectRectBGColor: "rgba(1,130,212,0.06)", //背景色
  //   this.SelectRectAlpha=0.06;                  //透明度

  UpBarColor: "rgb(238,21,21)",
  DownBarColor: "rgb(25,158,0)",
  UnchagneBarColor: "rgb(0,0,0)",

  Minute:
  {
    VolBarColor: "rgb(238,127,9)",
    PriceColor: "rgb(50,171,205)",
    AvPriceColor: "rgb(238,127,9)" },


  DefaultTextColor: "rgb(43,54,69)",
  DefaultTextFont: '14px 微软雅黑',

  DynamicTitleFont: '12px 微软雅黑', //指标动态标题字体


  UpTextColor: "rgb(238,21,21)",
  DownTextColor: "rgb(25,158,0)",
  UnchagneTextColor: "rgb(0,0,0)",
  CloseLineColor: 'rgb(178,34,34)',

  FrameBorderPen: "rgb(225,236,242)", //边框
  FrameSplitPen: "rgb(225,236,242)", //分割线
  FrameSplitTextColor: "rgb(51,51,51)", //刻度文字颜色
  FrameSplitTextFont: "12px 微软雅黑", //坐标刻度文字字体
  FrameTitleBGColor: "rgb(246,251,253)", //标题栏背景色

  CorssCursorBGColor: "rgb(43,54,69)", //十字光标背景
  CorssCursorTextColor: "rgb(255,255,255)",
  CorssCursorTextFont: "12px 微软雅黑",
  CorssCursorPenColor: "rgb(130,130,130)", //十字光标线段颜色

  KLine:
  {
    MaxMin: { Font: '12px 微软雅黑', Color: 'rgb(111,111,111)' }, //K线最大最小值显示
    Info: //信息地雷
    {
      Color: 'rgb(205,149,12)',
      TextColor: '#197de9',
      TextBGColor: '#e1e4ef',
      Investor:
      {
        ApiUrl: '/API/NewsInteract' //互动易
      },
      Announcement: //公告
      {
        ApiUrl: '/API/ReportList' },

      Pforecast: //业绩预告
      {
        ApiUrl: '/API/StockHistoryDay' },

      Research: //调研
      {
        ApiUrl: '/API/InvestorRelationsList' },

      BlockTrading: //大宗交易
      {
        ApiUrl: '/API/StockHistoryDay' },

      TradeDetail: //龙虎榜
      {
        ApiUrl: '/API/StockHistoryDay' },

      Policy: //策略
      {
        ApiUrl: '/API/StockHistoryDay' } } },




  Index:
  { //指标线段颜色
    LineColor:
    [
    "rgb(255,189,09)",
    "rgb(22,198,255)",
    "rgb(174,35,161)",
    "rgb(236,105,65)",
    "rgb(68,114,196)",
    "rgb(229,0,79)",
    "rgb(0,128,255)",
    "rgb(252,96,154)",
    "rgb(42,230,215)",
    "rgb(24,71,178)"],

    NotSupport: { Font: "14px 微软雅黑", TextColor: "rgb(52,52,52)" } },


  ColorArray: //自定义指标默认颜色
  [
  "rgb(255,174,0)",
  "rgb(25,199,255)",
  "rgb(175,95,162)",
  "rgb(236,105,65)",
  "rgb(68,114,196)",
  "rgb(229,0,79)",
  "rgb(0,128,255)",
  "rgb(252,96,154)",
  "rgb(42,230,215)",
  "rgb(24,71,178)"],


  //画图工具
  DrawPicture:
  {
    LineColor: "rgb(30,144,255)",
    PointColor: "rgb(105,105,105)" } };



var STYLE_TYPE_ID =
{
  BLACK_ID: 1, //黑色风格
  WHITE_ID: 2 //白色风格
};


function GetStyleConfig(styleid) //获取一个风格的配置变量
{
  switch (styleid) {

    case STYLE_TYPE_ID.BLACK_ID:
      return BLACK_STYLE;
      break;
    case STYLE_TYPE_ID.WHITE_ID:
      return WHITE_STYLE;
      break;
    default:
      return null;}

}


module.exports =
{
  JSCommonHQStyle:
  {
    GetStyleConfig: GetStyleConfig,
    STYLE_TYPE_ID: STYLE_TYPE_ID } };

/***/ }),
/* 117 */
/*!********************************************!*\
  !*** I:/out-project/FCoinEx/utils/pako.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;/* pako 1.0.3 nodeca/pako */
!function (t) {if (true) module.exports = t();else { var e; }}(function () {return function t(e, a, i) {function n(s, o) {if (!a[s]) {if (!e[s]) {var l = "function" == typeof require && require;if (!o && l) return require(s, !0);if (r) return r(s, !0);var h = new Error("Cannot find module '" + s + "'");throw h.code = "MODULE_NOT_FOUND", h;}var d = a[s] = { exports: {} };e[s][0].call(d.exports, function (t) {var a = e[s][1][t];return n(a ? a : t);}, d, d.exports, t, e, a, i);}return a[s].exports;}for (var r = "function" == typeof require && require, s = 0; s < i.length; s++) {n(i[s]);}return n;}({ 1: [function (t, e, a) {"use strict";function i(t) {if (!(this instanceof i)) return new i(t);this.options = l.assign({ level: w, method: v, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: p, to: "" }, t || {});var e = this.options;e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new f(), this.strm.avail_out = 0;var a = o.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);if (a !== b) throw new Error(d[a]);if (e.header && o.deflateSetHeader(this.strm, e.header), e.dictionary) {var n;if (n = "string" == typeof e.dictionary ? h.string2buf(e.dictionary) : "[object ArrayBuffer]" === _.call(e.dictionary) ? new Uint8Array(e.dictionary) : e.dictionary, a = o.deflateSetDictionary(this.strm, n), a !== b) throw new Error(d[a]);this._dict_set = !0;}}function n(t, e) {var a = new i(e);if (a.push(t, !0), a.err) throw a.msg;return a.result;}function r(t, e) {return e = e || {}, e.raw = !0, n(t, e);}function s(t, e) {return e = e || {}, e.gzip = !0, n(t, e);}var o = t("./zlib/deflate"),l = t("./utils/common"),h = t("./utils/strings"),d = t("./zlib/messages"),f = t("./zlib/zstream"),_ = Object.prototype.toString,u = 0,c = 4,b = 0,g = 1,m = 2,w = -1,p = 0,v = 8;i.prototype.push = function (t, e) {var a,i,n = this.strm,r = this.options.chunkSize;if (this.ended) return !1;i = e === ~~e ? e : e === !0 ? c : u, "string" == typeof t ? n.input = h.string2buf(t) : "[object ArrayBuffer]" === _.call(t) ? n.input = new Uint8Array(t) : n.input = t, n.next_in = 0, n.avail_in = n.input.length;do {if (0 === n.avail_out && (n.output = new l.Buf8(r), n.next_out = 0, n.avail_out = r), a = o.deflate(n, i), a !== g && a !== b) return this.onEnd(a), this.ended = !0, !1;0 !== n.avail_out && (0 !== n.avail_in || i !== c && i !== m) || ("string" === this.options.to ? this.onData(h.buf2binstring(l.shrinkBuf(n.output, n.next_out))) : this.onData(l.shrinkBuf(n.output, n.next_out)));} while ((n.avail_in > 0 || 0 === n.avail_out) && a !== g);return i === c ? (a = o.deflateEnd(this.strm), this.onEnd(a), this.ended = !0, a === b) : i !== m || (this.onEnd(b), n.avail_out = 0, !0);}, i.prototype.onData = function (t) {this.chunks.push(t);}, i.prototype.onEnd = function (t) {t === b && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = l.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;}, a.Deflate = i, a.deflate = n, a.deflateRaw = r, a.gzip = s;}, { "./utils/common": 3, "./utils/strings": 4, "./zlib/deflate": 8, "./zlib/messages": 13, "./zlib/zstream": 15 }], 2: [function (t, e, a) {"use strict";function i(t) {if (!(this instanceof i)) return new i(t);this.options = o.assign({ chunkSize: 16384, windowBits: 0, to: "" }, t || {});var e = this.options;e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, 0 === e.windowBits && (e.windowBits = -15)), !(e.windowBits >= 0 && e.windowBits < 16) || t && t.windowBits || (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && 0 === (15 & e.windowBits) && (e.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new f(), this.strm.avail_out = 0;var a = s.inflateInit2(this.strm, e.windowBits);if (a !== h.Z_OK) throw new Error(d[a]);this.header = new _(), s.inflateGetHeader(this.strm, this.header);}function n(t, e) {var a = new i(e);if (a.push(t, !0), a.err) throw a.msg;return a.result;}function r(t, e) {return e = e || {}, e.raw = !0, n(t, e);}var s = t("./zlib/inflate"),o = t("./utils/common"),l = t("./utils/strings"),h = t("./zlib/constants"),d = t("./zlib/messages"),f = t("./zlib/zstream"),_ = t("./zlib/gzheader"),u = Object.prototype.toString;i.prototype.push = function (t, e) {var a,i,n,r,d,f,_ = this.strm,c = this.options.chunkSize,b = this.options.dictionary,g = !1;if (this.ended) return !1;i = e === ~~e ? e : e === !0 ? h.Z_FINISH : h.Z_NO_FLUSH, "string" == typeof t ? _.input = l.binstring2buf(t) : "[object ArrayBuffer]" === u.call(t) ? _.input = new Uint8Array(t) : _.input = t, _.next_in = 0, _.avail_in = _.input.length;do {if (0 === _.avail_out && (_.output = new o.Buf8(c), _.next_out = 0, _.avail_out = c), a = s.inflate(_, h.Z_NO_FLUSH), a === h.Z_NEED_DICT && b && (f = "string" == typeof b ? l.string2buf(b) : "[object ArrayBuffer]" === u.call(b) ? new Uint8Array(b) : b, a = s.inflateSetDictionary(this.strm, f)), a === h.Z_BUF_ERROR && g === !0 && (a = h.Z_OK, g = !1), a !== h.Z_STREAM_END && a !== h.Z_OK) return this.onEnd(a), this.ended = !0, !1;_.next_out && (0 !== _.avail_out && a !== h.Z_STREAM_END && (0 !== _.avail_in || i !== h.Z_FINISH && i !== h.Z_SYNC_FLUSH) || ("string" === this.options.to ? (n = l.utf8border(_.output, _.next_out), r = _.next_out - n, d = l.buf2string(_.output, n), _.next_out = r, _.avail_out = c - r, r && o.arraySet(_.output, _.output, n, r, 0), this.onData(d)) : this.onData(o.shrinkBuf(_.output, _.next_out)))), 0 === _.avail_in && 0 === _.avail_out && (g = !0);} while ((_.avail_in > 0 || 0 === _.avail_out) && a !== h.Z_STREAM_END);return a === h.Z_STREAM_END && (i = h.Z_FINISH), i === h.Z_FINISH ? (a = s.inflateEnd(this.strm), this.onEnd(a), this.ended = !0, a === h.Z_OK) : i !== h.Z_SYNC_FLUSH || (this.onEnd(h.Z_OK), _.avail_out = 0, !0);}, i.prototype.onData = function (t) {this.chunks.push(t);}, i.prototype.onEnd = function (t) {t === h.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;}, a.Inflate = i, a.inflate = n, a.inflateRaw = r, a.ungzip = n;}, { "./utils/common": 3, "./utils/strings": 4, "./zlib/constants": 6, "./zlib/gzheader": 9, "./zlib/inflate": 11, "./zlib/messages": 13, "./zlib/zstream": 15 }], 3: [function (t, e, a) {"use strict";var i = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;a.assign = function (t) {for (var e = Array.prototype.slice.call(arguments, 1); e.length;) {var a = e.shift();if (a) {if ("object" != typeof a) throw new TypeError(a + "must be non-object");for (var i in a) {a.hasOwnProperty(i) && (t[i] = a[i]);}}}return t;}, a.shrinkBuf = function (t, e) {return t.length === e ? t : t.subarray ? t.subarray(0, e) : (t.length = e, t);};var n = { arraySet: function arraySet(t, e, a, i, n) {if (e.subarray && t.subarray) return void t.set(e.subarray(a, a + i), n);for (var r = 0; r < i; r++) {t[n + r] = e[a + r];}}, flattenChunks: function flattenChunks(t) {var e, a, i, n, r, s;for (i = 0, e = 0, a = t.length; e < a; e++) {i += t[e].length;}for (s = new Uint8Array(i), n = 0, e = 0, a = t.length; e < a; e++) {r = t[e], s.set(r, n), n += r.length;}return s;} },r = { arraySet: function arraySet(t, e, a, i, n) {for (var r = 0; r < i; r++) {t[n + r] = e[a + r];}}, flattenChunks: function flattenChunks(t) {return [].concat.apply([], t);} };a.setTyped = function (t) {t ? (a.Buf8 = Uint8Array, a.Buf16 = Uint16Array, a.Buf32 = Int32Array, a.assign(a, n)) : (a.Buf8 = Array, a.Buf16 = Array, a.Buf32 = Array, a.assign(a, r));}, a.setTyped(i);}, {}], 4: [function (t, e, a) {"use strict";function i(t, e) {if (e < 65537 && (t.subarray && s || !t.subarray && r)) return String.fromCharCode.apply(null, n.shrinkBuf(t, e));for (var a = "", i = 0; i < e; i++) {a += String.fromCharCode(t[i]);}return a;}var n = t("./common"),r = !0,s = !0;try {String.fromCharCode.apply(null, [0]);} catch (t) {r = !1;}try {String.fromCharCode.apply(null, new Uint8Array(1));} catch (t) {s = !1;}for (var o = new n.Buf8(256), l = 0; l < 256; l++) {o[l] = l >= 252 ? 6 : l >= 248 ? 5 : l >= 240 ? 4 : l >= 224 ? 3 : l >= 192 ? 2 : 1;}o[254] = o[254] = 1, a.string2buf = function (t) {var e,a,i,r,s,o = t.length,l = 0;for (r = 0; r < o; r++) {a = t.charCodeAt(r), 55296 === (64512 & a) && r + 1 < o && (i = t.charCodeAt(r + 1), 56320 === (64512 & i) && (a = 65536 + (a - 55296 << 10) + (i - 56320), r++)), l += a < 128 ? 1 : a < 2048 ? 2 : a < 65536 ? 3 : 4;}for (e = new n.Buf8(l), s = 0, r = 0; s < l; r++) {a = t.charCodeAt(r), 55296 === (64512 & a) && r + 1 < o && (i = t.charCodeAt(r + 1), 56320 === (64512 & i) && (a = 65536 + (a - 55296 << 10) + (i - 56320), r++)), a < 128 ? e[s++] = a : a < 2048 ? (e[s++] = 192 | a >>> 6, e[s++] = 128 | 63 & a) : a < 65536 ? (e[s++] = 224 | a >>> 12, e[s++] = 128 | a >>> 6 & 63, e[s++] = 128 | 63 & a) : (e[s++] = 240 | a >>> 18, e[s++] = 128 | a >>> 12 & 63, e[s++] = 128 | a >>> 6 & 63, e[s++] = 128 | 63 & a);}return e;}, a.buf2binstring = function (t) {return i(t, t.length);}, a.binstring2buf = function (t) {for (var e = new n.Buf8(t.length), a = 0, i = e.length; a < i; a++) {e[a] = t.charCodeAt(a);}return e;}, a.buf2string = function (t, e) {var a,n,r,s,l = e || t.length,h = new Array(2 * l);for (n = 0, a = 0; a < l;) {if (r = t[a++], r < 128) h[n++] = r;else if (s = o[r], s > 4) h[n++] = 65533, a += s - 1;else {for (r &= 2 === s ? 31 : 3 === s ? 15 : 7; s > 1 && a < l;) {r = r << 6 | 63 & t[a++], s--;}s > 1 ? h[n++] = 65533 : r < 65536 ? h[n++] = r : (r -= 65536, h[n++] = 55296 | r >> 10 & 1023, h[n++] = 56320 | 1023 & r);}}return i(h, n);}, a.utf8border = function (t, e) {var a;for (e = e || t.length, e > t.length && (e = t.length), a = e - 1; a >= 0 && 128 === (192 & t[a]);) {a--;}return a < 0 ? e : 0 === a ? e : a + o[t[a]] > e ? a : e;};}, { "./common": 3 }], 5: [function (t, e, a) {"use strict";function i(t, e, a, i) {for (var n = 65535 & t | 0, r = t >>> 16 & 65535 | 0, s = 0; 0 !== a;) {s = a > 2e3 ? 2e3 : a, a -= s;do {n = n + e[i++] | 0, r = r + n | 0;} while (--s);n %= 65521, r %= 65521;}return n | r << 16 | 0;}e.exports = i;}, {}], 6: [function (t, e, a) {"use strict";e.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };}, {}], 7: [function (t, e, a) {"use strict";function i() {for (var t, e = [], a = 0; a < 256; a++) {t = a;for (var i = 0; i < 8; i++) {t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;}e[a] = t;}return e;}function n(t, e, a, i) {var n = r,s = i + a;t ^= -1;for (var o = i; o < s; o++) {t = t >>> 8 ^ n[255 & (t ^ e[o])];}return t ^ -1;}var r = i();e.exports = n;}, {}], 8: [function (t, e, a) {"use strict";function i(t, e) {return t.msg = D[e], e;}function n(t) {return (t << 1) - (t > 4 ? 9 : 0);}function r(t) {for (var e = t.length; --e >= 0;) {t[e] = 0;}}function s(t) {var e = t.state,a = e.pending;a > t.avail_out && (a = t.avail_out), 0 !== a && (R.arraySet(t.output, e.pending_buf, e.pending_out, a, t.next_out), t.next_out += a, e.pending_out += a, t.total_out += a, t.avail_out -= a, e.pending -= a, 0 === e.pending && (e.pending_out = 0));}function o(t, e) {C._tr_flush_block(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, s(t.strm);}function l(t, e) {t.pending_buf[t.pending++] = e;}function h(t, e) {t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e;}function d(t, e, a, i) {var n = t.avail_in;return n > i && (n = i), 0 === n ? 0 : (t.avail_in -= n, R.arraySet(e, t.input, t.next_in, n, a), 1 === t.state.wrap ? t.adler = N(t.adler, e, n, a) : 2 === t.state.wrap && (t.adler = O(t.adler, e, n, a)), t.next_in += n, t.total_in += n, n);}function f(t, e) {var a,i,n = t.max_chain_length,r = t.strstart,s = t.prev_length,o = t.nice_match,l = t.strstart > t.w_size - ft ? t.strstart - (t.w_size - ft) : 0,h = t.window,d = t.w_mask,f = t.prev,_ = t.strstart + dt,u = h[r + s - 1],c = h[r + s];t.prev_length >= t.good_match && (n >>= 2), o > t.lookahead && (o = t.lookahead);do {if (a = e, h[a + s] === c && h[a + s - 1] === u && h[a] === h[r] && h[++a] === h[r + 1]) {r += 2, a++;do {;} while (h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && r < _);if (i = dt - (_ - r), r = _ - dt, i > s) {if (t.match_start = e, s = i, i >= o) break;u = h[r + s - 1], c = h[r + s];}}} while ((e = f[e & d]) > l && 0 !== --n);return s <= t.lookahead ? s : t.lookahead;}function _(t) {var e,a,i,n,r,s = t.w_size;do {if (n = t.window_size - t.lookahead - t.strstart, t.strstart >= s + (s - ft)) {R.arraySet(t.window, t.window, s, s, 0), t.match_start -= s, t.strstart -= s, t.block_start -= s, a = t.hash_size, e = a;do {i = t.head[--e], t.head[e] = i >= s ? i - s : 0;} while (--a);a = s, e = a;do {i = t.prev[--e], t.prev[e] = i >= s ? i - s : 0;} while (--a);n += s;}if (0 === t.strm.avail_in) break;if (a = d(t.strm, t.window, t.strstart + t.lookahead, n), t.lookahead += a, t.lookahead + t.insert >= ht) for (r = t.strstart - t.insert, t.ins_h = t.window[r], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[r + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[r + ht - 1]) & t.hash_mask, t.prev[r & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = r, r++, t.insert--, !(t.lookahead + t.insert < ht));) {;}} while (t.lookahead < ft && 0 !== t.strm.avail_in);}function u(t, e) {var a = 65535;for (a > t.pending_buf_size - 5 && (a = t.pending_buf_size - 5);;) {if (t.lookahead <= 1) {if (_(t), 0 === t.lookahead && e === I) return vt;if (0 === t.lookahead) break;}t.strstart += t.lookahead, t.lookahead = 0;var i = t.block_start + a;if ((0 === t.strstart || t.strstart >= i) && (t.lookahead = t.strstart - i, t.strstart = i, o(t, !1), 0 === t.strm.avail_out)) return vt;if (t.strstart - t.block_start >= t.w_size - ft && (o(t, !1), 0 === t.strm.avail_out)) return vt;}return t.insert = 0, e === F ? (o(t, !0), 0 === t.strm.avail_out ? yt : xt) : t.strstart > t.block_start && (o(t, !1), 0 === t.strm.avail_out) ? vt : vt;}function c(t, e) {for (var a, i;;) {if (t.lookahead < ft) {if (_(t), t.lookahead < ft && e === I) return vt;if (0 === t.lookahead) break;}if (a = 0, t.lookahead >= ht && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + ht - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== a && t.strstart - a <= t.w_size - ft && (t.match_length = f(t, a)), t.match_length >= ht) {if (i = C._tr_tally(t, t.strstart - t.match_start, t.match_length - ht), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= ht) {t.match_length--;do {t.strstart++, t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + ht - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart;} while (0 !== --t.match_length);t.strstart++;} else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask;} else i = C._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;if (i && (o(t, !1), 0 === t.strm.avail_out)) return vt;}return t.insert = t.strstart < ht - 1 ? t.strstart : ht - 1, e === F ? (o(t, !0), 0 === t.strm.avail_out ? yt : xt) : t.last_lit && (o(t, !1), 0 === t.strm.avail_out) ? vt : kt;}function b(t, e) {for (var a, i, n;;) {if (t.lookahead < ft) {if (_(t), t.lookahead < ft && e === I) return vt;if (0 === t.lookahead) break;}if (a = 0, t.lookahead >= ht && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + ht - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = ht - 1, 0 !== a && t.prev_length < t.max_lazy_match && t.strstart - a <= t.w_size - ft && (t.match_length = f(t, a), t.match_length <= 5 && (t.strategy === q || t.match_length === ht && t.strstart - t.match_start > 4096) && (t.match_length = ht - 1)), t.prev_length >= ht && t.match_length <= t.prev_length) {n = t.strstart + t.lookahead - ht, i = C._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - ht), t.lookahead -= t.prev_length - 1, t.prev_length -= 2;do {++t.strstart <= n && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + ht - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart);} while (0 !== --t.prev_length);if (t.match_available = 0, t.match_length = ht - 1, t.strstart++, i && (o(t, !1), 0 === t.strm.avail_out)) return vt;} else if (t.match_available) {if (i = C._tr_tally(t, 0, t.window[t.strstart - 1]), i && o(t, !1), t.strstart++, t.lookahead--, 0 === t.strm.avail_out) return vt;} else t.match_available = 1, t.strstart++, t.lookahead--;}return t.match_available && (i = C._tr_tally(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < ht - 1 ? t.strstart : ht - 1, e === F ? (o(t, !0), 0 === t.strm.avail_out ? yt : xt) : t.last_lit && (o(t, !1), 0 === t.strm.avail_out) ? vt : kt;}function g(t, e) {for (var a, i, n, r, s = t.window;;) {if (t.lookahead <= dt) {if (_(t), t.lookahead <= dt && e === I) return vt;if (0 === t.lookahead) break;}if (t.match_length = 0, t.lookahead >= ht && t.strstart > 0 && (n = t.strstart - 1, i = s[n], i === s[++n] && i === s[++n] && i === s[++n])) {r = t.strstart + dt;do {;} while (i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && n < r);t.match_length = dt - (r - n), t.match_length > t.lookahead && (t.match_length = t.lookahead);}if (t.match_length >= ht ? (a = C._tr_tally(t, 1, t.match_length - ht), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (a = C._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), a && (o(t, !1), 0 === t.strm.avail_out)) return vt;}return t.insert = 0, e === F ? (o(t, !0), 0 === t.strm.avail_out ? yt : xt) : t.last_lit && (o(t, !1), 0 === t.strm.avail_out) ? vt : kt;}function m(t, e) {for (var a;;) {if (0 === t.lookahead && (_(t), 0 === t.lookahead)) {if (e === I) return vt;break;}if (t.match_length = 0, a = C._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, a && (o(t, !1), 0 === t.strm.avail_out)) return vt;}return t.insert = 0, e === F ? (o(t, !0), 0 === t.strm.avail_out ? yt : xt) : t.last_lit && (o(t, !1), 0 === t.strm.avail_out) ? vt : kt;}function w(t, e, a, i, n) {this.good_length = t, this.max_lazy = e, this.nice_length = a, this.max_chain = i, this.func = n;}function p(t) {t.window_size = 2 * t.w_size, r(t.head), t.max_lazy_match = Z[t.level].max_lazy, t.good_match = Z[t.level].good_length, t.nice_match = Z[t.level].nice_length, t.max_chain_length = Z[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = ht - 1, t.match_available = 0, t.ins_h = 0;}function v() {this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = V, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new R.Buf16(2 * ot), this.dyn_dtree = new R.Buf16(2 * (2 * rt + 1)), this.bl_tree = new R.Buf16(2 * (2 * st + 1)), r(this.dyn_ltree), r(this.dyn_dtree), r(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new R.Buf16(lt + 1), this.heap = new R.Buf16(2 * nt + 1), r(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new R.Buf16(2 * nt + 1), r(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;}function k(t) {var e;return t && t.state ? (t.total_in = t.total_out = 0, t.data_type = Q, e = t.state, e.pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap ? ut : wt, t.adler = 2 === e.wrap ? 0 : 1, e.last_flush = I, C._tr_init(e), H) : i(t, K);}function y(t) {var e = k(t);return e === H && p(t.state), e;}function x(t, e) {return t && t.state ? 2 !== t.state.wrap ? K : (t.state.gzhead = e, H) : K;}function z(t, e, a, n, r, s) {if (!t) return K;var o = 1;if (e === Y && (e = 6), n < 0 ? (o = 0, n = -n) : n > 15 && (o = 2, n -= 16), r < 1 || r > $ || a !== V || n < 8 || n > 15 || e < 0 || e > 9 || s < 0 || s > W) return i(t, K);8 === n && (n = 9);var l = new v();return t.state = l, l.strm = t, l.wrap = o, l.gzhead = null, l.w_bits = n, l.w_size = 1 << l.w_bits, l.w_mask = l.w_size - 1, l.hash_bits = r + 7, l.hash_size = 1 << l.hash_bits, l.hash_mask = l.hash_size - 1, l.hash_shift = ~~((l.hash_bits + ht - 1) / ht), l.window = new R.Buf8(2 * l.w_size), l.head = new R.Buf16(l.hash_size), l.prev = new R.Buf16(l.w_size), l.lit_bufsize = 1 << r + 6, l.pending_buf_size = 4 * l.lit_bufsize, l.pending_buf = new R.Buf8(l.pending_buf_size), l.d_buf = 1 * l.lit_bufsize, l.l_buf = 3 * l.lit_bufsize, l.level = e, l.strategy = s, l.method = a, y(t);}function B(t, e) {return z(t, e, V, tt, et, J);}function S(t, e) {var a, o, d, f;if (!t || !t.state || e > L || e < 0) return t ? i(t, K) : K;if (o = t.state, !t.output || !t.input && 0 !== t.avail_in || o.status === pt && e !== F) return i(t, 0 === t.avail_out ? P : K);if (o.strm = t, a = o.last_flush, o.last_flush = e, o.status === ut) if (2 === o.wrap) t.adler = 0, l(o, 31), l(o, 139), l(o, 8), o.gzhead ? (l(o, (o.gzhead.text ? 1 : 0) + (o.gzhead.hcrc ? 2 : 0) + (o.gzhead.extra ? 4 : 0) + (o.gzhead.name ? 8 : 0) + (o.gzhead.comment ? 16 : 0)), l(o, 255 & o.gzhead.time), l(o, o.gzhead.time >> 8 & 255), l(o, o.gzhead.time >> 16 & 255), l(o, o.gzhead.time >> 24 & 255), l(o, 9 === o.level ? 2 : o.strategy >= G || o.level < 2 ? 4 : 0), l(o, 255 & o.gzhead.os), o.gzhead.extra && o.gzhead.extra.length && (l(o, 255 & o.gzhead.extra.length), l(o, o.gzhead.extra.length >> 8 & 255)), o.gzhead.hcrc && (t.adler = O(t.adler, o.pending_buf, o.pending, 0)), o.gzindex = 0, o.status = ct) : (l(o, 0), l(o, 0), l(o, 0), l(o, 0), l(o, 0), l(o, 9 === o.level ? 2 : o.strategy >= G || o.level < 2 ? 4 : 0), l(o, zt), o.status = wt);else {var _ = V + (o.w_bits - 8 << 4) << 8,u = -1;u = o.strategy >= G || o.level < 2 ? 0 : o.level < 6 ? 1 : 6 === o.level ? 2 : 3, _ |= u << 6, 0 !== o.strstart && (_ |= _t), _ += 31 - _ % 31, o.status = wt, h(o, _), 0 !== o.strstart && (h(o, t.adler >>> 16), h(o, 65535 & t.adler)), t.adler = 1;}if (o.status === ct) if (o.gzhead.extra) {for (d = o.pending; o.gzindex < (65535 & o.gzhead.extra.length) && (o.pending !== o.pending_buf_size || (o.gzhead.hcrc && o.pending > d && (t.adler = O(t.adler, o.pending_buf, o.pending - d, d)), s(t), d = o.pending, o.pending !== o.pending_buf_size));) {l(o, 255 & o.gzhead.extra[o.gzindex]), o.gzindex++;}o.gzhead.hcrc && o.pending > d && (t.adler = O(t.adler, o.pending_buf, o.pending - d, d)), o.gzindex === o.gzhead.extra.length && (o.gzindex = 0, o.status = bt);} else o.status = bt;if (o.status === bt) if (o.gzhead.name) {d = o.pending;do {if (o.pending === o.pending_buf_size && (o.gzhead.hcrc && o.pending > d && (t.adler = O(t.adler, o.pending_buf, o.pending - d, d)), s(t), d = o.pending, o.pending === o.pending_buf_size)) {f = 1;break;}f = o.gzindex < o.gzhead.name.length ? 255 & o.gzhead.name.charCodeAt(o.gzindex++) : 0, l(o, f);} while (0 !== f);o.gzhead.hcrc && o.pending > d && (t.adler = O(t.adler, o.pending_buf, o.pending - d, d)), 0 === f && (o.gzindex = 0, o.status = gt);} else o.status = gt;if (o.status === gt) if (o.gzhead.comment) {d = o.pending;do {if (o.pending === o.pending_buf_size && (o.gzhead.hcrc && o.pending > d && (t.adler = O(t.adler, o.pending_buf, o.pending - d, d)), s(t), d = o.pending, o.pending === o.pending_buf_size)) {f = 1;break;}f = o.gzindex < o.gzhead.comment.length ? 255 & o.gzhead.comment.charCodeAt(o.gzindex++) : 0, l(o, f);} while (0 !== f);o.gzhead.hcrc && o.pending > d && (t.adler = O(t.adler, o.pending_buf, o.pending - d, d)), 0 === f && (o.status = mt);} else o.status = mt;if (o.status === mt && (o.gzhead.hcrc ? (o.pending + 2 > o.pending_buf_size && s(t), o.pending + 2 <= o.pending_buf_size && (l(o, 255 & t.adler), l(o, t.adler >> 8 & 255), t.adler = 0, o.status = wt)) : o.status = wt), 0 !== o.pending) {if (s(t), 0 === t.avail_out) return o.last_flush = -1, H;} else if (0 === t.avail_in && n(e) <= n(a) && e !== F) return i(t, P);if (o.status === pt && 0 !== t.avail_in) return i(t, P);if (0 !== t.avail_in || 0 !== o.lookahead || e !== I && o.status !== pt) {var c = o.strategy === G ? m(o, e) : o.strategy === X ? g(o, e) : Z[o.level].func(o, e);if (c !== yt && c !== xt || (o.status = pt), c === vt || c === yt) return 0 === t.avail_out && (o.last_flush = -1), H;if (c === kt && (e === U ? C._tr_align(o) : e !== L && (C._tr_stored_block(o, 0, 0, !1), e === T && (r(o.head), 0 === o.lookahead && (o.strstart = 0, o.block_start = 0, o.insert = 0))), s(t), 0 === t.avail_out)) return o.last_flush = -1, H;}return e !== F ? H : o.wrap <= 0 ? j : (2 === o.wrap ? (l(o, 255 & t.adler), l(o, t.adler >> 8 & 255), l(o, t.adler >> 16 & 255), l(o, t.adler >> 24 & 255), l(o, 255 & t.total_in), l(o, t.total_in >> 8 & 255), l(o, t.total_in >> 16 & 255), l(o, t.total_in >> 24 & 255)) : (h(o, t.adler >>> 16), h(o, 65535 & t.adler)), s(t), o.wrap > 0 && (o.wrap = -o.wrap), 0 !== o.pending ? H : j);}function E(t) {var e;return t && t.state ? (e = t.state.status, e !== ut && e !== ct && e !== bt && e !== gt && e !== mt && e !== wt && e !== pt ? i(t, K) : (t.state = null, e === wt ? i(t, M) : H)) : K;}function A(t, e) {var a,i,n,s,o,l,h,d,f = e.length;if (!t || !t.state) return K;if (a = t.state, s = a.wrap, 2 === s || 1 === s && a.status !== ut || a.lookahead) return K;for (1 === s && (t.adler = N(t.adler, e, f, 0)), a.wrap = 0, f >= a.w_size && (0 === s && (r(a.head), a.strstart = 0, a.block_start = 0, a.insert = 0), d = new R.Buf8(a.w_size), R.arraySet(d, e, f - a.w_size, a.w_size, 0), e = d, f = a.w_size), o = t.avail_in, l = t.next_in, h = t.input, t.avail_in = f, t.next_in = 0, t.input = e, _(a); a.lookahead >= ht;) {i = a.strstart, n = a.lookahead - (ht - 1);do {a.ins_h = (a.ins_h << a.hash_shift ^ a.window[i + ht - 1]) & a.hash_mask, a.prev[i & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = i, i++;} while (--n);a.strstart = i, a.lookahead = ht - 1, _(a);}return a.strstart += a.lookahead, a.block_start = a.strstart, a.insert = a.lookahead, a.lookahead = 0, a.match_length = a.prev_length = ht - 1, a.match_available = 0, t.next_in = l, t.input = h, t.avail_in = o, a.wrap = s, H;}var Z,R = t("../utils/common"),C = t("./trees"),N = t("./adler32"),O = t("./crc32"),D = t("./messages"),I = 0,U = 1,T = 3,F = 4,L = 5,H = 0,j = 1,K = -2,M = -3,P = -5,Y = -1,q = 1,G = 2,X = 3,W = 4,J = 0,Q = 2,V = 8,$ = 9,tt = 15,et = 8,at = 29,it = 256,nt = it + 1 + at,rt = 30,st = 19,ot = 2 * nt + 1,lt = 15,ht = 3,dt = 258,ft = dt + ht + 1,_t = 32,ut = 42,ct = 69,bt = 73,gt = 91,mt = 103,wt = 113,pt = 666,vt = 1,kt = 2,yt = 3,xt = 4,zt = 3;Z = [new w(0, 0, 0, 0, u), new w(4, 4, 8, 4, c), new w(4, 5, 16, 8, c), new w(4, 6, 32, 32, c), new w(4, 4, 16, 16, b), new w(8, 16, 32, 32, b), new w(8, 16, 128, 128, b), new w(8, 32, 128, 256, b), new w(32, 128, 258, 1024, b), new w(32, 258, 258, 4096, b)], a.deflateInit = B, a.deflateInit2 = z, a.deflateReset = y, a.deflateResetKeep = k, a.deflateSetHeader = x, a.deflate = S, a.deflateEnd = E, a.deflateSetDictionary = A, a.deflateInfo = "pako deflate (from Nodeca project)";}, { "../utils/common": 3, "./adler32": 5, "./crc32": 7, "./messages": 13, "./trees": 14 }], 9: [function (t, e, a) {"use strict";function i() {this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;}e.exports = i;}, {}], 10: [function (t, e, a) {"use strict";var i = 30,n = 12;e.exports = function (t, e) {var a, r, s, o, l, h, d, f, _, u, c, b, g, m, w, p, v, k, y, x, z, B, S, E, A;a = t.state, r = t.next_in, E = t.input, s = r + (t.avail_in - 5), o = t.next_out, A = t.output, l = o - (e - t.avail_out), h = o + (t.avail_out - 257), d = a.dmax, f = a.wsize, _ = a.whave, u = a.wnext, c = a.window, b = a.hold, g = a.bits, m = a.lencode, w = a.distcode, p = (1 << a.lenbits) - 1, v = (1 << a.distbits) - 1;t: do {g < 15 && (b += E[r++] << g, g += 8, b += E[r++] << g, g += 8), k = m[b & p];e: for (;;) {if (y = k >>> 24, b >>>= y, g -= y, y = k >>> 16 & 255, 0 === y) A[o++] = 65535 & k;else {if (!(16 & y)) {if (0 === (64 & y)) {k = m[(65535 & k) + (b & (1 << y) - 1)];continue e;}if (32 & y) {a.mode = n;break t;}t.msg = "invalid literal/length code", a.mode = i;break t;}x = 65535 & k, y &= 15, y && (g < y && (b += E[r++] << g, g += 8), x += b & (1 << y) - 1, b >>>= y, g -= y), g < 15 && (b += E[r++] << g, g += 8, b += E[r++] << g, g += 8), k = w[b & v];a: for (;;) {if (y = k >>> 24, b >>>= y, g -= y, y = k >>> 16 & 255, !(16 & y)) {if (0 === (64 & y)) {k = w[(65535 & k) + (b & (1 << y) - 1)];continue a;}t.msg = "invalid distance code", a.mode = i;break t;}if (z = 65535 & k, y &= 15, g < y && (b += E[r++] << g, g += 8, g < y && (b += E[r++] << g, g += 8)), z += b & (1 << y) - 1, z > d) {t.msg = "invalid distance too far back", a.mode = i;break t;}if (b >>>= y, g -= y, y = o - l, z > y) {if (y = z - y, y > _ && a.sane) {t.msg = "invalid distance too far back", a.mode = i;break t;}if (B = 0, S = c, 0 === u) {if (B += f - y, y < x) {x -= y;do {A[o++] = c[B++];} while (--y);B = o - z, S = A;}} else if (u < y) {if (B += f + u - y, y -= u, y < x) {x -= y;do {A[o++] = c[B++];} while (--y);if (B = 0, u < x) {y = u, x -= y;do {A[o++] = c[B++];} while (--y);B = o - z, S = A;}}} else if (B += u - y, y < x) {x -= y;do {A[o++] = c[B++];} while (--y);B = o - z, S = A;}for (; x > 2;) {A[o++] = S[B++], A[o++] = S[B++], A[o++] = S[B++], x -= 3;}x && (A[o++] = S[B++], x > 1 && (A[o++] = S[B++]));} else {B = o - z;do {A[o++] = A[B++], A[o++] = A[B++], A[o++] = A[B++], x -= 3;} while (x > 2);x && (A[o++] = A[B++], x > 1 && (A[o++] = A[B++]));}break;}}break;}} while (r < s && o < h);x = g >> 3, r -= x, g -= x << 3, b &= (1 << g) - 1, t.next_in = r, t.next_out = o, t.avail_in = r < s ? 5 + (s - r) : 5 - (r - s), t.avail_out = o < h ? 257 + (h - o) : 257 - (o - h), a.hold = b, a.bits = g;};}, {}], 11: [function (t, e, a) {"use strict";function i(t) {return (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24);}function n() {this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new w.Buf16(320), this.work = new w.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;}function r(t) {var e;return t && t.state ? (e = t.state, t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = 1 & e.wrap), e.mode = T, e.last = 0, e.havedict = 0, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new w.Buf32(bt), e.distcode = e.distdyn = new w.Buf32(gt), e.sane = 1, e.back = -1, Z) : N;}function s(t) {var e;return t && t.state ? (e = t.state, e.wsize = 0, e.whave = 0, e.wnext = 0, r(t)) : N;}function o(t, e) {var a, i;return t && t.state ? (i = t.state, e < 0 ? (a = 0, e = -e) : (a = (e >> 4) + 1, e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? N : (null !== i.window && i.wbits !== e && (i.window = null), i.wrap = a, i.wbits = e, s(t))) : N;}function l(t, e) {var a, i;return t ? (i = new n(), t.state = i, i.window = null, a = o(t, e), a !== Z && (t.state = null), a) : N;}function h(t) {return l(t, wt);}function d(t) {if (pt) {var e;for (g = new w.Buf32(512), m = new w.Buf32(32), e = 0; e < 144;) {t.lens[e++] = 8;}for (; e < 256;) {t.lens[e++] = 9;}for (; e < 280;) {t.lens[e++] = 7;}for (; e < 288;) {t.lens[e++] = 8;}for (y(z, t.lens, 0, 288, g, 0, t.work, { bits: 9 }), e = 0; e < 32;) {t.lens[e++] = 5;}y(B, t.lens, 0, 32, m, 0, t.work, { bits: 5 }), pt = !1;}t.lencode = g, t.lenbits = 9, t.distcode = m, t.distbits = 5;}function f(t, e, a, i) {var n,r = t.state;return null === r.window && (r.wsize = 1 << r.wbits, r.wnext = 0, r.whave = 0, r.window = new w.Buf8(r.wsize)), i >= r.wsize ? (w.arraySet(r.window, e, a - r.wsize, r.wsize, 0), r.wnext = 0, r.whave = r.wsize) : (n = r.wsize - r.wnext, n > i && (n = i), w.arraySet(r.window, e, a - i, n, r.wnext), i -= n, i ? (w.arraySet(r.window, e, a - i, i, 0), r.wnext = i, r.whave = r.wsize) : (r.wnext += n, r.wnext === r.wsize && (r.wnext = 0), r.whave < r.wsize && (r.whave += n))), 0;}function _(t, e) {var a,n,r,s,o,l,h,_,u,c,b,g,m,bt,gt,mt,wt,pt,vt,kt,yt,xt,zt,Bt,St = 0,Et = new w.Buf8(4),At = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];if (!t || !t.state || !t.output || !t.input && 0 !== t.avail_in) return N;a = t.state, a.mode === X && (a.mode = W), o = t.next_out, r = t.output, h = t.avail_out, s = t.next_in, n = t.input, l = t.avail_in, _ = a.hold, u = a.bits, c = l, b = h, xt = Z;t: for (;;) {switch (a.mode) {case T:if (0 === a.wrap) {a.mode = W;break;}for (; u < 16;) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}if (2 & a.wrap && 35615 === _) {a.check = 0, Et[0] = 255 & _, Et[1] = _ >>> 8 & 255, a.check = v(a.check, Et, 2, 0), _ = 0, u = 0, a.mode = F;break;}if (a.flags = 0, a.head && (a.head.done = !1), !(1 & a.wrap) || (((255 & _) << 8) + (_ >> 8)) % 31) {t.msg = "incorrect header check", a.mode = _t;break;}if ((15 & _) !== U) {t.msg = "unknown compression method", a.mode = _t;break;}if (_ >>>= 4, u -= 4, yt = (15 & _) + 8, 0 === a.wbits) a.wbits = yt;else if (yt > a.wbits) {t.msg = "invalid window size", a.mode = _t;break;}a.dmax = 1 << yt, t.adler = a.check = 1, a.mode = 512 & _ ? q : X, _ = 0, u = 0;break;case F:for (; u < 16;) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}if (a.flags = _, (255 & a.flags) !== U) {t.msg = "unknown compression method", a.mode = _t;break;}if (57344 & a.flags) {t.msg = "unknown header flags set", a.mode = _t;break;}a.head && (a.head.text = _ >> 8 & 1), 512 & a.flags && (Et[0] = 255 & _, Et[1] = _ >>> 8 & 255, a.check = v(a.check, Et, 2, 0)), _ = 0, u = 0, a.mode = L;case L:for (; u < 32;) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}a.head && (a.head.time = _), 512 & a.flags && (Et[0] = 255 & _, Et[1] = _ >>> 8 & 255, Et[2] = _ >>> 16 & 255, Et[3] = _ >>> 24 & 255, a.check = v(a.check, Et, 4, 0)), _ = 0, u = 0, a.mode = H;case H:for (; u < 16;) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}a.head && (a.head.xflags = 255 & _, a.head.os = _ >> 8), 512 & a.flags && (Et[0] = 255 & _, Et[1] = _ >>> 8 & 255, a.check = v(a.check, Et, 2, 0)), _ = 0, u = 0, a.mode = j;case j:if (1024 & a.flags) {for (; u < 16;) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}a.length = _, a.head && (a.head.extra_len = _), 512 & a.flags && (Et[0] = 255 & _, Et[1] = _ >>> 8 & 255, a.check = v(a.check, Et, 2, 0)), _ = 0, u = 0;} else a.head && (a.head.extra = null);a.mode = K;case K:if (1024 & a.flags && (g = a.length, g > l && (g = l), g && (a.head && (yt = a.head.extra_len - a.length, a.head.extra || (a.head.extra = new Array(a.head.extra_len)), w.arraySet(a.head.extra, n, s, g, yt)), 512 & a.flags && (a.check = v(a.check, n, g, s)), l -= g, s += g, a.length -= g), a.length)) break t;a.length = 0, a.mode = M;case M:if (2048 & a.flags) {if (0 === l) break t;g = 0;do {yt = n[s + g++], a.head && yt && a.length < 65536 && (a.head.name += String.fromCharCode(yt));} while (yt && g < l);if (512 & a.flags && (a.check = v(a.check, n, g, s)), l -= g, s += g, yt) break t;} else a.head && (a.head.name = null);a.length = 0, a.mode = P;case P:if (4096 & a.flags) {if (0 === l) break t;g = 0;do {yt = n[s + g++], a.head && yt && a.length < 65536 && (a.head.comment += String.fromCharCode(yt));} while (yt && g < l);if (512 & a.flags && (a.check = v(a.check, n, g, s)), l -= g, s += g, yt) break t;} else a.head && (a.head.comment = null);a.mode = Y;case Y:if (512 & a.flags) {for (; u < 16;) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}if (_ !== (65535 & a.check)) {t.msg = "header crc mismatch", a.mode = _t;break;}_ = 0, u = 0;}a.head && (a.head.hcrc = a.flags >> 9 & 1, a.head.done = !0), t.adler = a.check = 0, a.mode = X;break;case q:for (; u < 32;) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}t.adler = a.check = i(_), _ = 0, u = 0, a.mode = G;case G:if (0 === a.havedict) return t.next_out = o, t.avail_out = h, t.next_in = s, t.avail_in = l, a.hold = _, a.bits = u, C;t.adler = a.check = 1, a.mode = X;case X:if (e === E || e === A) break t;case W:if (a.last) {_ >>>= 7 & u, u -= 7 & u, a.mode = ht;break;}for (; u < 3;) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}switch (a.last = 1 & _, _ >>>= 1, u -= 1, 3 & _) {case 0:a.mode = J;break;case 1:if (d(a), a.mode = at, e === A) {_ >>>= 2, u -= 2;break t;}break;case 2:a.mode = $;break;case 3:t.msg = "invalid block type", a.mode = _t;}_ >>>= 2, u -= 2;break;case J:for (_ >>>= 7 & u, u -= 7 & u; u < 32;) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}if ((65535 & _) !== (_ >>> 16 ^ 65535)) {t.msg = "invalid stored block lengths", a.mode = _t;break;}if (a.length = 65535 & _, _ = 0, u = 0, a.mode = Q, e === A) break t;case Q:a.mode = V;case V:if (g = a.length) {if (g > l && (g = l), g > h && (g = h), 0 === g) break t;w.arraySet(r, n, s, g, o), l -= g, s += g, h -= g, o += g, a.length -= g;break;}a.mode = X;break;case $:for (; u < 14;) {if (0 === l) break t;
                l--, _ += n[s++] << u, u += 8;}if (a.nlen = (31 & _) + 257, _ >>>= 5, u -= 5, a.ndist = (31 & _) + 1, _ >>>= 5, u -= 5, a.ncode = (15 & _) + 4, _ >>>= 4, u -= 4, a.nlen > 286 || a.ndist > 30) {t.msg = "too many length or distance symbols", a.mode = _t;break;}a.have = 0, a.mode = tt;case tt:for (; a.have < a.ncode;) {for (; u < 3;) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}a.lens[At[a.have++]] = 7 & _, _ >>>= 3, u -= 3;}for (; a.have < 19;) {a.lens[At[a.have++]] = 0;}if (a.lencode = a.lendyn, a.lenbits = 7, zt = { bits: a.lenbits }, xt = y(x, a.lens, 0, 19, a.lencode, 0, a.work, zt), a.lenbits = zt.bits, xt) {t.msg = "invalid code lengths set", a.mode = _t;break;}a.have = 0, a.mode = et;case et:for (; a.have < a.nlen + a.ndist;) {for (; St = a.lencode[_ & (1 << a.lenbits) - 1], gt = St >>> 24, mt = St >>> 16 & 255, wt = 65535 & St, !(gt <= u);) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}if (wt < 16) _ >>>= gt, u -= gt, a.lens[a.have++] = wt;else {if (16 === wt) {for (Bt = gt + 2; u < Bt;) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}if (_ >>>= gt, u -= gt, 0 === a.have) {t.msg = "invalid bit length repeat", a.mode = _t;break;}yt = a.lens[a.have - 1], g = 3 + (3 & _), _ >>>= 2, u -= 2;} else if (17 === wt) {for (Bt = gt + 3; u < Bt;) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}_ >>>= gt, u -= gt, yt = 0, g = 3 + (7 & _), _ >>>= 3, u -= 3;} else {for (Bt = gt + 7; u < Bt;) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}_ >>>= gt, u -= gt, yt = 0, g = 11 + (127 & _), _ >>>= 7, u -= 7;}if (a.have + g > a.nlen + a.ndist) {t.msg = "invalid bit length repeat", a.mode = _t;break;}for (; g--;) {a.lens[a.have++] = yt;}}}if (a.mode === _t) break;if (0 === a.lens[256]) {t.msg = "invalid code -- missing end-of-block", a.mode = _t;break;}if (a.lenbits = 9, zt = { bits: a.lenbits }, xt = y(z, a.lens, 0, a.nlen, a.lencode, 0, a.work, zt), a.lenbits = zt.bits, xt) {t.msg = "invalid literal/lengths set", a.mode = _t;break;}if (a.distbits = 6, a.distcode = a.distdyn, zt = { bits: a.distbits }, xt = y(B, a.lens, a.nlen, a.ndist, a.distcode, 0, a.work, zt), a.distbits = zt.bits, xt) {t.msg = "invalid distances set", a.mode = _t;break;}if (a.mode = at, e === A) break t;case at:a.mode = it;case it:if (l >= 6 && h >= 258) {t.next_out = o, t.avail_out = h, t.next_in = s, t.avail_in = l, a.hold = _, a.bits = u, k(t, b), o = t.next_out, r = t.output, h = t.avail_out, s = t.next_in, n = t.input, l = t.avail_in, _ = a.hold, u = a.bits, a.mode === X && (a.back = -1);break;}for (a.back = 0; St = a.lencode[_ & (1 << a.lenbits) - 1], gt = St >>> 24, mt = St >>> 16 & 255, wt = 65535 & St, !(gt <= u);) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}if (mt && 0 === (240 & mt)) {for (pt = gt, vt = mt, kt = wt; St = a.lencode[kt + ((_ & (1 << pt + vt) - 1) >> pt)], gt = St >>> 24, mt = St >>> 16 & 255, wt = 65535 & St, !(pt + gt <= u);) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}_ >>>= pt, u -= pt, a.back += pt;}if (_ >>>= gt, u -= gt, a.back += gt, a.length = wt, 0 === mt) {a.mode = lt;break;}if (32 & mt) {a.back = -1, a.mode = X;break;}if (64 & mt) {t.msg = "invalid literal/length code", a.mode = _t;break;}a.extra = 15 & mt, a.mode = nt;case nt:if (a.extra) {for (Bt = a.extra; u < Bt;) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}a.length += _ & (1 << a.extra) - 1, _ >>>= a.extra, u -= a.extra, a.back += a.extra;}a.was = a.length, a.mode = rt;case rt:for (; St = a.distcode[_ & (1 << a.distbits) - 1], gt = St >>> 24, mt = St >>> 16 & 255, wt = 65535 & St, !(gt <= u);) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}if (0 === (240 & mt)) {for (pt = gt, vt = mt, kt = wt; St = a.distcode[kt + ((_ & (1 << pt + vt) - 1) >> pt)], gt = St >>> 24, mt = St >>> 16 & 255, wt = 65535 & St, !(pt + gt <= u);) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}_ >>>= pt, u -= pt, a.back += pt;}if (_ >>>= gt, u -= gt, a.back += gt, 64 & mt) {t.msg = "invalid distance code", a.mode = _t;break;}a.offset = wt, a.extra = 15 & mt, a.mode = st;case st:if (a.extra) {for (Bt = a.extra; u < Bt;) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}a.offset += _ & (1 << a.extra) - 1, _ >>>= a.extra, u -= a.extra, a.back += a.extra;}if (a.offset > a.dmax) {t.msg = "invalid distance too far back", a.mode = _t;break;}a.mode = ot;case ot:if (0 === h) break t;if (g = b - h, a.offset > g) {if (g = a.offset - g, g > a.whave && a.sane) {t.msg = "invalid distance too far back", a.mode = _t;break;}g > a.wnext ? (g -= a.wnext, m = a.wsize - g) : m = a.wnext - g, g > a.length && (g = a.length), bt = a.window;} else bt = r, m = o - a.offset, g = a.length;g > h && (g = h), h -= g, a.length -= g;do {r[o++] = bt[m++];} while (--g);0 === a.length && (a.mode = it);break;case lt:if (0 === h) break t;r[o++] = a.length, h--, a.mode = it;break;case ht:if (a.wrap) {for (; u < 32;) {if (0 === l) break t;l--, _ |= n[s++] << u, u += 8;}if (b -= h, t.total_out += b, a.total += b, b && (t.adler = a.check = a.flags ? v(a.check, r, b, o - b) : p(a.check, r, b, o - b)), b = h, (a.flags ? _ : i(_)) !== a.check) {t.msg = "incorrect data check", a.mode = _t;break;}_ = 0, u = 0;}a.mode = dt;case dt:if (a.wrap && a.flags) {for (; u < 32;) {if (0 === l) break t;l--, _ += n[s++] << u, u += 8;}if (_ !== (4294967295 & a.total)) {t.msg = "incorrect length check", a.mode = _t;break;}_ = 0, u = 0;}a.mode = ft;case ft:xt = R;break t;case _t:xt = O;break t;case ut:return D;case ct:default:return N;}}return t.next_out = o, t.avail_out = h, t.next_in = s, t.avail_in = l, a.hold = _, a.bits = u, (a.wsize || b !== t.avail_out && a.mode < _t && (a.mode < ht || e !== S)) && f(t, t.output, t.next_out, b - t.avail_out) ? (a.mode = ut, D) : (c -= t.avail_in, b -= t.avail_out, t.total_in += c, t.total_out += b, a.total += b, a.wrap && b && (t.adler = a.check = a.flags ? v(a.check, r, b, t.next_out - b) : p(a.check, r, b, t.next_out - b)), t.data_type = a.bits + (a.last ? 64 : 0) + (a.mode === X ? 128 : 0) + (a.mode === at || a.mode === Q ? 256 : 0), (0 === c && 0 === b || e === S) && xt === Z && (xt = I), xt);}function u(t) {if (!t || !t.state) return N;var e = t.state;return e.window && (e.window = null), t.state = null, Z;}function c(t, e) {var a;return t && t.state ? (a = t.state, 0 === (2 & a.wrap) ? N : (a.head = e, e.done = !1, Z)) : N;}function b(t, e) {var a,i,n,r = e.length;return t && t.state ? (a = t.state, 0 !== a.wrap && a.mode !== G ? N : a.mode === G && (i = 1, i = p(i, e, r, 0), i !== a.check) ? O : (n = f(t, e, r, r)) ? (a.mode = ut, D) : (a.havedict = 1, Z)) : N;}var g,m,w = t("../utils/common"),p = t("./adler32"),v = t("./crc32"),k = t("./inffast"),y = t("./inftrees"),x = 0,z = 1,B = 2,S = 4,E = 5,A = 6,Z = 0,R = 1,C = 2,N = -2,O = -3,D = -4,I = -5,U = 8,T = 1,F = 2,L = 3,H = 4,j = 5,K = 6,M = 7,P = 8,Y = 9,q = 10,G = 11,X = 12,W = 13,J = 14,Q = 15,V = 16,$ = 17,tt = 18,et = 19,at = 20,it = 21,nt = 22,rt = 23,st = 24,ot = 25,lt = 26,ht = 27,dt = 28,ft = 29,_t = 30,ut = 31,ct = 32,bt = 852,gt = 592,mt = 15,wt = mt,pt = !0;a.inflateReset = s, a.inflateReset2 = o, a.inflateResetKeep = r, a.inflateInit = h, a.inflateInit2 = l, a.inflate = _, a.inflateEnd = u, a.inflateGetHeader = c, a.inflateSetDictionary = b, a.inflateInfo = "pako inflate (from Nodeca project)";}, { "../utils/common": 3, "./adler32": 5, "./crc32": 7, "./inffast": 10, "./inftrees": 12 }], 12: [function (t, e, a) {"use strict";var i = t("../utils/common"),n = 15,r = 852,s = 592,o = 0,l = 1,h = 2,d = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0],f = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78],_ = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0],u = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];e.exports = function (t, e, a, c, b, g, m, w) {var p,v,k,y,x,z,B,S,E,A = w.bits,Z = 0,R = 0,C = 0,N = 0,O = 0,D = 0,I = 0,U = 0,T = 0,F = 0,L = null,H = 0,j = new i.Buf16(n + 1),K = new i.Buf16(n + 1),M = null,P = 0;for (Z = 0; Z <= n; Z++) {j[Z] = 0;}for (R = 0; R < c; R++) {j[e[a + R]]++;}for (O = A, N = n; N >= 1 && 0 === j[N]; N--) {;}if (O > N && (O = N), 0 === N) return b[g++] = 20971520, b[g++] = 20971520, w.bits = 1, 0;for (C = 1; C < N && 0 === j[C]; C++) {;}for (O < C && (O = C), U = 1, Z = 1; Z <= n; Z++) {if (U <<= 1, U -= j[Z], U < 0) return -1;}if (U > 0 && (t === o || 1 !== N)) return -1;for (K[1] = 0, Z = 1; Z < n; Z++) {K[Z + 1] = K[Z] + j[Z];}for (R = 0; R < c; R++) {0 !== e[a + R] && (m[K[e[a + R]]++] = R);}if (t === o ? (L = M = m, z = 19) : t === l ? (L = d, H -= 257, M = f, P -= 257, z = 256) : (L = _, M = u, z = -1), F = 0, R = 0, Z = C, x = g, D = O, I = 0, k = -1, T = 1 << O, y = T - 1, t === l && T > r || t === h && T > s) return 1;for (var Y = 0;;) {Y++, B = Z - I, m[R] < z ? (S = 0, E = m[R]) : m[R] > z ? (S = M[P + m[R]], E = L[H + m[R]]) : (S = 96, E = 0), p = 1 << Z - I, v = 1 << D, C = v;do {v -= p, b[x + (F >> I) + v] = B << 24 | S << 16 | E | 0;} while (0 !== v);for (p = 1 << Z - 1; F & p;) {p >>= 1;}if (0 !== p ? (F &= p - 1, F += p) : F = 0, R++, 0 === --j[Z]) {if (Z === N) break;Z = e[a + m[R]];}if (Z > O && (F & y) !== k) {for (0 === I && (I = O), x += C, D = Z - I, U = 1 << D; D + I < N && (U -= j[D + I], !(U <= 0));) {D++, U <<= 1;}if (T += 1 << D, t === l && T > r || t === h && T > s) return 1;k = F & y, b[k] = O << 24 | D << 16 | x - g | 0;}}return 0 !== F && (b[x + F] = Z - I << 24 | 64 << 16 | 0), w.bits = O, 0;};}, { "../utils/common": 3 }], 13: [function (t, e, a) {"use strict";e.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };}, {}], 14: [function (t, e, a) {"use strict";function i(t) {for (var e = t.length; --e >= 0;) {t[e] = 0;}}function n(t, e, a, i, n) {this.static_tree = t, this.extra_bits = e, this.extra_base = a, this.elems = i, this.max_length = n, this.has_stree = t && t.length;}function r(t, e) {this.dyn_tree = t, this.max_code = 0, this.stat_desc = e;}function s(t) {return t < 256 ? lt[t] : lt[256 + (t >>> 7)];}function o(t, e) {t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255;}function l(t, e, a) {t.bi_valid > W - a ? (t.bi_buf |= e << t.bi_valid & 65535, o(t, t.bi_buf), t.bi_buf = e >> W - t.bi_valid, t.bi_valid += a - W) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += a);}function h(t, e, a) {l(t, a[2 * e], a[2 * e + 1]);}function d(t, e) {var a = 0;do {a |= 1 & t, t >>>= 1, a <<= 1;} while (--e > 0);return a >>> 1;}function f(t) {16 === t.bi_valid ? (o(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8);}function _(t, e) {var a,i,n,r,s,o,l = e.dyn_tree,h = e.max_code,d = e.stat_desc.static_tree,f = e.stat_desc.has_stree,_ = e.stat_desc.extra_bits,u = e.stat_desc.extra_base,c = e.stat_desc.max_length,b = 0;for (r = 0; r <= X; r++) {t.bl_count[r] = 0;}for (l[2 * t.heap[t.heap_max] + 1] = 0, a = t.heap_max + 1; a < G; a++) {i = t.heap[a], r = l[2 * l[2 * i + 1] + 1] + 1, r > c && (r = c, b++), l[2 * i + 1] = r, i > h || (t.bl_count[r]++, s = 0, i >= u && (s = _[i - u]), o = l[2 * i], t.opt_len += o * (r + s), f && (t.static_len += o * (d[2 * i + 1] + s)));}if (0 !== b) {do {for (r = c - 1; 0 === t.bl_count[r];) {r--;}t.bl_count[r]--, t.bl_count[r + 1] += 2, t.bl_count[c]--, b -= 2;} while (b > 0);for (r = c; 0 !== r; r--) {for (i = t.bl_count[r]; 0 !== i;) {n = t.heap[--a], n > h || (l[2 * n + 1] !== r && (t.opt_len += (r - l[2 * n + 1]) * l[2 * n], l[2 * n + 1] = r), i--);}}}}function u(t, e, a) {var i,n,r = new Array(X + 1),s = 0;for (i = 1; i <= X; i++) {r[i] = s = s + a[i - 1] << 1;}for (n = 0; n <= e; n++) {var o = t[2 * n + 1];0 !== o && (t[2 * n] = d(r[o]++, o));}}function c() {var t,e,a,i,r,s = new Array(X + 1);for (a = 0, i = 0; i < K - 1; i++) {for (dt[i] = a, t = 0; t < 1 << et[i]; t++) {ht[a++] = i;}}for (ht[a - 1] = i, r = 0, i = 0; i < 16; i++) {for (ft[i] = r, t = 0; t < 1 << at[i]; t++) {lt[r++] = i;}}for (r >>= 7; i < Y; i++) {for (ft[i] = r << 7, t = 0; t < 1 << at[i] - 7; t++) {lt[256 + r++] = i;}}for (e = 0; e <= X; e++) {s[e] = 0;}for (t = 0; t <= 143;) {st[2 * t + 1] = 8, t++, s[8]++;}for (; t <= 255;) {st[2 * t + 1] = 9, t++, s[9]++;}for (; t <= 279;) {st[2 * t + 1] = 7, t++, s[7]++;}for (; t <= 287;) {st[2 * t + 1] = 8, t++, s[8]++;}for (u(st, P + 1, s), t = 0; t < Y; t++) {ot[2 * t + 1] = 5, ot[2 * t] = d(t, 5);}_t = new n(st, et, M + 1, P, X), ut = new n(ot, at, 0, Y, X), ct = new n(new Array(0), it, 0, q, J);}function b(t) {var e;for (e = 0; e < P; e++) {t.dyn_ltree[2 * e] = 0;}for (e = 0; e < Y; e++) {t.dyn_dtree[2 * e] = 0;}for (e = 0; e < q; e++) {t.bl_tree[2 * e] = 0;}t.dyn_ltree[2 * Q] = 1, t.opt_len = t.static_len = 0, t.last_lit = t.matches = 0;}function g(t) {t.bi_valid > 8 ? o(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0;}function m(t, e, a, i) {g(t), i && (o(t, a), o(t, ~a)), N.arraySet(t.pending_buf, t.window, e, a, t.pending), t.pending += a;}function w(t, e, a, i) {var n = 2 * e,r = 2 * a;return t[n] < t[r] || t[n] === t[r] && i[e] <= i[a];}function p(t, e, a) {for (var i = t.heap[a], n = a << 1; n <= t.heap_len && (n < t.heap_len && w(e, t.heap[n + 1], t.heap[n], t.depth) && n++, !w(e, i, t.heap[n], t.depth));) {t.heap[a] = t.heap[n], a = n, n <<= 1;}t.heap[a] = i;}function v(t, e, a) {var i,n,r,o,d = 0;if (0 !== t.last_lit) do {i = t.pending_buf[t.d_buf + 2 * d] << 8 | t.pending_buf[t.d_buf + 2 * d + 1], n = t.pending_buf[t.l_buf + d], d++, 0 === i ? h(t, n, e) : (r = ht[n], h(t, r + M + 1, e), o = et[r], 0 !== o && (n -= dt[r], l(t, n, o)), i--, r = s(i), h(t, r, a), o = at[r], 0 !== o && (i -= ft[r], l(t, i, o)));} while (d < t.last_lit);h(t, Q, e);}function k(t, e) {var a,i,n,r = e.dyn_tree,s = e.stat_desc.static_tree,o = e.stat_desc.has_stree,l = e.stat_desc.elems,h = -1;for (t.heap_len = 0, t.heap_max = G, a = 0; a < l; a++) {0 !== r[2 * a] ? (t.heap[++t.heap_len] = h = a, t.depth[a] = 0) : r[2 * a + 1] = 0;}for (; t.heap_len < 2;) {n = t.heap[++t.heap_len] = h < 2 ? ++h : 0, r[2 * n] = 1, t.depth[n] = 0, t.opt_len--, o && (t.static_len -= s[2 * n + 1]);}for (e.max_code = h, a = t.heap_len >> 1; a >= 1; a--) {p(t, r, a);}n = l;do {a = t.heap[1], t.heap[1] = t.heap[t.heap_len--], p(t, r, 1), i = t.heap[1], t.heap[--t.heap_max] = a, t.heap[--t.heap_max] = i, r[2 * n] = r[2 * a] + r[2 * i], t.depth[n] = (t.depth[a] >= t.depth[i] ? t.depth[a] : t.depth[i]) + 1, r[2 * a + 1] = r[2 * i + 1] = n, t.heap[1] = n++, p(t, r, 1);} while (t.heap_len >= 2);t.heap[--t.heap_max] = t.heap[1], _(t, e), u(r, h, t.bl_count);}function y(t, e, a) {var i,n,r = -1,s = e[1],o = 0,l = 7,h = 4;for (0 === s && (l = 138, h = 3), e[2 * (a + 1) + 1] = 65535, i = 0; i <= a; i++) {n = s, s = e[2 * (i + 1) + 1], ++o < l && n === s || (o < h ? t.bl_tree[2 * n] += o : 0 !== n ? (n !== r && t.bl_tree[2 * n]++, t.bl_tree[2 * V]++) : o <= 10 ? t.bl_tree[2 * $]++ : t.bl_tree[2 * tt]++, o = 0, r = n, 0 === s ? (l = 138, h = 3) : n === s ? (l = 6, h = 3) : (l = 7, h = 4));}}function x(t, e, a) {var i,n,r = -1,s = e[1],o = 0,d = 7,f = 4;for (0 === s && (d = 138, f = 3), i = 0; i <= a; i++) {if (n = s, s = e[2 * (i + 1) + 1], !(++o < d && n === s)) {if (o < f) {do {h(t, n, t.bl_tree);} while (0 !== --o);} else 0 !== n ? (n !== r && (h(t, n, t.bl_tree), o--), h(t, V, t.bl_tree), l(t, o - 3, 2)) : o <= 10 ? (h(t, $, t.bl_tree), l(t, o - 3, 3)) : (h(t, tt, t.bl_tree), l(t, o - 11, 7));o = 0, r = n, 0 === s ? (d = 138, f = 3) : n === s ? (d = 6, f = 3) : (d = 7, f = 4);}}}function z(t) {var e;for (y(t, t.dyn_ltree, t.l_desc.max_code), y(t, t.dyn_dtree, t.d_desc.max_code), k(t, t.bl_desc), e = q - 1; e >= 3 && 0 === t.bl_tree[2 * nt[e] + 1]; e--) {;}return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e;}function B(t, e, a, i) {var n;for (l(t, e - 257, 5), l(t, a - 1, 5), l(t, i - 4, 4), n = 0; n < i; n++) {l(t, t.bl_tree[2 * nt[n] + 1], 3);}x(t, t.dyn_ltree, e - 1), x(t, t.dyn_dtree, a - 1);}function S(t) {var e,a = 4093624447;for (e = 0; e <= 31; e++, a >>>= 1) {if (1 & a && 0 !== t.dyn_ltree[2 * e]) return D;}if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return I;for (e = 32; e < M; e++) {if (0 !== t.dyn_ltree[2 * e]) return I;}return D;}function E(t) {bt || (c(), bt = !0), t.l_desc = new r(t.dyn_ltree, _t), t.d_desc = new r(t.dyn_dtree, ut), t.bl_desc = new r(t.bl_tree, ct), t.bi_buf = 0, t.bi_valid = 0, b(t);}function A(t, e, a, i) {l(t, (T << 1) + (i ? 1 : 0), 3), m(t, e, a, !0);}function Z(t) {l(t, F << 1, 3), h(t, Q, st), f(t);}function R(t, e, a, i) {var n,r,s = 0;t.level > 0 ? (t.strm.data_type === U && (t.strm.data_type = S(t)), k(t, t.l_desc), k(t, t.d_desc), s = z(t), n = t.opt_len + 3 + 7 >>> 3, r = t.static_len + 3 + 7 >>> 3, r <= n && (n = r)) : n = r = a + 5, a + 4 <= n && e !== -1 ? A(t, e, a, i) : t.strategy === O || r === n ? (l(t, (F << 1) + (i ? 1 : 0), 3), v(t, st, ot)) : (l(t, (L << 1) + (i ? 1 : 0), 3), B(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, s + 1), v(t, t.dyn_ltree, t.dyn_dtree)), b(t), i && g(t);}function C(t, e, a) {return t.pending_buf[t.d_buf + 2 * t.last_lit] = e >>> 8 & 255, t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e, t.pending_buf[t.l_buf + t.last_lit] = 255 & a, t.last_lit++, 0 === e ? t.dyn_ltree[2 * a]++ : (t.matches++, e--, t.dyn_ltree[2 * (ht[a] + M + 1)]++, t.dyn_dtree[2 * s(e)]++), t.last_lit === t.lit_bufsize - 1;}var N = t("../utils/common"),O = 4,D = 0,I = 1,U = 2,T = 0,F = 1,L = 2,H = 3,j = 258,K = 29,M = 256,P = M + 1 + K,Y = 30,q = 19,G = 2 * P + 1,X = 15,W = 16,J = 7,Q = 256,V = 16,$ = 17,tt = 18,et = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0],at = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],it = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],nt = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],rt = 512,st = new Array(2 * (P + 2));i(st);var ot = new Array(2 * Y);i(ot);var lt = new Array(rt);i(lt);var ht = new Array(j - H + 1);i(ht);var dt = new Array(K);i(dt);var ft = new Array(Y);i(ft);var _t,ut,ct,bt = !1;a._tr_init = E, a._tr_stored_block = A, a._tr_flush_block = R, a._tr_tally = C, a._tr_align = Z;}, { "../utils/common": 3 }], 15: [function (t, e, a) {"use strict";function i() {this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;}e.exports = i;}, {}], "/": [function (t, e, a) {"use strict";var i = t("./lib/utils/common").assign,n = t("./lib/deflate"),r = t("./lib/inflate"),s = t("./lib/zlib/constants"),o = {};i(o, n, r, s), e.exports = o;}, { "./lib/deflate": 1, "./lib/inflate": 2, "./lib/utils/common": 3, "./lib/zlib/constants": 6 }] }, {}, [])("/");});

/***/ }),
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */
/*!************************************************!*\
  !*** I:/out-project/FCoinEx/utils/validate.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.isEmail = isEmail;exports.isMobile = isMobile;exports.isPassword = isPassword;exports.isPayPassword = isPayPassword;exports.isPhone = isPhone;exports.isURL = isURL;exports.isId = isId;exports.isImg = isImg;exports.isVideo = isVideo;exports.isZip = isZip;exports.isDoc = isDoc; /**
                                                                                                                                                                                                                                                                                                                                                                         * 邮箱
                                                                                                                                                                                                                                                                                                                                                                         * @param {*} s
                                                                                                                                                                                                                                                                                                                                                                         */
function isEmail(s) {
  return /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/.test(s);
}

/**
   * 手机号码
   * @param {*} s
   */
function isMobile(s) {
  return /^[1][3-9][0-9]{9}$/.test(s);
}

/**
   * 密码
   * @param {Object} s
   */
function isPassword(s) {
  return /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{8,18}$/.test(s);
}

/**
   * 支付密码
   * @param {Object} s
   */
function isPayPassword(s) {
  return /^\d{6}$/.test(s);
}

/**
   * 电话号码
   * @param {*} s
   */
function isPhone(s) {
  return /^([0-9]{3,4}-)?[0-9]{7,8}$/.test(s);
}

/**
   * URL地址
   * @param {*} s
   */
function isURL(s) {
  return /^http[s]?:\/\/.*/.test(s);
}

/**
   * 身份证
   * @param {*} s
   */
function isId(s) {
  return /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/.test(s);
}

/**
   * 是否是图片类型
   * @param {*} type
   */
function isImg(type) {
  if (type !== 'image/jpg' && type !== 'image/jpeg' && type !== 'image/png' && type !== 'image/gif') {
    this.$message.error('只支持jpg、png、gif格式的图片！');
    return false;
  }
  return true;
}

/**
   * 是否是视频类型['video/mp4', 'video/ogg', 'video/flv','video/avi','video/wmv','video/rmvb']
   * @param {*} type
   */
function isVideo(type) {
  if (type !== 'video/mp4' && type !== 'video/ogg' && type !== 'video/flv' && type !== 'video/avi' && type !== 'video/wmv' && type !== 'video/rmvb') {
    this.$message.error('只支持mp4、ogg、flv、avi、wmv、rmvb格式的视频！');
    return false;
  }
  return true;
}

/**
   * 是否是压缩包类型
   * @param {*} type
   */
function isZip(type) {
  if (type !== 'application/zip') {
    this.$message.error('只支持zip格式的图片！');
    return false;
  }
  return true;
}

/**
   * 是否是文档类型['application/msword'、'application/pdf']
   * @param {*} type
   */
function isDoc(type) {
  if (type !== 'application/zip' && type !== 'application/pdf') {
    this.$message.error('只支持doc、docx、pdf格式的文档！');
    return false;
  }
  return true;
}

/***/ }),
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */
/*!**********************************************************************!*\
  !*** I:/out-project/FCoinEx/components/mescroll-uni/mescroll-uni.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(uni) {Object.defineProperty(exports, "__esModule", { value: true });exports.default = MeScroll; /* mescroll
                                                                                                        * version 1.2.5
                                                                                                        * 2020-03-15 wenju
                                                                                                        * http://www.mescroll.com
                                                                                                        */

function MeScroll(options, isScrollBody) {
  var me = this;
  me.version = '1.2.5'; // mescroll版本号
  me.options = options || {}; // 配置
  me.isScrollBody = isScrollBody || false; // 滚动区域是否为原生页面滚动; 默认为scroll-view

  me.isDownScrolling = false; // 是否在执行下拉刷新的回调
  me.isUpScrolling = false; // 是否在执行上拉加载的回调
  var hasDownCallback = me.options.down && me.options.down.callback; // 是否配置了down的callback

  // 初始化下拉刷新
  me.initDownScroll();
  // 初始化上拉加载,则初始化
  me.initUpScroll();

  // 自动加载
  setTimeout(function () {// 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例
    // 自动触发下拉刷新 (只有配置了down的callback才自动触发下拉刷新)
    if (me.optDown.use && me.optDown.auto && hasDownCallback) {
      if (me.optDown.autoShowLoading) {
        me.triggerDownScroll(); // 显示下拉进度,执行下拉回调
      } else {
        me.optDown.callback && me.optDown.callback(me); // 不显示下拉进度,直接执行下拉回调
      }
    }
    // 自动触发上拉加载
    setTimeout(function () {// 延时确保先执行down的callback,再执行up的callback,因为部分小程序emit是异步,会导致isUpAutoLoad判断有误
      me.optUp.use && me.optUp.auto && !me.isUpAutoLoad && me.triggerUpScroll();
    }, 100);
  }, 30); // 需让me.optDown.inited和me.optUp.inited先执行
}

/* 配置参数:下拉刷新 */
MeScroll.prototype.extendDownScroll = function (optDown) {
  // 下拉刷新的配置
  MeScroll.extend(optDown, {
    use: true, // 是否启用下拉刷新; 默认true
    auto: true, // 是否在初始化完毕之后自动执行下拉刷新的回调; 默认true
    native: false, // 是否使用系统自带的下拉刷新; 默认false; 仅mescroll-body生效 (值为true时,还需在pages配置enablePullDownRefresh:true;详请参考mescroll-native的案例)
    autoShowLoading: false, // 如果设置auto=true(在初始化完毕之后自动执行下拉刷新的回调),那么是否显示下拉刷新的进度; 默认false
    isLock: false, // 是否锁定下拉刷新,默认false;
    offset: 80, // 在列表顶部,下拉大于80px,松手即可触发下拉刷新的回调
    startTop: 100, // scroll-view滚动到顶部时,此时的scroll-top不一定为0, 此值用于控制最大的误差
    fps: 80, // 下拉节流 (值越大每秒刷新频率越高)
    inOffsetRate: 1, // 在列表顶部,下拉的距离小于offset时,改变下拉区域高度比例;值小于1且越接近0,高度变化越小,表现为越往下越难拉
    outOffsetRate: 0.2, // 在列表顶部,下拉的距离大于offset时,改变下拉区域高度比例;值小于1且越接近0,高度变化越小,表现为越往下越难拉
    bottomOffset: 20, // 当手指touchmove位置在距离body底部20px范围内的时候结束上拉刷新,避免Webview嵌套导致touchend事件不执行
    minAngle: 45, // 向下滑动最少偏移的角度,取值区间  [0,90];默认45度,即向下滑动的角度大于45度则触发下拉;而小于45度,将不触发下拉,避免与左右滑动的轮播等组件冲突;
    textInOffset: '下拉刷新', // 下拉的距离在offset范围内的提示文本
    textOutOffset: '释放更新', // 下拉的距离大于offset范围的提示文本
    textLoading: '加载中 ...', // 加载中的提示文本
    bgColor: "transparent", // 背景颜色 (建议在pages.json中再设置一下backgroundColorTop)
    textColor: "gray", // 文本颜色 (当bgColor配置了颜色,而textColor未配置时,则textColor会默认为白色)
    inited: null, // 下拉刷新初始化完毕的回调
    inOffset: null, // 下拉的距离进入offset范围内那一刻的回调
    outOffset: null, // 下拉的距离大于offset那一刻的回调
    onMoving: null, // 下拉过程中的回调,滑动过程一直在执行; rate下拉区域当前高度与指定距离的比值(inOffset: rate<1; outOffset: rate>=1); downHight当前下拉区域的高度
    beforeLoading: null, // 准备触发下拉刷新的回调: 如果return true,将不触发showLoading和callback回调; 常用来完全自定义下拉刷新, 参考案例【淘宝 v6.8.0】
    showLoading: null, // 显示下拉刷新进度的回调
    afterLoading: null, // 准备结束下拉的回调. 返回结束下拉的延时执行时间,默认0ms; 常用于结束下拉之前再显示另外一小段动画,才去隐藏下拉刷新的场景, 参考案例【dotJump】
    endDownScroll: null, // 结束下拉刷新的回调
    callback: function callback(mescroll) {
      // 下拉刷新的回调;默认重置上拉加载列表为第一页
      mescroll.resetUpScroll();
    } });

};

/* 配置参数:上拉加载 */
MeScroll.prototype.extendUpScroll = function (optUp) {
  // 上拉加载的配置
  MeScroll.extend(optUp, {
    use: true, // 是否启用上拉加载; 默认true
    auto: true, // 是否在初始化完毕之后自动执行上拉加载的回调; 默认true
    isLock: false, // 是否锁定上拉加载,默认false;
    isBoth: true, // 上拉加载时,如果滑动到列表顶部是否可以同时触发下拉刷新;默认true,两者可同时触发;
    isBounce: false, // 默认禁止橡皮筋的回弹效果, 必读事项: http://www.mescroll.com/qa.html?v=190725#q25
    callback: null, // 上拉加载的回调;function(page,mescroll){ }
    page: {
      num: 0, // 当前页码,默认0,回调之前会加1,即callback(page)会从1开始
      size: 10, // 每页数据的数量
      time: null // 加载第一页数据服务器返回的时间; 防止用户翻页时,后台新增了数据从而导致下一页数据重复;
    },
    noMoreSize: 5, // 如果列表已无数据,可设置列表的总数量要大于等于5条才显示无更多数据;避免列表数据过少(比如只有一条数据),显示无更多数据会不好看
    offset: 80, // 距底部多远时,触发upCallback
    textLoading: '加载中 ...', // 加载中的提示文本
    textNoMore: '-- END --', // 没有更多数据的提示文本
    bgColor: "transparent", // 背景颜色 (建议在pages.json中再设置一下backgroundColorBottom)
    textColor: "gray", // 文本颜色 (当bgColor配置了颜色,而textColor未配置时,则textColor会默认为白色)
    inited: null, // 初始化完毕的回调
    showLoading: null, // 显示加载中的回调
    showNoMore: null, // 显示无更多数据的回调
    hideUpScroll: null, // 隐藏上拉加载的回调
    errDistance: 60, // endErr的时候需往上滑动一段距离,使其往下滑动时再次触发onReachBottom,仅mescroll-body生效
    toTop: {
      // 回到顶部按钮,需配置src才显示
      src: null, // 图片路径,默认null (绝对路径或网络图)
      offset: 1000, // 列表滚动多少距离才显示回到顶部按钮,默认1000
      duration: 300, // 回到顶部的动画时长,默认300ms (当值为0或300则使用系统自带回到顶部,更流畅; 其他值则通过step模拟,部分机型可能不够流畅,所以非特殊情况不建议修改此项)
      btnClick: null, // 点击按钮的回调
      onShow: null, // 是否显示的回调
      zIndex: 9990, // fixed定位z-index值
      left: null, // 到左边的距离, 默认null. 此项有值时,right不生效. (支持20, "20rpx", "20px", "20%"格式的值, 其中纯数字则默认单位rpx)
      right: 20, // 到右边的距离, 默认20 (支持20, "20rpx", "20px", "20%"格式的值, 其中纯数字则默认单位rpx)
      bottom: 120, // 到底部的距离, 默认120 (支持20, "20rpx", "20px", "20%"格式的值, 其中纯数字则默认单位rpx)
      safearea: false, // bottom的偏移量是否加上底部安全区的距离, 默认false, 需要适配iPhoneX时使用 (具体的界面如果不配置此项,则取本vue的safearea值)
      width: 72, // 回到顶部图标的宽度, 默认72 (支持20, "20rpx", "20px", "20%"格式的值, 其中纯数字则默认单位rpx)
      radius: "50%" // 圆角, 默认"50%" (支持20, "20rpx", "20px", "20%"格式的值, 其中纯数字则默认单位rpx)
    },
    empty: {
      use: true, // 是否显示空布局
      icon: null, // 图标路径
      tip: '~ 暂无相关数据 ~', // 提示
      btnText: '', // 按钮
      btnClick: null, // 点击按钮的回调
      onShow: null, // 是否显示的回调
      fixed: false, // 是否使用fixed定位,默认false; 配置fixed为true,以下的top和zIndex才生效 (transform会使fixed失效,最终会降级为absolute)
      top: "100rpx", // fixed定位的top值 (完整的单位值,如 "10%"; "100rpx")
      zIndex: 99 // fixed定位z-index值
    },
    onScroll: false // 是否监听滚动事件
  });
};

/* 配置参数 */
MeScroll.extend = function (userOption, defaultOption) {
  if (!userOption) return defaultOption;
  for (var key in defaultOption) {
    if (userOption[key] == null) {
      var def = defaultOption[key];
      if (def != null && typeof def === 'object') {
        userOption[key] = MeScroll.extend({}, def); // 深度匹配
      } else {
        userOption[key] = def;
      }
    } else if (typeof userOption[key] === 'object') {
      MeScroll.extend(userOption[key], defaultOption[key]); // 深度匹配
    }
  }
  return userOption;
};

/* 简单判断是否配置了颜色 (非透明,非白色) */
MeScroll.prototype.hasColor = function (color) {
  if (!color) return false;
  var c = color.toLowerCase();
  return c != "#fff" && c != "#ffffff" && c != "transparent" && c != "white";
};

/* -------初始化下拉刷新------- */
MeScroll.prototype.initDownScroll = function () {
  var me = this;
  // 配置参数
  me.optDown = me.options.down || {};
  if (!me.optDown.textColor && me.hasColor(me.optDown.bgColor)) me.optDown.textColor = "#fff"; // 当bgColor有值且textColor未设置,则textColor默认白色
  me.extendDownScroll(me.optDown);

  // 如果是mescroll-body且配置了native,则禁止自定义的下拉刷新
  if (me.isScrollBody && me.optDown.native) {
    me.optDown.use = false;
  } else {
    me.optDown.native = false; // 仅mescroll-body支持,mescroll-uni不支持
  }

  me.downHight = 0; // 下拉区域的高度

  // 在页面中加入下拉布局
  if (me.optDown.use && me.optDown.inited) {
    // 初始化完毕的回调
    setTimeout(function () {// 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例
      me.optDown.inited(me);
    }, 0);
  }
};

/* 列表touchstart事件 */
MeScroll.prototype.touchstartEvent = function (e) {
  if (!this.optDown.use) return;

  this.startPoint = this.getPoint(e); // 记录起点
  this.startTop = this.getScrollTop(); // 记录此时的滚动条位置
  this.lastPoint = this.startPoint; // 重置上次move的点
  this.maxTouchmoveY = this.getBodyHeight() - this.optDown.bottomOffset; // 手指触摸的最大范围(写在touchstart避免body获取高度为0的情况)
  this.inTouchend = false; // 标记不是touchend
};

/* 列表touchmove事件 */
MeScroll.prototype.touchmoveEvent = function (e) {




  if (!this.optDown.use) return;
  if (!this.startPoint) return;
  var me = this;

  // 节流
  var t = new Date().getTime();
  if (me.moveTime && t - me.moveTime < me.moveTimeDiff) {// 小于节流时间,则不处理
    return;
  } else {
    me.moveTime = t;
    if (!me.moveTimeDiff) me.moveTimeDiff = 1000 / me.optDown.fps;
  }

  var scrollTop = me.getScrollTop(); // 当前滚动条的距离
  var curPoint = me.getPoint(e); // 当前点

  var moveY = curPoint.y - me.startPoint.y; // 和起点比,移动的距离,大于0向下拉,小于0向上拉

  // 向下拉 && 在顶部
  // mescroll-body,直接判定在顶部即可
  // scroll-view在滚动时不会触发touchmove,当触顶/底/左/右时,才会触发touchmove
  // scroll-view滚动到顶部时,scrollTop不一定为0; 在iOS的APP中scrollTop可能为负数,不一定和startTop相等
  if (moveY > 0 && (
  me.isScrollBody && scrollTop <= 0 ||

  !me.isScrollBody && (scrollTop <= 0 || scrollTop <= me.optDown.startTop && scrollTop === me.startTop)))
  {
    // 可下拉的条件
    if (!me.inTouchend && !me.isDownScrolling && !me.optDown.isLock && (!me.isUpScrolling || me.isUpScrolling &&
    me.optUp.isBoth)) {

      // 下拉的角度是否在配置的范围内
      var angle = me.getAngle(me.lastPoint, curPoint); // 两点之间的角度,区间 [0,90]
      if (angle < me.optDown.minAngle) return; // 如果小于配置的角度,则不往下执行下拉刷新

      // 如果手指的位置超过配置的距离,则提前结束下拉,避免Webview嵌套导致touchend无法触发
      if (me.maxTouchmoveY > 0 && curPoint.y >= me.maxTouchmoveY) {
        me.inTouchend = true; // 标记执行touchend
        me.touchendEvent(); // 提前触发touchend
        return;
      }




      me.preventDefault(e); // 阻止默认事件

      var diff = curPoint.y - me.lastPoint.y; // 和上次比,移动的距离 (大于0向下,小于0向上)

      // 下拉距离  < 指定距离
      if (me.downHight < me.optDown.offset) {
        if (me.movetype !== 1) {
          me.movetype = 1; // 加入标记,保证只执行一次
          me.optDown.inOffset && me.optDown.inOffset(me); // 进入指定距离范围内那一刻的回调,只执行一次
          me.isMoveDown = true; // 标记下拉区域高度改变,在touchend重置回来
        }
        me.downHight += diff * me.optDown.inOffsetRate; // 越往下,高度变化越小

        // 指定距离  <= 下拉距离
      } else {
        if (me.movetype !== 2) {
          me.movetype = 2; // 加入标记,保证只执行一次
          me.optDown.outOffset && me.optDown.outOffset(me); // 下拉超过指定距离那一刻的回调,只执行一次
          me.isMoveDown = true; // 标记下拉区域高度改变,在touchend重置回来
        }
        if (diff > 0) {// 向下拉
          me.downHight += Math.round(diff * me.optDown.outOffsetRate); // 越往下,高度变化越小
        } else {// 向上收
          me.downHight += diff; // 向上收回高度,则向上滑多少收多少高度
        }
      }

      var rate = me.downHight / me.optDown.offset; // 下拉区域当前高度与指定距离的比值
      me.optDown.onMoving && me.optDown.onMoving(me, rate, me.downHight); // 下拉过程中的回调,一直在执行
    }
  }

  me.lastPoint = curPoint; // 记录本次移动的点
};

/* 列表touchend事件 */
MeScroll.prototype.touchendEvent = function (e) {
  if (!this.optDown.use) return;
  // 如果下拉区域高度已改变,则需重置回来
  if (this.isMoveDown) {
    if (this.downHight >= this.optDown.offset) {
      // 符合触发刷新的条件
      this.triggerDownScroll();
    } else {
      // 不符合的话 则重置
      this.downHight = 0;
      this.optDown.endDownScroll && this.optDown.endDownScroll(this);
    }
    this.movetype = 0;
    this.isMoveDown = false;
  } else if (!this.isScrollBody && this.getScrollTop() === this.startTop) {// scroll-view到顶/左/右/底的滑动事件
    var isScrollUp = this.getPoint(e).y - this.startPoint.y < 0; // 和起点比,移动的距离,大于0向下拉,小于0向上拉
    // 上滑
    if (isScrollUp) {
      // 需检查滑动的角度
      var angle = this.getAngle(this.getPoint(e), this.startPoint); // 两点之间的角度,区间 [0,90]
      if (angle > 80) {
        // 检查并触发上拉
        this.triggerUpScroll(true);
      }
    }
  }
};

/* 根据点击滑动事件获取第一个手指的坐标 */
MeScroll.prototype.getPoint = function (e) {
  if (!e) {
    return {
      x: 0,
      y: 0 };

  }
  if (e.touches && e.touches[0]) {
    return {
      x: e.touches[0].pageX,
      y: e.touches[0].pageY };

  } else if (e.changedTouches && e.changedTouches[0]) {
    return {
      x: e.changedTouches[0].pageX,
      y: e.changedTouches[0].pageY };

  } else {
    return {
      x: e.clientX,
      y: e.clientY };

  }
};

/* 计算两点之间的角度: 区间 [0,90]*/
MeScroll.prototype.getAngle = function (p1, p2) {
  var x = Math.abs(p1.x - p2.x);
  var y = Math.abs(p1.y - p2.y);
  var z = Math.sqrt(x * x + y * y);
  var angle = 0;
  if (z !== 0) {
    angle = Math.asin(y / z) / Math.PI * 180;
  }
  return angle;
};

/* 触发下拉刷新 */
MeScroll.prototype.triggerDownScroll = function () {
  if (this.optDown.beforeLoading && this.optDown.beforeLoading(this)) {
    //return true则处于完全自定义状态
  } else {
    this.showDownScroll(); // 下拉刷新中...
    this.optDown.callback && this.optDown.callback(this); // 执行回调,联网加载数据
  }
};

/* 显示下拉进度布局 */
MeScroll.prototype.showDownScroll = function () {
  this.isDownScrolling = true; // 标记下拉中
  if (this.optDown.native) {
    uni.startPullDownRefresh(); // 系统自带的下拉刷新
    this.optDown.showLoading && this.optDown.showLoading(this, 0); // 仍触发showLoading,因为上拉加载用到
  } else {
    this.downHight = this.optDown.offset; // 更新下拉区域高度
    this.optDown.showLoading && this.optDown.showLoading(this, this.downHight); // 下拉刷新中...
  }
};

/* 显示系统自带的下拉刷新时需要处理的业务 */
MeScroll.prototype.onPullDownRefresh = function () {
  this.isDownScrolling = true; // 标记下拉中
  this.optDown.showLoading && this.optDown.showLoading(this, 0); // 仍触发showLoading,因为上拉加载用到
  this.optDown.callback && this.optDown.callback(this); // 执行回调,联网加载数据
};

/* 结束下拉刷新 */
MeScroll.prototype.endDownScroll = function () {
  if (this.optDown.native) {// 结束原生下拉刷新
    this.isDownScrolling = false;
    this.optDown.endDownScroll && this.optDown.endDownScroll(this);
    uni.stopPullDownRefresh();
    return;
  }
  var me = this;
  // 结束下拉刷新的方法
  var endScroll = function endScroll() {
    me.downHight = 0;
    me.isDownScrolling = false;
    me.optDown.endDownScroll && me.optDown.endDownScroll(me);
    !me.isScrollBody && me.setScrollHeight(0); // scroll-view重置滚动区域,使数据不满屏时仍可检查触发翻页
  };
  // 结束下拉刷新时的回调
  var delay = 0;
  if (me.optDown.afterLoading) delay = me.optDown.afterLoading(me); // 结束下拉刷新的延时,单位ms
  if (typeof delay === 'number' && delay > 0) {
    setTimeout(endScroll, delay);
  } else {
    endScroll();
  }
};

/* 锁定下拉刷新:isLock=ture,null锁定;isLock=false解锁 */
MeScroll.prototype.lockDownScroll = function (isLock) {
  if (isLock == null) isLock = true;
  this.optDown.isLock = isLock;
};

/* 锁定上拉加载:isLock=ture,null锁定;isLock=false解锁 */
MeScroll.prototype.lockUpScroll = function (isLock) {
  if (isLock == null) isLock = true;
  this.optUp.isLock = isLock;
};

/* -------初始化上拉加载------- */
MeScroll.prototype.initUpScroll = function () {
  var me = this;
  // 配置参数
  me.optUp = me.options.up || { use: false };
  if (!me.optUp.textColor && me.hasColor(me.optUp.bgColor)) me.optUp.textColor = "#fff"; // 当bgColor有值且textColor未设置,则textColor默认白色
  me.extendUpScroll(me.optUp);

  if (!me.optUp.isBounce) me.setBounce(false); // 不允许bounce时,需禁止window的touchmove事件

  if (me.optUp.use === false) return; // 配置不使用上拉加载时,则不初始化上拉布局
  me.optUp.hasNext = true; // 如果使用上拉,则默认有下一页
  me.startNum = me.optUp.page.num + 1; // 记录page开始的页码

  // 初始化完毕的回调
  if (me.optUp.inited) {
    setTimeout(function () {// 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例
      me.optUp.inited(me);
    }, 0);
  }
};

/*滚动到底部的事件 (仅mescroll-body生效)*/
MeScroll.prototype.onReachBottom = function () {
  if (this.isScrollBody && !this.isUpScrolling) {// 只能支持下拉刷新的时候同时可以触发上拉加载,否则滚动到底部就需要上滑一点才能触发onReachBottom
    if (!this.optUp.isLock && this.optUp.hasNext) {
      this.triggerUpScroll();
    }
  }
};

/*列表滚动事件 (仅mescroll-body生效)*/
MeScroll.prototype.onPageScroll = function (e) {
  if (!this.isScrollBody) return;

  // 更新滚动条的位置 (主要用于判断下拉刷新时,滚动条是否在顶部)
  this.setScrollTop(e.scrollTop);

  // 顶部按钮的显示隐藏
  if (e.scrollTop >= this.optUp.toTop.offset) {
    this.showTopBtn();
  } else {
    this.hideTopBtn();
  }
};

/*列表滚动事件*/
MeScroll.prototype.scroll = function (e, onScroll) {
  // 更新滚动条的位置
  this.setScrollTop(e.scrollTop);
  // 更新滚动内容高度
  this.setScrollHeight(e.scrollHeight);

  // 向上滑还是向下滑动
  if (this.preScrollY == null) this.preScrollY = 0;
  this.isScrollUp = e.scrollTop - this.preScrollY > 0;
  this.preScrollY = e.scrollTop;

  // 上滑 && 检查并触发上拉
  this.isScrollUp && this.triggerUpScroll(true);

  // 顶部按钮的显示隐藏
  if (e.scrollTop >= this.optUp.toTop.offset) {
    this.showTopBtn();
  } else {
    this.hideTopBtn();
  }

  // 滑动监听
  this.optUp.onScroll && onScroll && onScroll();
};

/* 触发上拉加载 */
MeScroll.prototype.triggerUpScroll = function (isCheck) {
  if (!this.isUpScrolling && this.optUp.use && this.optUp.callback) {
    // 是否校验在底部; 默认不校验
    if (isCheck === true) {
      var canUp = false;
      // 还有下一页 && 没有锁定 && 不在下拉中
      if (this.optUp.hasNext && !this.optUp.isLock && !this.isDownScrolling) {
        if (this.getScrollBottom() <= this.optUp.offset) {// 到底部
          canUp = true; // 标记可上拉
        }
      }
      if (canUp === false) return;
    }
    this.showUpScroll(); // 上拉加载中...
    this.optUp.page.num++; // 预先加一页,如果失败则减回
    this.isUpAutoLoad = true; // 标记上拉已经自动执行过,避免初始化时多次触发上拉回调
    this.num = this.optUp.page.num; // 把最新的页数赋值在mescroll上,避免对page的影响
    this.size = this.optUp.page.size; // 把最新的页码赋值在mescroll上,避免对page的影响
    this.time = this.optUp.page.time; // 把最新的页码赋值在mescroll上,避免对page的影响
    this.optUp.callback(this); // 执行回调,联网加载数据
  }
};

/* 显示上拉加载中 */
MeScroll.prototype.showUpScroll = function () {
  this.isUpScrolling = true; // 标记上拉加载中
  this.optUp.showLoading && this.optUp.showLoading(this); // 回调
};

/* 显示上拉无更多数据 */
MeScroll.prototype.showNoMore = function () {
  this.optUp.hasNext = false; // 标记无更多数据
  this.optUp.showNoMore && this.optUp.showNoMore(this); // 回调
};

/* 隐藏上拉区域**/
MeScroll.prototype.hideUpScroll = function () {
  this.optUp.hideUpScroll && this.optUp.hideUpScroll(this); // 回调
};

/* 结束上拉加载 */
MeScroll.prototype.endUpScroll = function (isShowNoMore) {
  if (isShowNoMore != null) {// isShowNoMore=null,不处理下拉状态,下拉刷新的时候调用
    if (isShowNoMore) {
      this.showNoMore(); // isShowNoMore=true,显示无更多数据
    } else {
      this.hideUpScroll(); // isShowNoMore=false,隐藏上拉加载
    }
  }
  this.isUpScrolling = false; // 标记结束上拉加载
};

/* 重置上拉加载列表为第一页
    *isShowLoading 是否显示进度布局;
    * 1.默认null,不传参,则显示上拉加载的进度布局
    * 2.传参true, 则显示下拉刷新的进度布局
    * 3.传参false,则不显示上拉和下拉的进度 (常用于静默更新列表数据)
    */
MeScroll.prototype.resetUpScroll = function (isShowLoading) {
  if (this.optUp && this.optUp.use) {
    var page = this.optUp.page;
    this.prePageNum = page.num; // 缓存重置前的页码,加载失败可退回
    this.prePageTime = page.time; // 缓存重置前的时间,加载失败可退回
    page.num = this.startNum; // 重置为第一页
    page.time = null; // 重置时间为空
    if (!this.isDownScrolling && isShowLoading !== false) {// 如果不是下拉刷新触发的resetUpScroll并且不配置列表静默更新,则显示进度;
      if (isShowLoading == null) {
        this.removeEmpty(); // 移除空布局
        this.showUpScroll(); // 不传参,默认显示上拉加载的进度布局
      } else {
        this.showDownScroll(); // 传true,显示下拉刷新的进度布局,不清空列表
      }
    }
    this.isUpAutoLoad = true; // 标记上拉已经自动执行过,避免初始化时多次触发上拉回调
    this.num = page.num; // 把最新的页数赋值在mescroll上,避免对page的影响
    this.size = page.size; // 把最新的页码赋值在mescroll上,避免对page的影响
    this.time = page.time; // 把最新的页码赋值在mescroll上,避免对page的影响
    this.optUp.callback && this.optUp.callback(this); // 执行上拉回调
  }
};

/* 设置page.num的值 */
MeScroll.prototype.setPageNum = function (num) {
  this.optUp.page.num = num - 1;
};

/* 设置page.size的值 */
MeScroll.prototype.setPageSize = function (size) {
  this.optUp.page.size = size;
};

/* 联网回调成功,结束下拉刷新和上拉加载
    * dataSize: 当前页的数据量(必传)
    * totalPage: 总页数(必传)
    * systime: 服务器时间 (可空)
    */
MeScroll.prototype.endByPage = function (dataSize, totalPage, systime) {
  var hasNext;
  if (this.optUp.use && totalPage != null) hasNext = this.optUp.page.num < totalPage; // 是否还有下一页
  this.endSuccess(dataSize, hasNext, systime);
};

/* 联网回调成功,结束下拉刷新和上拉加载
    * dataSize: 当前页的数据量(必传)
    * totalSize: 列表所有数据总数量(必传)
    * systime: 服务器时间 (可空)
    */
MeScroll.prototype.endBySize = function (dataSize, totalSize, systime) {
  var hasNext;
  if (this.optUp.use && totalSize != null) {
    var loadSize = (this.optUp.page.num - 1) * this.optUp.page.size + dataSize; // 已加载的数据总数
    hasNext = loadSize < totalSize; // 是否还有下一页
  }
  this.endSuccess(dataSize, hasNext, systime);
};

/* 联网回调成功,结束下拉刷新和上拉加载
    * dataSize: 当前页的数据个数(不是所有页的数据总和),用于上拉加载判断是否还有下一页.如果不传,则会判断还有下一页
    * hasNext: 是否还有下一页,布尔类型;用来解决这个小问题:比如列表共有20条数据,每页加载10条,共2页.如果只根据dataSize判断,则需翻到第三页才会知道无更多数据,如果传了hasNext,则翻到第二页即可显示无更多数据.
    * systime: 服务器时间(可空);用来解决这个小问题:当准备翻下一页时,数据库新增了几条记录,此时翻下一页,前面的几条数据会和上一页的重复;这里传入了systime,那么upCallback的page.time就会有值,把page.time传给服务器,让后台过滤新加入的那几条记录
    */
MeScroll.prototype.endSuccess = function (dataSize, hasNext, systime) {
  var me = this;
  // 结束下拉刷新
  if (me.isDownScrolling) me.endDownScroll();

  // 结束上拉加载
  if (me.optUp.use) {
    var isShowNoMore; // 是否已无更多数据
    if (dataSize != null) {
      var pageNum = me.optUp.page.num; // 当前页码
      var pageSize = me.optUp.page.size; // 每页长度
      // 如果是第一页
      if (pageNum === 1) {
        if (systime) me.optUp.page.time = systime; // 设置加载列表数据第一页的时间
      }
      if (dataSize < pageSize || hasNext === false) {
        // 返回的数据不满一页时,则说明已无更多数据
        me.optUp.hasNext = false;
        if (dataSize === 0 && pageNum === 1) {
          // 如果第一页无任何数据且配置了空布局
          isShowNoMore = false;
          me.showEmpty();
        } else {
          // 总列表数少于配置的数量,则不显示无更多数据
          var allDataSize = (pageNum - 1) * pageSize + dataSize;
          if (allDataSize < me.optUp.noMoreSize) {
            isShowNoMore = false;
          } else {
            isShowNoMore = true;
          }
          me.removeEmpty(); // 移除空布局
        }
      } else {
        // 还有下一页
        isShowNoMore = false;
        me.optUp.hasNext = true;
        me.removeEmpty(); // 移除空布局
      }
    }

    // 隐藏上拉
    me.endUpScroll(isShowNoMore);
  }
};

/* 回调失败,结束下拉刷新和上拉加载 */
MeScroll.prototype.endErr = function (errDistance) {
  // 结束下拉,回调失败重置回原来的页码和时间
  if (this.isDownScrolling) {
    var page = this.optUp.page;
    if (page && this.prePageNum) {
      page.num = this.prePageNum;
      page.time = this.prePageTime;
    }
    this.endDownScroll();
  }
  // 结束上拉,回调失败重置回原来的页码
  if (this.isUpScrolling) {
    this.optUp.page.num--;
    this.endUpScroll(false);
    // 如果是mescroll-body,则需往回滚一定距离
    if (this.isScrollBody && errDistance !== 0) {// 不处理0
      if (!errDistance) errDistance = this.optUp.errDistance; // 不传,则取默认
      this.scrollTo(this.getScrollTop() - errDistance, 0); // 往上回滚的距离
    }
  }
};

/* 显示空布局 */
MeScroll.prototype.showEmpty = function () {
  this.optUp.empty.use && this.optUp.empty.onShow && this.optUp.empty.onShow(true);
};

/* 移除空布局 */
MeScroll.prototype.removeEmpty = function () {
  this.optUp.empty.use && this.optUp.empty.onShow && this.optUp.empty.onShow(false);
};

/* 显示回到顶部的按钮 */
MeScroll.prototype.showTopBtn = function () {
  if (!this.topBtnShow) {
    this.topBtnShow = true;
    this.optUp.toTop.onShow && this.optUp.toTop.onShow(true);
  }
};

/* 隐藏回到顶部的按钮 */
MeScroll.prototype.hideTopBtn = function () {
  if (this.topBtnShow) {
    this.topBtnShow = false;
    this.optUp.toTop.onShow && this.optUp.toTop.onShow(false);
  }
};

/* 获取滚动条的位置 */
MeScroll.prototype.getScrollTop = function () {
  return this.scrollTop || 0;
};

/* 记录滚动条的位置 */
MeScroll.prototype.setScrollTop = function (y) {
  this.scrollTop = y;
};

/* 滚动到指定位置 */
MeScroll.prototype.scrollTo = function (y, t) {
  this.myScrollTo && this.myScrollTo(y, t); // scrollview需自定义回到顶部方法
};

/* 自定义scrollTo */
MeScroll.prototype.resetScrollTo = function (myScrollTo) {
  this.myScrollTo = myScrollTo;
};

/* 滚动条到底部的距离 */
MeScroll.prototype.getScrollBottom = function () {
  return this.getScrollHeight() - this.getClientHeight() - this.getScrollTop();
};

/* 计步器
    star: 开始值
    end: 结束值
    callback(step,timer): 回调step值,计步器timer,可自行通过window.clearInterval(timer)结束计步器;
    t: 计步时长,传0则直接回调end值;不传则默认300ms
    rate: 周期;不传则默认30ms计步一次
    * */
MeScroll.prototype.getStep = function (star, end, callback, t, rate) {
  var diff = end - star; // 差值
  if (t === 0 || diff === 0) {
    callback && callback(end);
    return;
  }
  t = t || 300; // 时长 300ms
  rate = rate || 30; // 周期 30ms
  var count = t / rate; // 次数
  var step = diff / count; // 步长
  var i = 0; // 计数
  var timer = setInterval(function () {
    if (i < count - 1) {
      star += step;
      callback && callback(star, timer);
      i++;
    } else {
      callback && callback(end, timer); // 最后一次直接设置end,避免计算误差
      clearInterval(timer);
    }
  }, rate);
};

/* 滚动容器的高度 */
MeScroll.prototype.getClientHeight = function (isReal) {
  var h = this.clientHeight || 0;
  if (h === 0 && isReal !== true) {// 未获取到容器的高度,可临时取body的高度 (可能会有误差)
    h = this.getBodyHeight();
  }
  return h;
};
MeScroll.prototype.setClientHeight = function (h) {
  this.clientHeight = h;
};

/* 滚动内容的高度 */
MeScroll.prototype.getScrollHeight = function () {
  return this.scrollHeight || 0;
};
MeScroll.prototype.setScrollHeight = function (h) {
  this.scrollHeight = h;
};

/* body的高度 */
MeScroll.prototype.getBodyHeight = function () {
  return this.bodyHeight || 0;
};
MeScroll.prototype.setBodyHeight = function (h) {
  this.bodyHeight = h;
};

/* 阻止浏览器默认滚动事件 */
MeScroll.prototype.preventDefault = function (e) {
  // 小程序不支持e.preventDefault
  // app的bounce只能通过配置pages.json的style.app-plus.bounce为"none"来禁止
  // cancelable:是否可以被禁用; defaultPrevented:是否已经被禁用
  if (e && e.cancelable && !e.defaultPrevented) e.preventDefault();
};

/* 是否允许下拉回弹(橡皮筋效果); true或null为允许; false禁止bounce */
MeScroll.prototype.setBounce = function (isBounce) {




































































};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["default"]))

/***/ }),
/* 244 */
/*!*****************************************************************************!*\
  !*** I:/out-project/FCoinEx/components/mescroll-uni/mescroll-uni-option.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0; // 全局配置
// mescroll-body 和 mescroll-uni 通用
var GlobalOption = {
  down: {
    // 其他down的配置参数也可以写,这里只展示了常用的配置:
    textInOffset: '下拉刷新', // 下拉的距离在offset范围内的提示文本
    textOutOffset: '释放更新', // 下拉的距离大于offset范围的提示文本
    textLoading: '加载中 ...', // 加载中的提示文本
    offset: 80, // 在列表顶部,下拉大于80px,松手即可触发下拉刷新的回调
    native: false // 是否使用系统自带的下拉刷新; 默认false; 仅在mescroll-body生效 (值为true时,还需在pages配置enablePullDownRefresh:true;详请参考mescroll-native的案例)
  },
  up: {
    // 其他up的配置参数也可以写,这里只展示了常用的配置:
    textLoading: '加载中 ...', // 加载中的提示文本
    textNoMore: '---- 我是有底线的 ----', // 没有更多数据的提示文本
    offset: 80, // 距底部多远时,触发upCallback
    isBounce: false, // 默认禁止橡皮筋的回弹效果, 必读事项: http://www.mescroll.com/qa.html?v=190725#q25
    toTop: {
      // 回到顶部按钮,需配置src才显示
      src: "http://www.mescroll.com/img/mescroll-totop.png?v=1", // 图片路径 (建议放入static目录, 如 /static/img/mescroll-totop.png )
      offset: 1000, // 列表滚动多少距离才显示回到顶部按钮,默认1000px
      right: 20, // 到右边的距离, 默认20 (支持"20rpx", "20px", "20%"格式的值, 纯数字则默认单位rpx)
      bottom: 120, // 到底部的距离, 默认120 (支持"20rpx", "20px", "20%"格式的值, 纯数字则默认单位rpx)
      width: 72 // 回到顶部图标的宽度, 默认72 (支持"20rpx", "20px", "20%"格式的值, 纯数字则默认单位rpx)
    },
    empty: {
      use: true, // 是否显示空布局
      icon: "http://www.mescroll.com/img/mescroll-empty.png?v=1", // 图标路径 (建议放入static目录, 如 /static/img/mescroll-empty.png )
      tip: '~ 暂无相关数据 ~' // 提示
    } } };var _default =



GlobalOption;exports.default = _default;

/***/ }),
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */
/*!***********************************************************************************!*\
  !*** I:/out-project/FCoinEx/node_modules/@dcloudio/uni-ui/lib/uni-icons/icons.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _default = {
  "pulldown": "\uE588",
  "refreshempty": "\uE461",
  "back": "\uE471",
  "forward": "\uE470",
  "more": "\uE507",
  "more-filled": "\uE537",
  "scan": "\uE612",
  "qq": "\uE264",
  "weibo": "\uE260",
  "weixin": "\uE261",
  "pengyouquan": "\uE262",
  "loop": "\uE565",
  "refresh": "\uE407",
  "refresh-filled": "\uE437",
  "arrowthindown": "\uE585",
  "arrowthinleft": "\uE586",
  "arrowthinright": "\uE587",
  "arrowthinup": "\uE584",
  "undo-filled": "\uE7D6",
  "undo": "\uE406",
  "redo": "\uE405",
  "redo-filled": "\uE7D9",
  "bars": "\uE563",
  "chatboxes": "\uE203",
  "camera": "\uE301",
  "chatboxes-filled": "\uE233",
  "camera-filled": "\uE7EF",
  "cart-filled": "\uE7F4",
  "cart": "\uE7F5",
  "checkbox-filled": "\uE442",
  "checkbox": "\uE7FA",
  "arrowleft": "\uE582",
  "arrowdown": "\uE581",
  "arrowright": "\uE583",
  "smallcircle-filled": "\uE801",
  "arrowup": "\uE580",
  "circle": "\uE411",
  "eye-filled": "\uE568",
  "eye-slash-filled": "\uE822",
  "eye-slash": "\uE823",
  "eye": "\uE824",
  "flag-filled": "\uE825",
  "flag": "\uE508",
  "gear-filled": "\uE532",
  "reload": "\uE462",
  "gear": "\uE502",
  "hand-thumbsdown-filled": "\uE83B",
  "hand-thumbsdown": "\uE83C",
  "hand-thumbsup-filled": "\uE83D",
  "heart-filled": "\uE83E",
  "hand-thumbsup": "\uE83F",
  "heart": "\uE840",
  "home": "\uE500",
  "info": "\uE504",
  "home-filled": "\uE530",
  "info-filled": "\uE534",
  "circle-filled": "\uE441",
  "chat-filled": "\uE847",
  "chat": "\uE263",
  "mail-open-filled": "\uE84D",
  "email-filled": "\uE231",
  "mail-open": "\uE84E",
  "email": "\uE201",
  "checkmarkempty": "\uE472",
  "list": "\uE562",
  "locked-filled": "\uE856",
  "locked": "\uE506",
  "map-filled": "\uE85C",
  "map-pin": "\uE85E",
  "map-pin-ellipse": "\uE864",
  "map": "\uE364",
  "minus-filled": "\uE440",
  "mic-filled": "\uE332",
  "minus": "\uE410",
  "micoff": "\uE360",
  "mic": "\uE302",
  "clear": "\uE434",
  "smallcircle": "\uE868",
  "close": "\uE404",
  "closeempty": "\uE460",
  "paperclip": "\uE567",
  "paperplane": "\uE503",
  "paperplane-filled": "\uE86E",
  "person-filled": "\uE131",
  "contact-filled": "\uE130",
  "person": "\uE101",
  "contact": "\uE100",
  "images-filled": "\uE87A",
  "phone": "\uE200",
  "images": "\uE87B",
  "image": "\uE363",
  "image-filled": "\uE877",
  "location-filled": "\uE333",
  "location": "\uE303",
  "plus-filled": "\uE439",
  "plus": "\uE409",
  "plusempty": "\uE468",
  "help-filled": "\uE535",
  "help": "\uE505",
  "navigate-filled": "\uE884",
  "navigate": "\uE501",
  "mic-slash-filled": "\uE892",
  "search": "\uE466",
  "settings": "\uE560",
  "sound": "\uE590",
  "sound-filled": "\uE8A1",
  "spinner-cycle": "\uE465",
  "download-filled": "\uE8A4",
  "personadd-filled": "\uE132",
  "videocam-filled": "\uE8AF",
  "personadd": "\uE102",
  "upload": "\uE402",
  "upload-filled": "\uE8B1",
  "starhalf": "\uE463",
  "star-filled": "\uE438",
  "star": "\uE408",
  "trash": "\uE401",
  "phone-filled": "\uE230",
  "compose": "\uE400",
  "videocam": "\uE300",
  "trash-filled": "\uE8DC",
  "download": "\uE403",
  "chatbubble-filled": "\uE232",
  "chatbubble": "\uE202",
  "cloud-download": "\uE8E4",
  "cloud-upload-filled": "\uE8E5",
  "cloud-upload": "\uE8E6",
  "cloud-download-filled": "\uE8E9",
  "headphones": "\uE8BF",
  "shop": "\uE609" };exports.default = _default;

/***/ }),
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */
/*!**************************************************************************!*\
  !*** I:/out-project/FCoinEx/components/SJ-LotteryDraw/SJ-LotteryDraw.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


function LotteryDraw(obj, callback) {
  this.timer = null; //计时器
  this.startIndex = obj.startIndex - 1 || 0; //从第几个位置开始抽奖 [默认为零]
  this.count = 0; //计数，跑的圈数
  this.winingIndex = obj.winingIndex || 0; //获奖的位置
  this.totalCount = obj.totalCount || 6; //抽奖跑的圈数
  this.speed = obj.speed || 100;
  this.domData = obj.domData;
  this.rollFn();
  this.callback = callback;
}

LotteryDraw.prototype = {
  rollFn: function rollFn() {
    var that = this;
    // 活动index值增加，即移动到下一个格子
    this.startIndex++;

    //startIndex是最后一个时一圈走完，重新开始
    if (this.startIndex >= this.domData.length) {
      this.startIndex = 0;
      this.count++;
    }

    // 当跑的圈数等于设置的圈数，且活动的index值是奖品的位置时停止
    if (this.count >= this.totalCount && this.startIndex === this.winingIndex) {
      if (typeof this.callback === 'function') {
        setTimeout(function () {
          that.callback(that.startIndex, that.count); //执行回调函数，抽奖完成的相关操作
        }, 400);
      }
      clearInterval(this.timer);
    } else {//重新开始一圈
      if (this.count >= this.totalCount) {
        this.speed += 30;
      }
      this.timer = setTimeout(function () {
        that.callback(that.startIndex, that.count);
        that.rollFn();
      }, this.speed);
    }
  } };


module.exports = LotteryDraw;

/***/ }),
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */
/*!**************************************************************!*\
  !*** I:/out-project/FCoinEx/components/tki-qrcode/qrcode.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(uni) {Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var QRCode = {};
(function () {
  /**
               * 获取单个字符的utf8编码
               * unicode BMP平面约65535个字符
               * @param {num} code
               * return {array}
               */
  function unicodeFormat8(code) {
    // 1 byte
    var c0, c1, c2;
    if (code < 128) {
      return [code];
      // 2 bytes
    } else if (code < 2048) {
      c0 = 192 + (code >> 6);
      c1 = 128 + (code & 63);
      return [c0, c1];
      // 3 bytes
    } else {
      c0 = 224 + (code >> 12);
      c1 = 128 + (code >> 6 & 63);
      c2 = 128 + (code & 63);
      return [c0, c1, c2];
    }
  }
  /**
     * 获取字符串的utf8编码字节串
     * @param {string} string
     * @return {array}
     */
  function getUTF8Bytes(string) {
    var utf8codes = [];
    for (var i = 0; i < string.length; i++) {
      var code = string.charCodeAt(i);
      var utf8 = unicodeFormat8(code);
      for (var j = 0; j < utf8.length; j++) {
        utf8codes.push(utf8[j]);
      }
    }
    return utf8codes;
  }
  /**
     * 二维码算法实现
     * @param {string} data              要编码的信息字符串
     * @param {num} errorCorrectLevel 纠错等级
     */
  function QRCodeAlg(data, errorCorrectLevel) {
    this.typeNumber = -1; //版本
    this.errorCorrectLevel = errorCorrectLevel;
    this.modules = null; //二维矩阵，存放最终结果
    this.moduleCount = 0; //矩阵大小
    this.dataCache = null; //数据缓存
    this.rsBlocks = null; //版本数据信息
    this.totalDataCount = -1; //可使用的数据量
    this.data = data;
    this.utf8bytes = getUTF8Bytes(data);
    this.make();
  }
  QRCodeAlg.prototype = {
    constructor: QRCodeAlg,
    /**
                             * 获取二维码矩阵大小
                             * @return {num} 矩阵大小
                             */
    getModuleCount: function getModuleCount() {
      return this.moduleCount;
    },
    /**
        * 编码
        */
    make: function make() {
      this.getRightType();
      this.dataCache = this.createData();
      this.createQrcode();
    },
    /**
        * 设置二位矩阵功能图形
        * @param  {bool} test 表示是否在寻找最好掩膜阶段
        * @param  {num} maskPattern 掩膜的版本
        */
    makeImpl: function makeImpl(maskPattern) {
      this.moduleCount = this.typeNumber * 4 + 17;
      this.modules = new Array(this.moduleCount);
      for (var row = 0; row < this.moduleCount; row++) {
        this.modules[row] = new Array(this.moduleCount);
      }
      this.setupPositionProbePattern(0, 0);
      this.setupPositionProbePattern(this.moduleCount - 7, 0);
      this.setupPositionProbePattern(0, this.moduleCount - 7);
      this.setupPositionAdjustPattern();
      this.setupTimingPattern();
      this.setupTypeInfo(true, maskPattern);
      if (this.typeNumber >= 7) {
        this.setupTypeNumber(true);
      }
      this.mapData(this.dataCache, maskPattern);
    },
    /**
        * 设置二维码的位置探测图形
        * @param  {num} row 探测图形的中心横坐标
        * @param  {num} col 探测图形的中心纵坐标
        */
    setupPositionProbePattern: function setupPositionProbePattern(row, col) {
      for (var r = -1; r <= 7; r++) {
        if (row + r <= -1 || this.moduleCount <= row + r) continue;
        for (var c = -1; c <= 7; c++) {
          if (col + c <= -1 || this.moduleCount <= col + c) continue;
          if (0 <= r && r <= 6 && (c == 0 || c == 6) || 0 <= c && c <= 6 && (r == 0 || r == 6) || 2 <= r && r <= 4 && 2 <= c && c <= 4) {
            this.modules[row + r][col + c] = true;
          } else {
            this.modules[row + r][col + c] = false;
          }
        }
      }
    },
    /**
        * 创建二维码
        * @return {[type]} [description]
        */
    createQrcode: function createQrcode() {
      var minLostPoint = 0;
      var pattern = 0;
      var bestModules = null;
      for (var i = 0; i < 8; i++) {
        this.makeImpl(i);
        var lostPoint = QRUtil.getLostPoint(this);
        if (i == 0 || minLostPoint > lostPoint) {
          minLostPoint = lostPoint;
          pattern = i;
          bestModules = this.modules;
        }
      }
      this.modules = bestModules;
      this.setupTypeInfo(false, pattern);
      if (this.typeNumber >= 7) {
        this.setupTypeNumber(false);
      }
    },
    /**
        * 设置定位图形
        * @return {[type]} [description]
        */
    setupTimingPattern: function setupTimingPattern() {
      for (var r = 8; r < this.moduleCount - 8; r++) {
        if (this.modules[r][6] != null) {
          continue;
        }
        this.modules[r][6] = r % 2 == 0;
        if (this.modules[6][r] != null) {
          continue;
        }
        this.modules[6][r] = r % 2 == 0;
      }
    },
    /**
        * 设置矫正图形
        * @return {[type]} [description]
        */
    setupPositionAdjustPattern: function setupPositionAdjustPattern() {
      var pos = QRUtil.getPatternPosition(this.typeNumber);
      for (var i = 0; i < pos.length; i++) {
        for (var j = 0; j < pos.length; j++) {
          var row = pos[i];
          var col = pos[j];
          if (this.modules[row][col] != null) {
            continue;
          }
          for (var r = -2; r <= 2; r++) {
            for (var c = -2; c <= 2; c++) {
              if (r == -2 || r == 2 || c == -2 || c == 2 || r == 0 && c == 0) {
                this.modules[row + r][col + c] = true;
              } else {
                this.modules[row + r][col + c] = false;
              }
            }
          }
        }
      }
    },
    /**
        * 设置版本信息（7以上版本才有）
        * @param  {bool} test 是否处于判断最佳掩膜阶段
        * @return {[type]}      [description]
        */
    setupTypeNumber: function setupTypeNumber(test) {
      var bits = QRUtil.getBCHTypeNumber(this.typeNumber);
      for (var i = 0; i < 18; i++) {
        var mod = !test && (bits >> i & 1) == 1;
        this.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = mod;
        this.modules[i % 3 + this.moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
      }
    },
    /**
        * 设置格式信息（纠错等级和掩膜版本）
        * @param  {bool} test
        * @param  {num} maskPattern 掩膜版本
        * @return {}
        */
    setupTypeInfo: function setupTypeInfo(test, maskPattern) {
      var data = QRErrorCorrectLevel[this.errorCorrectLevel] << 3 | maskPattern;
      var bits = QRUtil.getBCHTypeInfo(data);
      // vertical
      for (var i = 0; i < 15; i++) {
        var mod = !test && (bits >> i & 1) == 1;
        if (i < 6) {
          this.modules[i][8] = mod;
        } else if (i < 8) {
          this.modules[i + 1][8] = mod;
        } else {
          this.modules[this.moduleCount - 15 + i][8] = mod;
        }
        // horizontal
        var mod = !test && (bits >> i & 1) == 1;
        if (i < 8) {
          this.modules[8][this.moduleCount - i - 1] = mod;
        } else if (i < 9) {
          this.modules[8][15 - i - 1 + 1] = mod;
        } else {
          this.modules[8][15 - i - 1] = mod;
        }
      }
      // fixed module
      this.modules[this.moduleCount - 8][8] = !test;
    },
    /**
        * 数据编码
        * @return {[type]} [description]
        */
    createData: function createData() {
      var buffer = new QRBitBuffer();
      var lengthBits = this.typeNumber > 9 ? 16 : 8;
      buffer.put(4, 4); //添加模式
      buffer.put(this.utf8bytes.length, lengthBits);
      for (var i = 0, l = this.utf8bytes.length; i < l; i++) {
        buffer.put(this.utf8bytes[i], 8);
      }
      if (buffer.length + 4 <= this.totalDataCount * 8) {
        buffer.put(0, 4);
      }
      // padding
      while (buffer.length % 8 != 0) {
        buffer.putBit(false);
      }
      // padding
      while (true) {
        if (buffer.length >= this.totalDataCount * 8) {
          break;
        }
        buffer.put(QRCodeAlg.PAD0, 8);
        if (buffer.length >= this.totalDataCount * 8) {
          break;
        }
        buffer.put(QRCodeAlg.PAD1, 8);
      }
      return this.createBytes(buffer);
    },
    /**
        * 纠错码编码
        * @param  {buffer} buffer 数据编码
        * @return {[type]}
        */
    createBytes: function createBytes(buffer) {
      var offset = 0;
      var maxDcCount = 0;
      var maxEcCount = 0;
      var length = this.rsBlock.length / 3;
      var rsBlocks = new Array();
      for (var i = 0; i < length; i++) {
        var count = this.rsBlock[i * 3 + 0];
        var totalCount = this.rsBlock[i * 3 + 1];
        var dataCount = this.rsBlock[i * 3 + 2];
        for (var j = 0; j < count; j++) {
          rsBlocks.push([dataCount, totalCount]);
        }
      }
      var dcdata = new Array(rsBlocks.length);
      var ecdata = new Array(rsBlocks.length);
      for (var r = 0; r < rsBlocks.length; r++) {
        var dcCount = rsBlocks[r][0];
        var ecCount = rsBlocks[r][1] - dcCount;
        maxDcCount = Math.max(maxDcCount, dcCount);
        maxEcCount = Math.max(maxEcCount, ecCount);
        dcdata[r] = new Array(dcCount);
        for (var i = 0; i < dcdata[r].length; i++) {
          dcdata[r][i] = 0xff & buffer.buffer[i + offset];
        }
        offset += dcCount;
        var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
        var rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1);
        var modPoly = rawPoly.mod(rsPoly);
        ecdata[r] = new Array(rsPoly.getLength() - 1);
        for (var i = 0; i < ecdata[r].length; i++) {
          var modIndex = i + modPoly.getLength() - ecdata[r].length;
          ecdata[r][i] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
        }
      }
      var data = new Array(this.totalDataCount);
      var index = 0;
      for (var i = 0; i < maxDcCount; i++) {
        for (var r = 0; r < rsBlocks.length; r++) {
          if (i < dcdata[r].length) {
            data[index++] = dcdata[r][i];
          }
        }
      }
      for (var i = 0; i < maxEcCount; i++) {
        for (var r = 0; r < rsBlocks.length; r++) {
          if (i < ecdata[r].length) {
            data[index++] = ecdata[r][i];
          }
        }
      }
      return data;

    },
    /**
        * 布置模块，构建最终信息
        * @param  {} data
        * @param  {} maskPattern
        * @return {}
        */
    mapData: function mapData(data, maskPattern) {
      var inc = -1;
      var row = this.moduleCount - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      for (var col = this.moduleCount - 1; col > 0; col -= 2) {
        if (col == 6) col--;
        while (true) {
          for (var c = 0; c < 2; c++) {
            if (this.modules[row][col - c] == null) {
              var dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) == 1;
              }
              var mask = QRUtil.getMask(maskPattern, row, col - c);
              if (mask) {
                dark = !dark;
              }
              this.modules[row][col - c] = dark;
              bitIndex--;
              if (bitIndex == -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || this.moduleCount <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    } };

  /**
          * 填充字段
          */
  QRCodeAlg.PAD0 = 0xEC;
  QRCodeAlg.PAD1 = 0x11;
  //---------------------------------------------------------------------
  // 纠错等级对应的编码
  //---------------------------------------------------------------------
  var QRErrorCorrectLevel = [1, 0, 3, 2];
  //---------------------------------------------------------------------
  // 掩膜版本
  //---------------------------------------------------------------------
  var QRMaskPattern = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7 };

  //---------------------------------------------------------------------
  // 工具类
  //---------------------------------------------------------------------
  var QRUtil = {
    /*
                 每个版本矫正图形的位置
                  */
    PATTERN_POSITION_TABLE: [
    [],
    [6, 18],
    [6, 22],
    [6, 26],
    [6, 30],
    [6, 34],
    [6, 22, 38],
    [6, 24, 42],
    [6, 26, 46],
    [6, 28, 50],
    [6, 30, 54],
    [6, 32, 58],
    [6, 34, 62],
    [6, 26, 46, 66],
    [6, 26, 48, 70],
    [6, 26, 50, 74],
    [6, 30, 54, 78],
    [6, 30, 56, 82],
    [6, 30, 58, 86],
    [6, 34, 62, 90],
    [6, 28, 50, 72, 94],
    [6, 26, 50, 74, 98],
    [6, 30, 54, 78, 102],
    [6, 28, 54, 80, 106],
    [6, 32, 58, 84, 110],
    [6, 30, 58, 86, 114],
    [6, 34, 62, 90, 118],
    [6, 26, 50, 74, 98, 122],
    [6, 30, 54, 78, 102, 126],
    [6, 26, 52, 78, 104, 130],
    [6, 30, 56, 82, 108, 134],
    [6, 34, 60, 86, 112, 138],
    [6, 30, 58, 86, 114, 142],
    [6, 34, 62, 90, 118, 146],
    [6, 30, 54, 78, 102, 126, 150],
    [6, 24, 50, 76, 102, 128, 154],
    [6, 28, 54, 80, 106, 132, 158],
    [6, 32, 58, 84, 110, 136, 162],
    [6, 26, 54, 82, 110, 138, 166],
    [6, 30, 58, 86, 114, 142, 170]],

    G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0,
    G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0,
    G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1,
    /*
                                                             BCH编码格式信息
                                                              */
    getBCHTypeInfo: function getBCHTypeInfo(data) {
      var d = data << 10;
      while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
        d ^= QRUtil.G15 << QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15);
      }
      return (data << 10 | d) ^ QRUtil.G15_MASK;
    },
    /*
       BCH编码版本信息
        */
    getBCHTypeNumber: function getBCHTypeNumber(data) {
      var d = data << 12;
      while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
        d ^= QRUtil.G18 << QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18);
      }
      return data << 12 | d;
    },
    /*
       获取BCH位信息
        */
    getBCHDigit: function getBCHDigit(data) {
      var digit = 0;
      while (data != 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    },
    /*
       获取版本对应的矫正图形位置
        */
    getPatternPosition: function getPatternPosition(typeNumber) {
      return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
    },
    /*
       掩膜算法
        */
    getMask: function getMask(maskPattern, i, j) {
      switch (maskPattern) {
        case QRMaskPattern.PATTERN000:
          return (i + j) % 2 == 0;
        case QRMaskPattern.PATTERN001:
          return i % 2 == 0;
        case QRMaskPattern.PATTERN010:
          return j % 3 == 0;
        case QRMaskPattern.PATTERN011:
          return (i + j) % 3 == 0;
        case QRMaskPattern.PATTERN100:
          return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
        case QRMaskPattern.PATTERN101:
          return i * j % 2 + i * j % 3 == 0;
        case QRMaskPattern.PATTERN110:
          return (i * j % 2 + i * j % 3) % 2 == 0;
        case QRMaskPattern.PATTERN111:
          return (i * j % 3 + (i + j) % 2) % 2 == 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);}

    },
    /*
       获取RS的纠错多项式
        */
    getErrorCorrectPolynomial: function getErrorCorrectPolynomial(errorCorrectLength) {
      var a = new QRPolynomial([1], 0);
      for (var i = 0; i < errorCorrectLength; i++) {
        a = a.multiply(new QRPolynomial([1, QRMath.gexp(i)], 0));
      }
      return a;
    },
    /*
       获取评价
        */
    getLostPoint: function getLostPoint(qrCode) {
      var moduleCount = qrCode.getModuleCount(),
      lostPoint = 0,
      darkCount = 0;
      for (var row = 0; row < moduleCount; row++) {
        var sameCount = 0;
        var head = qrCode.modules[row][0];
        for (var col = 0; col < moduleCount; col++) {
          var current = qrCode.modules[row][col];
          //level 3 评价
          if (col < moduleCount - 6) {
            if (current && !qrCode.modules[row][col + 1] && qrCode.modules[row][col + 2] && qrCode.modules[row][col + 3] && qrCode.modules[row][col + 4] && !qrCode.modules[row][col + 5] && qrCode.modules[row][col + 6]) {
              if (col < moduleCount - 10) {
                if (qrCode.modules[row][col + 7] && qrCode.modules[row][col + 8] && qrCode.modules[row][col + 9] && qrCode.modules[row][col + 10]) {
                  lostPoint += 40;
                }
              } else if (col > 3) {
                if (qrCode.modules[row][col - 1] && qrCode.modules[row][col - 2] && qrCode.modules[row][col - 3] && qrCode.modules[row][col - 4]) {
                  lostPoint += 40;
                }
              }
            }
          }
          //level 2 评价
          if (row < moduleCount - 1 && col < moduleCount - 1) {
            var count = 0;
            if (current) count++;
            if (qrCode.modules[row + 1][col]) count++;
            if (qrCode.modules[row][col + 1]) count++;
            if (qrCode.modules[row + 1][col + 1]) count++;
            if (count == 0 || count == 4) {
              lostPoint += 3;
            }
          }
          //level 1 评价
          if (head ^ current) {
            sameCount++;
          } else {
            head = current;
            if (sameCount >= 5) {
              lostPoint += 3 + sameCount - 5;
            }
            sameCount = 1;
          }
          //level 4 评价
          if (current) {
            darkCount++;
          }
        }
      }
      for (var col = 0; col < moduleCount; col++) {
        var sameCount = 0;
        var head = qrCode.modules[0][col];
        for (var row = 0; row < moduleCount; row++) {
          var current = qrCode.modules[row][col];
          //level 3 评价
          if (row < moduleCount - 6) {
            if (current && !qrCode.modules[row + 1][col] && qrCode.modules[row + 2][col] && qrCode.modules[row + 3][col] && qrCode.modules[row + 4][col] && !qrCode.modules[row + 5][col] && qrCode.modules[row + 6][col]) {
              if (row < moduleCount - 10) {
                if (qrCode.modules[row + 7][col] && qrCode.modules[row + 8][col] && qrCode.modules[row + 9][col] && qrCode.modules[row + 10][col]) {
                  lostPoint += 40;
                }
              } else if (row > 3) {
                if (qrCode.modules[row - 1][col] && qrCode.modules[row - 2][col] && qrCode.modules[row - 3][col] && qrCode.modules[row - 4][col]) {
                  lostPoint += 40;
                }
              }
            }
          }
          //level 1 评价
          if (head ^ current) {
            sameCount++;
          } else {
            head = current;
            if (sameCount >= 5) {
              lostPoint += 3 + sameCount - 5;
            }
            sameCount = 1;
          }
        }
      }
      // LEVEL4
      var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
      lostPoint += ratio * 10;
      return lostPoint;
    } };


  //---------------------------------------------------------------------
  // QRMath使用的数学工具
  //---------------------------------------------------------------------
  var QRMath = {
    /*
                 将n转化为a^m
                  */
    glog: function glog(n) {
      if (n < 1) {
        throw new Error("glog(" + n + ")");
      }
      return QRMath.LOG_TABLE[n];
    },
    /*
       将a^m转化为n
        */
    gexp: function gexp(n) {
      while (n < 0) {
        n += 255;
      }
      while (n >= 256) {
        n -= 255;
      }
      return QRMath.EXP_TABLE[n];
    },
    EXP_TABLE: new Array(256),
    LOG_TABLE: new Array(256) };


  for (var i = 0; i < 8; i++) {
    QRMath.EXP_TABLE[i] = 1 << i;
  }
  for (var i = 8; i < 256; i++) {
    QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
  }
  for (var i = 0; i < 255; i++) {
    QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
  }
  //---------------------------------------------------------------------
  // QRPolynomial 多项式
  //---------------------------------------------------------------------
  /**
   * 多项式类
   * @param {Array} num   系数
   * @param {num} shift a^shift
   */
  function QRPolynomial(num, shift) {
    if (num.length == undefined) {
      throw new Error(num.length + "/" + shift);
    }
    var offset = 0;
    while (offset < num.length && num[offset] == 0) {
      offset++;
    }
    this.num = new Array(num.length - offset + shift);
    for (var i = 0; i < num.length - offset; i++) {
      this.num[i] = num[i + offset];
    }
  }
  QRPolynomial.prototype = {
    get: function get(index) {
      return this.num[index];
    },
    getLength: function getLength() {
      return this.num.length;
    },
    /**
        * 多项式乘法
        * @param  {QRPolynomial} e 被乘多项式
        * @return {[type]}   [description]
        */
    multiply: function multiply(e) {
      var num = new Array(this.getLength() + e.getLength() - 1);
      for (var i = 0; i < this.getLength(); i++) {
        for (var j = 0; j < e.getLength(); j++) {
          num[i + j] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e.get(j)));
        }
      }
      return new QRPolynomial(num, 0);
    },
    /**
        * 多项式模运算
        * @param  {QRPolynomial} e 模多项式
        * @return {}
        */
    mod: function mod(e) {
      var tl = this.getLength(),
      el = e.getLength();
      if (tl - el < 0) {
        return this;
      }
      var num = new Array(tl);
      for (var i = 0; i < tl; i++) {
        num[i] = this.get(i);
      }
      while (num.length >= el) {
        var ratio = QRMath.glog(num[0]) - QRMath.glog(e.get(0));

        for (var i = 0; i < e.getLength(); i++) {
          num[i] ^= QRMath.gexp(QRMath.glog(e.get(i)) + ratio);
        }
        while (num[0] == 0) {
          num.shift();
        }
      }
      return new QRPolynomial(num, 0);
    } };


  //---------------------------------------------------------------------
  // RS_BLOCK_TABLE
  //---------------------------------------------------------------------
  /*
  二维码各个版本信息[块数, 每块中的数据块数, 每块中的信息块数]
   */
  var RS_BLOCK_TABLE = [
  // L
  // M
  // Q
  // H
  // 1
  [1, 26, 19],
  [1, 26, 16],
  [1, 26, 13],
  [1, 26, 9],

  // 2
  [1, 44, 34],
  [1, 44, 28],
  [1, 44, 22],
  [1, 44, 16],

  // 3
  [1, 70, 55],
  [1, 70, 44],
  [2, 35, 17],
  [2, 35, 13],

  // 4
  [1, 100, 80],
  [2, 50, 32],
  [2, 50, 24],
  [4, 25, 9],

  // 5
  [1, 134, 108],
  [2, 67, 43],
  [2, 33, 15, 2, 34, 16],
  [2, 33, 11, 2, 34, 12],

  // 6
  [2, 86, 68],
  [4, 43, 27],
  [4, 43, 19],
  [4, 43, 15],

  // 7
  [2, 98, 78],
  [4, 49, 31],
  [2, 32, 14, 4, 33, 15],
  [4, 39, 13, 1, 40, 14],

  // 8
  [2, 121, 97],
  [2, 60, 38, 2, 61, 39],
  [4, 40, 18, 2, 41, 19],
  [4, 40, 14, 2, 41, 15],

  // 9
  [2, 146, 116],
  [3, 58, 36, 2, 59, 37],
  [4, 36, 16, 4, 37, 17],
  [4, 36, 12, 4, 37, 13],

  // 10
  [2, 86, 68, 2, 87, 69],
  [4, 69, 43, 1, 70, 44],
  [6, 43, 19, 2, 44, 20],
  [6, 43, 15, 2, 44, 16],

  // 11
  [4, 101, 81],
  [1, 80, 50, 4, 81, 51],
  [4, 50, 22, 4, 51, 23],
  [3, 36, 12, 8, 37, 13],

  // 12
  [2, 116, 92, 2, 117, 93],
  [6, 58, 36, 2, 59, 37],
  [4, 46, 20, 6, 47, 21],
  [7, 42, 14, 4, 43, 15],

  // 13
  [4, 133, 107],
  [8, 59, 37, 1, 60, 38],
  [8, 44, 20, 4, 45, 21],
  [12, 33, 11, 4, 34, 12],

  // 14
  [3, 145, 115, 1, 146, 116],
  [4, 64, 40, 5, 65, 41],
  [11, 36, 16, 5, 37, 17],
  [11, 36, 12, 5, 37, 13],

  // 15
  [5, 109, 87, 1, 110, 88],
  [5, 65, 41, 5, 66, 42],
  [5, 54, 24, 7, 55, 25],
  [11, 36, 12],

  // 16
  [5, 122, 98, 1, 123, 99],
  [7, 73, 45, 3, 74, 46],
  [15, 43, 19, 2, 44, 20],
  [3, 45, 15, 13, 46, 16],

  // 17
  [1, 135, 107, 5, 136, 108],
  [10, 74, 46, 1, 75, 47],
  [1, 50, 22, 15, 51, 23],
  [2, 42, 14, 17, 43, 15],

  // 18
  [5, 150, 120, 1, 151, 121],
  [9, 69, 43, 4, 70, 44],
  [17, 50, 22, 1, 51, 23],
  [2, 42, 14, 19, 43, 15],

  // 19
  [3, 141, 113, 4, 142, 114],
  [3, 70, 44, 11, 71, 45],
  [17, 47, 21, 4, 48, 22],
  [9, 39, 13, 16, 40, 14],

  // 20
  [3, 135, 107, 5, 136, 108],
  [3, 67, 41, 13, 68, 42],
  [15, 54, 24, 5, 55, 25],
  [15, 43, 15, 10, 44, 16],

  // 21
  [4, 144, 116, 4, 145, 117],
  [17, 68, 42],
  [17, 50, 22, 6, 51, 23],
  [19, 46, 16, 6, 47, 17],

  // 22
  [2, 139, 111, 7, 140, 112],
  [17, 74, 46],
  [7, 54, 24, 16, 55, 25],
  [34, 37, 13],

  // 23
  [4, 151, 121, 5, 152, 122],
  [4, 75, 47, 14, 76, 48],
  [11, 54, 24, 14, 55, 25],
  [16, 45, 15, 14, 46, 16],

  // 24
  [6, 147, 117, 4, 148, 118],
  [6, 73, 45, 14, 74, 46],
  [11, 54, 24, 16, 55, 25],
  [30, 46, 16, 2, 47, 17],

  // 25
  [8, 132, 106, 4, 133, 107],
  [8, 75, 47, 13, 76, 48],
  [7, 54, 24, 22, 55, 25],
  [22, 45, 15, 13, 46, 16],

  // 26
  [10, 142, 114, 2, 143, 115],
  [19, 74, 46, 4, 75, 47],
  [28, 50, 22, 6, 51, 23],
  [33, 46, 16, 4, 47, 17],

  // 27
  [8, 152, 122, 4, 153, 123],
  [22, 73, 45, 3, 74, 46],
  [8, 53, 23, 26, 54, 24],
  [12, 45, 15, 28, 46, 16],

  // 28
  [3, 147, 117, 10, 148, 118],
  [3, 73, 45, 23, 74, 46],
  [4, 54, 24, 31, 55, 25],
  [11, 45, 15, 31, 46, 16],

  // 29
  [7, 146, 116, 7, 147, 117],
  [21, 73, 45, 7, 74, 46],
  [1, 53, 23, 37, 54, 24],
  [19, 45, 15, 26, 46, 16],

  // 30
  [5, 145, 115, 10, 146, 116],
  [19, 75, 47, 10, 76, 48],
  [15, 54, 24, 25, 55, 25],
  [23, 45, 15, 25, 46, 16],

  // 31
  [13, 145, 115, 3, 146, 116],
  [2, 74, 46, 29, 75, 47],
  [42, 54, 24, 1, 55, 25],
  [23, 45, 15, 28, 46, 16],

  // 32
  [17, 145, 115],
  [10, 74, 46, 23, 75, 47],
  [10, 54, 24, 35, 55, 25],
  [19, 45, 15, 35, 46, 16],

  // 33
  [17, 145, 115, 1, 146, 116],
  [14, 74, 46, 21, 75, 47],
  [29, 54, 24, 19, 55, 25],
  [11, 45, 15, 46, 46, 16],

  // 34
  [13, 145, 115, 6, 146, 116],
  [14, 74, 46, 23, 75, 47],
  [44, 54, 24, 7, 55, 25],
  [59, 46, 16, 1, 47, 17],

  // 35
  [12, 151, 121, 7, 152, 122],
  [12, 75, 47, 26, 76, 48],
  [39, 54, 24, 14, 55, 25],
  [22, 45, 15, 41, 46, 16],

  // 36
  [6, 151, 121, 14, 152, 122],
  [6, 75, 47, 34, 76, 48],
  [46, 54, 24, 10, 55, 25],
  [2, 45, 15, 64, 46, 16],

  // 37
  [17, 152, 122, 4, 153, 123],
  [29, 74, 46, 14, 75, 47],
  [49, 54, 24, 10, 55, 25],
  [24, 45, 15, 46, 46, 16],

  // 38
  [4, 152, 122, 18, 153, 123],
  [13, 74, 46, 32, 75, 47],
  [48, 54, 24, 14, 55, 25],
  [42, 45, 15, 32, 46, 16],

  // 39
  [20, 147, 117, 4, 148, 118],
  [40, 75, 47, 7, 76, 48],
  [43, 54, 24, 22, 55, 25],
  [10, 45, 15, 67, 46, 16],

  // 40
  [19, 148, 118, 6, 149, 119],
  [18, 75, 47, 31, 76, 48],
  [34, 54, 24, 34, 55, 25],
  [20, 45, 15, 61, 46, 16]];


  /**
                              * 根据数据获取对应版本
                              * @return {[type]} [description]
                              */
  QRCodeAlg.prototype.getRightType = function () {
    for (var typeNumber = 1; typeNumber < 41; typeNumber++) {
      var rsBlock = RS_BLOCK_TABLE[(typeNumber - 1) * 4 + this.errorCorrectLevel];
      if (rsBlock == undefined) {
        throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + this.errorCorrectLevel);
      }
      var length = rsBlock.length / 3;
      var totalDataCount = 0;
      for (var i = 0; i < length; i++) {
        var count = rsBlock[i * 3 + 0];
        var dataCount = rsBlock[i * 3 + 2];
        totalDataCount += dataCount * count;
      }
      var lengthBytes = typeNumber > 9 ? 2 : 1;
      if (this.utf8bytes.length + lengthBytes < totalDataCount || typeNumber == 40) {
        this.typeNumber = typeNumber;
        this.rsBlock = rsBlock;
        this.totalDataCount = totalDataCount;
        break;
      }
    }
  };

  //---------------------------------------------------------------------
  // QRBitBuffer
  //---------------------------------------------------------------------
  function QRBitBuffer() {
    this.buffer = new Array();
    this.length = 0;
  }
  QRBitBuffer.prototype = {
    get: function get(index) {
      var bufIndex = Math.floor(index / 8);
      return this.buffer[bufIndex] >>> 7 - index % 8 & 1;
    },
    put: function put(num, length) {
      for (var i = 0; i < length; i++) {
        this.putBit(num >>> length - i - 1 & 1);
      }
    },
    putBit: function putBit(bit) {
      var bufIndex = Math.floor(this.length / 8);
      if (this.buffer.length <= bufIndex) {
        this.buffer.push(0);
      }
      if (bit) {
        this.buffer[bufIndex] |= 0x80 >>> this.length % 8;
      }
      this.length++;
    } };




  // xzedit
  var qrcodeAlgObjCache = [];
  /**
                               * 二维码构造函数，主要用于绘制
                               * @param  {参数列表} opt 传递参数
                               * @return {}
                               */
  QRCode = function QRCode(opt) {
    //设置默认参数
    this.options = {
      text: '',
      size: 256,
      correctLevel: 3,
      background: '#ffffff',
      foreground: '#000000',
      pdground: '#000000',
      image: '',
      imageSize: 30,
      canvasId: opt.canvasId,
      context: opt.context,
      usingComponents: opt.usingComponents,
      showLoading: opt.showLoading,
      loadingText: opt.loadingText };

    if (typeof opt === 'string') {// 只编码ASCII字符串
      opt = {
        text: opt };

    }
    if (opt) {
      for (var i in opt) {
        this.options[i] = opt[i];
      }
    }
    //使用QRCodeAlg创建二维码结构
    var qrCodeAlg = null;
    for (var i = 0, l = qrcodeAlgObjCache.length; i < l; i++) {
      if (qrcodeAlgObjCache[i].text == this.options.text && qrcodeAlgObjCache[i].text.correctLevel == this.options.correctLevel) {
        qrCodeAlg = qrcodeAlgObjCache[i].obj;
        break;
      }
    }
    if (i == l) {
      qrCodeAlg = new QRCodeAlg(this.options.text, this.options.correctLevel);
      qrcodeAlgObjCache.push({
        text: this.options.text,
        correctLevel: this.options.correctLevel,
        obj: qrCodeAlg });

    }
    /**
       * 计算矩阵点的前景色
       * @param {Obj} config
       * @param {Number} config.row 点x坐标
       * @param {Number} config.col 点y坐标
       * @param {Number} config.count 矩阵大小
       * @param {Number} config.options 组件的options
       * @return {String}
       */
    var getForeGround = function getForeGround(config) {
      var options = config.options;
      if (options.pdground && (
      config.row > 1 && config.row < 5 && config.col > 1 && config.col < 5 ||
      config.row > config.count - 6 && config.row < config.count - 2 && config.col > 1 && config.col < 5 ||
      config.row > 1 && config.row < 5 && config.col > config.count - 6 && config.col < config.count - 2))
      {
        return options.pdground;
      }
      return options.foreground;
    };
    // 创建canvas
    var createCanvas = function createCanvas(options) {
      if (options.showLoading) {
        uni.showLoading({
          title: options.loadingText,
          mask: true });

      }
      var ctx = uni.createCanvasContext(options.canvasId, options.context);
      var count = qrCodeAlg.getModuleCount();
      var ratioSize = options.size;
      var ratioImgSize = options.imageSize;
      //计算每个点的长宽
      var tileW = (ratioSize / count).toPrecision(4);
      var tileH = (ratioSize / count).toPrecision(4);
      //绘制
      for (var row = 0; row < count; row++) {
        for (var col = 0; col < count; col++) {
          var w = Math.ceil((col + 1) * tileW) - Math.floor(col * tileW);
          var h = Math.ceil((row + 1) * tileW) - Math.floor(row * tileW);
          var foreground = getForeGround({
            row: row,
            col: col,
            count: count,
            options: options });

          ctx.setFillStyle(qrCodeAlg.modules[row][col] ? foreground : options.background);
          ctx.fillRect(Math.round(col * tileW), Math.round(row * tileH), w, h);
        }
      }
      if (options.image) {




        // 画圆角矩形
        var drawRoundedRect = function drawRoundedRect(ctxi, x, y, width, height, r, lineWidth, fill, stroke) {
          ctxi.setLineWidth(lineWidth);
          ctxi.setFillStyle(options.background);
          ctxi.setStrokeStyle(options.background);
          ctxi.beginPath(); // draw top and top right corner 
          ctxi.moveTo(x + r, y);
          ctxi.arcTo(x + width, y, x + width, y + r, r); // draw right side and bottom right corner 
          ctxi.arcTo(x + width, y + height, x + width - r, y + height, r); // draw bottom and bottom left corner 
          ctxi.arcTo(x, y + height, x, y + height - r, r); // draw left and top left corner 
          ctxi.arcTo(x, y, x + r, y, r);
          ctxi.closePath();
          if (fill) {
            ctxi.fill();
          }
          if (stroke) {
            ctxi.stroke();
          }
        };var x = Number(((ratioSize - ratioImgSize) / 2).toFixed(2));var y = Number(((ratioSize - ratioImgSize) / 2).toFixed(2));drawRoundedRect(ctx, x, y, ratioImgSize, ratioImgSize, 2, 6, true, true);ctx.drawImage(options.image, x, y, ratioImgSize, ratioImgSize);
      }
      setTimeout(function () {
        ctx.draw(true, function () {
          // 保存到临时区域
          setTimeout(function () {
            uni.canvasToTempFilePath({
              width: options.width,
              height: options.height,
              destWidth: options.width,
              destHeight: options.height,
              canvasId: options.canvasId,
              quality: Number(1),
              success: function success(res) {
                if (options.cbResult) {
                  // 由于官方还没有统一此接口的输出字段，所以先判定下  支付宝为 res.apFilePath
                  if (!empty(res.tempFilePath)) {
                    options.cbResult(res.tempFilePath);
                  } else if (!empty(res.apFilePath)) {
                    options.cbResult(res.apFilePath);
                  } else {
                    options.cbResult(res.tempFilePath);
                  }
                }
              },
              fail: function fail(res) {
                if (options.cbResult) {
                  options.cbResult(res);
                }
              },
              complete: function complete() {
                uni.hideLoading();
              } },
            options.context);
          }, options.text.length + 100);
        });
      }, options.usingComponents ? 0 : 150);
    };
    createCanvas(this.options);
    // 空判定
    var empty = function empty(v) {
      var tp = typeof v,
      rt = false;
      if (tp == "number" && String(v) == "") {
        rt = true;
      } else if (tp == "undefined") {
        rt = true;
      } else if (tp == "object") {
        if (JSON.stringify(v) == "{}" || JSON.stringify(v) == "[]" || v == null) rt = true;
      } else if (tp == "string") {
        if (v == "" || v == "undefined" || v == "null" || v == "{}" || v == "[]") rt = true;
      } else if (tp == "function") {
        rt = false;
      }
      return rt;
    };
  };
  QRCode.prototype.clear = function (fn) {
    var ctx = uni.createCanvasContext(this.options.canvasId, this.options.context);
    ctx.clearRect(0, 0, this.options.size, this.options.size);
    ctx.draw(false, function () {
      if (fn) {
        fn();
      }
    });
  };
})();var _default =

QRCode;exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["default"]))

/***/ }),
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */
/*!************************************************************************************!*\
  !*** ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/uni-cloud/dist/index.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, uni) {Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _regenerator = _interopRequireDefault(__webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ 17));var _uniI18n = __webpack_require__(/*! @dcloudio/uni-i18n */ 4);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _toConsumableArray(arr) {return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();}function _nonIterableSpread() {throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _iterableToArray(iter) {if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);}function _arrayWithoutHoles(arr) {if (Array.isArray(arr)) return _arrayLikeToArray(arr);}function _createForOfIteratorHelper(o, allowArrayLike) {var it;if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e24) {throw _e24;}, f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = o[Symbol.iterator]();}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e25) {didErr = true;err = _e25;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {_defineProperty(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (typeof call === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _wrapNativeSuper(Class) {var _cache = typeof Map === "function" ? new Map() : undefined;_wrapNativeSuper = function _wrapNativeSuper(Class) {if (Class === null || !_isNativeFunction(Class)) return Class;if (typeof Class !== "function") {throw new TypeError("Super expression must either be null or a function");}if (typeof _cache !== "undefined") {if (_cache.has(Class)) return _cache.get(Class);_cache.set(Class, Wrapper);}function Wrapper() {return _construct(Class, arguments, _getPrototypeOf(this).constructor);}Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });return _setPrototypeOf(Wrapper, Class);};return _wrapNativeSuper(Class);}function _construct(Parent, args, Class) {if (_isNativeReflectConstruct()) {_construct = Reflect.construct;} else {_construct = function _construct(Parent, args, Class) {var a = [null];a.push.apply(a, args);var Constructor = Function.bind.apply(Parent, a);var instance = new Constructor();if (Class) _setPrototypeOf(instance, Class.prototype);return instance;};}return _construct.apply(null, arguments);}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _isNativeFunction(fn) {return Function.toString.call(fn).indexOf("[native code]") !== -1;}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}"undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self;function t(e) {return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;}function n(e, t, n) {return e(n = { path: t, exports: {}, require: function require(e, t) {return function () {throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");}(null == t && n.path);} }, n.exports), n.exports;}var s = n(function (e, t) {var n;e.exports = (n = n || function (e, t) {var n = Object.create || function () {function e() {}return function (t) {var n;return e.prototype = t, n = new e(), e.prototype = null, n;};}(),s = {},r = s.lib = {},o = r.Base = { extend: function extend(e) {var t = n(this);return e && t.mixIn(e), t.hasOwnProperty("init") && this.init !== t.init || (t.init = function () {t.$super.init.apply(this, arguments);}), t.init.prototype = t, t.$super = this, t;}, create: function create() {var e = this.extend();return e.init.apply(e, arguments), e;}, init: function init() {}, mixIn: function mixIn(e) {for (var t in e) {e.hasOwnProperty(t) && (this[t] = e[t]);}e.hasOwnProperty("toString") && (this.toString = e.toString);}, clone: function clone() {return this.init.prototype.extend(this);} },i = r.WordArray = o.extend({ init: function init(e, n) {e = this.words = e || [], this.sigBytes = n != t ? n : 4 * e.length;}, toString: function toString(e) {return (e || c).stringify(this);}, concat: function concat(e) {var t = this.words,n = e.words,s = this.sigBytes,r = e.sigBytes;if (this.clamp(), s % 4) for (var o = 0; o < r; o++) {var i = n[o >>> 2] >>> 24 - o % 4 * 8 & 255;t[s + o >>> 2] |= i << 24 - (s + o) % 4 * 8;} else for (o = 0; o < r; o += 4) {t[s + o >>> 2] = n[o >>> 2];}return this.sigBytes += r, this;}, clamp: function clamp() {var t = this.words,n = this.sigBytes;t[n >>> 2] &= 4294967295 << 32 - n % 4 * 8, t.length = e.ceil(n / 4);}, clone: function clone() {var e = o.clone.call(this);return e.words = this.words.slice(0), e;}, random: function random(t) {for (var n, s = [], r = function r(t) {t = t;var n = 987654321,s = 4294967295;return function () {var r = ((n = 36969 * (65535 & n) + (n >> 16) & s) << 16) + (t = 18e3 * (65535 & t) + (t >> 16) & s) & s;return r /= 4294967296, (r += .5) * (e.random() > .5 ? 1 : -1);};}, o = 0; o < t; o += 4) {var a = r(4294967296 * (n || e.random()));n = 987654071 * a(), s.push(4294967296 * a() | 0);}return new i.init(s, t);} }),a = s.enc = {},c = a.Hex = { stringify: function stringify(e) {for (var t = e.words, n = e.sigBytes, s = [], r = 0; r < n; r++) {var o = t[r >>> 2] >>> 24 - r % 4 * 8 & 255;s.push((o >>> 4).toString(16)), s.push((15 & o).toString(16));}return s.join("");}, parse: function parse(e) {for (var t = e.length, n = [], s = 0; s < t; s += 2) {n[s >>> 3] |= parseInt(e.substr(s, 2), 16) << 24 - s % 8 * 4;}return new i.init(n, t / 2);} },u = a.Latin1 = { stringify: function stringify(e) {for (var t = e.words, n = e.sigBytes, s = [], r = 0; r < n; r++) {var o = t[r >>> 2] >>> 24 - r % 4 * 8 & 255;s.push(String.fromCharCode(o));}return s.join("");}, parse: function parse(e) {for (var t = e.length, n = [], s = 0; s < t; s++) {n[s >>> 2] |= (255 & e.charCodeAt(s)) << 24 - s % 4 * 8;}return new i.init(n, t);} },h = a.Utf8 = { stringify: function stringify(e) {try {return decodeURIComponent(escape(u.stringify(e)));} catch (e) {throw new Error("Malformed UTF-8 data");}}, parse: function parse(e) {return u.parse(unescape(encodeURIComponent(e)));} },l = r.BufferedBlockAlgorithm = o.extend({ reset: function reset() {this._data = new i.init(), this._nDataBytes = 0;}, _append: function _append(e) {"string" == typeof e && (e = h.parse(e)), this._data.concat(e), this._nDataBytes += e.sigBytes;}, _process: function _process(t) {var n = this._data,s = n.words,r = n.sigBytes,o = this.blockSize,a = r / (4 * o),c = (a = t ? e.ceil(a) : e.max((0 | a) - this._minBufferSize, 0)) * o,u = e.min(4 * c, r);if (c) {for (var h = 0; h < c; h += o) {this._doProcessBlock(s, h);}var l = s.splice(0, c);n.sigBytes -= u;}return new i.init(l, u);}, clone: function clone() {var e = o.clone.call(this);return e._data = this._data.clone(), e;}, _minBufferSize: 0 });r.Hasher = l.extend({ cfg: o.extend(), init: function init(e) {this.cfg = this.cfg.extend(e), this.reset();}, reset: function reset() {l.reset.call(this), this._doReset();}, update: function update(e) {return this._append(e), this._process(), this;}, finalize: function finalize(e) {return e && this._append(e), this._doFinalize();}, blockSize: 16, _createHelper: function _createHelper(e) {return function (t, n) {return new e.init(n).finalize(t);};}, _createHmacHelper: function _createHmacHelper(e) {return function (t, n) {return new d.HMAC.init(e, n).finalize(t);};} });var d = s.algo = {};return s;}(Math), n);}),r = (n(function (e, t) {var n;e.exports = (n = s, function (e) {var t = n,s = t.lib,r = s.WordArray,o = s.Hasher,i = t.algo,a = [];!function () {for (var t = 0; t < 64; t++) {a[t] = 4294967296 * e.abs(e.sin(t + 1)) | 0;}}();var c = i.MD5 = o.extend({ _doReset: function _doReset() {this._hash = new r.init([1732584193, 4023233417, 2562383102, 271733878]);}, _doProcessBlock: function _doProcessBlock(e, t) {for (var n = 0; n < 16; n++) {var s = t + n,r = e[s];e[s] = 16711935 & (r << 8 | r >>> 24) | 4278255360 & (r << 24 | r >>> 8);}var o = this._hash.words,i = e[t + 0],c = e[t + 1],f = e[t + 2],p = e[t + 3],g = e[t + 4],m = e[t + 5],y = e[t + 6],_ = e[t + 7],w = e[t + 8],k = e[t + 9],S = e[t + 10],v = e[t + 11],T = e[t + 12],A = e[t + 13],P = e[t + 14],I = e[t + 15],b = o[0],E = o[1],O = o[2],C = o[3];b = u(b, E, O, C, i, 7, a[0]), C = u(C, b, E, O, c, 12, a[1]), O = u(O, C, b, E, f, 17, a[2]), E = u(E, O, C, b, p, 22, a[3]), b = u(b, E, O, C, g, 7, a[4]), C = u(C, b, E, O, m, 12, a[5]), O = u(O, C, b, E, y, 17, a[6]), E = u(E, O, C, b, _, 22, a[7]), b = u(b, E, O, C, w, 7, a[8]), C = u(C, b, E, O, k, 12, a[9]), O = u(O, C, b, E, S, 17, a[10]), E = u(E, O, C, b, v, 22, a[11]), b = u(b, E, O, C, T, 7, a[12]), C = u(C, b, E, O, A, 12, a[13]), O = u(O, C, b, E, P, 17, a[14]), b = h(b, E = u(E, O, C, b, I, 22, a[15]), O, C, c, 5, a[16]), C = h(C, b, E, O, y, 9, a[17]), O = h(O, C, b, E, v, 14, a[18]), E = h(E, O, C, b, i, 20, a[19]), b = h(b, E, O, C, m, 5, a[20]), C = h(C, b, E, O, S, 9, a[21]), O = h(O, C, b, E, I, 14, a[22]), E = h(E, O, C, b, g, 20, a[23]), b = h(b, E, O, C, k, 5, a[24]), C = h(C, b, E, O, P, 9, a[25]), O = h(O, C, b, E, p, 14, a[26]), E = h(E, O, C, b, w, 20, a[27]), b = h(b, E, O, C, A, 5, a[28]), C = h(C, b, E, O, f, 9, a[29]), O = h(O, C, b, E, _, 14, a[30]), b = l(b, E = h(E, O, C, b, T, 20, a[31]), O, C, m, 4, a[32]), C = l(C, b, E, O, w, 11, a[33]), O = l(O, C, b, E, v, 16, a[34]), E = l(E, O, C, b, P, 23, a[35]), b = l(b, E, O, C, c, 4, a[36]), C = l(C, b, E, O, g, 11, a[37]), O = l(O, C, b, E, _, 16, a[38]), E = l(E, O, C, b, S, 23, a[39]), b = l(b, E, O, C, A, 4, a[40]), C = l(C, b, E, O, i, 11, a[41]), O = l(O, C, b, E, p, 16, a[42]), E = l(E, O, C, b, y, 23, a[43]), b = l(b, E, O, C, k, 4, a[44]), C = l(C, b, E, O, T, 11, a[45]), O = l(O, C, b, E, I, 16, a[46]), b = d(b, E = l(E, O, C, b, f, 23, a[47]), O, C, i, 6, a[48]), C = d(C, b, E, O, _, 10, a[49]), O = d(O, C, b, E, P, 15, a[50]), E = d(E, O, C, b, m, 21, a[51]), b = d(b, E, O, C, T, 6, a[52]), C = d(C, b, E, O, p, 10, a[53]), O = d(O, C, b, E, S, 15, a[54]), E = d(E, O, C, b, c, 21, a[55]), b = d(b, E, O, C, w, 6, a[56]), C = d(C, b, E, O, I, 10, a[57]), O = d(O, C, b, E, y, 15, a[58]), E = d(E, O, C, b, A, 21, a[59]), b = d(b, E, O, C, g, 6, a[60]), C = d(C, b, E, O, v, 10, a[61]), O = d(O, C, b, E, f, 15, a[62]), E = d(E, O, C, b, k, 21, a[63]), o[0] = o[0] + b | 0, o[1] = o[1] + E | 0, o[2] = o[2] + O | 0, o[3] = o[3] + C | 0;}, _doFinalize: function _doFinalize() {var t = this._data,n = t.words,s = 8 * this._nDataBytes,r = 8 * t.sigBytes;n[r >>> 5] |= 128 << 24 - r % 32;var o = e.floor(s / 4294967296),i = s;n[15 + (r + 64 >>> 9 << 4)] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8), n[14 + (r + 64 >>> 9 << 4)] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8), t.sigBytes = 4 * (n.length + 1), this._process();for (var a = this._hash, c = a.words, u = 0; u < 4; u++) {var h = c[u];c[u] = 16711935 & (h << 8 | h >>> 24) | 4278255360 & (h << 24 | h >>> 8);}return a;}, clone: function clone() {var e = o.clone.call(this);return e._hash = this._hash.clone(), e;} });function u(e, t, n, s, r, o, i) {var a = e + (t & n | ~t & s) + r + i;return (a << o | a >>> 32 - o) + t;}function h(e, t, n, s, r, o, i) {var a = e + (t & s | n & ~s) + r + i;return (a << o | a >>> 32 - o) + t;}function l(e, t, n, s, r, o, i) {var a = e + (t ^ n ^ s) + r + i;return (a << o | a >>> 32 - o) + t;}function d(e, t, n, s, r, o, i) {var a = e + (n ^ (t | ~s)) + r + i;return (a << o | a >>> 32 - o) + t;}t.MD5 = o._createHelper(c), t.HmacMD5 = o._createHmacHelper(c);}(Math), n.MD5);}), n(function (e, t) {var n, r, o;e.exports = (r = (n = s).lib.Base, o = n.enc.Utf8, void (n.algo.HMAC = r.extend({ init: function init(e, t) {e = this._hasher = new e.init(), "string" == typeof t && (t = o.parse(t));var n = e.blockSize,s = 4 * n;t.sigBytes > s && (t = e.finalize(t)), t.clamp();for (var r = this._oKey = t.clone(), i = this._iKey = t.clone(), a = r.words, c = i.words, u = 0; u < n; u++) {a[u] ^= 1549556828, c[u] ^= 909522486;}r.sigBytes = i.sigBytes = s, this.reset();}, reset: function reset() {var e = this._hasher;e.reset(), e.update(this._iKey);}, update: function update(e) {return this._hasher.update(e), this;}, finalize: function finalize(e) {var t = this._hasher,n = t.finalize(e);return t.reset(), t.finalize(this._oKey.clone().concat(n));} })));}), n(function (e, t) {e.exports = s.HmacMD5;}));function o(e) {return Object.prototype.toString.call(e).slice(8, -1).toLowerCase();}function i(e) {return "object" === o(e);}var a = /*#__PURE__*/function (_Error) {_inherits(a, _Error);var _super = _createSuper(a);function a(e, t) {var _this;_classCallCheck(this, a);_this = _super.call(this, e), _this.code = t;return _this;}return a;}( /*#__PURE__*/_wrapNativeSuper(Error));function c(e) {return e && "string" == typeof e ? JSON.parse(e) : e;}var u = "development" === "development",h = "mp-weixin",l = c(undefined),d = c([]),f = true;var p = "";try {{var _e2 = __webpack_require__(/*! uni-stat-config */ 333).default || __webpack_require__(/*! uni-stat-config */ 333);p = _e2.appid;}} catch (e) {}var g = {};function m(e) {var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};var n, s;return n = g, s = e, Object.prototype.hasOwnProperty.call(n, s) || (g[e] = t), g[e];}"app-plus" === h && (g = uni._globalUniCloudObj ? uni._globalUniCloudObj : uni._globalUniCloudObj = {});var y = ["invoke", "success", "fail", "complete"],_ = m("_globalUniCloudInterceptor");function w(e, t) {_[e] || (_[e] = {}), i(t) && Object.keys(t).forEach(function (n) {y.indexOf(n) > -1 && function (e, t, n) {var s = _[e][t];s || (s = _[e][t] = []), -1 === s.indexOf(n) && "function" == typeof n && s.push(n);}(e, n, t[n]);});}function k(e, t) {_[e] || (_[e] = {}), i(t) ? Object.keys(t).forEach(function (n) {y.indexOf(n) > -1 && function (e, t, n) {var s = _[e][t];if (!s) return;var r = s.indexOf(n);r > -1 && s.splice(r, 1);}(e, n, t[n]);}) : delete _[e];}function S(e, t) {return e && 0 !== e.length ? e.reduce(function (e, n) {return e.then(function () {return n(t);});}, Promise.resolve()) : Promise.resolve();}function v(e, t) {return _[e] && _[e][t] || [];}function T(e, t) {return t ? function (n) {var _this2 = this;var s = "callFunction" === t && "DCloud-clientDB" === (n && n.name);var r;r = this.isReady ? Promise.resolve() : this.initUniCloud, n = n || {};var o = r.then(function () {return s ? Promise.resolve() : S(v(t, "invoke"), n);}).then(function () {return e.call(_this2, n);}).then(function (e) {return s ? Promise.resolve(e) : S(v(t, "success"), e).then(function () {return S(v(t, "complete"), e);}).then(function () {return Promise.resolve(e);});}, function (e) {return s ? Promise.reject(e) : S(v(t, "fail"), e).then(function () {return S(v(t, "complete"), e);}).then(function () {return Promise.reject(e);});});if (!(n.success || n.fail || n.complete)) return o;o.then(function (e) {n.success && n.success(e), n.complete && n.complete(e);}, function (e) {n.fail && n.fail(e), n.complete && n.complete(e);});} : function (t) {if (!((t = t || {}).success || t.fail || t.complete)) return e.call(this, t);e.call(this, t).then(function (e) {t.success && t.success(e), t.complete && t.complete(e);}, function (e) {t.fail && t.fail(e), t.complete && t.complete(e);});};}var A = /*#__PURE__*/function (_Error2) {_inherits(A, _Error2);var _super2 = _createSuper(A);function A(e) {var _this3;_classCallCheck(this, A);_this3 = _super2.call(this, e.message), _this3.errMsg = e.message || "", Object.defineProperties(_assertThisInitialized(_this3), { code: { get: function get() {return e.code;} }, requestId: { get: function get() {return e.requestId;} }, message: { get: function get() {return this.errMsg;}, set: function set(e) {this.errMsg = e;} } });return _this3;}return A;}( /*#__PURE__*/_wrapNativeSuper(Error));var P;function I() {var e = uni.getLocale && uni.getLocale() || "en";if (P) return _objectSpread(_objectSpread({}, P), {}, { LOCALE: e });var _uni$getSystemInfoSyn = uni.getSystemInfoSync(),t = _uni$getSystemInfoSyn.deviceId,n = _uni$getSystemInfoSyn.platform;return P = { PLATFORM: h, OS: n, APPID: p, DEVICEID: t, CLIENT_SDK_VERSION: "1.0.21" }, _objectSpread(_objectSpread({}, P), {}, { LOCALE: e });}var b = { sign: function sign(e, t) {var n = "";return Object.keys(e).sort().forEach(function (t) {e[t] && (n = n + "&" + t + "=" + e[t]);}), n = n.slice(1), r(n, t).toString();}, wrappedRequest: function wrappedRequest(e, t) {return new Promise(function (n, s) {t(Object.assign(e, { complete: function complete(e) {e || (e = {}), u && "h5" === h && e.errMsg && 0 === e.errMsg.indexOf("request:fail") && console.warn("发布H5，需要在uniCloud后台操作，绑定安全域名，否则会因为跨域问题而无法访问。教程参考：https://uniapp.dcloud.io/uniCloud/quickstart?id=useinh5");var t = e.data && e.data.header && e.data.header["x-serverless-request-id"] || e.header && e.header["request-id"];if (!e.statusCode || e.statusCode >= 400) return s(new A({ code: "SYS_ERR", message: e.errMsg || "request:fail", requestId: t }));var r = e.data;if (r.error) return s(new A({ code: r.error.code, message: r.error.message, requestId: t }));r.result = r.data, r.requestId = t, delete r.data, n(r);} }));});} };var E = { request: function request(e) {return uni.request(e);}, uploadFile: function uploadFile(e) {return uni.uploadFile(e);}, setStorageSync: function setStorageSync(e, t) {return uni.setStorageSync(e, t);}, getStorageSync: function getStorageSync(e) {return uni.getStorageSync(e);}, removeStorageSync: function removeStorageSync(e) {return uni.removeStorageSync(e);}, clearStorageSync: function clearStorageSync() {return uni.clearStorageSync();} },O = { "uniCloud.init.paramRequired": "{param} required", "uniCloud.uploadFile.fileError": "filePath should be instance of File" };var _e3 = (0, _uniI18n.initVueI18n)({ "zh-Hans": { "uniCloud.init.paramRequired": "缺少参数：{param}", "uniCloud.uploadFile.fileError": "filePath应为File对象" }, "zh-Hant": { "uniCloud.init.paramRequired": "缺少参数：{param}", "uniCloud.uploadFile.fileError": "filePath应为File对象" }, en: O, fr: { "uniCloud.init.paramRequired": "{param} required", "uniCloud.uploadFile.fileError": "filePath should be instance of File" }, es: { "uniCloud.init.paramRequired": "{param} required", "uniCloud.uploadFile.fileError": "filePath should be instance of File" }, ja: O }, "zh-Hans"),C = _e3.t;var U = /*#__PURE__*/function () {function U(e) {_classCallCheck(this, U);["spaceId", "clientSecret"].forEach(function (t) {if (!Object.prototype.hasOwnProperty.call(e, t)) throw new Error(C("uniCloud.init.paramRequired", { param: t }));}), this.config = Object.assign({}, { endpoint: "https://api.bspapp.com" }, e), this.config.provider = "aliyun", this.config.requestUrl = this.config.endpoint + "/client", this.config.envType = this.config.envType || "public", this.config.accessTokenKey = "access_token_" + this.config.spaceId, this.adapter = E, this._getAccessTokenPromise = null, this._getAccessTokenPromiseStatus = null;}_createClass(U, [{ key: "setAccessToken", value: function setAccessToken(e) {this.accessToken = e;} }, { key: "requestWrapped", value: function requestWrapped(e) {return b.wrappedRequest(e, this.adapter.request);} }, { key: "requestAuth", value: function requestAuth(e) {return this.requestWrapped(e);} }, { key: "request", value: function request(e, t) {var _this4 = this;return Promise.resolve().then(function () {return _this4.hasAccessToken ? t ? _this4.requestWrapped(e) : _this4.requestWrapped(e).catch(function (t) {return new Promise(function (e, n) {!t || "GATEWAY_INVALID_TOKEN" !== t.code && "InvalidParameter.InvalidToken" !== t.code ? n(t) : e();}).then(function () {return _this4.getAccessToken();}).then(function () {var t = _this4.rebuildRequest(e);return _this4.request(t, !0);});}) : _this4.getAccessToken().then(function () {var t = _this4.rebuildRequest(e);return _this4.request(t, !0);});});} }, { key: "rebuildRequest", value: function rebuildRequest(e) {var t = Object.assign({}, e);return t.data.token = this.accessToken, t.header["x-basement-token"] = this.accessToken, t.header["x-serverless-sign"] = b.sign(t.data, this.config.clientSecret), t;} }, { key: "setupRequest", value: function setupRequest(e, t) {var n = Object.assign({}, e, { spaceId: this.config.spaceId, timestamp: Date.now() }),s = { "Content-Type": "application/json" };return "auth" !== t && (n.token = this.accessToken, s["x-basement-token"] = this.accessToken), s["x-serverless-sign"] = b.sign(n, this.config.clientSecret), { url: this.config.requestUrl, method: "POST", data: n, dataType: "json", header: s };} }, { key: "getAccessToken", value: function getAccessToken() {var _this5 = this;if ("pending" === this._getAccessTokenPromiseStatus) return this._getAccessTokenPromise;this._getAccessTokenPromiseStatus = "pending";return this._getAccessTokenPromise = this.requestAuth(this.setupRequest({ method: "serverless.auth.user.anonymousAuthorize", params: "{}" }, "auth")).then(function (e) {return new Promise(function (t, n) {e.result && e.result.accessToken ? (_this5.setAccessToken(e.result.accessToken), _this5._getAccessTokenPromiseStatus = "fulfilled", t(_this5.accessToken)) : (_this5._getAccessTokenPromiseStatus = "rejected", n(new A({ code: "AUTH_FAILED", message: "获取accessToken失败" })));});}, function (e) {return _this5._getAccessTokenPromiseStatus = "rejected", Promise.reject(e);}), this._getAccessTokenPromise;} }, { key: "authorize", value: function authorize() {this.getAccessToken();} }, { key: "callFunction", value: function callFunction(e) {var t = { method: "serverless.function.runtime.invoke", params: JSON.stringify({ functionTarget: e.name, functionArgs: e.data || {} }) };return this.request(this.setupRequest(t));} }, { key: "getOSSUploadOptionsFromPath", value: function getOSSUploadOptionsFromPath(e) {var t = { method: "serverless.file.resource.generateProximalSign", params: JSON.stringify(e) };return this.request(this.setupRequest(t));} }, { key: "uploadFileToOSS", value: function uploadFileToOSS(_ref) {var _this6 = this;var e = _ref.url,t = _ref.formData,n = _ref.name,s = _ref.filePath,r = _ref.fileType,o = _ref.onUploadProgress;return new Promise(function (i, a) {var c = _this6.adapter.uploadFile({ url: e, formData: t, name: n, filePath: s, fileType: r, header: { "X-OSS-server-side-encrpytion": "AES256" }, success: function success(e) {e && e.statusCode < 400 ? i(e) : a(new A({ code: "UPLOAD_FAILED", message: "文件上传失败" }));}, fail: function fail(e) {a(new A({ code: e.code || "UPLOAD_FAILED", message: e.message || e.errMsg || "文件上传失败" }));} });"function" == typeof o && c && "function" == typeof c.onProgressUpdate && c.onProgressUpdate(function (e) {o({ loaded: e.totalBytesSent, total: e.totalBytesExpectedToSend });});});} }, { key: "reportOSSUpload", value: function reportOSSUpload(e) {var t = { method: "serverless.file.resource.report", params: JSON.stringify(e) };return this.request(this.setupRequest(t));} }, { key: "uploadFile", value: function uploadFile(_ref2) {var _this7 = this;var e = _ref2.filePath,t = _ref2.cloudPath,_ref2$fileType = _ref2.fileType,n = _ref2$fileType === void 0 ? "image" : _ref2$fileType,s = _ref2.onUploadProgress,r = _ref2.config;if ("string" !== o(t)) throw new A({ code: "INVALID_PARAM", message: "cloudPath必须为字符串类型" });if (!(t = t.trim())) throw new A({ code: "CLOUDPATH_REQUIRED", message: "cloudPath不可为空" });if (/:\/\//.test(t)) throw new A({ code: "INVALID_PARAM", message: "cloudPath不合法" });var i = r && r.envType || this.config.envType;var a, c;return this.getOSSUploadOptionsFromPath({ env: i, filename: t }).then(function (t) {var r = t.result;a = r.id, c = "https://" + r.cdnDomain + "/" + r.ossPath;var o = { url: "https://" + r.host, formData: { "Cache-Control": "max-age=2592000", "Content-Disposition": "attachment", OSSAccessKeyId: r.accessKeyId, Signature: r.signature, host: r.host, id: a, key: r.ossPath, policy: r.policy, success_action_status: 200 }, fileName: "file", name: "file", filePath: e, fileType: n };return _this7.uploadFileToOSS(Object.assign({}, o, { onUploadProgress: s }));}).then(function () {return _this7.reportOSSUpload({ id: a });}).then(function (t) {return new Promise(function (n, s) {t.success ? n({ success: !0, filePath: e, fileID: c }) : s(new A({ code: "UPLOAD_FAILED", message: "文件上传失败" }));});});} }, { key: "deleteFile", value: function deleteFile(_ref3) {var e = _ref3.fileList;var t = { method: "serverless.file.resource.delete", params: JSON.stringify({ id: e[0] }) };return this.request(this.setupRequest(t));} }, { key: "getTempFileURL", value: function getTempFileURL() {var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},e = _ref4.fileList;return new Promise(function (t, n) {Array.isArray(e) && 0 !== e.length || n(new A({ code: "INVALID_PARAM", message: "fileList的元素必须是非空的字符串" })), t({ fileList: e.map(function (e) {return { fileID: e, tempFileURL: e };}) });});} }, { key: "hasAccessToken", get: function get() {return !!this.accessToken;} }]);return U;}();var x = { init: function init(e) {var t = new U(e),n = { signInAnonymously: function signInAnonymously() {return t.authorize();}, getLoginState: function getLoginState() {return Promise.resolve(!1);} };return t.auth = function () {return n;}, t.customAuth = t.auth, t;} };var D = "undefined" != typeof location && "http:" === location.protocol ? "http:" : "https:";var R;!function (e) {e.local = "local", e.none = "none", e.session = "session";}(R || (R = {}));var q = function q() {};var L = function L() {var e;if (!Promise) {e = function e() {}, e.promise = {};var _t2 = function _t2() {throw new Error('Your Node runtime does support ES6 Promises. Set "global.Promise" to your preferred implementation of promises.');};return Object.defineProperty(e.promise, "then", { get: _t2 }), Object.defineProperty(e.promise, "catch", { get: _t2 }), e;}var t = new Promise(function (t, n) {e = function e(_e4, s) {return _e4 ? n(_e4) : t(s);};});return e.promise = t, e;};function F(e) {return void 0 === e;}function N(e) {return "[object Null]" === Object.prototype.toString.call(e);}var $;function M(e) {var t = (n = e, "[object Array]" === Object.prototype.toString.call(n) ? e : [e]);var n;var _iterator = _createForOfIteratorHelper(t),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var _e5 = _step.value;var _t3 = _e5.isMatch,_n = _e5.genAdapter,_s = _e5.runtime;if (_t3()) return { adapter: _n(), runtime: _s };}} catch (err) {_iterator.e(err);} finally {_iterator.f();}}!function (e) {e.WEB = "web", e.WX_MP = "wx_mp";}($ || ($ = {}));var j = { adapter: null, runtime: void 0 },B = ["anonymousUuidKey"];var K = /*#__PURE__*/function (_q) {_inherits(K, _q);var _super3 = _createSuper(K);function K() {var _this8;_classCallCheck(this, K);_this8 = _super3.call(this), j.adapter.root.tcbObject || (j.adapter.root.tcbObject = {});return _this8;}_createClass(K, [{ key: "setItem", value: function setItem(e, t) {j.adapter.root.tcbObject[e] = t;} }, { key: "getItem", value: function getItem(e) {return j.adapter.root.tcbObject[e];} }, { key: "removeItem", value: function removeItem(e) {delete j.adapter.root.tcbObject[e];} }, { key: "clear", value: function clear() {delete j.adapter.root.tcbObject;} }]);return K;}(q);function H(e, t) {switch (e) {case "local":return t.localStorage || new K();case "none":return new K();default:return t.sessionStorage || new K();}}var W = /*#__PURE__*/function () {function W(e) {_classCallCheck(this, W);if (!this._storage) {this._persistence = j.adapter.primaryStorage || e.persistence, this._storage = H(this._persistence, j.adapter);var _t4 = "access_token_".concat(e.env),_n2 = "access_token_expire_".concat(e.env),_s2 = "refresh_token_".concat(e.env),_r = "anonymous_uuid_".concat(e.env),_o = "login_type_".concat(e.env),_i = "user_info_".concat(e.env);this.keys = { accessTokenKey: _t4, accessTokenExpireKey: _n2, refreshTokenKey: _s2, anonymousUuidKey: _r, loginTypeKey: _o, userInfoKey: _i };}}_createClass(W, [{ key: "updatePersistence", value: function updatePersistence(e) {if (e === this._persistence) return;var t = "local" === this._persistence;this._persistence = e;var n = H(e, j.adapter);for (var _e6 in this.keys) {var _s3 = this.keys[_e6];if (t && B.includes(_e6)) continue;var _r2 = this._storage.getItem(_s3);F(_r2) || N(_r2) || (n.setItem(_s3, _r2), this._storage.removeItem(_s3));}this._storage = n;} }, { key: "setStore", value: function setStore(e, t, n) {if (!this._storage) return;var s = { version: n || "localCachev1", content: t },r = JSON.stringify(s);try {this._storage.setItem(e, r);} catch (e) {throw e;}} }, { key: "getStore", value: function getStore(e, t) {try {if (!this._storage) return;} catch (e) {return "";}t = t || "localCachev1";var n = this._storage.getItem(e);if (!n) return "";if (n.indexOf(t) >= 0) {return JSON.parse(n).content;}return "";} }, { key: "removeStore", value: function removeStore(e) {this._storage.removeItem(e);} }]);return W;}();var z = {},J = {};function V(e) {return z[e];}var Y = function Y(e, t) {_classCallCheck(this, Y);this.data = t || null, this.name = e;};var X = /*#__PURE__*/function (_Y) {_inherits(X, _Y);var _super4 = _createSuper(X);function X(e, t) {var _this9;_classCallCheck(this, X);_this9 = _super4.call(this, "error", { error: e, data: t }), _this9.error = e;return _this9;}return X;}(Y);var G = new ( /*#__PURE__*/function () {function _class() {_classCallCheck(this, _class);this._listeners = {};}_createClass(_class, [{ key: "on", value: function on(e, t) {return function (e, t, n) {n[e] = n[e] || [], n[e].push(t);}(e, t, this._listeners), this;} }, { key: "off", value: function off(e, t) {return function (e, t, n) {if (n && n[e]) {var _s4 = n[e].indexOf(t);-1 !== _s4 && n[e].splice(_s4, 1);}}(e, t, this._listeners), this;} }, { key: "fire", value: function fire(e, t) {if (e instanceof X) return console.error(e.error), this;var n = "string" == typeof e ? new Y(e, t || {}) : e;var s = n.name;if (this._listens(s)) {n.target = this;var _e7 = this._listeners[s] ? _toConsumableArray(this._listeners[s]) : [];var _iterator2 = _createForOfIteratorHelper(_e7),_step2;try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {var _t5 = _step2.value;_t5.call(this, n);}} catch (err) {_iterator2.e(err);} finally {_iterator2.f();}}return this;} }, { key: "_listens", value: function _listens(e) {return this._listeners[e] && this._listeners[e].length > 0;} }]);return _class;}())();function Q(e, t) {G.on(e, t);}function Z(e) {var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};G.fire(e, t);}function ee(e, t) {G.off(e, t);}var te = "loginStateChanged",ne = "loginStateExpire",se = "loginTypeChanged",re = "anonymousConverted",oe = "refreshAccessToken";var ie;!function (e) {e.ANONYMOUS = "ANONYMOUS", e.WECHAT = "WECHAT", e.WECHAT_PUBLIC = "WECHAT-PUBLIC", e.WECHAT_OPEN = "WECHAT-OPEN", e.CUSTOM = "CUSTOM", e.EMAIL = "EMAIL", e.USERNAME = "USERNAME", e.NULL = "NULL";}(ie || (ie = {}));var ae = ["auth.getJwt", "auth.logout", "auth.signInWithTicket", "auth.signInAnonymously", "auth.signIn", "auth.fetchAccessTokenWithRefreshToken", "auth.signUpWithEmailAndPassword", "auth.activateEndUserMail", "auth.sendPasswordResetEmail", "auth.resetPasswordWithToken", "auth.isUsernameRegistered"],ce = { "X-SDK-Version": "1.3.5" };function ue(e, t, n) {var s = e[t];e[t] = function (t) {var r = {},o = {};n.forEach(function (n) {var _n$call = n.call(e, t),s = _n$call.data,i = _n$call.headers;Object.assign(r, s), Object.assign(o, i);});var i = t.data;return i && function () {var e;if (e = i, "[object FormData]" !== Object.prototype.toString.call(e)) t.data = _objectSpread(_objectSpread({}, i), r);else for (var _e8 in r) {i.append(_e8, r[_e8]);}}(), t.headers = _objectSpread(_objectSpread({}, t.headers || {}), o), s.call(e, t);};}function he() {var e = Math.random().toString(16).slice(2);return { data: { seqId: e }, headers: _objectSpread(_objectSpread({}, ce), {}, { "x-seqid": e }) };}var le = /*#__PURE__*/function () {function le() {var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};_classCallCheck(this, le);var t;this.config = e, this._reqClass = new j.adapter.reqClass({ timeout: this.config.timeout, timeoutMsg: "\u8BF7\u6C42\u5728".concat(this.config.timeout / 1e3, "s\u5185\u672A\u5B8C\u6210\uFF0C\u5DF2\u4E2D\u65AD"), restrictedMethods: ["post"] }), this._cache = V(this.config.env), this._localCache = (t = this.config.env, J[t]), ue(this._reqClass, "post", [he]), ue(this._reqClass, "upload", [he]), ue(this._reqClass, "download", [he]);}_createClass(le, [{ key: "post", value: function () {var _post = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee(e) {return _regenerator.default.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return this._reqClass.post(e);case 2:return _context.abrupt("return", _context.sent);case 3:case "end":return _context.stop();}}}, _callee, this);}));function post(_x) {return _post.apply(this, arguments);}return post;}() }, { key: "upload", value: function () {var _upload = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee2(e) {return _regenerator.default.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.next = 2;return this._reqClass.upload(e);case 2:return _context2.abrupt("return", _context2.sent);case 3:case "end":return _context2.stop();}}}, _callee2, this);}));function upload(_x2) {return _upload.apply(this, arguments);}return upload;}() }, { key: "download", value: function () {var _download = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee3(e) {return _regenerator.default.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:_context3.next = 2;return this._reqClass.download(e);case 2:return _context3.abrupt("return", _context3.sent);case 3:case "end":return _context3.stop();}}}, _callee3, this);}));function download(_x3) {return _download.apply(this, arguments);}return download;}() }, { key: "refreshAccessToken", value: function () {var _refreshAccessToken2 = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee4() {var e, t;return _regenerator.default.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:this._refreshAccessTokenPromise || (this._refreshAccessTokenPromise = this._refreshAccessToken());_context4.prev = 1;_context4.next = 4;return this._refreshAccessTokenPromise;case 4:e = _context4.sent;_context4.next = 10;break;case 7:_context4.prev = 7;_context4.t0 = _context4["catch"](1);t = _context4.t0;case 10:if (!(this._refreshAccessTokenPromise = null, this._shouldRefreshAccessTokenHook = null, t)) {_context4.next = 12;break;}throw t;case 12:return _context4.abrupt("return", e);case 13:case "end":return _context4.stop();}}}, _callee4, this, [[1, 7]]);}));function refreshAccessToken() {return _refreshAccessToken2.apply(this, arguments);}return refreshAccessToken;}() }, { key: "_refreshAccessToken", value: function () {var _refreshAccessToken3 = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee5() {var _this$_cache$keys, e, t, n, s, r, o, i, a, _e9, _e10, _t6, _s5;return _regenerator.default.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:_this$_cache$keys = this._cache.keys, e = _this$_cache$keys.accessTokenKey, t = _this$_cache$keys.accessTokenExpireKey, n = _this$_cache$keys.refreshTokenKey, s = _this$_cache$keys.loginTypeKey, r = _this$_cache$keys.anonymousUuidKey;this._cache.removeStore(e), this._cache.removeStore(t);o = this._cache.getStore(n);if (o) {_context5.next = 5;break;}throw new Error("未登录CloudBase");case 5:i = { refresh_token: o };_context5.next = 8;return this.request("auth.fetchAccessTokenWithRefreshToken", i);case 8:a = _context5.sent;if (!a.data.code) {_context5.next = 21;break;}_e9 = a.data.code;if (!("SIGN_PARAM_INVALID" === _e9 || "REFRESH_TOKEN_EXPIRED" === _e9 || "INVALID_REFRESH_TOKEN" === _e9)) {_context5.next = 20;break;}if (!(this._cache.getStore(s) === ie.ANONYMOUS && "INVALID_REFRESH_TOKEN" === _e9)) {_context5.next = 19;break;}_e10 = this._cache.getStore(r);_t6 = this._cache.getStore(n);_context5.next = 17;return this.send("auth.signInAnonymously", { anonymous_uuid: _e10, refresh_token: _t6 });case 17:_s5 = _context5.sent;return _context5.abrupt("return", (this.setRefreshToken(_s5.refresh_token), this._refreshAccessToken()));case 19:Z(ne), this._cache.removeStore(n);case 20:throw new Error("\u5237\u65B0access token\u5931\u8D25\uFF1A".concat(a.data.code));case 21:if (!a.data.access_token) {_context5.next = 23;break;}return _context5.abrupt("return", (Z(oe), this._cache.setStore(e, a.data.access_token), this._cache.setStore(t, a.data.access_token_expire + Date.now()), { accessToken: a.data.access_token, accessTokenExpire: a.data.access_token_expire }));case 23:a.data.refresh_token && (this._cache.removeStore(n), this._cache.setStore(n, a.data.refresh_token), this._refreshAccessToken());case 24:case "end":return _context5.stop();}}}, _callee5, this);}));function _refreshAccessToken() {return _refreshAccessToken3.apply(this, arguments);}return _refreshAccessToken;}() }, { key: "getAccessToken", value: function () {var _getAccessToken = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee6() {var _this$_cache$keys2, e, t, n, s, r, o;return _regenerator.default.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:_this$_cache$keys2 = this._cache.keys, e = _this$_cache$keys2.accessTokenKey, t = _this$_cache$keys2.accessTokenExpireKey, n = _this$_cache$keys2.refreshTokenKey;if (this._cache.getStore(n)) {_context6.next = 3;break;}throw new Error("refresh token不存在，登录状态异常");case 3:s = this._cache.getStore(e), r = this._cache.getStore(t), o = !0;_context6.t0 = this._shouldRefreshAccessTokenHook;if (!_context6.t0) {_context6.next = 9;break;}_context6.next = 8;return this._shouldRefreshAccessTokenHook(s, r);case 8:_context6.t0 = !_context6.sent;case 9:_context6.t1 = _context6.t0;if (!_context6.t1) {_context6.next = 12;break;}o = !1;case 12:return _context6.abrupt("return", (!s || !r || r < Date.now()) && o ? this.refreshAccessToken() : { accessToken: s, accessTokenExpire: r });case 13:case "end":return _context6.stop();}}}, _callee6, this);}));function getAccessToken() {return _getAccessToken.apply(this, arguments);}return getAccessToken;}() }, { key: "request", value: function () {var _request = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee7(e, t, n) {var s, r, o, _e11, i, _e12, _e13, a, c, u, h, l, d, f, p, g;return _regenerator.default.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:s = "x-tcb-trace_".concat(this.config.env);r = "application/x-www-form-urlencoded";o = _objectSpread({ action: e, env: this.config.env, dataVersion: "2019-08-16" }, t);if (!(-1 === ae.indexOf(e))) {_context7.next = 10;break;}_e11 = this._cache.keys.refreshTokenKey;_context7.t0 = this._cache.getStore(_e11);if (!_context7.t0) {_context7.next = 10;break;}_context7.next = 9;return this.getAccessToken();case 9:o.access_token = _context7.sent.accessToken;case 10:if ("storage.uploadFile" === e) {i = new FormData();for (_e12 in i) {i.hasOwnProperty(_e12) && void 0 !== i[_e12] && i.append(_e12, o[_e12]);}r = "multipart/form-data";} else {r = "application/json", i = {};for (_e13 in o) {void 0 !== o[_e13] && (i[_e13] = o[_e13]);}}a = { headers: { "content-type": r } };n && n.onUploadProgress && (a.onUploadProgress = n.onUploadProgress);c = this._localCache.getStore(s);c && (a.headers["X-TCB-Trace"] = c);u = t.parse, h = t.inQuery, l = t.search;d = { env: this.config.env };u && (d.parse = !0), h && (d = _objectSpread(_objectSpread({}, h), d));f = function (e, t) {var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};var s = /\?/.test(t);var r = "";for (var _e14 in n) {"" === r ? !s && (t += "?") : r += "&", r += "".concat(_e14, "=").concat(encodeURIComponent(n[_e14]));}return /^http(s)?\:\/\//.test(t += r) ? t : "".concat(e).concat(t);}(D, "//tcb-api.tencentcloudapi.com/web", d);l && (f += l);_context7.next = 22;return this.post(_objectSpread({ url: f, data: i }, a));case 22:p = _context7.sent;g = p.header && p.header["x-tcb-trace"];if (!(g && this._localCache.setStore(s, g), 200 !== Number(p.status) && 200 !== Number(p.statusCode) || !p.data)) {_context7.next = 26;break;}throw new Error("network request error");case 26:return _context7.abrupt("return", p);case 27:case "end":return _context7.stop();}}}, _callee7, this);}));function request(_x4, _x5, _x6) {return _request.apply(this, arguments);}return request;}() }, { key: "send", value: function () {var _send = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee8(e) {var t,n,_n3,_args8 = arguments;return _regenerator.default.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:t = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};_context8.next = 3;return this.request(e, t, { onUploadProgress: t.onUploadProgress });case 3:n = _context8.sent;if (!("ACCESS_TOKEN_EXPIRED" === n.data.code && -1 === ae.indexOf(e))) {_context8.next = 13;break;}_context8.next = 7;return this.refreshAccessToken();case 7:_context8.next = 9;return this.request(e, t, { onUploadProgress: t.onUploadProgress });case 9:_n3 = _context8.sent;if (!_n3.data.code) {_context8.next = 12;break;}throw new Error("[".concat(_n3.data.code, "] ").concat(_n3.data.message));case 12:return _context8.abrupt("return", _n3.data);case 13:if (!n.data.code) {_context8.next = 15;break;}throw new Error("[".concat(n.data.code, "] ").concat(n.data.message));case 15:return _context8.abrupt("return", n.data);case 16:case "end":return _context8.stop();}}}, _callee8, this);}));function send(_x7) {return _send.apply(this, arguments);}return send;}() }, { key: "setRefreshToken", value: function setRefreshToken(e) {var _this$_cache$keys3 = this._cache.keys,t = _this$_cache$keys3.accessTokenKey,n = _this$_cache$keys3.accessTokenExpireKey,s = _this$_cache$keys3.refreshTokenKey;this._cache.removeStore(t), this._cache.removeStore(n), this._cache.setStore(s, e);} }]);return le;}();var de = {};function fe(e) {return de[e];}var pe = /*#__PURE__*/function () {function pe(e) {_classCallCheck(this, pe);this.config = e, this._cache = V(e.env), this._request = fe(e.env);}_createClass(pe, [{ key: "setRefreshToken", value: function setRefreshToken(e) {var _this$_cache$keys4 = this._cache.keys,t = _this$_cache$keys4.accessTokenKey,n = _this$_cache$keys4.accessTokenExpireKey,s = _this$_cache$keys4.refreshTokenKey;this._cache.removeStore(t), this._cache.removeStore(n), this._cache.setStore(s, e);} }, { key: "setAccessToken", value: function setAccessToken(e, t) {var _this$_cache$keys5 = this._cache.keys,n = _this$_cache$keys5.accessTokenKey,s = _this$_cache$keys5.accessTokenExpireKey;this._cache.setStore(n, e), this._cache.setStore(s, t);} }, { key: "refreshUserInfo", value: function () {var _refreshUserInfo = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee9() {var _yield$this$_request$, e;return _regenerator.default.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:_context9.next = 2;return this._request.send("auth.getUserInfo", {});case 2:_yield$this$_request$ = _context9.sent;e = _yield$this$_request$.data;return _context9.abrupt("return", (this.setLocalUserInfo(e), e));case 5:case "end":return _context9.stop();}}}, _callee9, this);}));function refreshUserInfo() {return _refreshUserInfo.apply(this, arguments);}return refreshUserInfo;}() }, { key: "setLocalUserInfo", value: function setLocalUserInfo(e) {var t = this._cache.keys.userInfoKey;this._cache.setStore(t, e);} }]);return pe;}();var ge = /*#__PURE__*/function () {function ge(e) {_classCallCheck(this, ge);if (!e) throw new Error("envId is not defined");this._envId = e, this._cache = V(this._envId), this._request = fe(this._envId), this.setUserInfo();}_createClass(ge, [{ key: "linkWithTicket", value: function linkWithTicket(e) {if ("string" != typeof e) throw new Error("ticket must be string");return this._request.send("auth.linkWithTicket", { ticket: e });} }, { key: "linkWithRedirect", value: function linkWithRedirect(e) {e.signInWithRedirect();} }, { key: "updatePassword", value: function updatePassword(e, t) {return this._request.send("auth.updatePassword", { oldPassword: t, newPassword: e });} }, { key: "updateEmail", value: function updateEmail(e) {return this._request.send("auth.updateEmail", { newEmail: e });} }, { key: "updateUsername", value: function updateUsername(e) {if ("string" != typeof e) throw new Error("username must be a string");return this._request.send("auth.updateUsername", { username: e });} }, { key: "getLinkedUidList", value: function () {var _getLinkedUidList = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee10() {var _yield$this$_request$2, e, t, n;return _regenerator.default.wrap(function _callee10$(_context10) {while (1) {switch (_context10.prev = _context10.next) {case 0:_context10.next = 2;return this._request.send("auth.getLinkedUidList", {});case 2:_yield$this$_request$2 = _context10.sent;e = _yield$this$_request$2.data;t = !1;n = e.users;return _context10.abrupt("return", (n.forEach(function (e) {e.wxOpenId && e.wxPublicId && (t = !0);}), { users: n, hasPrimaryUid: t }));case 7:case "end":return _context10.stop();}}}, _callee10, this);}));function getLinkedUidList() {return _getLinkedUidList.apply(this, arguments);}return getLinkedUidList;}() }, { key: "setPrimaryUid", value: function setPrimaryUid(e) {return this._request.send("auth.setPrimaryUid", { uid: e });} }, { key: "unlink", value: function unlink(e) {return this._request.send("auth.unlink", { platform: e });} }, { key: "update", value: function () {var _update = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee11(e) {var t, n, s, r, o, i, _yield$this$_request$3, a;return _regenerator.default.wrap(function _callee11$(_context11) {while (1) {switch (_context11.prev = _context11.next) {case 0:t = e.nickName;n = e.gender;s = e.avatarUrl;r = e.province;o = e.country;i = e.city;_context11.next = 8;return this._request.send("auth.updateUserInfo", { nickName: t, gender: n, avatarUrl: s, province: r, country: o, city: i });case 8:_yield$this$_request$3 = _context11.sent;a = _yield$this$_request$3.data;this.setLocalUserInfo(a);case 11:case "end":return _context11.stop();}}}, _callee11, this);}));function update(_x8) {return _update.apply(this, arguments);}return update;}() }, { key: "refresh", value: function () {var _refresh = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee12() {var _yield$this$_request$4, e;return _regenerator.default.wrap(function _callee12$(_context12) {while (1) {switch (_context12.prev = _context12.next) {case 0:_context12.next = 2;return this._request.send("auth.getUserInfo", {});case 2:_yield$this$_request$4 = _context12.sent;e = _yield$this$_request$4.data;return _context12.abrupt("return", (this.setLocalUserInfo(e), e));case 5:case "end":return _context12.stop();}}}, _callee12, this);}));function refresh() {return _refresh.apply(this, arguments);}return refresh;}() }, { key: "setUserInfo", value: function setUserInfo() {var _this10 = this;var e = this._cache.keys.userInfoKey,t = this._cache.getStore(e);["uid", "loginType", "openid", "wxOpenId", "wxPublicId", "unionId", "qqMiniOpenId", "email", "hasPassword", "customUserId", "nickName", "gender", "avatarUrl"].forEach(function (e) {_this10[e] = t[e];}), this.location = { country: t.country, province: t.province, city: t.city };} }, { key: "setLocalUserInfo", value: function setLocalUserInfo(e) {var t = this._cache.keys.userInfoKey;this._cache.setStore(t, e), this.setUserInfo();} }]);return ge;}();var me = /*#__PURE__*/function () {function me(e) {_classCallCheck(this, me);if (!e) throw new Error("envId is not defined");this._cache = V(e);var _this$_cache$keys6 = this._cache.keys,t = _this$_cache$keys6.refreshTokenKey,n = _this$_cache$keys6.accessTokenKey,s = _this$_cache$keys6.accessTokenExpireKey,r = this._cache.getStore(t),o = this._cache.getStore(n),i = this._cache.getStore(s);this.credential = { refreshToken: r, accessToken: o, accessTokenExpire: i }, this.user = new ge(e);}_createClass(me, [{ key: "isAnonymousAuth", get: function get() {return this.loginType === ie.ANONYMOUS;} }, { key: "isCustomAuth", get: function get() {return this.loginType === ie.CUSTOM;} }, { key: "isWeixinAuth", get: function get() {return this.loginType === ie.WECHAT || this.loginType === ie.WECHAT_OPEN || this.loginType === ie.WECHAT_PUBLIC;} }, { key: "loginType", get: function get() {return this._cache.getStore(this._cache.keys.loginTypeKey);} }]);return me;}();var ye = /*#__PURE__*/function (_pe) {_inherits(ye, _pe);var _super5 = _createSuper(ye);function ye() {_classCallCheck(this, ye);return _super5.apply(this, arguments);}_createClass(ye, [{ key: "signIn", value: function () {var _signIn = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee13() {var _this$_cache$keys7, e, t, n, s, r, _e15;return _regenerator.default.wrap(function _callee13$(_context13) {while (1) {switch (_context13.prev = _context13.next) {case 0:this._cache.updatePersistence("local");_this$_cache$keys7 = this._cache.keys;e = _this$_cache$keys7.anonymousUuidKey;t = _this$_cache$keys7.refreshTokenKey;n = this._cache.getStore(e) || void 0;s = this._cache.getStore(t) || void 0;_context13.next = 8;return this._request.send("auth.signInAnonymously", { anonymous_uuid: n, refresh_token: s });case 8:r = _context13.sent;if (!(r.uuid && r.refresh_token)) {_context13.next = 20;break;}this._setAnonymousUUID(r.uuid);this.setRefreshToken(r.refresh_token);_context13.next = 14;return this._request.refreshAccessToken();case 14:Z(te);Z(se, { env: this.config.env, loginType: ie.ANONYMOUS, persistence: "local" });_e15 = new me(this.config.env);_context13.next = 19;return _e15.user.refresh();case 19:return _context13.abrupt("return", _e15);case 20:throw new Error("匿名登录失败");case 21:case "end":return _context13.stop();}}}, _callee13, this);}));function signIn() {return _signIn.apply(this, arguments);}return signIn;}() }, { key: "linkAndRetrieveDataWithTicket", value: function () {var _linkAndRetrieveDataWithTicket = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee14(e) {var _this$_cache$keys8, t, n, s, r, o;return _regenerator.default.wrap(function _callee14$(_context14) {while (1) {switch (_context14.prev = _context14.next) {case 0:_this$_cache$keys8 = this._cache.keys;t = _this$_cache$keys8.anonymousUuidKey;n = _this$_cache$keys8.refreshTokenKey;s = this._cache.getStore(t);r = this._cache.getStore(n);_context14.next = 7;return this._request.send("auth.linkAndRetrieveDataWithTicket", { anonymous_uuid: s, refresh_token: r, ticket: e });case 7:o = _context14.sent;if (!o.refresh_token) {_context14.next = 16;break;}this._clearAnonymousUUID();this.setRefreshToken(o.refresh_token);_context14.next = 13;return this._request.refreshAccessToken();case 13:Z(re, { env: this.config.env });Z(se, { loginType: ie.CUSTOM, persistence: "local" });return _context14.abrupt("return", { credential: { refreshToken: o.refresh_token } });case 16:throw new Error("匿名转化失败");case 17:case "end":return _context14.stop();}}}, _callee14, this);}));function linkAndRetrieveDataWithTicket(_x9) {return _linkAndRetrieveDataWithTicket.apply(this, arguments);}return linkAndRetrieveDataWithTicket;}() }, { key: "_setAnonymousUUID", value: function _setAnonymousUUID(e) {var _this$_cache$keys9 = this._cache.keys,t = _this$_cache$keys9.anonymousUuidKey,n = _this$_cache$keys9.loginTypeKey;this._cache.removeStore(t), this._cache.setStore(t, e), this._cache.setStore(n, ie.ANONYMOUS);} }, { key: "_clearAnonymousUUID", value: function _clearAnonymousUUID() {this._cache.removeStore(this._cache.keys.anonymousUuidKey);} }]);return ye;}(pe);var _e = /*#__PURE__*/function (_pe2) {_inherits(_e, _pe2);var _super6 = _createSuper(_e);function _e() {_classCallCheck(this, _e);return _super6.apply(this, arguments);}_createClass(_e, [{ key: "signIn", value: function () {var _signIn2 = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee15(e) {var t, n;return _regenerator.default.wrap(function _callee15$(_context15) {while (1) {switch (_context15.prev = _context15.next) {case 0:if (!("string" != typeof e)) {_context15.next = 2;break;}throw new Error("ticket must be a string");case 2:t = this._cache.keys.refreshTokenKey;_context15.next = 5;return this._request.send("auth.signInWithTicket", { ticket: e, refresh_token: this._cache.getStore(t) || "" });case 5:n = _context15.sent;if (!n.refresh_token) {_context15.next = 15;break;}this.setRefreshToken(n.refresh_token);_context15.next = 10;return this._request.refreshAccessToken();case 10:Z(te);Z(se, { env: this.config.env, loginType: ie.CUSTOM, persistence: this.config.persistence });_context15.next = 14;return this.refreshUserInfo();case 14:return _context15.abrupt("return", new me(this.config.env));case 15:throw new Error("自定义登录失败");case 16:case "end":return _context15.stop();}}}, _callee15, this);}));function signIn(_x10) {return _signIn2.apply(this, arguments);}return signIn;}() }]);return _e;}(pe);var we = /*#__PURE__*/function (_pe3) {_inherits(we, _pe3);var _super7 = _createSuper(we);function we() {_classCallCheck(this, we);return _super7.apply(this, arguments);}_createClass(we, [{ key: "signIn", value: function () {var _signIn3 = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee16(e, t) {var n, s, r, o, i;return _regenerator.default.wrap(function _callee16$(_context16) {while (1) {switch (_context16.prev = _context16.next) {case 0:if (!("string" != typeof e)) {_context16.next = 2;break;}throw new Error("email must be a string");case 2:n = this._cache.keys.refreshTokenKey;_context16.next = 5;return this._request.send("auth.signIn", { loginType: "EMAIL", email: e, password: t, refresh_token: this._cache.getStore(n) || "" });case 5:s = _context16.sent;r = s.refresh_token;o = s.access_token;i = s.access_token_expire;if (!r) {_context16.next = 22;break;}this.setRefreshToken(r);if (!(o && i)) {_context16.next = 15;break;}this.setAccessToken(o, i);_context16.next = 17;break;case 15:_context16.next = 17;return this._request.refreshAccessToken();case 17:_context16.next = 19;return this.refreshUserInfo();case 19:Z(te);Z(se, { env: this.config.env, loginType: ie.EMAIL, persistence: this.config.persistence });return _context16.abrupt("return", new me(this.config.env));case 22:throw s.code ? new Error("\u90AE\u7BB1\u767B\u5F55\u5931\u8D25: [".concat(s.code, "] ").concat(s.message)) : new Error("邮箱登录失败");case 23:case "end":return _context16.stop();}}}, _callee16, this);}));function signIn(_x11, _x12) {return _signIn3.apply(this, arguments);}return signIn;}() }, { key: "activate", value: function () {var _activate = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee17(e) {return _regenerator.default.wrap(function _callee17$(_context17) {while (1) {switch (_context17.prev = _context17.next) {case 0:return _context17.abrupt("return", this._request.send("auth.activateEndUserMail", { token: e }));case 1:case "end":return _context17.stop();}}}, _callee17, this);}));function activate(_x13) {return _activate.apply(this, arguments);}return activate;}() }, { key: "resetPasswordWithToken", value: function () {var _resetPasswordWithToken = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee18(e, t) {return _regenerator.default.wrap(function _callee18$(_context18) {while (1) {switch (_context18.prev = _context18.next) {case 0:return _context18.abrupt("return", this._request.send("auth.resetPasswordWithToken", { token: e, newPassword: t }));case 1:case "end":return _context18.stop();}}}, _callee18, this);}));function resetPasswordWithToken(_x14, _x15) {return _resetPasswordWithToken.apply(this, arguments);}return resetPasswordWithToken;}() }]);return we;}(pe);var ke = /*#__PURE__*/function (_pe4) {_inherits(ke, _pe4);var _super8 = _createSuper(ke);function ke() {_classCallCheck(this, ke);return _super8.apply(this, arguments);}_createClass(ke, [{ key: "signIn", value: function () {var _signIn4 = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee19(e, t) {var n, s, r, o, i;return _regenerator.default.wrap(function _callee19$(_context19) {while (1) {switch (_context19.prev = _context19.next) {case 0:if (!("string" != typeof e)) {_context19.next = 2;break;}throw new Error("username must be a string");case 2:"string" != typeof t && (t = "", console.warn("password is empty"));n = this._cache.keys.refreshTokenKey;_context19.next = 6;return this._request.send("auth.signIn", { loginType: ie.USERNAME, username: e, password: t, refresh_token: this._cache.getStore(n) || "" });case 6:s = _context19.sent;r = s.refresh_token;o = s.access_token_expire;i = s.access_token;if (!r) {_context19.next = 23;break;}this.setRefreshToken(r);if (!(i && o)) {_context19.next = 16;break;}this.setAccessToken(i, o);_context19.next = 18;break;case 16:_context19.next = 18;return this._request.refreshAccessToken();case 18:_context19.next = 20;return this.refreshUserInfo();case 20:Z(te);Z(se, { env: this.config.env, loginType: ie.USERNAME, persistence: this.config.persistence });return _context19.abrupt("return", new me(this.config.env));case 23:throw s.code ? new Error("\u7528\u6237\u540D\u5BC6\u7801\u767B\u5F55\u5931\u8D25: [".concat(s.code, "] ").concat(s.message)) : new Error("用户名密码登录失败");case 24:case "end":return _context19.stop();}}}, _callee19, this);}));function signIn(_x16, _x17) {return _signIn4.apply(this, arguments);}return signIn;}() }]);return ke;}(pe);var Se = /*#__PURE__*/function () {function Se(e) {_classCallCheck(this, Se);this.config = e, this._cache = V(e.env), this._request = fe(e.env), this._onAnonymousConverted = this._onAnonymousConverted.bind(this), this._onLoginTypeChanged = this._onLoginTypeChanged.bind(this), Q(se, this._onLoginTypeChanged);}_createClass(Se, [{ key: "anonymousAuthProvider", value: function anonymousAuthProvider() {return new ye(this.config);} }, { key: "customAuthProvider", value: function customAuthProvider() {return new _e(this.config);} }, { key: "emailAuthProvider", value: function emailAuthProvider() {return new we(this.config);} }, { key: "usernameAuthProvider", value: function usernameAuthProvider() {return new ke(this.config);} }, { key: "signInAnonymously", value: function () {var _signInAnonymously = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee20() {return _regenerator.default.wrap(function _callee20$(_context20) {while (1) {switch (_context20.prev = _context20.next) {case 0:return _context20.abrupt("return", new ye(this.config).signIn());case 1:case "end":return _context20.stop();}}}, _callee20, this);}));function signInAnonymously() {return _signInAnonymously.apply(this, arguments);}return signInAnonymously;}() }, { key: "signInWithEmailAndPassword", value: function () {var _signInWithEmailAndPassword = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee21(e, t) {return _regenerator.default.wrap(function _callee21$(_context21) {while (1) {switch (_context21.prev = _context21.next) {case 0:return _context21.abrupt("return", new we(this.config).signIn(e, t));case 1:case "end":return _context21.stop();}}}, _callee21, this);}));function signInWithEmailAndPassword(_x18, _x19) {return _signInWithEmailAndPassword.apply(this, arguments);}return signInWithEmailAndPassword;}() }, { key: "signInWithUsernameAndPassword", value: function signInWithUsernameAndPassword(e, t) {return new ke(this.config).signIn(e, t);} }, { key: "linkAndRetrieveDataWithTicket", value: function () {var _linkAndRetrieveDataWithTicket2 = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee22(e) {return _regenerator.default.wrap(function _callee22$(_context22) {while (1) {switch (_context22.prev = _context22.next) {case 0:this._anonymousAuthProvider || (this._anonymousAuthProvider = new ye(this.config)), Q(re, this._onAnonymousConverted);_context22.next = 3;return this._anonymousAuthProvider.linkAndRetrieveDataWithTicket(e);case 3:return _context22.abrupt("return", _context22.sent);case 4:case "end":return _context22.stop();}}}, _callee22, this);}));function linkAndRetrieveDataWithTicket(_x20) {return _linkAndRetrieveDataWithTicket2.apply(this, arguments);}return linkAndRetrieveDataWithTicket;}() }, { key: "signOut", value: function () {var _signOut = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee23() {var _this$_cache$keys10, e, t, n, s, r;return _regenerator.default.wrap(function _callee23$(_context23) {while (1) {switch (_context23.prev = _context23.next) {case 0:if (!(this.loginType === ie.ANONYMOUS)) {_context23.next = 2;break;}throw new Error("匿名用户不支持登出操作");case 2:_this$_cache$keys10 = this._cache.keys, e = _this$_cache$keys10.refreshTokenKey, t = _this$_cache$keys10.accessTokenKey, n = _this$_cache$keys10.accessTokenExpireKey, s = this._cache.getStore(e);if (s) {_context23.next = 5;break;}return _context23.abrupt("return");case 5:_context23.next = 7;return this._request.send("auth.logout", { refresh_token: s });case 7:r = _context23.sent;return _context23.abrupt("return", (this._cache.removeStore(e), this._cache.removeStore(t), this._cache.removeStore(n), Z(te), Z(se, { env: this.config.env, loginType: ie.NULL, persistence: this.config.persistence }), r));case 9:case "end":return _context23.stop();}}}, _callee23, this);}));function signOut() {return _signOut.apply(this, arguments);}return signOut;}() }, { key: "signUpWithEmailAndPassword", value: function () {var _signUpWithEmailAndPassword = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee24(e, t) {return _regenerator.default.wrap(function _callee24$(_context24) {while (1) {switch (_context24.prev = _context24.next) {case 0:return _context24.abrupt("return", this._request.send("auth.signUpWithEmailAndPassword", { email: e, password: t }));case 1:case "end":return _context24.stop();}}}, _callee24, this);}));function signUpWithEmailAndPassword(_x21, _x22) {return _signUpWithEmailAndPassword.apply(this, arguments);}return signUpWithEmailAndPassword;}() }, { key: "sendPasswordResetEmail", value: function () {var _sendPasswordResetEmail = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee25(e) {return _regenerator.default.wrap(function _callee25$(_context25) {while (1) {switch (_context25.prev = _context25.next) {case 0:return _context25.abrupt("return", this._request.send("auth.sendPasswordResetEmail", { email: e }));case 1:case "end":return _context25.stop();}}}, _callee25, this);}));function sendPasswordResetEmail(_x23) {return _sendPasswordResetEmail.apply(this, arguments);}return sendPasswordResetEmail;}() }, { key: "onLoginStateChanged", value: function onLoginStateChanged(e) {var _this11 = this;Q(te, function () {var t = _this11.hasLoginState();e.call(_this11, t);});var t = this.hasLoginState();e.call(this, t);} }, { key: "onLoginStateExpired", value: function onLoginStateExpired(e) {Q(ne, e.bind(this));} }, { key: "onAccessTokenRefreshed", value: function onAccessTokenRefreshed(e) {Q(oe, e.bind(this));} }, { key: "onAnonymousConverted", value: function onAnonymousConverted(e) {Q(re, e.bind(this));} }, { key: "onLoginTypeChanged", value: function onLoginTypeChanged(e) {var _this12 = this;Q(se, function () {var t = _this12.hasLoginState();e.call(_this12, t);});} }, { key: "getAccessToken", value: function () {var _getAccessToken2 = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee26() {return _regenerator.default.wrap(function _callee26$(_context26) {while (1) {switch (_context26.prev = _context26.next) {case 0:_context26.next = 2;return this._request.getAccessToken();case 2:_context26.t0 = _context26.sent.accessToken;_context26.t1 = this.config.env;return _context26.abrupt("return", { accessToken: _context26.t0, env: _context26.t1 });case 5:case "end":return _context26.stop();}}}, _callee26, this);}));function getAccessToken() {return _getAccessToken2.apply(this, arguments);}return getAccessToken;}() }, { key: "hasLoginState", value: function hasLoginState() {var e = this._cache.keys.refreshTokenKey;return this._cache.getStore(e) ? new me(this.config.env) : null;} }, { key: "isUsernameRegistered", value: function () {var _isUsernameRegistered = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee27(e) {var _yield$this$_request$5, t;return _regenerator.default.wrap(function _callee27$(_context27) {while (1) {switch (_context27.prev = _context27.next) {case 0:if (!("string" != typeof e)) {_context27.next = 2;break;}throw new Error("username must be a string");case 2:_context27.next = 4;return this._request.send("auth.isUsernameRegistered", { username: e });case 4:_yield$this$_request$5 = _context27.sent;t = _yield$this$_request$5.data;return _context27.abrupt("return", t && t.isRegistered);case 7:case "end":return _context27.stop();}}}, _callee27, this);}));function isUsernameRegistered(_x24) {return _isUsernameRegistered.apply(this, arguments);}return isUsernameRegistered;}() }, { key: "getLoginState", value: function getLoginState() {return Promise.resolve(this.hasLoginState());} }, { key: "signInWithTicket", value: function () {var _signInWithTicket = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee28(e) {return _regenerator.default.wrap(function _callee28$(_context28) {while (1) {switch (_context28.prev = _context28.next) {case 0:return _context28.abrupt("return", new _e(this.config).signIn(e));case 1:case "end":return _context28.stop();}}}, _callee28, this);}));function signInWithTicket(_x25) {return _signInWithTicket.apply(this, arguments);}return signInWithTicket;}() }, { key: "shouldRefreshAccessToken", value: function shouldRefreshAccessToken(e) {this._request._shouldRefreshAccessTokenHook = e.bind(this);} }, { key: "getUserInfo", value: function getUserInfo() {return this._request.send("auth.getUserInfo", {}).then(function (e) {return e.code ? e : _objectSpread(_objectSpread({}, e.data), {}, { requestId: e.seqId });});} }, { key: "getAuthHeader", value: function getAuthHeader() {var _this$_cache$keys11 = this._cache.keys,e = _this$_cache$keys11.refreshTokenKey,t = _this$_cache$keys11.accessTokenKey,n = this._cache.getStore(e);return { "x-cloudbase-credentials": this._cache.getStore(t) + "/@@/" + n };} }, { key: "_onAnonymousConverted", value: function _onAnonymousConverted(e) {var t = e.data.env;t === this.config.env && this._cache.updatePersistence(this.config.persistence);} }, { key: "_onLoginTypeChanged", value: function _onLoginTypeChanged(e) {var _e$data = e.data,t = _e$data.loginType,n = _e$data.persistence,s = _e$data.env;s === this.config.env && (this._cache.updatePersistence(n), this._cache.setStore(this._cache.keys.loginTypeKey, t));} }, { key: "currentUser", get: function get() {var e = this.hasLoginState();return e && e.user || null;} }, { key: "loginType", get: function get() {return this._cache.getStore(this._cache.keys.loginTypeKey);} }]);return Se;}();var ve = function ve(e, t) {t = t || L();var n = fe(this.config.env),s = e.cloudPath,r = e.filePath,o = e.onUploadProgress,_e$fileType = e.fileType,i = _e$fileType === void 0 ? "image" : _e$fileType;return n.send("storage.getUploadMetadata", { path: s }).then(function (e) {var _e$data2 = e.data,a = _e$data2.url,c = _e$data2.authorization,u = _e$data2.token,h = _e$data2.fileId,l = _e$data2.cosFileId,d = e.requestId,f = { key: s, signature: c, "x-cos-meta-fileid": l, success_action_status: "201", "x-cos-security-token": u };n.upload({ url: a, data: f, file: r, name: s, fileType: i, onUploadProgress: o }).then(function (e) {201 === e.statusCode ? t(null, { fileID: h, requestId: d }) : t(new Error("STORAGE_REQUEST_FAIL: ".concat(e.data)));}).catch(function (e) {t(e);});}).catch(function (e) {t(e);}), t.promise;},Te = function Te(e, t) {t = t || L();var n = fe(this.config.env),s = e.cloudPath;return n.send("storage.getUploadMetadata", { path: s }).then(function (e) {t(null, e);}).catch(function (e) {t(e);}), t.promise;},Ae = function Ae(_ref5, t) {var e = _ref5.fileList;if (t = t || L(), !e || !Array.isArray(e)) return { code: "INVALID_PARAM", message: "fileList必须是非空的数组" };var _iterator3 = _createForOfIteratorHelper(e),_step3;try {for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {var _t7 = _step3.value;if (!_t7 || "string" != typeof _t7) return { code: "INVALID_PARAM", message: "fileList的元素必须是非空的字符串" };}} catch (err) {_iterator3.e(err);} finally {_iterator3.f();}var n = { fileid_list: e };return fe(this.config.env).send("storage.batchDeleteFile", n).then(function (e) {e.code ? t(null, e) : t(null, { fileList: e.data.delete_list, requestId: e.requestId });}).catch(function (e) {t(e);}), t.promise;},Pe = function Pe(_ref6, t) {var e = _ref6.fileList;t = t || L(), e && Array.isArray(e) || t(null, { code: "INVALID_PARAM", message: "fileList必须是非空的数组" });var n = [];var _iterator4 = _createForOfIteratorHelper(e),_step4;try {for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {var _s6 = _step4.value;"object" == typeof _s6 ? (_s6.hasOwnProperty("fileID") && _s6.hasOwnProperty("maxAge") || t(null, { code: "INVALID_PARAM", message: "fileList的元素必须是包含fileID和maxAge的对象" }), n.push({ fileid: _s6.fileID, max_age: _s6.maxAge })) : "string" == typeof _s6 ? n.push({ fileid: _s6 }) : t(null, { code: "INVALID_PARAM", message: "fileList的元素必须是字符串" });}} catch (err) {_iterator4.e(err);} finally {_iterator4.f();}var s = { file_list: n };return fe(this.config.env).send("storage.batchGetDownloadUrl", s).then(function (e) {e.code ? t(null, e) : t(null, { fileList: e.data.download_list, requestId: e.requestId });}).catch(function (e) {t(e);}), t.promise;},Ie = /*#__PURE__*/function () {var _ref8 = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee29(_ref7, t) {var e, n, s, r;return _regenerator.default.wrap(function _callee29$(_context29) {while (1) {switch (_context29.prev = _context29.next) {case 0:e = _ref7.fileID;_context29.next = 3;return Pe.call(this, { fileList: [{ fileID: e, maxAge: 600 }] });case 3:n = _context29.sent.fileList[0];if (!("SUCCESS" !== n.code)) {_context29.next = 6;break;}return _context29.abrupt("return", t ? t(n) : new Promise(function (e) {e(n);}));case 6:s = fe(this.config.env);r = n.download_url;if (!(r = encodeURI(r), !t)) {_context29.next = 10;break;}return _context29.abrupt("return", s.download({ url: r }));case 10:_context29.t0 = t;_context29.next = 13;return s.download({ url: r });case 13:_context29.t1 = _context29.sent;(0, _context29.t0)(_context29.t1);case 15:case "end":return _context29.stop();}}}, _callee29, this);}));return function Ie(_x26, _x27) {return _ref8.apply(this, arguments);};}(),be = function be(_ref9, o) {var e = _ref9.name,t = _ref9.data,n = _ref9.query,s = _ref9.parse,r = _ref9.search;var i = o || L();var a;try {a = t ? JSON.stringify(t) : "";} catch (e) {return Promise.reject(e);}if (!e) return Promise.reject(new Error("函数名不能为空"));var c = { inQuery: n, parse: s, search: r, function_name: e, request_data: a };return fe(this.config.env).send("functions.invokeFunction", c).then(function (e) {if (e.code) i(null, e);else {var _t8 = e.data.response_data;if (s) i(null, { result: _t8, requestId: e.requestId });else try {_t8 = JSON.parse(e.data.response_data), i(null, { result: _t8, requestId: e.requestId });} catch (e) {i(new Error("response data must be json"));}}return i.promise;}).catch(function (e) {i(e);}), i.promise;},Ee = { timeout: 15e3, persistence: "session" },Oe = {};var Ce = /*#__PURE__*/function () {function Ce(e) {_classCallCheck(this, Ce);this.config = e || this.config, this.authObj = void 0;}_createClass(Ce, [{ key: "init", value: function init(e) {switch (j.adapter || (this.requestClient = new j.adapter.reqClass({ timeout: e.timeout || 5e3, timeoutMsg: "\u8BF7\u6C42\u5728".concat((e.timeout || 5e3) / 1e3, "s\u5185\u672A\u5B8C\u6210\uFF0C\u5DF2\u4E2D\u65AD") })), this.config = _objectSpread(_objectSpread({}, Ee), e), !0) {case this.config.timeout > 6e5:console.warn("timeout大于可配置上限[10分钟]，已重置为上限数值"), this.config.timeout = 6e5;break;case this.config.timeout < 100:console.warn("timeout小于可配置下限[100ms]，已重置为下限数值"), this.config.timeout = 100;}return new Ce(this.config);} }, { key: "auth", value: function auth() {var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},e = _ref10.persistence;if (this.authObj) return this.authObj;var t = e || j.adapter.primaryStorage || Ee.persistence;var n;return t !== this.config.persistence && (this.config.persistence = t), function (e) {var t = e.env;z[t] = new W(e), J[t] = new W(_objectSpread(_objectSpread({}, e), {}, { persistence: "local" }));}(this.config), n = this.config, de[n.env] = new le(n), this.authObj = new Se(this.config), this.authObj;} }, { key: "on", value: function on(e, t) {return Q.apply(this, [e, t]);} }, { key: "off", value: function off(e, t) {return ee.apply(this, [e, t]);} }, { key: "callFunction", value: function callFunction(e, t) {return be.apply(this, [e, t]);} }, { key: "deleteFile", value: function deleteFile(e, t) {return Ae.apply(this, [e, t]);} }, { key: "getTempFileURL", value: function getTempFileURL(e, t) {return Pe.apply(this, [e, t]);} }, { key: "downloadFile", value: function downloadFile(e, t) {return Ie.apply(this, [e, t]);} }, { key: "uploadFile", value: function uploadFile(e, t) {return ve.apply(this, [e, t]);} }, { key: "getUploadMetadata", value: function getUploadMetadata(e, t) {return Te.apply(this, [e, t]);} }, { key: "registerExtension", value: function registerExtension(e) {Oe[e.name] = e;} }, { key: "invokeExtension", value: function () {var _invokeExtension = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee30(e, t) {var n;return _regenerator.default.wrap(function _callee30$(_context30) {while (1) {switch (_context30.prev = _context30.next) {case 0:n = Oe[e];if (n) {_context30.next = 3;break;}throw Error("\u6269\u5C55".concat(e, " \u5FC5\u987B\u5148\u6CE8\u518C"));case 3:_context30.next = 5;return n.invoke(t, this);case 5:return _context30.abrupt("return", _context30.sent);case 6:case "end":return _context30.stop();}}}, _callee30, this);}));function invokeExtension(_x28, _x29) {return _invokeExtension.apply(this, arguments);}return invokeExtension;}() }, { key: "useAdapters", value: function useAdapters(e) {var _ref11 = M(e) || {},t = _ref11.adapter,n = _ref11.runtime;t && (j.adapter = t), n && (j.runtime = n);} }]);return Ce;}();var Ue = new Ce();function xe(e, t, n) {void 0 === n && (n = {});var s = /\?/.test(t),r = "";for (var o in n) {"" === r ? !s && (t += "?") : r += "&", r += o + "=" + encodeURIComponent(n[o]);}return /^http(s)?:\/\//.test(t += r) ? t : "" + e + t;}var De = /*#__PURE__*/function () {function De() {_classCallCheck(this, De);}_createClass(De, [{ key: "post", value: function post(e) {var t = e.url,n = e.data,s = e.headers;return new Promise(function (e, r) {E.request({ url: xe("https:", t), data: n, method: "POST", header: s, success: function success(t) {e(t);}, fail: function fail(e) {r(e);} });});} }, { key: "upload", value: function upload(e) {return new Promise(function (t, n) {var s = e.url,r = e.file,o = e.data,i = e.headers,a = e.fileType,c = E.uploadFile({ url: xe("https:", s), name: "file", formData: Object.assign({}, o), filePath: r, fileType: a, header: i, success: function success(e) {var n = { statusCode: e.statusCode, data: e.data || {} };200 === e.statusCode && o.success_action_status && (n.statusCode = parseInt(o.success_action_status, 10)), t(n);}, fail: function fail(e) {u && "mp-alipay" === h && console.warn("支付宝小程序开发工具上传腾讯云时无法准确判断是否上传成功，请使用真机测试"), n(new Error(e.errMsg || "uploadFile:fail"));} });"function" == typeof e.onUploadProgress && c && "function" == typeof c.onProgressUpdate && c.onProgressUpdate(function (t) {e.onUploadProgress({ loaded: t.totalBytesSent, total: t.totalBytesExpectedToSend });});});} }]);return De;}();var Re = { setItem: function setItem(e, t) {E.setStorageSync(e, t);}, getItem: function getItem(e) {return E.getStorageSync(e);}, removeItem: function removeItem(e) {E.removeStorageSync(e);}, clear: function clear() {E.clearStorageSync();} };var qe = { genAdapter: function genAdapter() {return { root: {}, reqClass: De, localStorage: Re, primaryStorage: "local" };}, isMatch: function isMatch() {return !0;}, runtime: "uni_app" };Ue.useAdapters(qe);var Le = Ue,Fe = Le.init;Le.init = function (e) {e.env = e.spaceId;var t = Fe.call(this, e);t.config.provider = "tencent", t.config.spaceId = e.spaceId;var n = t.auth;return t.auth = function (e) {var t = n.call(this, e);return ["linkAndRetrieveDataWithTicket", "signInAnonymously", "signOut", "getAccessToken", "getLoginState", "signInWithTicket", "getUserInfo"].forEach(function (e) {t[e] = T(t[e]).bind(t);}), t;}, t.customAuth = t.auth, t;};var Ne = Le;function $e() {return { token: E.getStorageSync("uni_id_token") || E.getStorageSync("uniIdToken"), tokenExpired: E.getStorageSync("uni_id_token_expired") };}function Me() {if (!u || "h5" !== h) return;uni.getStorageSync("__LAST_DCLOUD_APPID") !== p && (uni.setStorageSync("__LAST_DCLOUD_APPID", p), console.warn("检测到当前项目与上次运行到此端口的项目不一致，自动清理uni-id保存的token信息（仅开发调试时生效）"), E.removeStorageSync("uni_id_token"), E.removeStorageSync("uniIdToken"), E.removeStorageSync("uni_id_token_expired"));}var je = /*#__PURE__*/function (_U) {_inherits(je, _U);var _super9 = _createSuper(je);function je() {_classCallCheck(this, je);return _super9.apply(this, arguments);}_createClass(je, [{ key: "getAccessToken", value: function getAccessToken() {var _this13 = this;return new Promise(function (e, t) {var n = "Anonymous_Access_token";_this13.setAccessToken(n), e(n);});} }, { key: "setupRequest", value: function setupRequest(e, t) {var n = Object.assign({}, e, { spaceId: this.config.spaceId, timestamp: Date.now() }),s = { "Content-Type": "application/json" };"auth" !== t && (n.token = this.accessToken, s["x-basement-token"] = this.accessToken), s["x-serverless-sign"] = b.sign(n, this.config.clientSecret);var r = I();s["x-client-info"] = JSON.stringify(r);var _$e = $e(),o = _$e.token;return s["x-client-token"] = o, { url: this.config.requestUrl, method: "POST", data: n, dataType: "json", header: JSON.parse(JSON.stringify(s)) };} }, { key: "uploadFileToOSS", value: function uploadFileToOSS(_ref12) {var _this14 = this;var e = _ref12.url,t = _ref12.formData,n = _ref12.name,s = _ref12.filePath,r = _ref12.fileType,o = _ref12.onUploadProgress;return new Promise(function (i, a) {var c = _this14.adapter.uploadFile({ url: e, formData: t, name: n, filePath: s, fileType: r, success: function success(e) {e && e.statusCode < 400 ? i(e) : a(new A({ code: "UPLOAD_FAILED", message: "文件上传失败" }));}, fail: function fail(e) {a(new A({ code: e.code || "UPLOAD_FAILED", message: e.message || e.errMsg || "文件上传失败" }));} });"function" == typeof o && c && "function" == typeof c.onProgressUpdate && c.onProgressUpdate(function (e) {o({ loaded: e.totalBytesSent, total: e.totalBytesExpectedToSend });});});} }, { key: "uploadFile", value: function uploadFile(_ref13) {var _this15 = this;var e = _ref13.filePath,t = _ref13.cloudPath,_ref13$fileType = _ref13.fileType,n = _ref13$fileType === void 0 ? "image" : _ref13$fileType,s = _ref13.onUploadProgress;if (!t) throw new A({ code: "CLOUDPATH_REQUIRED", message: "cloudPath不可为空" });var r;return this.getOSSUploadOptionsFromPath({ cloudPath: t }).then(function (t) {var _t$result = t.result,o = _t$result.url,i = _t$result.formData,a = _t$result.name;r = t.result.fileUrl;var c = { url: o, formData: i, name: a, filePath: e, fileType: n };return _this15.uploadFileToOSS(Object.assign({}, c, { onUploadProgress: s }));}).then(function () {return _this15.reportOSSUpload({ cloudPath: t });}).then(function (t) {return new Promise(function (n, s) {t.success ? n({ success: !0, filePath: e, fileID: r }) : s(new A({ code: "UPLOAD_FAILED", message: "文件上传失败" }));});});} }, { key: "deleteFile", value: function deleteFile(_ref14) {var e = _ref14.fileList;var t = { method: "serverless.file.resource.delete", params: JSON.stringify({ fileList: e }) };return this.request(this.setupRequest(t));} }, { key: "getTempFileURL", value: function getTempFileURL() {var _ref15 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},e = _ref15.fileList;var t = { method: "serverless.file.resource.getTempFileURL", params: JSON.stringify({ fileList: e }) };return this.request(this.setupRequest(t));} }]);return je;}(U);var Be = { init: function init(e) {var t = new je(e),n = { signInAnonymously: function signInAnonymously() {return t.authorize();}, getLoginState: function getLoginState() {return Promise.resolve(!1);} };return t.auth = function () {return n;}, t.customAuth = t.auth, t;} };function Ke(_ref16) {var e = _ref16.data;var t;t = I();var n = JSON.parse(JSON.stringify(e || {}));if (Object.assign(n, { clientInfo: t }), !n.uniIdToken) {var _$e2 = $e(),_e16 = _$e2.token;_e16 && (n.uniIdToken = _e16);}return n;}function He(_ref17) {var _this16 = this;var e = _ref17.name,t = _ref17.data;var n = this.localAddress,s = this.localPort,r = { aliyun: "aliyun", tencent: "tcb" }[this.config.provider],o = this.config.spaceId,i = "http://".concat(n, ":").concat(s, "/system/check-function"),a = "http://".concat(n, ":").concat(s, "/cloudfunctions/").concat(e);return new Promise(function (t, n) {E.request({ method: "POST", url: i, data: { name: e, platform: h, provider: r, spaceId: o }, timeout: 3e3, success: function success(e) {t(e);}, fail: function fail() {t({ data: { code: "NETWORK_ERROR", message: "连接本地调试服务失败，请检查客户端是否和主机在同一局域网下，自动切换为已部署的云函数。" } });} });}).then(function () {var _ref18 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},e = _ref18.data;var _ref19 = e || {},t = _ref19.code,n = _ref19.message;return { code: 0 === t ? 0 : t || "SYS_ERR", message: n || "SYS_ERR" };}).then(function (_ref20) {var n = _ref20.code,s = _ref20.message;if (0 !== n) {switch (n) {case "MODULE_ENCRYPTED":console.error("\u6B64\u4E91\u51FD\u6570\uFF08".concat(e, "\uFF09\u4F9D\u8D56\u52A0\u5BC6\u516C\u5171\u6A21\u5757\u4E0D\u53EF\u672C\u5730\u8C03\u8BD5\uFF0C\u81EA\u52A8\u5207\u6362\u4E3A\u4E91\u7AEF\u5DF2\u90E8\u7F72\u7684\u4E91\u51FD\u6570"));break;case "FUNCTION_ENCRYPTED":console.error("\u6B64\u4E91\u51FD\u6570\uFF08".concat(e, "\uFF09\u5DF2\u52A0\u5BC6\u4E0D\u53EF\u672C\u5730\u8C03\u8BD5\uFF0C\u81EA\u52A8\u5207\u6362\u4E3A\u4E91\u7AEF\u5DF2\u90E8\u7F72\u7684\u4E91\u51FD\u6570"));break;case "ACTION_ENCRYPTED":console.error(s || "需要访问加密的uni-clientDB-action，自动切换为云端环境");break;case "NETWORK_ERROR":{var _e17 = "连接本地调试服务失败，请检查客户端是否和主机在同一局域网下";throw console.error(_e17), new Error(_e17);}case "SWITCH_TO_CLOUD":break;default:{var _e18 = "\u68C0\u6D4B\u672C\u5730\u8C03\u8BD5\u670D\u52A1\u51FA\u73B0\u9519\u8BEF\uFF1A".concat(s, "\uFF0C\u8BF7\u68C0\u67E5\u7F51\u7EDC\u73AF\u5883\u6216\u91CD\u542F\u5BA2\u6237\u7AEF\u518D\u8BD5");throw console.error(_e18), new Error(_e18);}}return _this16._originCallFunction({ name: e, data: t });}return new Promise(function (e, n) {var s = Ke.call(_this16, { data: t });E.request({ method: "POST", url: a, data: { provider: r, platform: h, param: s }, success: function success() {var _ref21 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},t = _ref21.statusCode,s = _ref21.data;return !t || t >= 400 ? n(new A({ code: s.code || "SYS_ERR", message: s.message || "request:fail" })) : e({ result: s });}, fail: function fail(e) {n(new A({ code: e.code || e.errCode || "SYS_ERR", message: e.message || e.errMsg || "request:fail" }));} });});});}var We = [{ rule: /fc_function_not_found|FUNCTION_NOT_FOUND/, content: "，云函数[{functionName}]在云端不存在，请检查此云函数名称是否正确以及该云函数是否已上传到服务空间", mode: "append" }];var ze = /[\\^$.*+?()[\]{}|]/g,Je = RegExp(ze.source);function Ve(e, t, n) {return e.replace(new RegExp((s = t) && Je.test(s) ? s.replace(ze, "\\$&") : s, "g"), n);var s;}function Ye(_ref22) {var e = _ref22.functionName,t = _ref22.result,n = _ref22.logPvd;if (this.config.useDebugFunction && t && t.requestId) {var _s7 = JSON.stringify({ spaceId: this.config.spaceId, functionName: e, requestId: t.requestId });console.log("[".concat(n, "-request]").concat(_s7, "[/").concat(n, "-request]"));}}function Xe(e) {var t = e.callFunction,n = function n(_n4) {var _this17 = this;var s = _n4.name;_n4.data = Ke.call(e, { data: _n4.data });var r = { aliyun: "aliyun", tencent: "tcb" }[this.config.provider];return t.call(this, _n4).then(function (e) {return Ye.call(_this17, { functionName: s, result: e, logPvd: r }), Promise.resolve(e);}, function (e) {return Ye.call(_this17, { functionName: s, result: e, logPvd: r }), e && e.message && (e.message = function () {var _ref23 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},_ref23$message = _ref23.message,e = _ref23$message === void 0 ? "" : _ref23$message,_ref23$extraInfo = _ref23.extraInfo,t = _ref23$extraInfo === void 0 ? {} : _ref23$extraInfo,_ref23$formatter = _ref23.formatter,n = _ref23$formatter === void 0 ? [] : _ref23$formatter;for (var _s8 = 0; _s8 < n.length; _s8++) {var _n$_s = n[_s8],_r3 = _n$_s.rule,_o2 = _n$_s.content,i = _n$_s.mode,_a = e.match(_r3);if (!_a) continue;var _c = _o2;for (var _e19 = 1; _e19 < _a.length; _e19++) {_c = Ve(_c, "{$".concat(_e19, "}"), _a[_e19]);}for (var _e20 in t) {_c = Ve(_c, "{".concat(_e20, "}"), t[_e20]);}return "replace" === i ? _c : e + _c;}return e;}({ message: "[".concat(_n4.name, "]: ").concat(e.message), formatter: We, extraInfo: { functionName: s } })), Promise.reject(e);});};e.callFunction = function (t) {var s;return u && e.debugInfo && !e.debugInfo.forceRemote && d ? (e._originCallFunction || (e._originCallFunction = n), s = He.call(this, t)) : s = n.call(this, t), Object.defineProperty(s, "result", { get: function get() {return console.warn("当前返回结果为Promise类型，不可直接访问其result属性，详情请参考：https://uniapp.dcloud.net.cn/uniCloud/faq?id=promise"), {};} }), s;};}var Ge = Symbol("CLIENT_DB_INTERNAL");function Qe(e, t) {return e.then = "DoNotReturnProxyWithAFunctionNamedThen", e._internalType = Ge, e.__ob__ = void 0, new Proxy(e, { get: function get(e, n, s) {if ("_uniClient" === n) return null;if (n in e || "string" != typeof n) {var _t9 = e[n];return "function" == typeof _t9 ? _t9.bind(e) : _t9;}return t.get(e, n, s);} });}function Ze(e) {return { on: function on(t, n) {e[t] = e[t] || [], e[t].indexOf(n) > -1 || e[t].push(n);}, off: function off(t, n) {e[t] = e[t] || [];var s = e[t].indexOf(n);-1 !== s && e[t].splice(s, 1);} };}var et = ["db.Geo", "db.command", "command.aggregate"];function tt(e, t) {return et.indexOf("".concat(e, ".").concat(t)) > -1;}function nt(e) {switch (o(e)) {case "array":return e.map(function (e) {return nt(e);});case "object":return e._internalType === Ge || Object.keys(e).forEach(function (t) {e[t] = nt(e[t]);}), e;case "regexp":return { $regexp: { source: e.source, flags: e.flags } };case "date":return { $date: e.toISOString() };default:return e;}}var st = /*#__PURE__*/function () {function st(e, t, n) {_classCallCheck(this, st);this.content = e, this.prevStage = t || null, this.udb = null, this._database = n;}_createClass(st, [{ key: "toJSON", value: function toJSON() {var e = this;var t = [e.content];for (; e.prevStage;) {e = e.prevStage, t.push(e.content);}return { $db: t.reverse().map(function (e) {return { $method: e.$method, $param: nt(e.$param) };}) };} }, { key: "getAction", value: function getAction() {var e = this.toJSON().$db.find(function (e) {return "action" === e.$method;});return e && e.$param && e.$param[0];} }, { key: "getCommand", value: function getCommand() {return { $db: this.toJSON().$db.filter(function (e) {return "action" !== e.$method;}) };} }, { key: "get", value: function get() {return this._send("get", Array.from(arguments));} }, { key: "add", value: function add() {return this._send("add", Array.from(arguments));} }, { key: "remove", value: function remove() {return this._send("remove", Array.from(arguments));} }, { key: "update", value: function update() {return this._send("update", Array.from(arguments));} }, { key: "end", value: function end() {return this._send("end", Array.from(arguments));} }, { key: "set", value: function set() {throw new Error("clientDB禁止使用set方法");} }, { key: "_send", value: function _send(e, t) {var n = this.getAction(),s = this.getCommand();if (s.$db.push({ $method: e, $param: nt(t) }), u) {var _e21 = s.$db.find(function (e) {return "collection" === e.$method;}),_t10 = _e21 && _e21.$param;_t10 && 1 === _t10.length && "string" == typeof _e21.$param[0] && _e21.$param[0].indexOf(",") > -1 && console.warn("检测到使用JQL语法联表查询时，未使用getTemp先过滤主表数据，在主表数据量大的情况下可能会查询缓慢。\n- 如何优化请参考此文档：https://uniapp.dcloud.net.cn/uniCloud/jql?id=lookup-with-temp \n- 如果主表数据量很小请忽略此信息，项目发行时不会出现此提示。");}return this._database._callCloudFunction({ action: n, command: s });} }, { key: "useAggregate", get: function get() {var e = this,t = !1;for (; e.prevStage;) {e = e.prevStage;var _n5 = e.content.$method;if ("aggregate" === _n5 || "pipeline" === _n5) {t = !0;break;}}return t;} }, { key: "count", get: function get() {if (!this.useAggregate) return function () {return this._send("count", Array.from(arguments));};var e = this;return function () {return rt({ $method: "count", $param: nt(Array.from(arguments)) }, e, this._database);};} }]);return st;}();function rt(e, t, n) {return Qe(new st(e, t, n), { get: function get(e, t) {var s = "db";return e && e.content && (s = e.content.$method), tt(s, t) ? rt({ $method: t }, e, n) : function () {return rt({ $method: t, $param: nt(Array.from(arguments)) }, e, n);};} });}function ot(_ref24) {var e = _ref24.path,t = _ref24.method;return /*#__PURE__*/function () {function _class2() {_classCallCheck(this, _class2);this.param = Array.from(arguments);}_createClass(_class2, [{ key: "toJSON", value: function toJSON() {return { $newDb: [].concat(_toConsumableArray(e.map(function (e) {return { $method: e };})), [{ $method: t, $param: this.param }]) };} }]);return _class2;}();}var it = /*#__PURE__*/function (_ref25) {_inherits(it, _ref25);var _super10 = _createSuper(it);function it() {_classCallCheck(this, it);return _super10.apply(this, arguments);}_createClass(it, [{ key: "_callCloudFunction", value: function _callCloudFunction(_ref26) {var _this18 = this;var e = _ref26.action,t = _ref26.command,n = _ref26.multiCommand,s = _ref26.queryList;function r(e, t) {if (n && s) for (var _n6 = 0; _n6 < s.length; _n6++) {var _r4 = s[_n6];_r4.udb && "function" == typeof _r4.udb.setResult && (t ? _r4.udb.setResult(t) : _r4.udb.setResult(e.result.dataList[_n6]));}}var o = S(v("database", "invoke")),i = this._uniClient;return o.then(function () {return i.callFunction({ name: "DCloud-clientDB", data: { action: e, command: t, multiCommand: n } });}).then(function (e) {var _e$result = e.result,t = _e$result.code,n = _e$result.message,s = _e$result.token,o = _e$result.tokenExpired,_e$result$systemInfo = _e$result.systemInfo,i = _e$result$systemInfo === void 0 ? [] : _e$result$systemInfo;if (i) for (var _e22 = 0; _e22 < i.length; _e22++) {var _i$_e = i[_e22],_t11 = _i$_e.level,_n7 = _i$_e.message,_s9 = _i$_e.detail,_r5 = console["app-plus" === h && "warn" === _t11 ? "error" : _t11] || console.log;var _o3 = "[System Info]" + _n7;_s9 && (_o3 = "".concat(_o3, "\n\u8BE6\u7EC6\u4FE1\u606F\uFF1A").concat(_s9)), _r5(_o3);}if (t) {var _e23 = new a(n, t);return _this18._callback("error", [_e23]), Promise.reject(_e23);}s && o && (!function () {var _ref27 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},e = _ref27.token,t = _ref27.tokenExpired;e && E.setStorageSync("uni_id_token", e), t && E.setStorageSync("uni_id_token_expired", t);}({ token: s, tokenExpired: o }), _this18._callbackAuth("refreshToken", [{ token: s, tokenExpired: o }]), _this18._callback("refreshToken", [{ token: s, tokenExpired: o }]));var c = e.result.affectedDocs;return "number" == typeof c && Object.defineProperty(e.result, "affectedDocs", { get: function get() {return console.warn("affectedDocs不再推荐使用，请使用inserted/deleted/updated/data.length替代"), c;} }), S(v("database", "success"), e).then(function () {return S(v("database", "complete"), e);}).then(function () {return r(e, null), Promise.resolve(e);});}, function (e) {var t = new a(e.message, e.code || "SYSTEM_ERROR");return _this18._callback("error", [t]), /fc_function_not_found|FUNCTION_NOT_FOUND/g.test(e.message) && console.warn("clientDB未初始化，请在web控制台保存一次schema以开启clientDB"), S(v("database", "fail"), e).then(function () {return S(v("database", "complete"), e);}).then(function () {return r(null, e), Promise.reject(e);});});} }]);return it;}( /*#__PURE__*/function () {function _class3() {var _ref28 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},_ref28$uniClient = _ref28.uniClient,e = _ref28$uniClient === void 0 ? {} : _ref28$uniClient;_classCallCheck(this, _class3);this._uniClient = e, this._authCallBacks = {}, this._dbCallBacks = {}, e.isDefault && (this._dbCallBacks = m("_globalUniCloudDatabaseCallback")), this.auth = Ze(this._authCallBacks), Object.assign(this, Ze(this._dbCallBacks)), this.env = Qe({}, { get: function get(e, t) {return { $env: t };} }), this.Geo = Qe({}, { get: function get(e, t) {return ot({ path: ["Geo"], method: t });} }), this.serverDate = ot({ path: [], method: "serverDate" }), this.RegExp = ot({ path: [], method: "RegExp" });}_createClass(_class3, [{ key: "getCloudEnv", value: function getCloudEnv(e) {if ("string" != typeof e || !e.trim()) throw new Error("getCloudEnv参数错误");return { $env: e.replace("$cloudEnv_", "") };} }, { key: "_callback", value: function _callback(e, t) {var n = this._dbCallBacks;n[e] && n[e].forEach(function (e) {e.apply(void 0, _toConsumableArray(t));});} }, { key: "_callbackAuth", value: function _callbackAuth(e, t) {var n = this._authCallBacks;n[e] && n[e].forEach(function (e) {e.apply(void 0, _toConsumableArray(t));});} }, { key: "multiSend", value: function multiSend() {var e = Array.from(arguments),t = e.map(function (e) {var t = e.getAction(),n = e.getCommand();if ("getTemp" !== n.$db[n.$db.length - 1].$method) throw new Error("multiSend只支持子命令内使用getTemp");return { action: t, command: n };});return this._callCloudFunction({ multiCommand: t, queryList: e });} }]);return _class3;}());function at(e) {e.database = function (t) {if (t && Object.keys(t).length > 0) return e.init(t).database();if (this._database) return this._database;var n = function (e) {var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};return Qe(new e(t), { get: function get(e, t) {return tt("db", t) ? rt({ $method: t }, null, e) : function () {return rt({ $method: t, $param: nt(Array.from(arguments)) }, null, e);};} });}(it, { uniClient: e });return this._database = n, n;};}var ct;var ut = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",ht = /^(?:[A-Za-z\d+/]{4})*?(?:[A-Za-z\d+/]{2}(?:==)?|[A-Za-z\d+/]{3}=?)?$/;function lt() {var e = $e().token || "",t = e.split(".");if (!e || 3 !== t.length) return { uid: null, role: [], permission: [], tokenExpired: 0 };var n;try {n = JSON.parse((s = t[1], decodeURIComponent(ct(s).split("").map(function (e) {return "%" + ("00" + e.charCodeAt(0).toString(16)).slice(-2);}).join(""))));} catch (e) {throw new Error("获取当前用户信息出错，详细错误信息为：" + e.message);}var s;return n.tokenExpired = 1e3 * n.exp, delete n.exp, delete n.iat, n;}ct = "function" != typeof atob ? function (e) {if (e = String(e).replace(/[\t\n\f\r ]+/g, ""), !ht.test(e)) throw new Error("Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.");var t;e += "==".slice(2 - (3 & e.length));for (var n, s, r = "", o = 0; o < e.length;) {t = ut.indexOf(e.charAt(o++)) << 18 | ut.indexOf(e.charAt(o++)) << 12 | (n = ut.indexOf(e.charAt(o++))) << 6 | (s = ut.indexOf(e.charAt(o++))), r += 64 === n ? String.fromCharCode(t >> 16 & 255) : 64 === s ? String.fromCharCode(t >> 16 & 255, t >> 8 & 255) : String.fromCharCode(t >> 16 & 255, t >> 8 & 255, 255 & t);}return r;} : atob;var dt = t(n(function (e, t) {Object.defineProperty(t, "__esModule", { value: !0 });var n = "chooseAndUploadFile:ok",s = "chooseAndUploadFile:fail";function r(e, t) {return e.tempFiles.forEach(function (e, n) {e.name || (e.name = e.path.substring(e.path.lastIndexOf("/") + 1)), t && (e.fileType = t), e.cloudPath = Date.now() + "_" + n + e.name.substring(e.name.lastIndexOf("."));}), e.tempFilePaths || (e.tempFilePaths = e.tempFiles.map(function (e) {return e.path;})), e;}function o(e, t, _ref29) {var s = _ref29.onChooseFile,r = _ref29.onUploadProgress;return t.then(function (e) {if (s) {var _t12 = s(e);if (void 0 !== _t12) return Promise.resolve(_t12).then(function (t) {return void 0 === t ? e : t;});}return e;}).then(function (t) {return !1 === t ? { errMsg: n, tempFilePaths: [], tempFiles: [] } : function (e, t) {var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;var r = arguments.length > 3 ? arguments[3] : undefined;(t = Object.assign({}, t)).errMsg = n;var o = t.tempFiles,i = o.length;var a = 0;return new Promise(function (n) {for (; a < s;) {c();}function c() {var s = a++;if (s >= i) return void (!o.find(function (e) {return !e.url && !e.errMsg;}) && n(t));var u = o[s];e.uploadFile({ filePath: u.path, cloudPath: u.cloudPath, fileType: u.fileType, onUploadProgress: function onUploadProgress(e) {e.index = s, e.tempFile = u, e.tempFilePath = u.path, r && r(e);} }).then(function (e) {u.url = e.fileID, s < i && c();}).catch(function (e) {u.errMsg = e.errMsg || e.message, s < i && c();});}});}(e, t, 5, r);});}t.initChooseAndUploadFile = function (e) {return function () {var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { type: "all" };return "image" === t.type ? o(e, function (e) {var t = e.count,n = e.sizeType,_e$sourceType = e.sourceType,o = _e$sourceType === void 0 ? ["album", "camera"] : _e$sourceType,i = e.extension;return new Promise(function (e, a) {uni.chooseImage({ count: t, sizeType: n, sourceType: o, extension: i, success: function success(t) {e(r(t, "image"));}, fail: function fail(e) {a({ errMsg: e.errMsg.replace("chooseImage:fail", s) });} });});}(t), t) : "video" === t.type ? o(e, function (e) {var t = e.camera,n = e.compressed,o = e.maxDuration,_e$sourceType2 = e.sourceType,i = _e$sourceType2 === void 0 ? ["album", "camera"] : _e$sourceType2,a = e.extension;return new Promise(function (e, c) {uni.chooseVideo({ camera: t, compressed: n, maxDuration: o, sourceType: i, extension: a, success: function success(t) {var n = t.tempFilePath,s = t.duration,o = t.size,i = t.height,a = t.width;e(r({ errMsg: "chooseVideo:ok", tempFilePaths: [n], tempFiles: [{ name: t.tempFile && t.tempFile.name || "", path: n, size: o, type: t.tempFile && t.tempFile.type || "", width: a, height: i, duration: s, fileType: "video", cloudPath: "" }] }, "video"));}, fail: function fail(e) {c({ errMsg: e.errMsg.replace("chooseVideo:fail", s) });} });});}(t), t) : o(e, function (e) {var t = e.count,n = e.extension;return new Promise(function (e, o) {var i = uni.chooseFile;if ("undefined" != typeof wx && "function" == typeof wx.chooseMessageFile && (i = wx.chooseMessageFile), "function" != typeof i) return o({ errMsg: s + " 请指定 type 类型，该平台仅支持选择 image 或 video。" });i({ type: "all", count: t, extension: n, success: function success(t) {e(r(t));}, fail: function fail(e) {o({ errMsg: e.errMsg.replace("chooseFile:fail", s) });} });});}(t), t);};};}));var ft = "manual";function pt(e) {return { props: { localdata: { type: Array, default: function _default() {return [];} }, options: { type: [Object, Array], default: function _default() {return {};} }, spaceInfo: { type: Object, default: function _default() {return {};} }, collection: { type: [String, Array], default: "" }, action: { type: String, default: "" }, field: { type: String, default: "" }, orderby: { type: String, default: "" }, where: { type: [String, Object], default: "" }, pageData: { type: String, default: "add" }, pageCurrent: { type: Number, default: 1 }, pageSize: { type: Number, default: 20 }, getcount: { type: [Boolean, String], default: !1 }, gettree: { type: [Boolean, String], default: !1 }, gettreepath: { type: [Boolean, String], default: !1 }, startwith: { type: String, default: "" }, limitlevel: { type: Number, default: 10 }, groupby: { type: String, default: "" }, groupField: { type: String, default: "" }, distinct: { type: [Boolean, String], default: !1 }, foreignKey: { type: String, default: "" }, loadtime: { type: String, default: "auto" }, manual: { type: Boolean, default: !1 } }, data: function data() {return { mixinDatacomLoading: !1, mixinDatacomHasMore: !1, mixinDatacomResData: [], mixinDatacomErrorMessage: "", mixinDatacomPage: {} };}, created: function created() {var _this19 = this;this.mixinDatacomPage = { current: this.pageCurrent, size: this.pageSize, count: 0 }, this.$watch(function () {var e = [];return ["pageCurrent", "pageSize", "localdata", "collection", "action", "field", "orderby", "where", "getont", "getcount", "gettree", "groupby", "groupField", "distinct"].forEach(function (t) {e.push(_this19[t]);}), e;}, function (e, t) {if (_this19.loadtime === ft) return;var n = !1;var s = [];for (var _r6 = 2; _r6 < e.length; _r6++) {e[_r6] !== t[_r6] && (s.push(e[_r6]), n = !0);}e[0] !== t[0] && (_this19.mixinDatacomPage.current = _this19.pageCurrent), _this19.mixinDatacomPage.size = _this19.pageSize, _this19.onMixinDatacomPropsChange(n, s);});}, methods: { onMixinDatacomPropsChange: function onMixinDatacomPropsChange(e, t) {}, mixinDatacomEasyGet: function mixinDatacomEasyGet() {var _this20 = this;var _ref30 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},_ref30$getone = _ref30.getone,e = _ref30$getone === void 0 ? !1 : _ref30$getone,t = _ref30.success,n = _ref30.fail;this.mixinDatacomLoading || (this.mixinDatacomLoading = !0, this.mixinDatacomErrorMessage = "", this.mixinDatacomGet().then(function (n) {_this20.mixinDatacomLoading = !1;var _n$result = n.result,s = _n$result.data,r = _n$result.count;_this20.getcount && (_this20.mixinDatacomPage.count = r), _this20.mixinDatacomHasMore = s.length < _this20.pageSize;var o = e ? s.length ? s[0] : void 0 : s;_this20.mixinDatacomResData = o, t && t(o);}).catch(function (e) {_this20.mixinDatacomLoading = !1, _this20.mixinDatacomErrorMessage = e, n && n(e);}));}, mixinDatacomGet: function mixinDatacomGet() {var _n8;var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};var n = e.database(this.spaceInfo);var s = t.action || this.action;s && (n = n.action(s));var r = t.collection || this.collection;n = Array.isArray(r) ? (_n8 = n).collection.apply(_n8, _toConsumableArray(r)) : n.collection(r);var o = t.where || this.where;o && Object.keys(o).length && (n = n.where(o));var i = t.field || this.field;i && (n = n.field(i));var a = t.foreignKey || this.foreignKey;a && (n = n.foreignKey(a));var c = t.groupby || this.groupby;c && (n = n.groupBy(c));var u = t.groupField || this.groupField;u && (n = n.groupField(u));!0 === (void 0 !== t.distinct ? t.distinct : this.distinct) && (n = n.distinct());var h = t.orderby || this.orderby;h && (n = n.orderBy(h));var l = void 0 !== t.pageCurrent ? t.pageCurrent : this.mixinDatacomPage.current,d = void 0 !== t.pageSize ? t.pageSize : this.mixinDatacomPage.size,f = void 0 !== t.getcount ? t.getcount : this.getcount,p = void 0 !== t.gettree ? t.gettree : this.gettree,g = void 0 !== t.gettreepath ? t.gettreepath : this.gettreepath,m = { getCount: f },y = { limitLevel: void 0 !== t.limitlevel ? t.limitlevel : this.limitlevel, startWith: void 0 !== t.startwith ? t.startwith : this.startwith };return p && (m.getTree = y), g && (m.getTreePath = y), n = n.skip(d * (l - 1)).limit(d).get(m), n;} } };}function gt(_x30, _x31) {return _gt.apply(this, arguments);}function _gt() {_gt = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee32(e, t) {var n, _e26, s;return _regenerator.default.wrap(function _callee32$(_context32) {while (1) {switch (_context32.prev = _context32.next) {case 0:n = "http://".concat(e, ":").concat(t, "/system/ping");_context32.prev = 1;_context32.next = 4;return s = { url: n, timeout: 500 }, new Promise(function (e, t) {E.request(_objectSpread(_objectSpread({}, s), {}, { success: function success(t) {e(t);}, fail: function fail(e) {t(e);} }));});case 4:_e26 = _context32.sent;return _context32.abrupt("return", !(!_e26.data || 0 !== _e26.data.code));case 8:_context32.prev = 8;_context32.t0 = _context32["catch"](1);return _context32.abrupt("return", !1);case 11:case "end":return _context32.stop();}}}, _callee32, null, [[1, 8]]);}));return _gt.apply(this, arguments);}function mt(e) {if (e.initUniCloudStatus && "rejected" !== e.initUniCloudStatus) return;var t = Promise.resolve();var n;n = 1, t = new Promise(function (e, t) {setTimeout(function () {e();}, n);}), e.isReady = !1, e.isDefault = !1;var s = e.auth();e.initUniCloudStatus = "pending", e.initUniCloud = t.then(function () {return s.getLoginState();}).then(function (e) {return e ? Promise.resolve() : s.signInAnonymously();}).then(function () {if (!u) return Promise.resolve();if (u && e.debugInfo) {var _e$debugInfo = e.debugInfo,_t13 = _e$debugInfo.address,_n9 = _e$debugInfo.servePort;return function () {var _ref31 = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee31(e, t) {var n, _s10, _r7;return _regenerator.default.wrap(function _callee31$(_context31) {while (1) {switch (_context31.prev = _context31.next) {case 0:_s10 = 0;case 1:if (!(_s10 < e.length)) {_context31.next = 11;break;}_r7 = e[_s10];_context31.next = 5;return gt(_r7, t);case 5:if (!_context31.sent) {_context31.next = 8;break;}n = _r7;return _context31.abrupt("break", 11);case 8:_s10++;_context31.next = 1;break;case 11:return _context31.abrupt("return", { address: n, port: t });case 12:case "end":return _context31.stop();}}}, _callee31);}));return function (_x32, _x33) {return _ref31.apply(this, arguments);};}()(_t13, _n9);}}).then(function () {var _ref32 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},t = _ref32.address,n = _ref32.port;if (!u) return Promise.resolve();if (t) e.localAddress = t, e.localPort = n;else if (e.debugInfo) {var _t14 = console["app-plus" === h ? "error" : "warn"];var _n10 = "";"remote" === e.debugInfo.initialLaunchType ? (e.debugInfo.forceRemote = !0, _n10 = "当前客户端和HBuilderX不在同一局域网下（或其他网络原因无法连接HBuilderX），uniCloud本地调试服务不对当前客户端生效。\n- 如果不使用uniCloud本地调试服务，请直接忽略此信息。\n- 如需使用uniCloud本地调试服务，请将客户端与主机连接到同一局域网下并重新运行到客户端。\n- 如果在HBuilderX开启的状态下切换过网络环境，请重启HBuilderX后再试\n- 检查系统防火墙是否拦截了HBuilderX自带的nodejs") : _n10 = "无法连接uniCloud本地调试服务，请检查当前客户端是否与主机在同一局域网下。\n- 如需使用uniCloud本地调试服务，请将客户端与主机连接到同一局域网下并重新运行到客户端。\n- 如果在HBuilderX开启的状态下切换过网络环境，请重启HBuilderX后再试\n- 检查系统防火墙是否拦截了HBuilderX自带的nodejs", "h5" === h && (_n10 += "\n- 部分浏览器开启节流模式之后访问本地地址受限，请检查是否启用了节流模式"), _t14(_n10);}}).then(function () {Me(), e.isReady = !0, e.initUniCloudStatus = "fulfilled";}).catch(function (t) {console.error(t), e.initUniCloudStatus = "rejected";});}var yt = new ( /*#__PURE__*/function () {function _class4() {_classCallCheck(this, _class4);}_createClass(_class4, [{ key: "init", value: function init(e) {var t = {};var n = !1 !== e.debugFunction && u && ("h5" === h && navigator.userAgent.indexOf("HBuilderX") > 0 || "app-plus" === h);switch (e.provider) {case "tencent":t = Ne.init(Object.assign(e, { useDebugFunction: n }));break;case "aliyun":t = x.init(Object.assign(e, { useDebugFunction: n }));break;case "private":t = Be.init(Object.assign(e, { useDebugFunction: n }));break;default:throw new Error("未提供正确的provider参数");}var s = l;u && s && !s.code && (t.debugInfo = s), mt(t), t.reInit = function () {mt(this);}, Xe(t), function (e) {var t = e.uploadFile;e.uploadFile = function (e) {return t.call(this, e);};}(t), at(t), function (e) {e.getCurrentUserInfo = lt, e.chooseAndUploadFile = dt.initChooseAndUploadFile(e), Object.assign(e, { get mixinDatacom() {return pt(e);} });}(t);return ["callFunction", "uploadFile", "deleteFile", "getTempFileURL", "downloadFile", "chooseAndUploadFile"].forEach(function (e) {if (!t[e]) return;var n = t[e];t[e] = function () {return t.reInit(), n.apply(t, Array.from(arguments));}, t[e] = T(t[e], e).bind(t);}), t.init = this.init, t;} }]);return _class4;}())();(function () {{var e = d;var t = {};if (1 === e.length) t = e[0], yt = yt.init(t), yt.isDefault = !0;else {var _t15 = ["auth", "callFunction", "uploadFile", "deleteFile", "getTempFileURL", "downloadFile", "database", "getCurrentUSerInfo"];var _n11;_n11 = e && e.length > 0 ? "应用有多个服务空间，请通过uniCloud.init方法指定要使用的服务空间" : f ? "应用未关联服务空间，请在uniCloud目录右键关联服务空间" : "uni-app cli项目内使用uniCloud需要使用HBuilderX的运行菜单运行项目，且需要在uniCloud目录关联服务空间", _t15.forEach(function (e) {yt[e] = function () {return console.error(_n11), Promise.reject(new A({ code: "SYS_ERR", message: _n11 }));};});}Object.assign(yt, { get mixinDatacom() {return pt(yt);} }), yt.addInterceptor = w, yt.removeInterceptor = k, u && "h5" === h && (window.uniCloud = yt);}})();var _t = yt;exports.default = _t;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ 2), __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["default"]))

/***/ }),
/* 333 */
/*!*********************************************************!*\
  !*** I:/out-project/FCoinEx/pages.json?{"type":"stat"} ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _default = { "appid": "" };exports.default = _default;

/***/ }),
/* 334 */
/*!***************************************************************************************************************!*\
  !*** I:/out-project/FCoinEx/uni_modules/uni-file-picker/components/uni-file-picker/choose-and-upload-file.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(uni, uniCloud) {Object.defineProperty(exports, "__esModule", { value: true });exports.chooseAndUploadFile = chooseAndUploadFile;exports.uploadCloudFiles = uploadCloudFiles;

var ERR_MSG_OK = 'chooseAndUploadFile:ok';
var ERR_MSG_FAIL = 'chooseAndUploadFile:fail';

function chooseImage(opts) {var

  count =



  opts.count,_opts$sizeType = opts.sizeType,sizeType = _opts$sizeType === void 0 ? ['original', 'compressed'] : _opts$sizeType,_opts$sourceType = opts.sourceType,sourceType = _opts$sourceType === void 0 ? ['album', 'camera'] : _opts$sourceType,extension = opts.extension;
  return new Promise(function (resolve, reject) {
    uni.chooseImage({
      count: count,
      sizeType: sizeType,
      sourceType: sourceType,
      extension: extension,
      success: function success(res) {
        resolve(normalizeChooseAndUploadFileRes(res, 'image'));
      },
      fail: function fail(res) {
        reject({
          errMsg: res.errMsg.replace('chooseImage:fail', ERR_MSG_FAIL) });

      } });

  });
}

function chooseVideo(opts) {var

  camera =




  opts.camera,compressed = opts.compressed,maxDuration = opts.maxDuration,_opts$sourceType2 = opts.sourceType,sourceType = _opts$sourceType2 === void 0 ? ['album', 'camera'] : _opts$sourceType2,extension = opts.extension;
  return new Promise(function (resolve, reject) {
    uni.chooseVideo({
      camera: camera,
      compressed: compressed,
      maxDuration: maxDuration,
      sourceType: sourceType,
      extension: extension,
      success: function success(res) {var

        tempFilePath =




        res.tempFilePath,duration = res.duration,size = res.size,height = res.height,width = res.width;
        resolve(normalizeChooseAndUploadFileRes({
          errMsg: 'chooseVideo:ok',
          tempFilePaths: [tempFilePath],
          tempFiles: [
          {
            name: res.tempFile && res.tempFile.name || '',
            path: tempFilePath,
            size: size,
            type: res.tempFile && res.tempFile.type || '',
            width: width,
            height: height,
            duration: duration,
            fileType: 'video',
            cloudPath: '' }] },

        'video'));
      },
      fail: function fail(res) {
        reject({
          errMsg: res.errMsg.replace('chooseVideo:fail', ERR_MSG_FAIL) });

      } });

  });
}

function chooseAll(opts) {var

  count =

  opts.count,extension = opts.extension;
  return new Promise(function (resolve, reject) {
    var chooseFile = uni.chooseFile;
    if (typeof wx !== 'undefined' &&
    typeof wx.chooseMessageFile === 'function') {
      chooseFile = wx.chooseMessageFile;
    }
    if (typeof chooseFile !== 'function') {
      return reject({
        errMsg: ERR_MSG_FAIL + ' 请指定 type 类型，该平台仅支持选择 image 或 video。' });

    }
    chooseFile({
      type: 'all',
      count: count,
      extension: extension,
      success: function success(res) {
        resolve(normalizeChooseAndUploadFileRes(res));
      },
      fail: function fail(res) {
        reject({
          errMsg: res.errMsg.replace('chooseFile:fail', ERR_MSG_FAIL) });

      } });

  });
}

function normalizeChooseAndUploadFileRes(res, fileType) {
  res.tempFiles.forEach(function (item, index) {
    if (!item.name) {
      item.name = item.path.substring(item.path.lastIndexOf('/') + 1);
    }
    if (fileType) {
      item.fileType = fileType;
    }
    item.cloudPath =
    Date.now() + '_' + index + item.name.substring(item.name.lastIndexOf('.'));
  });
  if (!res.tempFilePaths) {
    res.tempFilePaths = res.tempFiles.map(function (file) {return file.path;});
  }
  return res;
}

function uploadCloudFiles(files) {var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;var _onUploadProgress = arguments.length > 2 ? arguments[2] : undefined;
  files = JSON.parse(JSON.stringify(files));
  var len = files.length;
  var count = 0;
  var self = this;
  return new Promise(function (resolve) {
    while (count < max) {
      next();
    }

    function next() {
      var cur = count++;
      if (cur >= len) {
        !files.find(function (item) {return !item.url && !item.errMsg;}) && resolve(files);
        return;
      }
      var fileItem = files[cur];
      var index = self.files.findIndex(function (v) {return v.uuid === fileItem.uuid;});
      fileItem.url = '';
      delete fileItem.errMsg;

      uniCloud.
      uploadFile({
        filePath: fileItem.path,
        cloudPath: fileItem.cloudPath,
        fileType: fileItem.fileType,
        onUploadProgress: function onUploadProgress(res) {
          res.index = index;
          _onUploadProgress && _onUploadProgress(res);
        } }).

      then(function (res) {
        fileItem.url = res.fileID;
        fileItem.index = index;
        if (cur < len) {
          next();
        }
      }).
      catch(function (res) {
        fileItem.errMsg = res.errMsg || res.message;
        fileItem.index = index;
        if (cur < len) {
          next();
        }
      });
    }
  });
}





function uploadFiles(choosePromise, _ref)


{var onChooseFile = _ref.onChooseFile,onUploadProgress = _ref.onUploadProgress;
  return choosePromise.
  then(function (res) {
    if (onChooseFile) {
      var customChooseRes = onChooseFile(res);
      if (typeof customChooseRes !== 'undefined') {
        return Promise.resolve(customChooseRes).then(function (chooseRes) {return typeof chooseRes === 'undefined' ?
          res : chooseRes;});
      }
    }
    return res;
  }).
  then(function (res) {
    if (res === false) {
      return {
        errMsg: ERR_MSG_OK,
        tempFilePaths: [],
        tempFiles: [] };

    }
    return res;
  });
}

function chooseAndUploadFile()

{var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { type: 'all' };
  if (opts.type === 'image') {
    return uploadFiles(chooseImage(opts), opts);
  } else
  if (opts.type === 'video') {
    return uploadFiles(chooseVideo(opts), opts);
  }
  return uploadFiles(chooseAll(opts), opts);
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["default"], __webpack_require__(/*! ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/uni-cloud/dist/index.js */ 332)["default"]))

/***/ }),
/* 335 */
/*!**********************************************************************************************!*\
  !*** I:/out-project/FCoinEx/uni_modules/uni-file-picker/components/uni-file-picker/utils.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(uni) {Object.defineProperty(exports, "__esModule", { value: true });exports.get_file_data = exports.get_file_info = exports.get_files_and_is_max = exports.get_extname = exports.get_file_ext = void 0;var _regenerator = _interopRequireDefault(__webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ 17));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};} /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * 获取文件名和后缀
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * @param {String} name
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             */
var get_file_ext = function get_file_ext(name) {
  var last_len = name.lastIndexOf('.');
  var len = name.length;
  return {
    name: name.substring(0, last_len),
    ext: name.substring(last_len + 1, len) };

};

/**
    * 获取扩展名
    * @param {Array} fileExtname
    */exports.get_file_ext = get_file_ext;
var get_extname = function get_extname(fileExtname) {
  if (!Array.isArray(fileExtname)) {
    var extname = fileExtname.replace(/(\[|\])/g, '');
    return extname.split(',');
  } else {
    return fileExtname;
  }
  return [];
};

/**
    * 获取文件和检测是否可选
    */exports.get_extname = get_extname;
var get_files_and_is_max = function get_files_and_is_max(res, _extname) {
  var filePaths = [];
  var files = [];
  if (!_extname || _extname.length === 0) {
    return {
      filePaths: filePaths,
      files: files };

  }
  res.tempFiles.forEach(function (v) {
    var fileFullName = get_file_ext(v.name);
    var extname = fileFullName.ext.toLowerCase();
    if (_extname.indexOf(extname) !== -1) {
      files.push(v);
      filePaths.push(v.path);
    }
  });
  if (files.length !== res.tempFiles.length) {
    uni.showToast({
      title: "\u5F53\u524D\u9009\u62E9\u4E86".concat(res.tempFiles.length, "\u4E2A\u6587\u4EF6 \uFF0C").concat(res.tempFiles.length - files.length, " \u4E2A\u6587\u4EF6\u683C\u5F0F\u4E0D\u6B63\u786E"),
      icon: 'none',
      duration: 5000 });

  }

  return {
    filePaths: filePaths,
    files: files };

};


/**
    * 获取图片信息
    * @param {Object} filepath
    */exports.get_files_and_is_max = get_files_and_is_max;
var get_file_info = function get_file_info(filepath) {
  return new Promise(function (resolve, reject) {
    uni.getImageInfo({
      src: filepath,
      success: function success(res) {
        resolve(res);
      },
      fail: function fail(err) {
        reject(err);
      } });

  });
};
/**
    * 获取封装数据
    */exports.get_file_info = get_file_info;
var get_file_data = /*#__PURE__*/function () {var _ref = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee(files) {var type,fileFullName,extname,filedata,imageinfo,_args = arguments;return _regenerator.default.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:type = _args.length > 1 && _args[1] !== undefined ? _args[1] : 'image';
            // 最终需要上传数据库的数据
            fileFullName = get_file_ext(files.name);
            extname = fileFullName.ext.toLowerCase();
            filedata = {
              name: files.name,
              uuid: files.uuid,
              extname: extname || '',
              cloudPath: files.cloudPath,
              fileType: files.fileType,
              url: files.path || files.path,
              size: files.size, //单位是字节
              image: {},
              path: files.path,
              video: {} };if (!(

            type === 'image')) {_context.next = 14;break;}_context.next = 7;return (
              get_file_info(files.path));case 7:imageinfo = _context.sent;
            delete filedata.video;
            filedata.image.width = imageinfo.width;
            filedata.image.height = imageinfo.height;
            filedata.image.location = imageinfo.path;_context.next = 15;break;case 14:

            delete filedata.image;case 15:return _context.abrupt("return",

            filedata);case 16:case "end":return _context.stop();}}}, _callee);}));return function get_file_data(_x) {return _ref.apply(this, arguments);};}();exports.get_file_data = get_file_data;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["default"]))

/***/ }),
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */,
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */,
/* 367 */,
/* 368 */,
/* 369 */,
/* 370 */,
/* 371 */,
/* 372 */,
/* 373 */,
/* 374 */,
/* 375 */,
/* 376 */,
/* 377 */,
/* 378 */,
/* 379 */,
/* 380 */,
/* 381 */,
/* 382 */,
/* 383 */,
/* 384 */,
/* 385 */,
/* 386 */,
/* 387 */,
/* 388 */,
/* 389 */,
/* 390 */,
/* 391 */,
/* 392 */
/*!************************************************************!*\
  !*** I:/out-project/FCoinEx/components/uni-icons/icons.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _default = {
  'contact': "\uE100",
  'person': "\uE101",
  'personadd': "\uE102",
  'contact-filled': "\uE130",
  'person-filled': "\uE131",
  'personadd-filled': "\uE132",
  'phone': "\uE200",
  'email': "\uE201",
  'chatbubble': "\uE202",
  'chatboxes': "\uE203",
  'phone-filled': "\uE230",
  'email-filled': "\uE231",
  'chatbubble-filled': "\uE232",
  'chatboxes-filled': "\uE233",
  'weibo': "\uE260",
  'weixin': "\uE261",
  'pengyouquan': "\uE262",
  'chat': "\uE263",
  'qq': "\uE264",
  'videocam': "\uE300",
  'camera': "\uE301",
  'mic': "\uE302",
  'location': "\uE303",
  'mic-filled': "\uE332",
  'speech': "\uE332",
  'location-filled': "\uE333",
  'micoff': "\uE360",
  'image': "\uE363",
  'map': "\uE364",
  'compose': "\uE400",
  'trash': "\uE401",
  'upload': "\uE402",
  'download': "\uE403",
  'close': "\uE404",
  'redo': "\uE405",
  'undo': "\uE406",
  'refresh': "\uE407",
  'star': "\uE408",
  'plus': "\uE409",
  'minus': "\uE410",
  'circle': "\uE411",
  'checkbox': "\uE411",
  'close-filled': "\uE434",
  'clear': "\uE434",
  'refresh-filled': "\uE437",
  'star-filled': "\uE438",
  'plus-filled': "\uE439",
  'minus-filled': "\uE440",
  'circle-filled': "\uE441",
  'checkbox-filled': "\uE442",
  'closeempty': "\uE460",
  'refreshempty': "\uE461",
  'reload': "\uE462",
  'starhalf': "\uE463",
  'spinner': "\uE464",
  'spinner-cycle': "\uE465",
  'search': "\uE466",
  'plusempty': "\uE468",
  'forward': "\uE470",
  'back': "\uE471",
  'left-nav': "\uE471",
  'checkmarkempty': "\uE472",
  'home': "\uE500",
  'navigate': "\uE501",
  'gear': "\uE502",
  'paperplane': "\uE503",
  'info': "\uE504",
  'help': "\uE505",
  'locked': "\uE506",
  'more': "\uE507",
  'flag': "\uE508",
  'home-filled': "\uE530",
  'gear-filled': "\uE532",
  'info-filled': "\uE534",
  'help-filled': "\uE535",
  'more-filled': "\uE537",
  'settings': "\uE560",
  'list': "\uE562",
  'bars': "\uE563",
  'loop': "\uE565",
  'paperclip': "\uE567",
  'eye': "\uE568",
  'arrowup': "\uE580",
  'arrowdown': "\uE581",
  'arrowleft': "\uE582",
  'arrowright': "\uE583",
  'arrowthinup': "\uE584",
  'arrowthindown': "\uE585",
  'arrowthinleft': "\uE586",
  'arrowthinright': "\uE587",
  'pulldown': "\uE588",
  'closefill': "\uE589",
  'sound': "\uE590",
  'scan': "\uE612" };exports.default = _default;

/***/ })
]]);
//# sourceMappingURL=../../.sourcemap/mp-weixin/common/vendor.js.map